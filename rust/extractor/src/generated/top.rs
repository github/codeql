// generated by codegen

#![cfg_attr(any(), rustfmt::skip)]

use crate::trap::{TrapId, TrapEntry};
use codeql_extractor::trap;

#[derive(Debug)]
pub struct DbFile {
    pub id: TrapId,
    pub name: String,
}

impl TrapEntry for DbFile {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("db_files", vec![trap::Arg::Label(id)]);
        out.add_tuple("files", vec![trap::Arg::Label(id), self.name.into()]);
    }
}

#[derive(Debug)]
pub struct DbLocation {
    pub id: TrapId,
    pub file: trap::Label,
    pub start_line: usize,
    pub start_column: usize,
    pub end_line: usize,
    pub end_column: usize,
}

impl TrapEntry for DbLocation {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("db_locations", vec![trap::Arg::Label(id)]);
        out.add_tuple("locations", vec![trap::Arg::Label(id), self.file.into(), self.start_line.into(), self.start_column.into(), self.end_line.into(), self.end_column.into()]);
    }
}

#[derive(Debug)]
pub struct Label {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub name: String,
}

impl TrapEntry for Label {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("labels", vec![trap::Arg::Label(id), self.name.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct MatchArm {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub pat: trap::Label,
    pub guard: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for MatchArm {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("match_arms", vec![trap::Arg::Label(id), self.pat.into(), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.guard {
            out.add_tuple("match_arm_guards", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct RecordFieldPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub name: String,
    pub pat: trap::Label,
}

impl TrapEntry for RecordFieldPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("record_field_pats", vec![trap::Arg::Label(id), self.name.into(), self.pat.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct RecordLitField {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub name: String,
    pub expr: trap::Label,
}

impl TrapEntry for RecordLitField {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("record_lit_fields", vec![trap::Arg::Label(id), self.name.into(), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct TypeRef {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for TypeRef {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("type_refs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct Unimplemented {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for Unimplemented {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("unimplementeds", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct AwaitExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for AwaitExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("await_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BecomeExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for BecomeExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("become_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BinaryOpExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub lhs: trap::Label,
    pub rhs: trap::Label,
    pub op: Option<String>,
}

impl TrapEntry for BinaryOpExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("binary_op_exprs", vec![trap::Arg::Label(id), self.lhs.into(), self.rhs.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.op {
            out.add_tuple("binary_op_expr_ops", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BindPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub binding_id: String,
    pub subpat: Option<trap::Label>,
}

impl TrapEntry for BindPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("bind_pats", vec![trap::Arg::Label(id), self.binding_id.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.subpat {
            out.add_tuple("bind_pat_subpats", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BoxExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for BoxExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("box_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BoxPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub inner: trap::Label,
}

impl TrapEntry for BoxPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("box_pats", vec![trap::Arg::Label(id), self.inner.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BreakExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: Option<trap::Label>,
    pub label: Option<trap::Label>,
}

impl TrapEntry for BreakExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("break_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.expr {
            out.add_tuple("break_expr_exprs", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("break_expr_labels", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct CallExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub callee: trap::Label,
    pub args: Vec<trap::Label>,
    pub is_assignee_expr: bool,
}

impl TrapEntry for CallExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("call_exprs", vec![trap::Arg::Label(id), self.callee.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("call_expr_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("call_expr_is_assignee_expr", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct CastExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub type_ref: trap::Label,
}

impl TrapEntry for CastExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("cast_exprs", vec![trap::Arg::Label(id), self.expr.into(), self.type_ref.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ClosureExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub args: Vec<trap::Label>,
    pub arg_types: Vec<Option<trap::Label>>,
    pub ret_type: Option<trap::Label>,
    pub body: trap::Label,
    pub closure_kind: String,
    pub is_move: bool,
}

impl TrapEntry for ClosureExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("closure_exprs", vec![trap::Arg::Label(id), self.body.into(), self.closure_kind.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("closure_expr_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        for (i, v) in self.arg_types.into_iter().enumerate() {
            if let Some(v) = v {
                out.add_tuple("closure_expr_arg_types", vec![trap::Arg::Label(id), i.into(), v.into()]);
            }
        }
        if let Some(v) = self.ret_type {
            out.add_tuple("closure_expr_ret_types", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.is_move {
            out.add_tuple("closure_expr_is_move", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct ConstBlockPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for ConstBlockPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("const_block_pats", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ConstExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for ConstExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("const_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ContinueExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub label: Option<trap::Label>,
}

impl TrapEntry for ContinueExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("continue_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("continue_expr_labels", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ExprStmt {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub has_semicolon: bool,
}

impl TrapEntry for ExprStmt {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("expr_stmts", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.has_semicolon {
            out.add_tuple("expr_stmt_has_semicolon", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct FieldExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub name: String,
}

impl TrapEntry for FieldExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("field_exprs", vec![trap::Arg::Label(id), self.expr.into(), self.name.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct Function {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub name: String,
    pub body: trap::Label,
}

impl TrapEntry for Function {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("functions", vec![trap::Arg::Label(id), self.name.into(), self.body.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct IfExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub condition: trap::Label,
    pub then: trap::Label,
    pub else_: Option<trap::Label>,
}

impl TrapEntry for IfExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("if_exprs", vec![trap::Arg::Label(id), self.condition.into(), self.then.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.else_ {
            out.add_tuple("if_expr_elses", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct IndexExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub base: trap::Label,
    pub index: trap::Label,
    pub is_assignee_expr: bool,
}

impl TrapEntry for IndexExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("index_exprs", vec![trap::Arg::Label(id), self.base.into(), self.index.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("index_expr_is_assignee_expr", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct InlineAsmExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for InlineAsmExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("inline_asm_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ItemStmt {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for ItemStmt {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("item_stmts", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct LetExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub pat: trap::Label,
    pub expr: trap::Label,
}

impl TrapEntry for LetExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("let_exprs", vec![trap::Arg::Label(id), self.pat.into(), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct LetStmt {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub pat: trap::Label,
    pub type_ref: Option<trap::Label>,
    pub initializer: Option<trap::Label>,
    pub else_: Option<trap::Label>,
}

impl TrapEntry for LetStmt {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("let_stmts", vec![trap::Arg::Label(id), self.pat.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.type_ref {
            out.add_tuple("let_stmt_type_refs", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.initializer {
            out.add_tuple("let_stmt_initializers", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.else_ {
            out.add_tuple("let_stmt_elses", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct LitPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
}

impl TrapEntry for LitPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("lit_pats", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct LiteralExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for LiteralExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("literal_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct LoopExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub body: trap::Label,
    pub label: Option<trap::Label>,
}

impl TrapEntry for LoopExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("loop_exprs", vec![trap::Arg::Label(id), self.body.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("loop_expr_labels", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct MatchExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub branches: Vec<trap::Label>,
}

impl TrapEntry for MatchExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("match_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.branches.into_iter().enumerate() {
            out.add_tuple("match_expr_branches", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct MethodCallExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub receiver: trap::Label,
    pub method_name: String,
    pub args: Vec<trap::Label>,
    pub generic_args: Option<trap::Label>,
}

impl TrapEntry for MethodCallExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("method_call_exprs", vec![trap::Arg::Label(id), self.receiver.into(), self.method_name.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("method_call_expr_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.generic_args {
            out.add_tuple("method_call_expr_generic_args", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct MissingExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for MissingExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("missing_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct MissingPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for MissingPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("missing_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct Module {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub declarations: Vec<trap::Label>,
}

impl TrapEntry for Module {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("modules", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.declarations.into_iter().enumerate() {
            out.add_tuple("module_declarations", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct OffsetOfExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub container: trap::Label,
    pub fields: Vec<String>,
}

impl TrapEntry for OffsetOfExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("offset_of_exprs", vec![trap::Arg::Label(id), self.container.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.fields.into_iter().enumerate() {
            out.add_tuple("offset_of_expr_fields", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct OrPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub args: Vec<trap::Label>,
}

impl TrapEntry for OrPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("or_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("or_pat_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct PathExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub path: trap::Label,
}

impl TrapEntry for PathExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("path_exprs", vec![trap::Arg::Label(id), self.path.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct PathPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub path: trap::Label,
}

impl TrapEntry for PathPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("path_pats", vec![trap::Arg::Label(id), self.path.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct RangeExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub lhs: Option<trap::Label>,
    pub rhs: Option<trap::Label>,
    pub is_inclusive: bool,
}

impl TrapEntry for RangeExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("range_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.lhs {
            out.add_tuple("range_expr_lhs", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.rhs {
            out.add_tuple("range_expr_rhs", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.is_inclusive {
            out.add_tuple("range_expr_is_inclusive", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct RangePat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub start: Option<trap::Label>,
    pub end: Option<trap::Label>,
}

impl TrapEntry for RangePat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("range_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.start {
            out.add_tuple("range_pat_starts", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.end {
            out.add_tuple("range_pat_ends", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct RecordLitExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub path: Option<trap::Label>,
    pub fields: Vec<trap::Label>,
    pub spread: Option<trap::Label>,
    pub has_ellipsis: bool,
    pub is_assignee_expr: bool,
}

impl TrapEntry for RecordLitExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("record_lit_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.path {
            out.add_tuple("record_lit_expr_paths", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.fields.into_iter().enumerate() {
            out.add_tuple("record_lit_expr_fields", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.spread {
            out.add_tuple("record_lit_expr_spreads", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_lit_expr_has_ellipsis", vec![trap::Arg::Label(id)]);
        }
        if self.is_assignee_expr {
            out.add_tuple("record_lit_expr_is_assignee_expr", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct RecordPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub path: Option<trap::Label>,
    pub args: Vec<trap::Label>,
    pub has_ellipsis: bool,
}

impl TrapEntry for RecordPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("record_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.path {
            out.add_tuple("record_pat_paths", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("record_pat_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_pat_has_ellipsis", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct RefExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub is_raw: bool,
    pub is_mut: bool,
}

impl TrapEntry for RefExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("ref_exprs", vec![trap::Arg::Label(id), self.expr.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.is_raw {
            out.add_tuple("ref_expr_is_raw", vec![trap::Arg::Label(id)]);
        }
        if self.is_mut {
            out.add_tuple("ref_expr_is_mut", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct RefPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub pat: trap::Label,
    pub is_mut: bool,
}

impl TrapEntry for RefPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("ref_pats", vec![trap::Arg::Label(id), self.pat.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if self.is_mut {
            out.add_tuple("ref_pat_is_mut", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct ReturnExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: Option<trap::Label>,
}

impl TrapEntry for ReturnExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("return_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.expr {
            out.add_tuple("return_expr_exprs", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct SlicePat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub prefix: Vec<trap::Label>,
    pub slice: Option<trap::Label>,
    pub suffix: Vec<trap::Label>,
}

impl TrapEntry for SlicePat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("slice_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.prefix.into_iter().enumerate() {
            out.add_tuple("slice_pat_prefixes", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.slice {
            out.add_tuple("slice_pat_slice", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.suffix.into_iter().enumerate() {
            out.add_tuple("slice_pat_suffixes", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct TupleExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub exprs: Vec<trap::Label>,
    pub is_assignee_expr: bool,
}

impl TrapEntry for TupleExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("tuple_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.exprs.into_iter().enumerate() {
            out.add_tuple("tuple_expr_exprs", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("tuple_expr_is_assignee_expr", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct TuplePat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub args: Vec<trap::Label>,
    pub ellipsis_index: Option<usize>,
}

impl TrapEntry for TuplePat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("tuple_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_pat_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_pat_ellipsis_indices", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct TupleStructPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub path: Option<trap::Label>,
    pub args: Vec<trap::Label>,
    pub ellipsis_index: Option<usize>,
}

impl TrapEntry for TupleStructPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("tuple_struct_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.path {
            out.add_tuple("tuple_struct_pat_paths", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_struct_pat_args", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_struct_pat_ellipsis_indices", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct UnaryOpExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: trap::Label,
    pub op: String,
}

impl TrapEntry for UnaryOpExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("unary_op_exprs", vec![trap::Arg::Label(id), self.expr.into(), self.op.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct UnderscoreExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for UnderscoreExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("underscore_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct WildPat {
    pub id: TrapId,
    pub location: Option<trap::Label>,
}

impl TrapEntry for WildPat {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("wild_pats", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct YeetExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: Option<trap::Label>,
}

impl TrapEntry for YeetExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("yeet_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.expr {
            out.add_tuple("yeet_expr_exprs", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct YieldExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub expr: Option<trap::Label>,
}

impl TrapEntry for YieldExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("yield_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.expr {
            out.add_tuple("yield_expr_exprs", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct AsyncBlockExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub statements: Vec<trap::Label>,
    pub tail: Option<trap::Label>,
}

impl TrapEntry for AsyncBlockExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("async_block_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct BlockExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub statements: Vec<trap::Label>,
    pub tail: Option<trap::Label>,
    pub label: Option<trap::Label>,
}

impl TrapEntry for BlockExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("block_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![trap::Arg::Label(id), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("block_expr_labels", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct ElementListExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub elements: Vec<trap::Label>,
    pub is_assignee_expr: bool,
}

impl TrapEntry for ElementListExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("element_list_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.elements.into_iter().enumerate() {
            out.add_tuple("element_list_expr_elements", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("element_list_expr_is_assignee_expr", vec![trap::Arg::Label(id)]);
        }
    }
}

#[derive(Debug)]
pub struct RepeatExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub initializer: trap::Label,
    pub repeat: trap::Label,
}

impl TrapEntry for RepeatExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("repeat_exprs", vec![trap::Arg::Label(id), self.initializer.into(), self.repeat.into()]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}

#[derive(Debug)]
pub struct UnsafeBlockExpr {
    pub id: TrapId,
    pub location: Option<trap::Label>,
    pub statements: Vec<trap::Label>,
    pub tail: Option<trap::Label>,
}

impl TrapEntry for UnsafeBlockExpr {
    fn extract_id(&mut self) -> TrapId {
        std::mem::replace(&mut self.id, TrapId::Star)
    }

    fn emit(self, id: trap::Label, out: &mut trap::Writer) {
        out.add_tuple("unsafe_block_exprs", vec![trap::Arg::Label(id)]);
        if let Some(v) = self.location {
            out.add_tuple("locatable_locations", vec![trap::Arg::Label(id), v.into()]);
        }
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![trap::Arg::Label(id), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![trap::Arg::Label(id), v.into()]);
        }
    }
}
