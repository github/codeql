// generated by codegen, do not edit

#![cfg_attr(any(), rustfmt::skip)]

use crate::trap;

#[derive(Debug)]
pub struct Element {
    _unused: ()
}

impl trap::TrapClass for Element {
    fn class_name() -> &'static str { "Element" }
}

#[derive(Debug)]
pub struct Locatable {
    _unused: ()
}

impl trap::TrapClass for Locatable {
    fn class_name() -> &'static str { "Locatable" }
}

impl From<trap::Label<Locatable>> for trap::Label<Element> {
    fn from(value: trap::Label<Locatable>) -> Self {
        // SAFETY: this is safe because in the dbscheme Locatable is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Unextracted {
    _unused: ()
}

impl trap::TrapClass for Unextracted {
    fn class_name() -> &'static str { "Unextracted" }
}

impl From<trap::Label<Unextracted>> for trap::Label<Element> {
    fn from(value: trap::Label<Unextracted>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unextracted is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AstNode {
    _unused: ()
}

impl trap::TrapClass for AstNode {
    fn class_name() -> &'static str { "AstNode" }
}

impl From<trap::Label<AstNode>> for trap::Label<Element> {
    fn from(value: trap::Label<AstNode>) -> Self {
        // SAFETY: this is safe because in the dbscheme AstNode is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AstNode>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AstNode>) -> Self {
        // SAFETY: this is safe because in the dbscheme AstNode is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Missing {
    _unused: ()
}

impl trap::TrapClass for Missing {
    fn class_name() -> &'static str { "Missing" }
}

impl From<trap::Label<Missing>> for trap::Label<Element> {
    fn from(value: trap::Label<Missing>) -> Self {
        // SAFETY: this is safe because in the dbscheme Missing is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Missing>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<Missing>) -> Self {
        // SAFETY: this is safe because in the dbscheme Missing is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Unimplemented {
    _unused: ()
}

impl trap::TrapClass for Unimplemented {
    fn class_name() -> &'static str { "Unimplemented" }
}

impl From<trap::Label<Unimplemented>> for trap::Label<Element> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Unimplemented>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<Unimplemented>) -> Self {
        // SAFETY: this is safe because in the dbscheme Unimplemented is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Declaration {
    _unused: ()
}

impl trap::TrapClass for Declaration {
    fn class_name() -> &'static str { "Declaration" }
}

impl From<trap::Label<Declaration>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Declaration>> for trap::Label<Element> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Declaration>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Declaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme Declaration is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Expr {
    _unused: ()
}

impl trap::TrapClass for Expr {
    fn class_name() -> &'static str { "Expr" }
}

impl From<trap::Label<Expr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Expr>> for trap::Label<Element> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Expr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Expr>) -> Self {
        // SAFETY: this is safe because in the dbscheme Expr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct GenericArgList {
    pub id: trap::TrapId<GenericArgList>,
}

impl trap::TrapEntry for GenericArgList {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("generic_arg_lists", vec![id.into()]);
    }
}

impl trap::TrapClass for GenericArgList {
    fn class_name() -> &'static str { "GenericArgList" }
}

impl From<trap::Label<GenericArgList>> for trap::Label<AstNode> {
    fn from(value: trap::Label<GenericArgList>) -> Self {
        // SAFETY: this is safe because in the dbscheme GenericArgList is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<GenericArgList>> for trap::Label<Element> {
    fn from(value: trap::Label<GenericArgList>) -> Self {
        // SAFETY: this is safe because in the dbscheme GenericArgList is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<GenericArgList>> for trap::Label<Locatable> {
    fn from(value: trap::Label<GenericArgList>) -> Self {
        // SAFETY: this is safe because in the dbscheme GenericArgList is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<GenericArgList>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<GenericArgList>) -> Self {
        // SAFETY: this is safe because in the dbscheme GenericArgList is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<GenericArgList>> for trap::Label<Unimplemented> {
    fn from(value: trap::Label<GenericArgList>) -> Self {
        // SAFETY: this is safe because in the dbscheme GenericArgList is a subclass of Unimplemented
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Label {
    pub id: trap::TrapId<Label>,
    pub name: String,
}

impl trap::TrapEntry for Label {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("labels", vec![id.into(), self.name.into()]);
    }
}

impl trap::TrapClass for Label {
    fn class_name() -> &'static str { "Label" }
}

impl From<trap::Label<Label>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Label>> for trap::Label<Element> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Label>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Label>) -> Self {
        // SAFETY: this is safe because in the dbscheme Label is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MatchArm {
    pub id: trap::TrapId<MatchArm>,
    pub pat: trap::Label<Pat>,
    pub guard: Option<trap::Label<Expr>>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for MatchArm {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("match_arms", vec![id.into(), self.pat.into(), self.expr.into()]);
        if let Some(v) = self.guard {
            out.add_tuple("match_arm_guards", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for MatchArm {
    fn class_name() -> &'static str { "MatchArm" }
}

impl From<trap::Label<MatchArm>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchArm>> for trap::Label<Element> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchArm>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MatchArm>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchArm is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Pat {
    _unused: ()
}

impl trap::TrapClass for Pat {
    fn class_name() -> &'static str { "Pat" }
}

impl From<trap::Label<Pat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Pat>> for trap::Label<Element> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Pat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Pat>) -> Self {
        // SAFETY: this is safe because in the dbscheme Pat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Path {
    pub id: trap::TrapId<Path>,
}

impl trap::TrapEntry for Path {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("paths", vec![id.into()]);
    }
}

impl trap::TrapClass for Path {
    fn class_name() -> &'static str { "Path" }
}

impl From<trap::Label<Path>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Path>) -> Self {
        // SAFETY: this is safe because in the dbscheme Path is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Path>> for trap::Label<Element> {
    fn from(value: trap::Label<Path>) -> Self {
        // SAFETY: this is safe because in the dbscheme Path is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Path>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Path>) -> Self {
        // SAFETY: this is safe because in the dbscheme Path is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Path>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<Path>) -> Self {
        // SAFETY: this is safe because in the dbscheme Path is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Path>> for trap::Label<Unimplemented> {
    fn from(value: trap::Label<Path>) -> Self {
        // SAFETY: this is safe because in the dbscheme Path is a subclass of Unimplemented
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordExprField {
    pub id: trap::TrapId<RecordExprField>,
    pub name: String,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for RecordExprField {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_expr_fields", vec![id.into(), self.name.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for RecordExprField {
    fn class_name() -> &'static str { "RecordExprField" }
}

impl From<trap::Label<RecordExprField>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordExprField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExprField is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordExprField>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordExprField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExprField is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordExprField>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordExprField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExprField is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordPatField {
    pub id: trap::TrapId<RecordPatField>,
    pub name: String,
    pub pat: trap::Label<Pat>,
}

impl trap::TrapEntry for RecordPatField {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_pat_fields", vec![id.into(), self.name.into(), self.pat.into()]);
    }
}

impl trap::TrapClass for RecordPatField {
    fn class_name() -> &'static str { "RecordPatField" }
}

impl From<trap::Label<RecordPatField>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordPatField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPatField is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPatField>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordPatField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPatField is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPatField>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordPatField>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPatField is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Stmt {
    _unused: ()
}

impl trap::TrapClass for Stmt {
    fn class_name() -> &'static str { "Stmt" }
}

impl From<trap::Label<Stmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Stmt>> for trap::Label<Element> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Stmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Stmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme Stmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TypeRef {
    pub id: trap::TrapId<TypeRef>,
}

impl trap::TrapEntry for TypeRef {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("type_refs", vec![id.into()]);
    }
}

impl trap::TrapClass for TypeRef {
    fn class_name() -> &'static str { "TypeRef" }
}

impl From<trap::Label<TypeRef>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Element> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TypeRef>> for trap::Label<Unimplemented> {
    fn from(value: trap::Label<TypeRef>) -> Self {
        // SAFETY: this is safe because in the dbscheme TypeRef is a subclass of Unimplemented
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ArrayExpr {
    _unused: ()
}

impl trap::TrapClass for ArrayExpr {
    fn class_name() -> &'static str { "ArrayExpr" }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ArrayExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ArrayExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ArrayExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AsmExpr {
    pub id: trap::TrapId<AsmExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for AsmExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("asm_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for AsmExpr {
    fn class_name() -> &'static str { "AsmExpr" }
}

impl From<trap::Label<AsmExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<AsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsmExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsmExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<AsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsmExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsmExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<AsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsmExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsmExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AsmExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsmExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AwaitExpr {
    pub id: trap::TrapId<AwaitExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for AwaitExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("await_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for AwaitExpr {
    fn class_name() -> &'static str { "AwaitExpr" }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AwaitExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AwaitExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AwaitExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BecomeExpr {
    pub id: trap::TrapId<BecomeExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for BecomeExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("become_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for BecomeExpr {
    fn class_name() -> &'static str { "BecomeExpr" }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BecomeExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BecomeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BecomeExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BinaryExpr {
    pub id: trap::TrapId<BinaryExpr>,
    pub lhs: trap::Label<Expr>,
    pub rhs: trap::Label<Expr>,
    pub op: Option<String>,
}

impl trap::TrapEntry for BinaryExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("binary_exprs", vec![id.into(), self.lhs.into(), self.rhs.into()]);
        if let Some(v) = self.op {
            out.add_tuple("binary_expr_ops", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for BinaryExpr {
    fn class_name() -> &'static str { "BinaryExpr" }
}

impl From<trap::Label<BinaryExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BinaryExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BinaryExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BinaryExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BinaryExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BinaryExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BinaryExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BlockExprBase {
    _unused: ()
}

impl trap::TrapClass for BlockExprBase {
    fn class_name() -> &'static str { "BlockExprBase" }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Element> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Expr> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExprBase>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BlockExprBase>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExprBase is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BoxExpr {
    pub id: trap::TrapId<BoxExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for BoxExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("box_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for BoxExpr {
    fn class_name() -> &'static str { "BoxExpr" }
}

impl From<trap::Label<BoxExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BoxExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BoxPat {
    pub id: trap::TrapId<BoxPat>,
    pub inner: trap::Label<Pat>,
}

impl trap::TrapEntry for BoxPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("box_pats", vec![id.into(), self.inner.into()]);
    }
}

impl trap::TrapClass for BoxPat {
    fn class_name() -> &'static str { "BoxPat" }
}

impl From<trap::Label<BoxPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Element> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BoxPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<BoxPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme BoxPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BreakExpr {
    pub id: trap::TrapId<BreakExpr>,
    pub expr: Option<trap::Label<Expr>>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for BreakExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("break_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("break_expr_exprs", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("break_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for BreakExpr {
    fn class_name() -> &'static str { "BreakExpr" }
}

impl From<trap::Label<BreakExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BreakExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BreakExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BreakExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct CallExpr {
    pub id: trap::TrapId<CallExpr>,
    pub callee: trap::Label<Expr>,
    pub args: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for CallExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("call_exprs", vec![id.into(), self.callee.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("call_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("call_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for CallExpr {
    fn class_name() -> &'static str { "CallExpr" }
}

impl From<trap::Label<CallExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CallExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<CallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CallExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct CastExpr {
    pub id: trap::TrapId<CastExpr>,
    pub expr: trap::Label<Expr>,
    pub type_: trap::Label<TypeRef>,
}

impl trap::TrapEntry for CastExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("cast_exprs", vec![id.into(), self.expr.into(), self.type_.into()]);
    }
}

impl trap::TrapClass for CastExpr {
    fn class_name() -> &'static str { "CastExpr" }
}

impl From<trap::Label<CastExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<CastExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<CastExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme CastExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ClosureExpr {
    pub id: trap::TrapId<ClosureExpr>,
    pub args: Vec<trap::Label<Pat>>,
    pub arg_types: Vec<Option<trap::Label<TypeRef>>>,
    pub ret_type: Option<trap::Label<TypeRef>>,
    pub body: trap::Label<Expr>,
    pub closure_kind: String,
    pub is_move: bool,
}

impl trap::TrapEntry for ClosureExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("closure_exprs", vec![id.into(), self.body.into(), self.closure_kind.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("closure_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        for (i, v) in self.arg_types.into_iter().enumerate() {
            if let Some(v) = v {
                out.add_tuple("closure_expr_arg_types", vec![id.into(), i.into(), v.into()]);
            }
        }
        if let Some(v) = self.ret_type {
            out.add_tuple("closure_expr_ret_types", vec![id.into(), v.into()]);
        }
        if self.is_move {
            out.add_tuple("closure_expr_is_move", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for ClosureExpr {
    fn class_name() -> &'static str { "ClosureExpr" }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ClosureExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ClosureExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ClosureExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ConstBlockPat {
    pub id: trap::TrapId<ConstBlockPat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for ConstBlockPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("const_block_pats", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for ConstBlockPat {
    fn class_name() -> &'static str { "ConstBlockPat" }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Element> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstBlockPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<ConstBlockPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstBlockPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ConstExpr {
    pub id: trap::TrapId<ConstExpr>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for ConstExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("const_exprs", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for ConstExpr {
    fn class_name() -> &'static str { "ConstExpr" }
}

impl From<trap::Label<ConstExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ConstExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ConstExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ConstExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ContinueExpr {
    pub id: trap::TrapId<ContinueExpr>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for ContinueExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("continue_exprs", vec![id.into()]);
        if let Some(v) = self.label {
            out.add_tuple("continue_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for ContinueExpr {
    fn class_name() -> &'static str { "ContinueExpr" }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ContinueExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ContinueExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ContinueExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ExprStmt {
    pub id: trap::TrapId<ExprStmt>,
    pub expr: trap::Label<Expr>,
    pub has_semicolon: bool,
}

impl trap::TrapEntry for ExprStmt {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("expr_stmts", vec![id.into(), self.expr.into()]);
        if self.has_semicolon {
            out.add_tuple("expr_stmt_has_semicolon", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for ExprStmt {
    fn class_name() -> &'static str { "ExprStmt" }
}

impl From<trap::Label<ExprStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ExprStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<ExprStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ExprStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct FieldExpr {
    pub id: trap::TrapId<FieldExpr>,
    pub expr: trap::Label<Expr>,
    pub name: String,
}

impl trap::TrapEntry for FieldExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("field_exprs", vec![id.into(), self.expr.into(), self.name.into()]);
    }
}

impl trap::TrapClass for FieldExpr {
    fn class_name() -> &'static str { "FieldExpr" }
}

impl From<trap::Label<FieldExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<FieldExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<FieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme FieldExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Function {
    pub id: trap::TrapId<Function>,
    pub name: String,
    pub body: trap::Label<Expr>,
}

impl trap::TrapEntry for Function {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("functions", vec![id.into(), self.name.into(), self.body.into()]);
    }
}

impl trap::TrapClass for Function {
    fn class_name() -> &'static str { "Function" }
}

impl From<trap::Label<Function>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Declaration> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Element> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Function>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Function>) -> Self {
        // SAFETY: this is safe because in the dbscheme Function is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct IdentPat {
    pub id: trap::TrapId<IdentPat>,
    pub binding_id: String,
    pub subpat: Option<trap::Label<Pat>>,
}

impl trap::TrapEntry for IdentPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ident_pats", vec![id.into(), self.binding_id.into()]);
        if let Some(v) = self.subpat {
            out.add_tuple("ident_pat_subpats", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for IdentPat {
    fn class_name() -> &'static str { "IdentPat" }
}

impl From<trap::Label<IdentPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<IdentPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme IdentPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IdentPat>> for trap::Label<Element> {
    fn from(value: trap::Label<IdentPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme IdentPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IdentPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<IdentPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme IdentPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IdentPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<IdentPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme IdentPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct IfExpr {
    pub id: trap::TrapId<IfExpr>,
    pub condition: trap::Label<Expr>,
    pub then: trap::Label<Expr>,
    pub else_: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for IfExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("if_exprs", vec![id.into(), self.condition.into(), self.then.into()]);
        if let Some(v) = self.else_ {
            out.add_tuple("if_expr_elses", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for IfExpr {
    fn class_name() -> &'static str { "IfExpr" }
}

impl From<trap::Label<IfExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IfExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<IfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IfExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct IndexExpr {
    pub id: trap::TrapId<IndexExpr>,
    pub base: trap::Label<Expr>,
    pub index: trap::Label<Expr>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for IndexExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("index_exprs", vec![id.into(), self.base.into(), self.index.into()]);
        if self.is_assignee_expr {
            out.add_tuple("index_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for IndexExpr {
    fn class_name() -> &'static str { "IndexExpr" }
}

impl From<trap::Label<IndexExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<IndexExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<IndexExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme IndexExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ItemStmt {
    pub id: trap::TrapId<ItemStmt>,
}

impl trap::TrapEntry for ItemStmt {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("item_stmts", vec![id.into()]);
    }
}

impl trap::TrapClass for ItemStmt {
    fn class_name() -> &'static str { "ItemStmt" }
}

impl From<trap::Label<ItemStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ItemStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<ItemStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme ItemStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LetExpr {
    pub id: trap::TrapId<LetExpr>,
    pub pat: trap::Label<Pat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for LetExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("let_exprs", vec![id.into(), self.pat.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for LetExpr {
    fn class_name() -> &'static str { "LetExpr" }
}

impl From<trap::Label<LetExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LetStmt {
    pub id: trap::TrapId<LetStmt>,
    pub pat: trap::Label<Pat>,
    pub type_: Option<trap::Label<TypeRef>>,
    pub initializer: Option<trap::Label<Expr>>,
    pub else_: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for LetStmt {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("let_stmts", vec![id.into(), self.pat.into()]);
        if let Some(v) = self.type_ {
            out.add_tuple("let_stmt_types", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.initializer {
            out.add_tuple("let_stmt_initializers", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.else_ {
            out.add_tuple("let_stmt_elses", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for LetStmt {
    fn class_name() -> &'static str { "LetStmt" }
}

impl From<trap::Label<LetStmt>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Element> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LetStmt>> for trap::Label<Stmt> {
    fn from(value: trap::Label<LetStmt>) -> Self {
        // SAFETY: this is safe because in the dbscheme LetStmt is a subclass of Stmt
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LiteralExpr {
    pub id: trap::TrapId<LiteralExpr>,
}

impl trap::TrapEntry for LiteralExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("literal_exprs", vec![id.into()]);
    }
}

impl trap::TrapClass for LiteralExpr {
    fn class_name() -> &'static str { "LiteralExpr" }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LiteralExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LiteralPat {
    pub id: trap::TrapId<LiteralPat>,
    pub expr: trap::Label<Expr>,
}

impl trap::TrapEntry for LiteralPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("literal_pats", vec![id.into(), self.expr.into()]);
    }
}

impl trap::TrapClass for LiteralPat {
    fn class_name() -> &'static str { "LiteralPat" }
}

impl From<trap::Label<LiteralPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LiteralPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralPat>> for trap::Label<Element> {
    fn from(value: trap::Label<LiteralPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LiteralPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LiteralPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<LiteralPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme LiteralPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct LoopExpr {
    pub id: trap::TrapId<LoopExpr>,
    pub body: trap::Label<Expr>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for LoopExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("loop_exprs", vec![id.into(), self.body.into()]);
        if let Some(v) = self.label {
            out.add_tuple("loop_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for LoopExpr {
    fn class_name() -> &'static str { "LoopExpr" }
}

impl From<trap::Label<LoopExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<LoopExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<LoopExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme LoopExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MatchExpr {
    pub id: trap::TrapId<MatchExpr>,
    pub expr: trap::Label<Expr>,
    pub branches: Vec<trap::Label<MatchArm>>,
}

impl trap::TrapEntry for MatchExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("match_exprs", vec![id.into(), self.expr.into()]);
        for (i, v) in self.branches.into_iter().enumerate() {
            out.add_tuple("match_expr_branches", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for MatchExpr {
    fn class_name() -> &'static str { "MatchExpr" }
}

impl From<trap::Label<MatchExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MatchExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MatchExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MatchExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MethodCallExpr {
    pub id: trap::TrapId<MethodCallExpr>,
    pub receiver: trap::Label<Expr>,
    pub method_name: String,
    pub args: Vec<trap::Label<Expr>>,
    pub generic_args: Option<trap::Label<GenericArgList>>,
}

impl trap::TrapEntry for MethodCallExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("method_call_exprs", vec![id.into(), self.receiver.into(), self.method_name.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("method_call_expr_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.generic_args {
            out.add_tuple("method_call_expr_generic_args", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for MethodCallExpr {
    fn class_name() -> &'static str { "MethodCallExpr" }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MethodCallExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MethodCallExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MethodCallExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MissingExpr {
    pub id: trap::TrapId<MissingExpr>,
}

impl trap::TrapEntry for MissingExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("missing_exprs", vec![id.into()]);
    }
}

impl trap::TrapClass for MissingExpr {
    fn class_name() -> &'static str { "MissingExpr" }
}

impl From<trap::Label<MissingExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Missing> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Missing
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingExpr>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<MissingExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingExpr is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct MissingPat {
    pub id: trap::TrapId<MissingPat>,
}

impl trap::TrapEntry for MissingPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("missing_pats", vec![id.into()]);
    }
}

impl trap::TrapClass for MissingPat {
    fn class_name() -> &'static str { "MissingPat" }
}

impl From<trap::Label<MissingPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Element> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Missing> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Missing
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<MissingPat>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<MissingPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme MissingPat is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct Module {
    pub id: trap::TrapId<Module>,
    pub declarations: Vec<trap::Label<Declaration>>,
}

impl trap::TrapEntry for Module {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("modules", vec![id.into()]);
        for (i, v) in self.declarations.into_iter().enumerate() {
            out.add_tuple("module_declarations", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for Module {
    fn class_name() -> &'static str { "Module" }
}

impl From<trap::Label<Module>> for trap::Label<AstNode> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Declaration> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Element> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<Module>> for trap::Label<Locatable> {
    fn from(value: trap::Label<Module>) -> Self {
        // SAFETY: this is safe because in the dbscheme Module is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct OffsetOfExpr {
    pub id: trap::TrapId<OffsetOfExpr>,
    pub container: trap::Label<TypeRef>,
    pub fields: Vec<String>,
}

impl trap::TrapEntry for OffsetOfExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("offset_of_exprs", vec![id.into(), self.container.into()]);
        for (i, v) in self.fields.into_iter().enumerate() {
            out.add_tuple("offset_of_expr_fields", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for OffsetOfExpr {
    fn class_name() -> &'static str { "OffsetOfExpr" }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OffsetOfExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<OffsetOfExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme OffsetOfExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct OrPat {
    pub id: trap::TrapId<OrPat>,
    pub args: Vec<trap::Label<Pat>>,
}

impl trap::TrapEntry for OrPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("or_pats", vec![id.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("or_pat_args", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for OrPat {
    fn class_name() -> &'static str { "OrPat" }
}

impl From<trap::Label<OrPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Element> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<OrPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<OrPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme OrPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct PathExpr {
    pub id: trap::TrapId<PathExpr>,
    pub path: trap::Label<Path>,
}

impl trap::TrapEntry for PathExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("path_exprs", vec![id.into(), self.path.into()]);
    }
}

impl trap::TrapClass for PathExpr {
    fn class_name() -> &'static str { "PathExpr" }
}

impl From<trap::Label<PathExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<PathExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct PathPat {
    pub id: trap::TrapId<PathPat>,
    pub path: trap::Label<Path>,
}

impl trap::TrapEntry for PathPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("path_pats", vec![id.into(), self.path.into()]);
    }
}

impl trap::TrapClass for PathPat {
    fn class_name() -> &'static str { "PathPat" }
}

impl From<trap::Label<PathPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Element> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PathPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<PathPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme PathPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct PrefixExpr {
    pub id: trap::TrapId<PrefixExpr>,
    pub expr: trap::Label<Expr>,
    pub op: String,
}

impl trap::TrapEntry for PrefixExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("prefix_exprs", vec![id.into(), self.expr.into(), self.op.into()]);
    }
}

impl trap::TrapClass for PrefixExpr {
    fn class_name() -> &'static str { "PrefixExpr" }
}

impl From<trap::Label<PrefixExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<PrefixExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PrefixExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PrefixExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<PrefixExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PrefixExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PrefixExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<PrefixExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PrefixExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<PrefixExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<PrefixExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme PrefixExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RangeExpr {
    pub id: trap::TrapId<RangeExpr>,
    pub lhs: Option<trap::Label<Expr>>,
    pub rhs: Option<trap::Label<Expr>>,
    pub is_inclusive: bool,
}

impl trap::TrapEntry for RangeExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("range_exprs", vec![id.into()]);
        if let Some(v) = self.lhs {
            out.add_tuple("range_expr_lhs", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.rhs {
            out.add_tuple("range_expr_rhs", vec![id.into(), v.into()]);
        }
        if self.is_inclusive {
            out.add_tuple("range_expr_is_inclusive", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for RangeExpr {
    fn class_name() -> &'static str { "RangeExpr" }
}

impl From<trap::Label<RangeExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangeExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RangeExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangeExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RangePat {
    pub id: trap::TrapId<RangePat>,
    pub start: Option<trap::Label<Pat>>,
    pub end: Option<trap::Label<Pat>>,
}

impl trap::TrapEntry for RangePat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("range_pats", vec![id.into()]);
        if let Some(v) = self.start {
            out.add_tuple("range_pat_starts", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.end {
            out.add_tuple("range_pat_ends", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for RangePat {
    fn class_name() -> &'static str { "RangePat" }
}

impl From<trap::Label<RangePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Element> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RangePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RangePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RangePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordExpr {
    pub id: trap::TrapId<RecordExpr>,
    pub path: Option<trap::Label<Path>>,
    pub flds: Vec<trap::Label<RecordExprField>>,
    pub spread: Option<trap::Label<Expr>>,
    pub has_ellipsis: bool,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for RecordExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_exprs", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("record_expr_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.flds.into_iter().enumerate() {
            out.add_tuple("record_expr_flds", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.spread {
            out.add_tuple("record_expr_spreads", vec![id.into(), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_expr_has_ellipsis", vec![id.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("record_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for RecordExpr {
    fn class_name() -> &'static str { "RecordExpr" }
}

impl From<trap::Label<RecordExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RecordExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RecordPat {
    pub id: trap::TrapId<RecordPat>,
    pub path: Option<trap::Label<Path>>,
    pub flds: Vec<trap::Label<RecordPatField>>,
    pub has_ellipsis: bool,
}

impl trap::TrapEntry for RecordPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("record_pats", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("record_pat_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.flds.into_iter().enumerate() {
            out.add_tuple("record_pat_flds", vec![id.into(), i.into(), v.into()]);
        }
        if self.has_ellipsis {
            out.add_tuple("record_pat_has_ellipsis", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for RecordPat {
    fn class_name() -> &'static str { "RecordPat" }
}

impl From<trap::Label<RecordPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Element> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RecordPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RecordPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RecordPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RefExpr {
    pub id: trap::TrapId<RefExpr>,
    pub expr: trap::Label<Expr>,
    pub is_raw: bool,
    pub is_mut: bool,
}

impl trap::TrapEntry for RefExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ref_exprs", vec![id.into(), self.expr.into()]);
        if self.is_raw {
            out.add_tuple("ref_expr_is_raw", vec![id.into()]);
        }
        if self.is_mut {
            out.add_tuple("ref_expr_is_mut", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for RefExpr {
    fn class_name() -> &'static str { "RefExpr" }
}

impl From<trap::Label<RefExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RefExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RefPat {
    pub id: trap::TrapId<RefPat>,
    pub pat: trap::Label<Pat>,
    pub is_mut: bool,
}

impl trap::TrapEntry for RefPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("ref_pats", vec![id.into(), self.pat.into()]);
        if self.is_mut {
            out.add_tuple("ref_pat_is_mut", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for RefPat {
    fn class_name() -> &'static str { "RefPat" }
}

impl From<trap::Label<RefPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Element> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RefPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<RefPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme RefPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ReturnExpr {
    pub id: trap::TrapId<ReturnExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for ReturnExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("return_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("return_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for ReturnExpr {
    fn class_name() -> &'static str { "ReturnExpr" }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ReturnExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ReturnExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ReturnExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct SlicePat {
    pub id: trap::TrapId<SlicePat>,
    pub prefix: Vec<trap::Label<Pat>>,
    pub slice: Option<trap::Label<Pat>>,
    pub suffix: Vec<trap::Label<Pat>>,
}

impl trap::TrapEntry for SlicePat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("slice_pats", vec![id.into()]);
        for (i, v) in self.prefix.into_iter().enumerate() {
            out.add_tuple("slice_pat_prefixes", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.slice {
            out.add_tuple("slice_pat_slice", vec![id.into(), v.into()]);
        }
        for (i, v) in self.suffix.into_iter().enumerate() {
            out.add_tuple("slice_pat_suffixes", vec![id.into(), i.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for SlicePat {
    fn class_name() -> &'static str { "SlicePat" }
}

impl From<trap::Label<SlicePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Element> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<SlicePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<SlicePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme SlicePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TupleExpr {
    pub id: trap::TrapId<TupleExpr>,
    pub exprs: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for TupleExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_exprs", vec![id.into()]);
        for (i, v) in self.exprs.into_iter().enumerate() {
            out.add_tuple("tuple_expr_exprs", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("tuple_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for TupleExpr {
    fn class_name() -> &'static str { "TupleExpr" }
}

impl From<trap::Label<TupleExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TupleExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TuplePat {
    pub id: trap::TrapId<TuplePat>,
    pub args: Vec<trap::Label<Pat>>,
    pub ellipsis_index: Option<usize>,
}

impl trap::TrapEntry for TuplePat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_pats", vec![id.into()]);
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_pat_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_pat_ellipsis_indices", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for TuplePat {
    fn class_name() -> &'static str { "TuplePat" }
}

impl From<trap::Label<TuplePat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Element> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TuplePat>> for trap::Label<Pat> {
    fn from(value: trap::Label<TuplePat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TuplePat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct TupleStructPat {
    pub id: trap::TrapId<TupleStructPat>,
    pub path: Option<trap::Label<Path>>,
    pub args: Vec<trap::Label<Pat>>,
    pub ellipsis_index: Option<usize>,
}

impl trap::TrapEntry for TupleStructPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("tuple_struct_pats", vec![id.into()]);
        if let Some(v) = self.path {
            out.add_tuple("tuple_struct_pat_paths", vec![id.into(), v.into()]);
        }
        for (i, v) in self.args.into_iter().enumerate() {
            out.add_tuple("tuple_struct_pat_args", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.ellipsis_index {
            out.add_tuple("tuple_struct_pat_ellipsis_indices", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for TupleStructPat {
    fn class_name() -> &'static str { "TupleStructPat" }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Element> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<TupleStructPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<TupleStructPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme TupleStructPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnderscoreExpr {
    pub id: trap::TrapId<UnderscoreExpr>,
}

impl trap::TrapEntry for UnderscoreExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("underscore_exprs", vec![id.into()]);
    }
}

impl trap::TrapClass for UnderscoreExpr {
    fn class_name() -> &'static str { "UnderscoreExpr" }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnderscoreExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnderscoreExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnderscoreExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnimplementedDeclaration {
    pub id: trap::TrapId<UnimplementedDeclaration>,
}

impl trap::TrapEntry for UnimplementedDeclaration {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("unimplemented_declarations", vec![id.into()]);
    }
}

impl trap::TrapClass for UnimplementedDeclaration {
    fn class_name() -> &'static str { "UnimplementedDeclaration" }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<Declaration> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of Declaration
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<Element> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<Unextracted> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of Unextracted
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnimplementedDeclaration>> for trap::Label<Unimplemented> {
    fn from(value: trap::Label<UnimplementedDeclaration>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnimplementedDeclaration is a subclass of Unimplemented
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct WildcardPat {
    pub id: trap::TrapId<WildcardPat>,
}

impl trap::TrapEntry for WildcardPat {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("wildcard_pats", vec![id.into()]);
    }
}

impl trap::TrapClass for WildcardPat {
    fn class_name() -> &'static str { "WildcardPat" }
}

impl From<trap::Label<WildcardPat>> for trap::Label<AstNode> {
    fn from(value: trap::Label<WildcardPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildcardPat is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildcardPat>> for trap::Label<Element> {
    fn from(value: trap::Label<WildcardPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildcardPat is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildcardPat>> for trap::Label<Locatable> {
    fn from(value: trap::Label<WildcardPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildcardPat is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<WildcardPat>> for trap::Label<Pat> {
    fn from(value: trap::Label<WildcardPat>) -> Self {
        // SAFETY: this is safe because in the dbscheme WildcardPat is a subclass of Pat
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct YeetExpr {
    pub id: trap::TrapId<YeetExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for YeetExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("yeet_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("yeet_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for YeetExpr {
    fn class_name() -> &'static str { "YeetExpr" }
}

impl From<trap::Label<YeetExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YeetExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<YeetExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YeetExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct YieldExpr {
    pub id: trap::TrapId<YieldExpr>,
    pub expr: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for YieldExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("yield_exprs", vec![id.into()]);
        if let Some(v) = self.expr {
            out.add_tuple("yield_expr_exprs", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for YieldExpr {
    fn class_name() -> &'static str { "YieldExpr" }
}

impl From<trap::Label<YieldExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<YieldExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<YieldExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme YieldExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct AsyncBlockExpr {
    pub id: trap::TrapId<AsyncBlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for AsyncBlockExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("async_block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for AsyncBlockExpr {
    fn class_name() -> &'static str { "AsyncBlockExpr" }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<AsyncBlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<AsyncBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme AsyncBlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct BlockExpr {
    pub id: trap::TrapId<BlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
    pub label: Option<trap::Label<Label>>,
}

impl trap::TrapEntry for BlockExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
        if let Some(v) = self.label {
            out.add_tuple("block_expr_labels", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for BlockExpr {
    fn class_name() -> &'static str { "BlockExpr" }
}

impl From<trap::Label<BlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<BlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<BlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme BlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct ElementListExpr {
    pub id: trap::TrapId<ElementListExpr>,
    pub elements: Vec<trap::Label<Expr>>,
    pub is_assignee_expr: bool,
}

impl trap::TrapEntry for ElementListExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("element_list_exprs", vec![id.into()]);
        for (i, v) in self.elements.into_iter().enumerate() {
            out.add_tuple("element_list_expr_elements", vec![id.into(), i.into(), v.into()]);
        }
        if self.is_assignee_expr {
            out.add_tuple("element_list_expr_is_assignee_expr", vec![id.into()]);
        }
    }
}

impl trap::TrapClass for ElementListExpr {
    fn class_name() -> &'static str { "ElementListExpr" }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<ArrayExpr> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of ArrayExpr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<ElementListExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<ElementListExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme ElementListExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct RepeatExpr {
    pub id: trap::TrapId<RepeatExpr>,
    pub initializer: trap::Label<Expr>,
    pub repeat: trap::Label<Expr>,
}

impl trap::TrapEntry for RepeatExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("repeat_exprs", vec![id.into(), self.initializer.into(), self.repeat.into()]);
    }
}

impl trap::TrapClass for RepeatExpr {
    fn class_name() -> &'static str { "RepeatExpr" }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<ArrayExpr> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of ArrayExpr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<RepeatExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<RepeatExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme RepeatExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

#[derive(Debug)]
pub struct UnsafeBlockExpr {
    pub id: trap::TrapId<UnsafeBlockExpr>,
    pub statements: Vec<trap::Label<Stmt>>,
    pub tail: Option<trap::Label<Expr>>,
}

impl trap::TrapEntry for UnsafeBlockExpr {
    fn extract_id(&mut self) -> trap::TrapId<Self> {
        std::mem::replace(&mut self.id, trap::TrapId::Star)
    }

    fn emit(self, id: trap::Label<Self>, out: &mut trap::Writer) {
        out.add_tuple("unsafe_block_exprs", vec![id.into()]);
        for (i, v) in self.statements.into_iter().enumerate() {
            out.add_tuple("block_expr_base_statements", vec![id.into(), i.into(), v.into()]);
        }
        if let Some(v) = self.tail {
            out.add_tuple("block_expr_base_tails", vec![id.into(), v.into()]);
        }
    }
}

impl trap::TrapClass for UnsafeBlockExpr {
    fn class_name() -> &'static str { "UnsafeBlockExpr" }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<AstNode> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of AstNode
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<BlockExprBase> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of BlockExprBase
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Element> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Element
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Expr> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Expr
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}

impl From<trap::Label<UnsafeBlockExpr>> for trap::Label<Locatable> {
    fn from(value: trap::Label<UnsafeBlockExpr>) -> Self {
        // SAFETY: this is safe because in the dbscheme UnsafeBlockExpr is a subclass of Locatable
        unsafe {
            Self::from_untyped(value.as_untyped())
        }
    }
}
