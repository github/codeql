//! Generated by `ast-generator`, do not edit by hand.
use super::base::Translator;
use super::mappings::TextValue;
use crate::generated;
use crate::trap::{Label, TrapId};
use crate::{post_emit, pre_emit};
use ra_ap_syntax::ast::{
    HasArgList, HasAttrs, HasGenericArgs, HasGenericParams, HasLoopBody, HasModuleItem, HasName,
    HasTypeBounds, HasVisibility, RangeItem,
};
#[rustfmt::skip]
use ra_ap_syntax::{AstNode, ast};
impl Translator<'_> {
    fn emit_else_branch(&mut self, node: &ast::ElseBranch) -> Option<Label<generated::Expr>> {
        match node {
            ast::ElseBranch::IfExpr(inner) => self.emit_if_expr(inner).map(Into::into),
            ast::ElseBranch::Block(inner) => self.emit_block_expr(inner).map(Into::into),
        }
    }
    pub(crate) fn emit_asm_operand(
        &mut self,
        node: &ast::AsmOperand,
    ) -> Option<Label<generated::AsmOperand>> {
        pre_emit!(AsmOperand, self, node);
        let label = match node {
            ast::AsmOperand::AsmConst(inner) => self.emit_asm_const(inner).map(Into::into),
            ast::AsmOperand::AsmLabel(inner) => self.emit_asm_label(inner).map(Into::into),
            ast::AsmOperand::AsmRegOperand(inner) => {
                self.emit_asm_reg_operand(inner).map(Into::into)
            }
            ast::AsmOperand::AsmSym(inner) => self.emit_asm_sym(inner).map(Into::into),
        }?;
        post_emit!(AsmOperand, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_asm_piece(
        &mut self,
        node: &ast::AsmPiece,
    ) -> Option<Label<generated::AsmPiece>> {
        pre_emit!(AsmPiece, self, node);
        let label = match node {
            ast::AsmPiece::AsmClobberAbi(inner) => self.emit_asm_clobber_abi(inner).map(Into::into),
            ast::AsmPiece::AsmOperandNamed(inner) => {
                self.emit_asm_operand_named(inner).map(Into::into)
            }
            ast::AsmPiece::AsmOptions(inner) => self.emit_asm_options(inner).map(Into::into),
        }?;
        post_emit!(AsmPiece, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_assoc_item(
        &mut self,
        node: &ast::AssocItem,
    ) -> Option<Label<generated::AssocItem>> {
        pre_emit!(AssocItem, self, node);
        let label = match node {
            ast::AssocItem::Const(inner) => self.emit_const(inner).map(Into::into),
            ast::AssocItem::Fn(inner) => self.emit_fn(inner).map(Into::into),
            ast::AssocItem::MacroCall(inner) => self.emit_macro_call(inner).map(Into::into),
            ast::AssocItem::TypeAlias(inner) => self.emit_type_alias(inner).map(Into::into),
        }?;
        post_emit!(AssocItem, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_expr(&mut self, node: &ast::Expr) -> Option<Label<generated::Expr>> {
        pre_emit!(Expr, self, node);
        let label = match node {
            ast::Expr::ArrayExpr(inner) => self.emit_array_expr(inner).map(Into::into),
            ast::Expr::AsmExpr(inner) => self.emit_asm_expr(inner).map(Into::into),
            ast::Expr::AwaitExpr(inner) => self.emit_await_expr(inner).map(Into::into),
            ast::Expr::BecomeExpr(inner) => self.emit_become_expr(inner).map(Into::into),
            ast::Expr::BinExpr(inner) => self.emit_bin_expr(inner).map(Into::into),
            ast::Expr::BlockExpr(inner) => self.emit_block_expr(inner).map(Into::into),
            ast::Expr::BreakExpr(inner) => self.emit_break_expr(inner).map(Into::into),
            ast::Expr::CallExpr(inner) => self.emit_call_expr(inner).map(Into::into),
            ast::Expr::CastExpr(inner) => self.emit_cast_expr(inner).map(Into::into),
            ast::Expr::ClosureExpr(inner) => self.emit_closure_expr(inner).map(Into::into),
            ast::Expr::ContinueExpr(inner) => self.emit_continue_expr(inner).map(Into::into),
            ast::Expr::FieldExpr(inner) => self.emit_field_expr(inner).map(Into::into),
            ast::Expr::ForExpr(inner) => self.emit_for_expr(inner).map(Into::into),
            ast::Expr::FormatArgsExpr(inner) => self.emit_format_args_expr(inner).map(Into::into),
            ast::Expr::IfExpr(inner) => self.emit_if_expr(inner).map(Into::into),
            ast::Expr::IndexExpr(inner) => self.emit_index_expr(inner).map(Into::into),
            ast::Expr::LetExpr(inner) => self.emit_let_expr(inner).map(Into::into),
            ast::Expr::Literal(inner) => self.emit_literal(inner).map(Into::into),
            ast::Expr::LoopExpr(inner) => self.emit_loop_expr(inner).map(Into::into),
            ast::Expr::MacroExpr(inner) => self.emit_macro_expr(inner).map(Into::into),
            ast::Expr::MatchExpr(inner) => self.emit_match_expr(inner).map(Into::into),
            ast::Expr::MethodCallExpr(inner) => self.emit_method_call_expr(inner).map(Into::into),
            ast::Expr::OffsetOfExpr(inner) => self.emit_offset_of_expr(inner).map(Into::into),
            ast::Expr::ParenExpr(inner) => self.emit_paren_expr(inner).map(Into::into),
            ast::Expr::PathExpr(inner) => self.emit_path_expr(inner).map(Into::into),
            ast::Expr::PrefixExpr(inner) => self.emit_prefix_expr(inner).map(Into::into),
            ast::Expr::RangeExpr(inner) => self.emit_range_expr(inner).map(Into::into),
            ast::Expr::RecordExpr(inner) => self.emit_record_expr(inner).map(Into::into),
            ast::Expr::RefExpr(inner) => self.emit_ref_expr(inner).map(Into::into),
            ast::Expr::ReturnExpr(inner) => self.emit_return_expr(inner).map(Into::into),
            ast::Expr::TryExpr(inner) => self.emit_try_expr(inner).map(Into::into),
            ast::Expr::TupleExpr(inner) => self.emit_tuple_expr(inner).map(Into::into),
            ast::Expr::UnderscoreExpr(inner) => self.emit_underscore_expr(inner).map(Into::into),
            ast::Expr::WhileExpr(inner) => self.emit_while_expr(inner).map(Into::into),
            ast::Expr::YeetExpr(inner) => self.emit_yeet_expr(inner).map(Into::into),
            ast::Expr::YieldExpr(inner) => self.emit_yield_expr(inner).map(Into::into),
        }?;
        post_emit!(Expr, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_extern_item(
        &mut self,
        node: &ast::ExternItem,
    ) -> Option<Label<generated::ExternItem>> {
        pre_emit!(ExternItem, self, node);
        let label = match node {
            ast::ExternItem::Fn(inner) => self.emit_fn(inner).map(Into::into),
            ast::ExternItem::MacroCall(inner) => self.emit_macro_call(inner).map(Into::into),
            ast::ExternItem::Static(inner) => self.emit_static(inner).map(Into::into),
            ast::ExternItem::TypeAlias(inner) => self.emit_type_alias(inner).map(Into::into),
        }?;
        post_emit!(ExternItem, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_field_list(
        &mut self,
        node: &ast::FieldList,
    ) -> Option<Label<generated::FieldList>> {
        pre_emit!(FieldList, self, node);
        let label = match node {
            ast::FieldList::RecordFieldList(inner) => {
                self.emit_record_field_list(inner).map(Into::into)
            }
            ast::FieldList::TupleFieldList(inner) => {
                self.emit_tuple_field_list(inner).map(Into::into)
            }
        }?;
        post_emit!(FieldList, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_generic_arg(
        &mut self,
        node: &ast::GenericArg,
    ) -> Option<Label<generated::GenericArg>> {
        pre_emit!(GenericArg, self, node);
        let label = match node {
            ast::GenericArg::AssocTypeArg(inner) => self.emit_assoc_type_arg(inner).map(Into::into),
            ast::GenericArg::ConstArg(inner) => self.emit_const_arg(inner).map(Into::into),
            ast::GenericArg::LifetimeArg(inner) => self.emit_lifetime_arg(inner).map(Into::into),
            ast::GenericArg::TypeArg(inner) => self.emit_type_arg(inner).map(Into::into),
        }?;
        post_emit!(GenericArg, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_generic_param(
        &mut self,
        node: &ast::GenericParam,
    ) -> Option<Label<generated::GenericParam>> {
        pre_emit!(GenericParam, self, node);
        let label = match node {
            ast::GenericParam::ConstParam(inner) => self.emit_const_param(inner).map(Into::into),
            ast::GenericParam::LifetimeParam(inner) => {
                self.emit_lifetime_param(inner).map(Into::into)
            }
            ast::GenericParam::TypeParam(inner) => self.emit_type_param(inner).map(Into::into),
        }?;
        post_emit!(GenericParam, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_pat(&mut self, node: &ast::Pat) -> Option<Label<generated::Pat>> {
        pre_emit!(Pat, self, node);
        let label = match node {
            ast::Pat::BoxPat(inner) => self.emit_box_pat(inner).map(Into::into),
            ast::Pat::ConstBlockPat(inner) => self.emit_const_block_pat(inner).map(Into::into),
            ast::Pat::IdentPat(inner) => self.emit_ident_pat(inner).map(Into::into),
            ast::Pat::LiteralPat(inner) => self.emit_literal_pat(inner).map(Into::into),
            ast::Pat::MacroPat(inner) => self.emit_macro_pat(inner).map(Into::into),
            ast::Pat::OrPat(inner) => self.emit_or_pat(inner).map(Into::into),
            ast::Pat::ParenPat(inner) => self.emit_paren_pat(inner).map(Into::into),
            ast::Pat::PathPat(inner) => self.emit_path_pat(inner).map(Into::into),
            ast::Pat::RangePat(inner) => self.emit_range_pat(inner).map(Into::into),
            ast::Pat::RecordPat(inner) => self.emit_record_pat(inner).map(Into::into),
            ast::Pat::RefPat(inner) => self.emit_ref_pat(inner).map(Into::into),
            ast::Pat::RestPat(inner) => self.emit_rest_pat(inner).map(Into::into),
            ast::Pat::SlicePat(inner) => self.emit_slice_pat(inner).map(Into::into),
            ast::Pat::TuplePat(inner) => self.emit_tuple_pat(inner).map(Into::into),
            ast::Pat::TupleStructPat(inner) => self.emit_tuple_struct_pat(inner).map(Into::into),
            ast::Pat::WildcardPat(inner) => self.emit_wildcard_pat(inner).map(Into::into),
        }?;
        post_emit!(Pat, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_stmt(&mut self, node: &ast::Stmt) -> Option<Label<generated::Stmt>> {
        pre_emit!(Stmt, self, node);
        let label = match node {
            ast::Stmt::ExprStmt(inner) => self.emit_expr_stmt(inner).map(Into::into),
            ast::Stmt::Item(inner) => self.emit_item(inner).map(Into::into),
            ast::Stmt::LetStmt(inner) => self.emit_let_stmt(inner).map(Into::into),
        }?;
        post_emit!(Stmt, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_type(&mut self, node: &ast::Type) -> Option<Label<generated::TypeRepr>> {
        pre_emit!(TypeRepr, self, node);
        let label = match node {
            ast::Type::ArrayType(inner) => self.emit_array_type(inner).map(Into::into),
            ast::Type::DynTraitType(inner) => self.emit_dyn_trait_type(inner).map(Into::into),
            ast::Type::FnPtrType(inner) => self.emit_fn_ptr_type(inner).map(Into::into),
            ast::Type::ForType(inner) => self.emit_for_type(inner).map(Into::into),
            ast::Type::ImplTraitType(inner) => self.emit_impl_trait_type(inner).map(Into::into),
            ast::Type::InferType(inner) => self.emit_infer_type(inner).map(Into::into),
            ast::Type::MacroType(inner) => self.emit_macro_type(inner).map(Into::into),
            ast::Type::NeverType(inner) => self.emit_never_type(inner).map(Into::into),
            ast::Type::ParenType(inner) => self.emit_paren_type(inner).map(Into::into),
            ast::Type::PathType(inner) => self.emit_path_type(inner).map(Into::into),
            ast::Type::PtrType(inner) => self.emit_ptr_type(inner).map(Into::into),
            ast::Type::RefType(inner) => self.emit_ref_type(inner).map(Into::into),
            ast::Type::SliceType(inner) => self.emit_slice_type(inner).map(Into::into),
            ast::Type::TupleType(inner) => self.emit_tuple_type(inner).map(Into::into),
        }?;
        post_emit!(TypeRepr, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_use_bound_generic_arg(
        &mut self,
        node: &ast::UseBoundGenericArg,
    ) -> Option<Label<generated::UseBoundGenericArg>> {
        pre_emit!(UseBoundGenericArg, self, node);
        let label = match node {
            ast::UseBoundGenericArg::Lifetime(inner) => self.emit_lifetime(inner).map(Into::into),
            ast::UseBoundGenericArg::NameRef(inner) => self.emit_name_ref(inner).map(Into::into),
        }?;
        post_emit!(UseBoundGenericArg, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_item(&mut self, node: &ast::Item) -> Option<Label<generated::Item>> {
        pre_emit!(Item, self, node);
        let label = match node {
            ast::Item::Const(inner) => self.emit_const(inner).map(Into::into),
            ast::Item::Enum(inner) => self.emit_enum(inner).map(Into::into),
            ast::Item::ExternBlock(inner) => self.emit_extern_block(inner).map(Into::into),
            ast::Item::ExternCrate(inner) => self.emit_extern_crate(inner).map(Into::into),
            ast::Item::Fn(inner) => self.emit_fn(inner).map(Into::into),
            ast::Item::Impl(inner) => self.emit_impl(inner).map(Into::into),
            ast::Item::MacroCall(inner) => self.emit_macro_call(inner).map(Into::into),
            ast::Item::MacroDef(inner) => self.emit_macro_def(inner).map(Into::into),
            ast::Item::MacroRules(inner) => self.emit_macro_rules(inner).map(Into::into),
            ast::Item::Module(inner) => self.emit_module(inner).map(Into::into),
            ast::Item::Static(inner) => self.emit_static(inner).map(Into::into),
            ast::Item::Struct(inner) => self.emit_struct(inner).map(Into::into),
            ast::Item::Trait(inner) => self.emit_trait(inner).map(Into::into),
            ast::Item::TraitAlias(inner) => self.emit_trait_alias(inner).map(Into::into),
            ast::Item::TypeAlias(inner) => self.emit_type_alias(inner).map(Into::into),
            ast::Item::Union(inner) => self.emit_union(inner).map(Into::into),
            ast::Item::Use(inner) => self.emit_use(inner).map(Into::into),
        }?;
        post_emit!(Item, self, node, label);
        Some(label)
    }
    pub(crate) fn emit_abi(&mut self, node: &ast::Abi) -> Option<Label<generated::Abi>> {
        pre_emit!(Abi, self, node);
        let abi_string = node.try_get_text();
        let label = self.trap.emit(generated::Abi {
            id: TrapId::Star,
            abi_string,
        });
        self.emit_location(label, node);
        post_emit!(Abi, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_arg_list(
        &mut self,
        node: &ast::ArgList,
    ) -> Option<Label<generated::ArgList>> {
        pre_emit!(ArgList, self, node);
        let args = node.args().filter_map(|x| self.emit_expr(&x)).collect();
        let label = self.trap.emit(generated::ArgList {
            id: TrapId::Star,
            args,
        });
        self.emit_location(label, node);
        post_emit!(ArgList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_array_expr(
        &mut self,
        node: &ast::ArrayExpr,
    ) -> Option<Label<generated::ArrayExprInternal>> {
        pre_emit!(ArrayExprInternal, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let exprs = node.exprs().filter_map(|x| self.emit_expr(&x)).collect();
        let is_semicolon = node.semicolon_token().is_some();
        let label = self.trap.emit(generated::ArrayExprInternal {
            id: TrapId::Star,
            attrs,
            exprs,
            is_semicolon,
        });
        self.emit_location(label, node);
        post_emit!(ArrayExprInternal, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_array_type(
        &mut self,
        node: &ast::ArrayType,
    ) -> Option<Label<generated::ArrayTypeRepr>> {
        pre_emit!(ArrayTypeRepr, self, node);
        let const_arg = node.const_arg().and_then(|x| self.emit_const_arg(&x));
        let element_type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::ArrayTypeRepr {
            id: TrapId::Star,
            const_arg,
            element_type_repr,
        });
        self.emit_location(label, node);
        post_emit!(ArrayTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_clobber_abi(
        &mut self,
        node: &ast::AsmClobberAbi,
    ) -> Option<Label<generated::AsmClobberAbi>> {
        pre_emit!(AsmClobberAbi, self, node);
        let label = self
            .trap
            .emit(generated::AsmClobberAbi { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(AsmClobberAbi, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_const(
        &mut self,
        node: &ast::AsmConst,
    ) -> Option<Label<generated::AsmConst>> {
        pre_emit!(AsmConst, self, node);
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let is_const = node.const_token().is_some();
        let label = self.trap.emit(generated::AsmConst {
            id: TrapId::Star,
            expr,
            is_const,
        });
        self.emit_location(label, node);
        post_emit!(AsmConst, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_dir_spec(
        &mut self,
        node: &ast::AsmDirSpec,
    ) -> Option<Label<generated::AsmDirSpec>> {
        pre_emit!(AsmDirSpec, self, node);
        let label = self.trap.emit(generated::AsmDirSpec { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(AsmDirSpec, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_expr(
        &mut self,
        node: &ast::AsmExpr,
    ) -> Option<Label<generated::AsmExpr>> {
        pre_emit!(AsmExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let asm_pieces = node
            .asm_pieces()
            .filter_map(|x| self.emit_asm_piece(&x))
            .collect();
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let template = node.template().filter_map(|x| self.emit_expr(&x)).collect();
        let label = self.trap.emit(generated::AsmExpr {
            id: TrapId::Star,
            asm_pieces,
            attrs,
            template,
        });
        self.emit_location(label, node);
        post_emit!(AsmExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_label(
        &mut self,
        node: &ast::AsmLabel,
    ) -> Option<Label<generated::AsmLabel>> {
        pre_emit!(AsmLabel, self, node);
        let block_expr = node.block_expr().and_then(|x| self.emit_block_expr(&x));
        let label = self.trap.emit(generated::AsmLabel {
            id: TrapId::Star,
            block_expr,
        });
        self.emit_location(label, node);
        post_emit!(AsmLabel, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_operand_expr(
        &mut self,
        node: &ast::AsmOperandExpr,
    ) -> Option<Label<generated::AsmOperandExpr>> {
        pre_emit!(AsmOperandExpr, self, node);
        let in_expr = node.in_expr().and_then(|x| self.emit_expr(&x));
        let out_expr = node.out_expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::AsmOperandExpr {
            id: TrapId::Star,
            in_expr,
            out_expr,
        });
        self.emit_location(label, node);
        post_emit!(AsmOperandExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_operand_named(
        &mut self,
        node: &ast::AsmOperandNamed,
    ) -> Option<Label<generated::AsmOperandNamed>> {
        pre_emit!(AsmOperandNamed, self, node);
        let asm_operand = node.asm_operand().and_then(|x| self.emit_asm_operand(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let label = self.trap.emit(generated::AsmOperandNamed {
            id: TrapId::Star,
            asm_operand,
            name,
        });
        self.emit_location(label, node);
        post_emit!(AsmOperandNamed, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_option(
        &mut self,
        node: &ast::AsmOption,
    ) -> Option<Label<generated::AsmOption>> {
        pre_emit!(AsmOption, self, node);
        let is_raw = node.raw_token().is_some();
        let label = self.trap.emit(generated::AsmOption {
            id: TrapId::Star,
            is_raw,
        });
        self.emit_location(label, node);
        post_emit!(AsmOption, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_options(
        &mut self,
        node: &ast::AsmOptions,
    ) -> Option<Label<generated::AsmOptionsList>> {
        pre_emit!(AsmOptionsList, self, node);
        let asm_options = node
            .asm_options()
            .filter_map(|x| self.emit_asm_option(&x))
            .collect();
        let label = self.trap.emit(generated::AsmOptionsList {
            id: TrapId::Star,
            asm_options,
        });
        self.emit_location(label, node);
        post_emit!(AsmOptionsList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_reg_operand(
        &mut self,
        node: &ast::AsmRegOperand,
    ) -> Option<Label<generated::AsmRegOperand>> {
        pre_emit!(AsmRegOperand, self, node);
        let asm_dir_spec = node.asm_dir_spec().and_then(|x| self.emit_asm_dir_spec(&x));
        let asm_operand_expr = node
            .asm_operand_expr()
            .and_then(|x| self.emit_asm_operand_expr(&x));
        let asm_reg_spec = node.asm_reg_spec().and_then(|x| self.emit_asm_reg_spec(&x));
        let label = self.trap.emit(generated::AsmRegOperand {
            id: TrapId::Star,
            asm_dir_spec,
            asm_operand_expr,
            asm_reg_spec,
        });
        self.emit_location(label, node);
        post_emit!(AsmRegOperand, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_reg_spec(
        &mut self,
        node: &ast::AsmRegSpec,
    ) -> Option<Label<generated::AsmRegSpec>> {
        pre_emit!(AsmRegSpec, self, node);
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let label = self.trap.emit(generated::AsmRegSpec {
            id: TrapId::Star,
            identifier,
        });
        self.emit_location(label, node);
        post_emit!(AsmRegSpec, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_asm_sym(&mut self, node: &ast::AsmSym) -> Option<Label<generated::AsmSym>> {
        pre_emit!(AsmSym, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::AsmSym {
            id: TrapId::Star,
            path,
        });
        self.emit_location(label, node);
        post_emit!(AsmSym, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_assoc_item_list(
        &mut self,
        node: &ast::AssocItemList,
    ) -> Option<Label<generated::AssocItemList>> {
        pre_emit!(AssocItemList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let assoc_items = node
            .assoc_items()
            .filter_map(|x| self.emit_assoc_item(&x))
            .collect();
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let label = self.trap.emit(generated::AssocItemList {
            id: TrapId::Star,
            assoc_items,
            attrs,
        });
        self.emit_location(label, node);
        post_emit!(AssocItemList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_assoc_type_arg(
        &mut self,
        node: &ast::AssocTypeArg,
    ) -> Option<Label<generated::AssocTypeArg>> {
        pre_emit!(AssocTypeArg, self, node);
        let const_arg = node.const_arg().and_then(|x| self.emit_const_arg(&x));
        let generic_arg_list = node
            .generic_arg_list()
            .and_then(|x| self.emit_generic_arg_list(&x));
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let param_list = node.param_list().and_then(|x| self.emit_param_list(&x));
        let ret_type = node.ret_type().and_then(|x| self.emit_ret_type(&x));
        let return_type_syntax = node
            .return_type_syntax()
            .and_then(|x| self.emit_return_type_syntax(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::AssocTypeArg {
            id: TrapId::Star,
            const_arg,
            generic_arg_list,
            identifier,
            param_list,
            ret_type,
            return_type_syntax,
            type_repr,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(AssocTypeArg, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_attr(&mut self, node: &ast::Attr) -> Option<Label<generated::Attr>> {
        pre_emit!(Attr, self, node);
        let meta = node.meta().and_then(|x| self.emit_meta(&x));
        let label = self.trap.emit(generated::Attr {
            id: TrapId::Star,
            meta,
        });
        self.emit_location(label, node);
        post_emit!(Attr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_await_expr(
        &mut self,
        node: &ast::AwaitExpr,
    ) -> Option<Label<generated::AwaitExpr>> {
        pre_emit!(AwaitExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::AwaitExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(AwaitExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_become_expr(
        &mut self,
        node: &ast::BecomeExpr,
    ) -> Option<Label<generated::BecomeExpr>> {
        pre_emit!(BecomeExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::BecomeExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(BecomeExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_bin_expr(
        &mut self,
        node: &ast::BinExpr,
    ) -> Option<Label<generated::BinaryExpr>> {
        pre_emit!(BinaryExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let lhs = node.lhs().and_then(|x| self.emit_expr(&x));
        let operator_name = node.try_get_text();
        let rhs = node.rhs().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::BinaryExpr {
            id: TrapId::Star,
            attrs,
            lhs,
            operator_name,
            rhs,
        });
        self.emit_location(label, node);
        post_emit!(BinaryExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_block_expr(
        &mut self,
        node: &ast::BlockExpr,
    ) -> Option<Label<generated::BlockExpr>> {
        pre_emit!(BlockExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let is_async = node.async_token().is_some();
        let is_const = node.const_token().is_some();
        let is_gen = node.gen_token().is_some();
        let is_move = node.move_token().is_some();
        let is_try = node.try_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let label = node.label().and_then(|x| self.emit_label(&x));
        let stmt_list = node.stmt_list().and_then(|x| self.emit_stmt_list(&x));
        let label = self.trap.emit(generated::BlockExpr {
            id: TrapId::Star,
            attrs,
            is_async,
            is_const,
            is_gen,
            is_move,
            is_try,
            is_unsafe,
            label,
            stmt_list,
        });
        self.emit_location(label, node);
        post_emit!(BlockExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_box_pat(&mut self, node: &ast::BoxPat) -> Option<Label<generated::BoxPat>> {
        pre_emit!(BoxPat, self, node);
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::BoxPat {
            id: TrapId::Star,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(BoxPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_break_expr(
        &mut self,
        node: &ast::BreakExpr,
    ) -> Option<Label<generated::BreakExpr>> {
        pre_emit!(BreakExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let label = self.trap.emit(generated::BreakExpr {
            id: TrapId::Star,
            attrs,
            expr,
            lifetime,
        });
        self.emit_location(label, node);
        post_emit!(BreakExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_call_expr(
        &mut self,
        node: &ast::CallExpr,
    ) -> Option<Label<generated::CallExpr>> {
        pre_emit!(CallExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let arg_list = node.arg_list().and_then(|x| self.emit_arg_list(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let function = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::CallExpr {
            id: TrapId::Star,
            arg_list,
            attrs,
            function,
        });
        self.emit_location(label, node);
        post_emit!(CallExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_cast_expr(
        &mut self,
        node: &ast::CastExpr,
    ) -> Option<Label<generated::CastExpr>> {
        pre_emit!(CastExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::CastExpr {
            id: TrapId::Star,
            attrs,
            expr,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(CastExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_closure_binder(
        &mut self,
        node: &ast::ClosureBinder,
    ) -> Option<Label<generated::ClosureBinder>> {
        pre_emit!(ClosureBinder, self, node);
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let label = self.trap.emit(generated::ClosureBinder {
            id: TrapId::Star,
            generic_param_list,
        });
        self.emit_location(label, node);
        post_emit!(ClosureBinder, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_closure_expr(
        &mut self,
        node: &ast::ClosureExpr,
    ) -> Option<Label<generated::ClosureExpr>> {
        pre_emit!(ClosureExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let body = node.body().and_then(|x| self.emit_expr(&x));
        let closure_binder = node
            .closure_binder()
            .and_then(|x| self.emit_closure_binder(&x));
        let is_async = node.async_token().is_some();
        let is_const = node.const_token().is_some();
        let is_gen = node.gen_token().is_some();
        let is_move = node.move_token().is_some();
        let is_static = node.static_token().is_some();
        let param_list = node.param_list().and_then(|x| self.emit_param_list(&x));
        let ret_type = node.ret_type().and_then(|x| self.emit_ret_type(&x));
        let label = self.trap.emit(generated::ClosureExpr {
            id: TrapId::Star,
            attrs,
            body,
            closure_binder,
            is_async,
            is_const,
            is_gen,
            is_move,
            is_static,
            param_list,
            ret_type,
        });
        self.emit_location(label, node);
        post_emit!(ClosureExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_const(&mut self, node: &ast::Const) -> Option<Label<generated::Const>> {
        pre_emit!(Const, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let body = node.body().and_then(|x| self.emit_expr(&x));
        let is_const = node.const_token().is_some();
        let is_default = node.default_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::Const {
            id: TrapId::Star,
            attrs,
            body,
            is_const,
            is_default,
            name,
            type_repr,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(Const, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_const_arg(
        &mut self,
        node: &ast::ConstArg,
    ) -> Option<Label<generated::ConstArg>> {
        pre_emit!(ConstArg, self, node);
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::ConstArg {
            id: TrapId::Star,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(ConstArg, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_const_block_pat(
        &mut self,
        node: &ast::ConstBlockPat,
    ) -> Option<Label<generated::ConstBlockPat>> {
        pre_emit!(ConstBlockPat, self, node);
        let block_expr = node.block_expr().and_then(|x| self.emit_block_expr(&x));
        let is_const = node.const_token().is_some();
        let label = self.trap.emit(generated::ConstBlockPat {
            id: TrapId::Star,
            block_expr,
            is_const,
        });
        self.emit_location(label, node);
        post_emit!(ConstBlockPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_const_param(
        &mut self,
        node: &ast::ConstParam,
    ) -> Option<Label<generated::ConstParam>> {
        pre_emit!(ConstParam, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let default_val = node.default_val().and_then(|x| self.emit_const_arg(&x));
        let is_const = node.const_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::ConstParam {
            id: TrapId::Star,
            attrs,
            default_val,
            is_const,
            name,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(ConstParam, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_continue_expr(
        &mut self,
        node: &ast::ContinueExpr,
    ) -> Option<Label<generated::ContinueExpr>> {
        pre_emit!(ContinueExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let label = self.trap.emit(generated::ContinueExpr {
            id: TrapId::Star,
            attrs,
            lifetime,
        });
        self.emit_location(label, node);
        post_emit!(ContinueExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_dyn_trait_type(
        &mut self,
        node: &ast::DynTraitType,
    ) -> Option<Label<generated::DynTraitTypeRepr>> {
        pre_emit!(DynTraitTypeRepr, self, node);
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::DynTraitTypeRepr {
            id: TrapId::Star,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(DynTraitTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_enum(&mut self, node: &ast::Enum) -> Option<Label<generated::Enum>> {
        pre_emit!(Enum, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let variant_list = node.variant_list().and_then(|x| self.emit_variant_list(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Enum {
            id: TrapId::Star,
            attrs,
            generic_param_list,
            name,
            variant_list,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Enum, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_expr_stmt(
        &mut self,
        node: &ast::ExprStmt,
    ) -> Option<Label<generated::ExprStmt>> {
        pre_emit!(ExprStmt, self, node);
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::ExprStmt {
            id: TrapId::Star,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(ExprStmt, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_extern_block(
        &mut self,
        node: &ast::ExternBlock,
    ) -> Option<Label<generated::ExternBlock>> {
        pre_emit!(ExternBlock, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let abi = node.abi().and_then(|x| self.emit_abi(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let extern_item_list = node
            .extern_item_list()
            .and_then(|x| self.emit_extern_item_list(&x));
        let is_unsafe = node.unsafe_token().is_some();
        let label = self.trap.emit(generated::ExternBlock {
            id: TrapId::Star,
            abi,
            attrs,
            extern_item_list,
            is_unsafe,
        });
        self.emit_location(label, node);
        post_emit!(ExternBlock, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_extern_crate(
        &mut self,
        node: &ast::ExternCrate,
    ) -> Option<Label<generated::ExternCrate>> {
        pre_emit!(ExternCrate, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let rename = node.rename().and_then(|x| self.emit_rename(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::ExternCrate {
            id: TrapId::Star,
            attrs,
            identifier,
            rename,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(ExternCrate, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_extern_item_list(
        &mut self,
        node: &ast::ExternItemList,
    ) -> Option<Label<generated::ExternItemList>> {
        pre_emit!(ExternItemList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let extern_items = node
            .extern_items()
            .filter_map(|x| self.emit_extern_item(&x))
            .collect();
        let label = self.trap.emit(generated::ExternItemList {
            id: TrapId::Star,
            attrs,
            extern_items,
        });
        self.emit_location(label, node);
        post_emit!(ExternItemList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_field_expr(
        &mut self,
        node: &ast::FieldExpr,
    ) -> Option<Label<generated::FieldExpr>> {
        pre_emit!(FieldExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let container = node.expr().and_then(|x| self.emit_expr(&x));
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let label = self.trap.emit(generated::FieldExpr {
            id: TrapId::Star,
            attrs,
            container,
            identifier,
        });
        self.emit_location(label, node);
        post_emit!(FieldExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_fn(&mut self, node: &ast::Fn) -> Option<Label<generated::Function>> {
        pre_emit!(Function, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let abi = node.abi().and_then(|x| self.emit_abi(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let body = node.body().and_then(|x| self.emit_block_expr(&x));
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let is_async = node.async_token().is_some();
        let is_const = node.const_token().is_some();
        let is_default = node.default_token().is_some();
        let is_gen = node.gen_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let param_list = node.param_list().and_then(|x| self.emit_param_list(&x));
        let ret_type = node.ret_type().and_then(|x| self.emit_ret_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Function {
            id: TrapId::Star,
            abi,
            attrs,
            body,
            generic_param_list,
            is_async,
            is_const,
            is_default,
            is_gen,
            is_unsafe,
            name,
            param_list,
            ret_type,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Function, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_fn_ptr_type(
        &mut self,
        node: &ast::FnPtrType,
    ) -> Option<Label<generated::FnPtrTypeRepr>> {
        pre_emit!(FnPtrTypeRepr, self, node);
        let abi = node.abi().and_then(|x| self.emit_abi(&x));
        let is_async = node.async_token().is_some();
        let is_const = node.const_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let param_list = node.param_list().and_then(|x| self.emit_param_list(&x));
        let ret_type = node.ret_type().and_then(|x| self.emit_ret_type(&x));
        let label = self.trap.emit(generated::FnPtrTypeRepr {
            id: TrapId::Star,
            abi,
            is_async,
            is_const,
            is_unsafe,
            param_list,
            ret_type,
        });
        self.emit_location(label, node);
        post_emit!(FnPtrTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_for_expr(
        &mut self,
        node: &ast::ForExpr,
    ) -> Option<Label<generated::ForExpr>> {
        pre_emit!(ForExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let iterable = node.iterable().and_then(|x| self.emit_expr(&x));
        let label = node.label().and_then(|x| self.emit_label(&x));
        let loop_body = node.loop_body().and_then(|x| self.emit_block_expr(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::ForExpr {
            id: TrapId::Star,
            attrs,
            iterable,
            label,
            loop_body,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(ForExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_for_type(
        &mut self,
        node: &ast::ForType,
    ) -> Option<Label<generated::ForTypeRepr>> {
        pre_emit!(ForTypeRepr, self, node);
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::ForTypeRepr {
            id: TrapId::Star,
            generic_param_list,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(ForTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_format_args_arg(
        &mut self,
        node: &ast::FormatArgsArg,
    ) -> Option<Label<generated::FormatArgsArg>> {
        pre_emit!(FormatArgsArg, self, node);
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let label = self.trap.emit(generated::FormatArgsArg {
            id: TrapId::Star,
            expr,
            name,
        });
        self.emit_location(label, node);
        post_emit!(FormatArgsArg, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_format_args_expr(
        &mut self,
        node: &ast::FormatArgsExpr,
    ) -> Option<Label<generated::FormatArgsExpr>> {
        pre_emit!(FormatArgsExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let args = node
            .args()
            .filter_map(|x| self.emit_format_args_arg(&x))
            .collect();
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let template = node.template().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::FormatArgsExpr {
            id: TrapId::Star,
            args,
            attrs,
            template,
        });
        self.emit_location(label, node);
        post_emit!(FormatArgsExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_generic_arg_list(
        &mut self,
        node: &ast::GenericArgList,
    ) -> Option<Label<generated::GenericArgList>> {
        pre_emit!(GenericArgList, self, node);
        let generic_args = node
            .generic_args()
            .filter_map(|x| self.emit_generic_arg(&x))
            .collect();
        let label = self.trap.emit(generated::GenericArgList {
            id: TrapId::Star,
            generic_args,
        });
        self.emit_location(label, node);
        post_emit!(GenericArgList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_generic_param_list(
        &mut self,
        node: &ast::GenericParamList,
    ) -> Option<Label<generated::GenericParamList>> {
        pre_emit!(GenericParamList, self, node);
        let generic_params = node
            .generic_params()
            .filter_map(|x| self.emit_generic_param(&x))
            .collect();
        let label = self.trap.emit(generated::GenericParamList {
            id: TrapId::Star,
            generic_params,
        });
        self.emit_location(label, node);
        post_emit!(GenericParamList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ident_pat(
        &mut self,
        node: &ast::IdentPat,
    ) -> Option<Label<generated::IdentPat>> {
        pre_emit!(IdentPat, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let is_mut = node.mut_token().is_some();
        let is_ref = node.ref_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::IdentPat {
            id: TrapId::Star,
            attrs,
            is_mut,
            is_ref,
            name,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(IdentPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_if_expr(&mut self, node: &ast::IfExpr) -> Option<Label<generated::IfExpr>> {
        pre_emit!(IfExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let condition = node.condition().and_then(|x| self.emit_expr(&x));
        let else_ = node.else_branch().and_then(|x| self.emit_else_branch(&x));
        let then = node.then_branch().and_then(|x| self.emit_block_expr(&x));
        let label = self.trap.emit(generated::IfExpr {
            id: TrapId::Star,
            attrs,
            condition,
            else_,
            then,
        });
        self.emit_location(label, node);
        post_emit!(IfExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_impl(&mut self, node: &ast::Impl) -> Option<Label<generated::Impl>> {
        pre_emit!(Impl, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let assoc_item_list = node
            .assoc_item_list()
            .and_then(|x| self.emit_assoc_item_list(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let is_const = node.const_token().is_some();
        let is_default = node.default_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let self_ty = node.self_ty().and_then(|x| self.emit_type(&x));
        let trait_ = node.trait_().and_then(|x| self.emit_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Impl {
            id: TrapId::Star,
            assoc_item_list,
            attrs,
            generic_param_list,
            is_const,
            is_default,
            is_unsafe,
            self_ty,
            trait_,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Impl, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_impl_trait_type(
        &mut self,
        node: &ast::ImplTraitType,
    ) -> Option<Label<generated::ImplTraitTypeRepr>> {
        pre_emit!(ImplTraitTypeRepr, self, node);
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::ImplTraitTypeRepr {
            id: TrapId::Star,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(ImplTraitTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_index_expr(
        &mut self,
        node: &ast::IndexExpr,
    ) -> Option<Label<generated::IndexExpr>> {
        pre_emit!(IndexExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let base = node.base().and_then(|x| self.emit_expr(&x));
        let index = node.index().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::IndexExpr {
            id: TrapId::Star,
            attrs,
            base,
            index,
        });
        self.emit_location(label, node);
        post_emit!(IndexExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_infer_type(
        &mut self,
        node: &ast::InferType,
    ) -> Option<Label<generated::InferTypeRepr>> {
        pre_emit!(InferTypeRepr, self, node);
        let label = self
            .trap
            .emit(generated::InferTypeRepr { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(InferTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_item_list(
        &mut self,
        node: &ast::ItemList,
    ) -> Option<Label<generated::ItemList>> {
        pre_emit!(ItemList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let items = node.items().filter_map(|x| self.emit_item(&x)).collect();
        let label = self.trap.emit(generated::ItemList {
            id: TrapId::Star,
            attrs,
            items,
        });
        self.emit_location(label, node);
        post_emit!(ItemList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_label(&mut self, node: &ast::Label) -> Option<Label<generated::Label>> {
        pre_emit!(Label, self, node);
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let label = self.trap.emit(generated::Label {
            id: TrapId::Star,
            lifetime,
        });
        self.emit_location(label, node);
        post_emit!(Label, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_let_else(
        &mut self,
        node: &ast::LetElse,
    ) -> Option<Label<generated::LetElse>> {
        pre_emit!(LetElse, self, node);
        let block_expr = node.block_expr().and_then(|x| self.emit_block_expr(&x));
        let label = self.trap.emit(generated::LetElse {
            id: TrapId::Star,
            block_expr,
        });
        self.emit_location(label, node);
        post_emit!(LetElse, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_let_expr(
        &mut self,
        node: &ast::LetExpr,
    ) -> Option<Label<generated::LetExpr>> {
        pre_emit!(LetExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let scrutinee = node.expr().and_then(|x| self.emit_expr(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::LetExpr {
            id: TrapId::Star,
            attrs,
            scrutinee,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(LetExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_let_stmt(
        &mut self,
        node: &ast::LetStmt,
    ) -> Option<Label<generated::LetStmt>> {
        pre_emit!(LetStmt, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let initializer = node.initializer().and_then(|x| self.emit_expr(&x));
        let let_else = node.let_else().and_then(|x| self.emit_let_else(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::LetStmt {
            id: TrapId::Star,
            attrs,
            initializer,
            let_else,
            pat,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(LetStmt, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_lifetime(
        &mut self,
        node: &ast::Lifetime,
    ) -> Option<Label<generated::Lifetime>> {
        pre_emit!(Lifetime, self, node);
        let text = node.try_get_text();
        let label = self.trap.emit(generated::Lifetime {
            id: TrapId::Star,
            text,
        });
        self.emit_location(label, node);
        post_emit!(Lifetime, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_lifetime_arg(
        &mut self,
        node: &ast::LifetimeArg,
    ) -> Option<Label<generated::LifetimeArg>> {
        pre_emit!(LifetimeArg, self, node);
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let label = self.trap.emit(generated::LifetimeArg {
            id: TrapId::Star,
            lifetime,
        });
        self.emit_location(label, node);
        post_emit!(LifetimeArg, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_lifetime_param(
        &mut self,
        node: &ast::LifetimeParam,
    ) -> Option<Label<generated::LifetimeParam>> {
        pre_emit!(LifetimeParam, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::LifetimeParam {
            id: TrapId::Star,
            attrs,
            lifetime,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(LifetimeParam, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_literal(
        &mut self,
        node: &ast::Literal,
    ) -> Option<Label<generated::LiteralExpr>> {
        pre_emit!(LiteralExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let text_value = node.try_get_text();
        let label = self.trap.emit(generated::LiteralExpr {
            id: TrapId::Star,
            attrs,
            text_value,
        });
        self.emit_location(label, node);
        post_emit!(LiteralExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_literal_pat(
        &mut self,
        node: &ast::LiteralPat,
    ) -> Option<Label<generated::LiteralPat>> {
        pre_emit!(LiteralPat, self, node);
        let literal = node.literal().and_then(|x| self.emit_literal(&x));
        let label = self.trap.emit(generated::LiteralPat {
            id: TrapId::Star,
            literal,
        });
        self.emit_location(label, node);
        post_emit!(LiteralPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_loop_expr(
        &mut self,
        node: &ast::LoopExpr,
    ) -> Option<Label<generated::LoopExpr>> {
        pre_emit!(LoopExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let label = node.label().and_then(|x| self.emit_label(&x));
        let loop_body = node.loop_body().and_then(|x| self.emit_block_expr(&x));
        let label = self.trap.emit(generated::LoopExpr {
            id: TrapId::Star,
            attrs,
            label,
            loop_body,
        });
        self.emit_location(label, node);
        post_emit!(LoopExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_call(
        &mut self,
        node: &ast::MacroCall,
    ) -> Option<Label<generated::MacroCall>> {
        pre_emit!(MacroCall, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let path = node.path().and_then(|x| self.emit_path(&x));
        let token_tree = node.token_tree().and_then(|x| self.emit_token_tree(&x));
        let label = self.trap.emit(generated::MacroCall {
            id: TrapId::Star,
            attrs,
            path,
            token_tree,
        });
        self.emit_location(label, node);
        post_emit!(MacroCall, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_def(
        &mut self,
        node: &ast::MacroDef,
    ) -> Option<Label<generated::MacroDef>> {
        pre_emit!(MacroDef, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let args = node.args().and_then(|x| self.emit_token_tree(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let body = node.body().and_then(|x| self.emit_token_tree(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::MacroDef {
            id: TrapId::Star,
            args,
            attrs,
            body,
            name,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(MacroDef, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_expr(
        &mut self,
        node: &ast::MacroExpr,
    ) -> Option<Label<generated::MacroExpr>> {
        pre_emit!(MacroExpr, self, node);
        let macro_call = node.macro_call().and_then(|x| self.emit_macro_call(&x));
        let label = self.trap.emit(generated::MacroExpr {
            id: TrapId::Star,
            macro_call,
        });
        self.emit_location(label, node);
        post_emit!(MacroExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_items(
        &mut self,
        node: &ast::MacroItems,
    ) -> Option<Label<generated::MacroItems>> {
        pre_emit!(MacroItems, self, node);
        let items = node.items().filter_map(|x| self.emit_item(&x)).collect();
        let label = self.trap.emit(generated::MacroItems {
            id: TrapId::Star,
            items,
        });
        self.emit_location(label, node);
        post_emit!(MacroItems, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_pat(
        &mut self,
        node: &ast::MacroPat,
    ) -> Option<Label<generated::MacroPat>> {
        pre_emit!(MacroPat, self, node);
        let macro_call = node.macro_call().and_then(|x| self.emit_macro_call(&x));
        let label = self.trap.emit(generated::MacroPat {
            id: TrapId::Star,
            macro_call,
        });
        self.emit_location(label, node);
        post_emit!(MacroPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_rules(
        &mut self,
        node: &ast::MacroRules,
    ) -> Option<Label<generated::MacroRules>> {
        pre_emit!(MacroRules, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let token_tree = node.token_tree().and_then(|x| self.emit_token_tree(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::MacroRules {
            id: TrapId::Star,
            attrs,
            name,
            token_tree,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(MacroRules, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_stmts(
        &mut self,
        node: &ast::MacroStmts,
    ) -> Option<Label<generated::MacroBlockExpr>> {
        pre_emit!(MacroBlockExpr, self, node);
        let tail_expr = node.expr().and_then(|x| self.emit_expr(&x));
        let statements = node
            .statements()
            .filter_map(|x| self.emit_stmt(&x))
            .collect();
        let label = self.trap.emit(generated::MacroBlockExpr {
            id: TrapId::Star,
            tail_expr,
            statements,
        });
        self.emit_location(label, node);
        post_emit!(MacroBlockExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_macro_type(
        &mut self,
        node: &ast::MacroType,
    ) -> Option<Label<generated::MacroTypeRepr>> {
        pre_emit!(MacroTypeRepr, self, node);
        let macro_call = node.macro_call().and_then(|x| self.emit_macro_call(&x));
        let label = self.trap.emit(generated::MacroTypeRepr {
            id: TrapId::Star,
            macro_call,
        });
        self.emit_location(label, node);
        post_emit!(MacroTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_match_arm(
        &mut self,
        node: &ast::MatchArm,
    ) -> Option<Label<generated::MatchArm>> {
        pre_emit!(MatchArm, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let guard = node.guard().and_then(|x| self.emit_match_guard(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::MatchArm {
            id: TrapId::Star,
            attrs,
            expr,
            guard,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(MatchArm, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_match_arm_list(
        &mut self,
        node: &ast::MatchArmList,
    ) -> Option<Label<generated::MatchArmList>> {
        pre_emit!(MatchArmList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let arms = node
            .arms()
            .filter_map(|x| self.emit_match_arm(&x))
            .collect();
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let label = self.trap.emit(generated::MatchArmList {
            id: TrapId::Star,
            arms,
            attrs,
        });
        self.emit_location(label, node);
        post_emit!(MatchArmList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_match_expr(
        &mut self,
        node: &ast::MatchExpr,
    ) -> Option<Label<generated::MatchExpr>> {
        pre_emit!(MatchExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let scrutinee = node.expr().and_then(|x| self.emit_expr(&x));
        let match_arm_list = node
            .match_arm_list()
            .and_then(|x| self.emit_match_arm_list(&x));
        let label = self.trap.emit(generated::MatchExpr {
            id: TrapId::Star,
            attrs,
            scrutinee,
            match_arm_list,
        });
        self.emit_location(label, node);
        post_emit!(MatchExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_match_guard(
        &mut self,
        node: &ast::MatchGuard,
    ) -> Option<Label<generated::MatchGuard>> {
        pre_emit!(MatchGuard, self, node);
        let condition = node.condition().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::MatchGuard {
            id: TrapId::Star,
            condition,
        });
        self.emit_location(label, node);
        post_emit!(MatchGuard, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_meta(&mut self, node: &ast::Meta) -> Option<Label<generated::Meta>> {
        pre_emit!(Meta, self, node);
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let is_unsafe = node.unsafe_token().is_some();
        let path = node.path().and_then(|x| self.emit_path(&x));
        let token_tree = node.token_tree().and_then(|x| self.emit_token_tree(&x));
        let label = self.trap.emit(generated::Meta {
            id: TrapId::Star,
            expr,
            is_unsafe,
            path,
            token_tree,
        });
        self.emit_location(label, node);
        post_emit!(Meta, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_method_call_expr(
        &mut self,
        node: &ast::MethodCallExpr,
    ) -> Option<Label<generated::MethodCallExpr>> {
        pre_emit!(MethodCallExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let arg_list = node.arg_list().and_then(|x| self.emit_arg_list(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_arg_list = node
            .generic_arg_list()
            .and_then(|x| self.emit_generic_arg_list(&x));
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let receiver = node.receiver().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::MethodCallExpr {
            id: TrapId::Star,
            arg_list,
            attrs,
            generic_arg_list,
            identifier,
            receiver,
        });
        self.emit_location(label, node);
        post_emit!(MethodCallExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_module(&mut self, node: &ast::Module) -> Option<Label<generated::Module>> {
        pre_emit!(Module, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let item_list = node.item_list().and_then(|x| self.emit_item_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::Module {
            id: TrapId::Star,
            attrs,
            item_list,
            name,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(Module, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_name(&mut self, node: &ast::Name) -> Option<Label<generated::Name>> {
        pre_emit!(Name, self, node);
        let text = node.try_get_text();
        let label = self.trap.emit(generated::Name {
            id: TrapId::Star,
            text,
        });
        self.emit_location(label, node);
        post_emit!(Name, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_name_ref(
        &mut self,
        node: &ast::NameRef,
    ) -> Option<Label<generated::NameRef>> {
        pre_emit!(NameRef, self, node);
        let text = node.try_get_text();
        let label = self.trap.emit(generated::NameRef {
            id: TrapId::Star,
            text,
        });
        self.emit_location(label, node);
        post_emit!(NameRef, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_never_type(
        &mut self,
        node: &ast::NeverType,
    ) -> Option<Label<generated::NeverTypeRepr>> {
        pre_emit!(NeverTypeRepr, self, node);
        let label = self
            .trap
            .emit(generated::NeverTypeRepr { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(NeverTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_offset_of_expr(
        &mut self,
        node: &ast::OffsetOfExpr,
    ) -> Option<Label<generated::OffsetOfExpr>> {
        pre_emit!(OffsetOfExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let fields = node
            .fields()
            .filter_map(|x| self.emit_name_ref(&x))
            .collect();
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::OffsetOfExpr {
            id: TrapId::Star,
            attrs,
            fields,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(OffsetOfExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_or_pat(&mut self, node: &ast::OrPat) -> Option<Label<generated::OrPat>> {
        pre_emit!(OrPat, self, node);
        let pats = node.pats().filter_map(|x| self.emit_pat(&x)).collect();
        let label = self.trap.emit(generated::OrPat {
            id: TrapId::Star,
            pats,
        });
        self.emit_location(label, node);
        post_emit!(OrPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_param(&mut self, node: &ast::Param) -> Option<Label<generated::Param>> {
        pre_emit!(Param, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::Param {
            id: TrapId::Star,
            attrs,
            pat,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(Param, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_param_list(
        &mut self,
        node: &ast::ParamList,
    ) -> Option<Label<generated::ParamList>> {
        pre_emit!(ParamList, self, node);
        let params = node.params().filter_map(|x| self.emit_param(&x)).collect();
        let self_param = node.self_param().and_then(|x| self.emit_self_param(&x));
        let label = self.trap.emit(generated::ParamList {
            id: TrapId::Star,
            params,
            self_param,
        });
        self.emit_location(label, node);
        post_emit!(ParamList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_paren_expr(
        &mut self,
        node: &ast::ParenExpr,
    ) -> Option<Label<generated::ParenExpr>> {
        pre_emit!(ParenExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::ParenExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(ParenExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_paren_pat(
        &mut self,
        node: &ast::ParenPat,
    ) -> Option<Label<generated::ParenPat>> {
        pre_emit!(ParenPat, self, node);
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::ParenPat {
            id: TrapId::Star,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(ParenPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_paren_type(
        &mut self,
        node: &ast::ParenType,
    ) -> Option<Label<generated::ParenTypeRepr>> {
        pre_emit!(ParenTypeRepr, self, node);
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::ParenTypeRepr {
            id: TrapId::Star,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(ParenTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_parenthesized_arg_list(
        &mut self,
        node: &ast::ParenthesizedArgList,
    ) -> Option<Label<generated::ParenthesizedArgList>> {
        pre_emit!(ParenthesizedArgList, self, node);
        let type_args = node
            .type_args()
            .filter_map(|x| self.emit_type_arg(&x))
            .collect();
        let label = self.trap.emit(generated::ParenthesizedArgList {
            id: TrapId::Star,
            type_args,
        });
        self.emit_location(label, node);
        post_emit!(ParenthesizedArgList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_path(&mut self, node: &ast::Path) -> Option<Label<generated::Path>> {
        pre_emit!(Path, self, node);
        let qualifier = node.qualifier().and_then(|x| self.emit_path(&x));
        let segment = node.segment().and_then(|x| self.emit_path_segment(&x));
        let label = self.trap.emit(generated::Path {
            id: TrapId::Star,
            qualifier,
            segment,
        });
        self.emit_location(label, node);
        post_emit!(Path, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_path_expr(
        &mut self,
        node: &ast::PathExpr,
    ) -> Option<Label<generated::PathExpr>> {
        pre_emit!(PathExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::PathExpr {
            id: TrapId::Star,
            attrs,
            path,
        });
        self.emit_location(label, node);
        post_emit!(PathExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_path_pat(
        &mut self,
        node: &ast::PathPat,
    ) -> Option<Label<generated::PathPat>> {
        pre_emit!(PathPat, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::PathPat {
            id: TrapId::Star,
            path,
        });
        self.emit_location(label, node);
        post_emit!(PathPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_path_segment(
        &mut self,
        node: &ast::PathSegment,
    ) -> Option<Label<generated::PathSegment>> {
        pre_emit!(PathSegment, self, node);
        let generic_arg_list = node
            .generic_arg_list()
            .and_then(|x| self.emit_generic_arg_list(&x));
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let parenthesized_arg_list = node
            .parenthesized_arg_list()
            .and_then(|x| self.emit_parenthesized_arg_list(&x));
        let ret_type = node.ret_type().and_then(|x| self.emit_ret_type(&x));
        let return_type_syntax = node
            .return_type_syntax()
            .and_then(|x| self.emit_return_type_syntax(&x));
        let label = self.trap.emit(generated::PathSegment {
            id: TrapId::Star,
            generic_arg_list,
            identifier,
            parenthesized_arg_list,
            ret_type,
            return_type_syntax,
        });
        self.emit_location(label, node);
        post_emit!(PathSegment, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_path_type(
        &mut self,
        node: &ast::PathType,
    ) -> Option<Label<generated::PathTypeRepr>> {
        pre_emit!(PathTypeRepr, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::PathTypeRepr {
            id: TrapId::Star,
            path,
        });
        self.emit_location(label, node);
        post_emit!(PathTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_prefix_expr(
        &mut self,
        node: &ast::PrefixExpr,
    ) -> Option<Label<generated::PrefixExpr>> {
        pre_emit!(PrefixExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let operator_name = node.try_get_text();
        let label = self.trap.emit(generated::PrefixExpr {
            id: TrapId::Star,
            attrs,
            expr,
            operator_name,
        });
        self.emit_location(label, node);
        post_emit!(PrefixExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ptr_type(
        &mut self,
        node: &ast::PtrType,
    ) -> Option<Label<generated::PtrTypeRepr>> {
        pre_emit!(PtrTypeRepr, self, node);
        let is_const = node.const_token().is_some();
        let is_mut = node.mut_token().is_some();
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::PtrTypeRepr {
            id: TrapId::Star,
            is_const,
            is_mut,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(PtrTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_range_expr(
        &mut self,
        node: &ast::RangeExpr,
    ) -> Option<Label<generated::RangeExpr>> {
        pre_emit!(RangeExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let end = node.end().and_then(|x| self.emit_expr(&x));
        let operator_name = node.try_get_text();
        let start = node.start().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::RangeExpr {
            id: TrapId::Star,
            attrs,
            end,
            operator_name,
            start,
        });
        self.emit_location(label, node);
        post_emit!(RangeExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_range_pat(
        &mut self,
        node: &ast::RangePat,
    ) -> Option<Label<generated::RangePat>> {
        pre_emit!(RangePat, self, node);
        let end = node.end().and_then(|x| self.emit_pat(&x));
        let operator_name = node.try_get_text();
        let start = node.start().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::RangePat {
            id: TrapId::Star,
            end,
            operator_name,
            start,
        });
        self.emit_location(label, node);
        post_emit!(RangePat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_expr(
        &mut self,
        node: &ast::RecordExpr,
    ) -> Option<Label<generated::StructExpr>> {
        pre_emit!(StructExpr, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let struct_expr_field_list = node
            .record_expr_field_list()
            .and_then(|x| self.emit_record_expr_field_list(&x));
        let label = self.trap.emit(generated::StructExpr {
            id: TrapId::Star,
            path,
            struct_expr_field_list,
        });
        self.emit_location(label, node);
        post_emit!(StructExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_expr_field(
        &mut self,
        node: &ast::RecordExprField,
    ) -> Option<Label<generated::StructExprField>> {
        pre_emit!(StructExprField, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let label = self.trap.emit(generated::StructExprField {
            id: TrapId::Star,
            attrs,
            expr,
            identifier,
        });
        self.emit_location(label, node);
        post_emit!(StructExprField, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_expr_field_list(
        &mut self,
        node: &ast::RecordExprFieldList,
    ) -> Option<Label<generated::StructExprFieldList>> {
        pre_emit!(StructExprFieldList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let fields = node
            .fields()
            .filter_map(|x| self.emit_record_expr_field(&x))
            .collect();
        let spread = node.spread().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::StructExprFieldList {
            id: TrapId::Star,
            attrs,
            fields,
            spread,
        });
        self.emit_location(label, node);
        post_emit!(StructExprFieldList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_field(
        &mut self,
        node: &ast::RecordField,
    ) -> Option<Label<generated::StructField>> {
        pre_emit!(StructField, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let default = node.expr().and_then(|x| self.emit_expr(&x));
        let is_unsafe = node.unsafe_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::StructField {
            id: TrapId::Star,
            attrs,
            default,
            is_unsafe,
            name,
            type_repr,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(StructField, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_field_list(
        &mut self,
        node: &ast::RecordFieldList,
    ) -> Option<Label<generated::StructFieldList>> {
        pre_emit!(StructFieldList, self, node);
        let fields = node
            .fields()
            .filter_map(|x| self.emit_record_field(&x))
            .collect();
        let label = self.trap.emit(generated::StructFieldList {
            id: TrapId::Star,
            fields,
        });
        self.emit_location(label, node);
        post_emit!(StructFieldList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_pat(
        &mut self,
        node: &ast::RecordPat,
    ) -> Option<Label<generated::StructPat>> {
        pre_emit!(StructPat, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let struct_pat_field_list = node
            .record_pat_field_list()
            .and_then(|x| self.emit_record_pat_field_list(&x));
        let label = self.trap.emit(generated::StructPat {
            id: TrapId::Star,
            path,
            struct_pat_field_list,
        });
        self.emit_location(label, node);
        post_emit!(StructPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_pat_field(
        &mut self,
        node: &ast::RecordPatField,
    ) -> Option<Label<generated::StructPatField>> {
        pre_emit!(StructPatField, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let identifier = node.name_ref().and_then(|x| self.emit_name_ref(&x));
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::StructPatField {
            id: TrapId::Star,
            attrs,
            identifier,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(StructPatField, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_record_pat_field_list(
        &mut self,
        node: &ast::RecordPatFieldList,
    ) -> Option<Label<generated::StructPatFieldList>> {
        pre_emit!(StructPatFieldList, self, node);
        let fields = node
            .fields()
            .filter_map(|x| self.emit_record_pat_field(&x))
            .collect();
        let rest_pat = node.rest_pat().and_then(|x| self.emit_rest_pat(&x));
        let label = self.trap.emit(generated::StructPatFieldList {
            id: TrapId::Star,
            fields,
            rest_pat,
        });
        self.emit_location(label, node);
        post_emit!(StructPatFieldList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ref_expr(
        &mut self,
        node: &ast::RefExpr,
    ) -> Option<Label<generated::RefExpr>> {
        pre_emit!(RefExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let is_const = node.const_token().is_some();
        let is_mut = node.mut_token().is_some();
        let is_raw = node.raw_token().is_some();
        let label = self.trap.emit(generated::RefExpr {
            id: TrapId::Star,
            attrs,
            expr,
            is_const,
            is_mut,
            is_raw,
        });
        self.emit_location(label, node);
        post_emit!(RefExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ref_pat(&mut self, node: &ast::RefPat) -> Option<Label<generated::RefPat>> {
        pre_emit!(RefPat, self, node);
        let is_mut = node.mut_token().is_some();
        let pat = node.pat().and_then(|x| self.emit_pat(&x));
        let label = self.trap.emit(generated::RefPat {
            id: TrapId::Star,
            is_mut,
            pat,
        });
        self.emit_location(label, node);
        post_emit!(RefPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ref_type(
        &mut self,
        node: &ast::RefType,
    ) -> Option<Label<generated::RefTypeRepr>> {
        pre_emit!(RefTypeRepr, self, node);
        let is_mut = node.mut_token().is_some();
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::RefTypeRepr {
            id: TrapId::Star,
            is_mut,
            lifetime,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(RefTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_rename(&mut self, node: &ast::Rename) -> Option<Label<generated::Rename>> {
        pre_emit!(Rename, self, node);
        let name = node.name().and_then(|x| self.emit_name(&x));
        let label = self.trap.emit(generated::Rename {
            id: TrapId::Star,
            name,
        });
        self.emit_location(label, node);
        post_emit!(Rename, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_rest_pat(
        &mut self,
        node: &ast::RestPat,
    ) -> Option<Label<generated::RestPat>> {
        pre_emit!(RestPat, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let label = self.trap.emit(generated::RestPat {
            id: TrapId::Star,
            attrs,
        });
        self.emit_location(label, node);
        post_emit!(RestPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_ret_type(
        &mut self,
        node: &ast::RetType,
    ) -> Option<Label<generated::RetTypeRepr>> {
        pre_emit!(RetTypeRepr, self, node);
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::RetTypeRepr {
            id: TrapId::Star,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(RetTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_return_expr(
        &mut self,
        node: &ast::ReturnExpr,
    ) -> Option<Label<generated::ReturnExpr>> {
        pre_emit!(ReturnExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::ReturnExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(ReturnExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_return_type_syntax(
        &mut self,
        node: &ast::ReturnTypeSyntax,
    ) -> Option<Label<generated::ReturnTypeSyntax>> {
        pre_emit!(ReturnTypeSyntax, self, node);
        let label = self
            .trap
            .emit(generated::ReturnTypeSyntax { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(ReturnTypeSyntax, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_self_param(
        &mut self,
        node: &ast::SelfParam,
    ) -> Option<Label<generated::SelfParam>> {
        pre_emit!(SelfParam, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let is_ref = node.amp_token().is_some();
        let is_mut = node.mut_token().is_some();
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::SelfParam {
            id: TrapId::Star,
            attrs,
            is_ref,
            is_mut,
            lifetime,
            name,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(SelfParam, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_slice_pat(
        &mut self,
        node: &ast::SlicePat,
    ) -> Option<Label<generated::SlicePat>> {
        pre_emit!(SlicePat, self, node);
        let pats = node.pats().filter_map(|x| self.emit_pat(&x)).collect();
        let label = self.trap.emit(generated::SlicePat {
            id: TrapId::Star,
            pats,
        });
        self.emit_location(label, node);
        post_emit!(SlicePat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_slice_type(
        &mut self,
        node: &ast::SliceType,
    ) -> Option<Label<generated::SliceTypeRepr>> {
        pre_emit!(SliceTypeRepr, self, node);
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::SliceTypeRepr {
            id: TrapId::Star,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(SliceTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_source_file(
        &mut self,
        node: &ast::SourceFile,
    ) -> Option<Label<generated::SourceFile>> {
        pre_emit!(SourceFile, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let items = node.items().filter_map(|x| self.emit_item(&x)).collect();
        let label = self.trap.emit(generated::SourceFile {
            id: TrapId::Star,
            attrs,
            items,
        });
        self.emit_location(label, node);
        post_emit!(SourceFile, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_static(&mut self, node: &ast::Static) -> Option<Label<generated::Static>> {
        pre_emit!(Static, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let body = node.body().and_then(|x| self.emit_expr(&x));
        let is_mut = node.mut_token().is_some();
        let is_static = node.static_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::Static {
            id: TrapId::Star,
            attrs,
            body,
            is_mut,
            is_static,
            is_unsafe,
            name,
            type_repr,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(Static, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_stmt_list(
        &mut self,
        node: &ast::StmtList,
    ) -> Option<Label<generated::StmtList>> {
        pre_emit!(StmtList, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let statements = node
            .statements()
            .filter_map(|x| self.emit_stmt(&x))
            .collect();
        let tail_expr = node.tail_expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::StmtList {
            id: TrapId::Star,
            attrs,
            statements,
            tail_expr,
        });
        self.emit_location(label, node);
        post_emit!(StmtList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_struct(&mut self, node: &ast::Struct) -> Option<Label<generated::Struct>> {
        pre_emit!(Struct, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let field_list = node.field_list().and_then(|x| self.emit_field_list(&x));
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Struct {
            id: TrapId::Star,
            attrs,
            field_list,
            generic_param_list,
            name,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Struct, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_token_tree(
        &mut self,
        node: &ast::TokenTree,
    ) -> Option<Label<generated::TokenTree>> {
        pre_emit!(TokenTree, self, node);
        let label = self.trap.emit(generated::TokenTree { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(TokenTree, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_trait(&mut self, node: &ast::Trait) -> Option<Label<generated::Trait>> {
        pre_emit!(Trait, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let assoc_item_list = node
            .assoc_item_list()
            .and_then(|x| self.emit_assoc_item_list(&x));
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let is_auto = node.auto_token().is_some();
        let is_unsafe = node.unsafe_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Trait {
            id: TrapId::Star,
            assoc_item_list,
            attrs,
            generic_param_list,
            is_auto,
            is_unsafe,
            name,
            type_bound_list,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Trait, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_trait_alias(
        &mut self,
        node: &ast::TraitAlias,
    ) -> Option<Label<generated::TraitAlias>> {
        pre_emit!(TraitAlias, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::TraitAlias {
            id: TrapId::Star,
            attrs,
            generic_param_list,
            name,
            type_bound_list,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(TraitAlias, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_try_expr(
        &mut self,
        node: &ast::TryExpr,
    ) -> Option<Label<generated::TryExpr>> {
        pre_emit!(TryExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::TryExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(TryExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_expr(
        &mut self,
        node: &ast::TupleExpr,
    ) -> Option<Label<generated::TupleExpr>> {
        pre_emit!(TupleExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let fields = node.fields().filter_map(|x| self.emit_expr(&x)).collect();
        let label = self.trap.emit(generated::TupleExpr {
            id: TrapId::Star,
            attrs,
            fields,
        });
        self.emit_location(label, node);
        post_emit!(TupleExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_field(
        &mut self,
        node: &ast::TupleField,
    ) -> Option<Label<generated::TupleField>> {
        pre_emit!(TupleField, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::TupleField {
            id: TrapId::Star,
            attrs,
            type_repr,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(TupleField, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_field_list(
        &mut self,
        node: &ast::TupleFieldList,
    ) -> Option<Label<generated::TupleFieldList>> {
        pre_emit!(TupleFieldList, self, node);
        let fields = node
            .fields()
            .filter_map(|x| self.emit_tuple_field(&x))
            .collect();
        let label = self.trap.emit(generated::TupleFieldList {
            id: TrapId::Star,
            fields,
        });
        self.emit_location(label, node);
        post_emit!(TupleFieldList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_pat(
        &mut self,
        node: &ast::TuplePat,
    ) -> Option<Label<generated::TuplePat>> {
        pre_emit!(TuplePat, self, node);
        let fields = node.fields().filter_map(|x| self.emit_pat(&x)).collect();
        let label = self.trap.emit(generated::TuplePat {
            id: TrapId::Star,
            fields,
        });
        self.emit_location(label, node);
        post_emit!(TuplePat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_struct_pat(
        &mut self,
        node: &ast::TupleStructPat,
    ) -> Option<Label<generated::TupleStructPat>> {
        pre_emit!(TupleStructPat, self, node);
        let fields = node.fields().filter_map(|x| self.emit_pat(&x)).collect();
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::TupleStructPat {
            id: TrapId::Star,
            fields,
            path,
        });
        self.emit_location(label, node);
        post_emit!(TupleStructPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_tuple_type(
        &mut self,
        node: &ast::TupleType,
    ) -> Option<Label<generated::TupleTypeRepr>> {
        pre_emit!(TupleTypeRepr, self, node);
        let fields = node.fields().filter_map(|x| self.emit_type(&x)).collect();
        let label = self.trap.emit(generated::TupleTypeRepr {
            id: TrapId::Star,
            fields,
        });
        self.emit_location(label, node);
        post_emit!(TupleTypeRepr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_type_alias(
        &mut self,
        node: &ast::TypeAlias,
    ) -> Option<Label<generated::TypeAlias>> {
        pre_emit!(TypeAlias, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let is_default = node.default_token().is_some();
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::TypeAlias {
            id: TrapId::Star,
            attrs,
            generic_param_list,
            is_default,
            name,
            type_repr,
            type_bound_list,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(TypeAlias, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_type_arg(
        &mut self,
        node: &ast::TypeArg,
    ) -> Option<Label<generated::TypeArg>> {
        pre_emit!(TypeArg, self, node);
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let label = self.trap.emit(generated::TypeArg {
            id: TrapId::Star,
            type_repr,
        });
        self.emit_location(label, node);
        post_emit!(TypeArg, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_type_bound(
        &mut self,
        node: &ast::TypeBound,
    ) -> Option<Label<generated::TypeBound>> {
        pre_emit!(TypeBound, self, node);
        let is_async = node.async_token().is_some();
        let is_const = node.const_token().is_some();
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let use_bound_generic_args = node
            .use_bound_generic_args()
            .and_then(|x| self.emit_use_bound_generic_args(&x));
        let label = self.trap.emit(generated::TypeBound {
            id: TrapId::Star,
            is_async,
            is_const,
            lifetime,
            type_repr,
            use_bound_generic_args,
        });
        self.emit_location(label, node);
        post_emit!(TypeBound, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_type_bound_list(
        &mut self,
        node: &ast::TypeBoundList,
    ) -> Option<Label<generated::TypeBoundList>> {
        pre_emit!(TypeBoundList, self, node);
        let bounds = node
            .bounds()
            .filter_map(|x| self.emit_type_bound(&x))
            .collect();
        let label = self.trap.emit(generated::TypeBoundList {
            id: TrapId::Star,
            bounds,
        });
        self.emit_location(label, node);
        post_emit!(TypeBoundList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_type_param(
        &mut self,
        node: &ast::TypeParam,
    ) -> Option<Label<generated::TypeParam>> {
        pre_emit!(TypeParam, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let default_type = node.default_type().and_then(|x| self.emit_type(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::TypeParam {
            id: TrapId::Star,
            attrs,
            default_type,
            name,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(TypeParam, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_underscore_expr(
        &mut self,
        node: &ast::UnderscoreExpr,
    ) -> Option<Label<generated::UnderscoreExpr>> {
        pre_emit!(UnderscoreExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let label = self.trap.emit(generated::UnderscoreExpr {
            id: TrapId::Star,
            attrs,
        });
        self.emit_location(label, node);
        post_emit!(UnderscoreExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_union(&mut self, node: &ast::Union) -> Option<Label<generated::Union>> {
        pre_emit!(Union, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let struct_field_list = node
            .record_field_list()
            .and_then(|x| self.emit_record_field_list(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let where_clause = node.where_clause().and_then(|x| self.emit_where_clause(&x));
        let label = self.trap.emit(generated::Union {
            id: TrapId::Star,
            attrs,
            generic_param_list,
            name,
            struct_field_list,
            visibility,
            where_clause,
        });
        self.emit_location(label, node);
        post_emit!(Union, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_use(&mut self, node: &ast::Use) -> Option<Label<generated::Use>> {
        pre_emit!(Use, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let use_tree = node.use_tree().and_then(|x| self.emit_use_tree(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::Use {
            id: TrapId::Star,
            attrs,
            use_tree,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(Use, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_use_bound_generic_args(
        &mut self,
        node: &ast::UseBoundGenericArgs,
    ) -> Option<Label<generated::UseBoundGenericArgs>> {
        pre_emit!(UseBoundGenericArgs, self, node);
        let use_bound_generic_args = node
            .use_bound_generic_args()
            .filter_map(|x| self.emit_use_bound_generic_arg(&x))
            .collect();
        let label = self.trap.emit(generated::UseBoundGenericArgs {
            id: TrapId::Star,
            use_bound_generic_args,
        });
        self.emit_location(label, node);
        post_emit!(UseBoundGenericArgs, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_use_tree(
        &mut self,
        node: &ast::UseTree,
    ) -> Option<Label<generated::UseTree>> {
        pre_emit!(UseTree, self, node);
        let is_glob = node.star_token().is_some();
        let path = node.path().and_then(|x| self.emit_path(&x));
        let rename = node.rename().and_then(|x| self.emit_rename(&x));
        let use_tree_list = node
            .use_tree_list()
            .and_then(|x| self.emit_use_tree_list(&x));
        let label = self.trap.emit(generated::UseTree {
            id: TrapId::Star,
            is_glob,
            path,
            rename,
            use_tree_list,
        });
        self.emit_location(label, node);
        post_emit!(UseTree, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_use_tree_list(
        &mut self,
        node: &ast::UseTreeList,
    ) -> Option<Label<generated::UseTreeList>> {
        pre_emit!(UseTreeList, self, node);
        let use_trees = node
            .use_trees()
            .filter_map(|x| self.emit_use_tree(&x))
            .collect();
        let label = self.trap.emit(generated::UseTreeList {
            id: TrapId::Star,
            use_trees,
        });
        self.emit_location(label, node);
        post_emit!(UseTreeList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_variant(
        &mut self,
        node: &ast::Variant,
    ) -> Option<Label<generated::Variant>> {
        pre_emit!(Variant, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let discriminant = node.expr().and_then(|x| self.emit_expr(&x));
        let field_list = node.field_list().and_then(|x| self.emit_field_list(&x));
        let name = node.name().and_then(|x| self.emit_name(&x));
        let visibility = node.visibility().and_then(|x| self.emit_visibility(&x));
        let label = self.trap.emit(generated::Variant {
            id: TrapId::Star,
            attrs,
            discriminant,
            field_list,
            name,
            visibility,
        });
        self.emit_location(label, node);
        post_emit!(Variant, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_variant_list(
        &mut self,
        node: &ast::VariantList,
    ) -> Option<Label<generated::VariantList>> {
        pre_emit!(VariantList, self, node);
        let variants = node
            .variants()
            .filter_map(|x| self.emit_variant(&x))
            .collect();
        let label = self.trap.emit(generated::VariantList {
            id: TrapId::Star,
            variants,
        });
        self.emit_location(label, node);
        post_emit!(VariantList, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_visibility(
        &mut self,
        node: &ast::Visibility,
    ) -> Option<Label<generated::Visibility>> {
        pre_emit!(Visibility, self, node);
        let path = node.path().and_then(|x| self.emit_path(&x));
        let label = self.trap.emit(generated::Visibility {
            id: TrapId::Star,
            path,
        });
        self.emit_location(label, node);
        post_emit!(Visibility, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_where_clause(
        &mut self,
        node: &ast::WhereClause,
    ) -> Option<Label<generated::WhereClause>> {
        pre_emit!(WhereClause, self, node);
        let predicates = node
            .predicates()
            .filter_map(|x| self.emit_where_pred(&x))
            .collect();
        let label = self.trap.emit(generated::WhereClause {
            id: TrapId::Star,
            predicates,
        });
        self.emit_location(label, node);
        post_emit!(WhereClause, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_where_pred(
        &mut self,
        node: &ast::WherePred,
    ) -> Option<Label<generated::WherePred>> {
        pre_emit!(WherePred, self, node);
        let generic_param_list = node
            .generic_param_list()
            .and_then(|x| self.emit_generic_param_list(&x));
        let lifetime = node.lifetime().and_then(|x| self.emit_lifetime(&x));
        let type_repr = node.ty().and_then(|x| self.emit_type(&x));
        let type_bound_list = node
            .type_bound_list()
            .and_then(|x| self.emit_type_bound_list(&x));
        let label = self.trap.emit(generated::WherePred {
            id: TrapId::Star,
            generic_param_list,
            lifetime,
            type_repr,
            type_bound_list,
        });
        self.emit_location(label, node);
        post_emit!(WherePred, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_while_expr(
        &mut self,
        node: &ast::WhileExpr,
    ) -> Option<Label<generated::WhileExpr>> {
        pre_emit!(WhileExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let condition = node.condition().and_then(|x| self.emit_expr(&x));
        let label = node.label().and_then(|x| self.emit_label(&x));
        let loop_body = node.loop_body().and_then(|x| self.emit_block_expr(&x));
        let label = self.trap.emit(generated::WhileExpr {
            id: TrapId::Star,
            attrs,
            condition,
            label,
            loop_body,
        });
        self.emit_location(label, node);
        post_emit!(WhileExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_wildcard_pat(
        &mut self,
        node: &ast::WildcardPat,
    ) -> Option<Label<generated::WildcardPat>> {
        pre_emit!(WildcardPat, self, node);
        let label = self.trap.emit(generated::WildcardPat { id: TrapId::Star });
        self.emit_location(label, node);
        post_emit!(WildcardPat, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_yeet_expr(
        &mut self,
        node: &ast::YeetExpr,
    ) -> Option<Label<generated::YeetExpr>> {
        pre_emit!(YeetExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::YeetExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(YeetExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    pub(crate) fn emit_yield_expr(
        &mut self,
        node: &ast::YieldExpr,
    ) -> Option<Label<generated::YieldExpr>> {
        pre_emit!(YieldExpr, self, node);
        if self.should_be_excluded(node) {
            return None;
        }
        let attrs = node.attrs().filter_map(|x| self.emit_attr(&x)).collect();
        let expr = node.expr().and_then(|x| self.emit_expr(&x));
        let label = self.trap.emit(generated::YieldExpr {
            id: TrapId::Star,
            attrs,
            expr,
        });
        self.emit_location(label, node);
        post_emit!(YieldExpr, self, node, label);
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
}
