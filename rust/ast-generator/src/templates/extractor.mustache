//! Generated by `ast-generator`, do not edit by hand.
¶{{! <- denotes empty line that should be kept, all blank lines are removed otherwise}}
#![cfg_attr(any(), rustfmt::skip)]
¶
use super::base::Translator;
use super::mappings::TextValue;
use crate::emit_detached;
use crate::generated;
use crate::trap::{Label, TrapId};
use ra_ap_syntax::ast::{
    HasArgList, HasAttrs, HasGenericArgs, HasGenericParams, HasLoopBody, HasModuleItem, HasName,
    HasTypeBounds, HasVisibility, RangeItem,
};
use ra_ap_syntax::{ast, AstNode};
¶
impl Translator<'_> {
    fn emit_else_branch(&mut self, node: ast::ElseBranch) -> Option<Label<generated::Expr>> {
        match node {
            ast::ElseBranch::IfExpr(inner) => self.emit_if_expr(inner).map(Into::into),
            ast::ElseBranch::Block(inner) => self.emit_block_expr(inner).map(Into::into),
        }
    }
    {{#enums}}
¶
    pub(crate) fn emit_{{snake_case_name}}(&mut self, node: ast::{{ast_name}}) -> Option<Label<generated::{{name}}>> {
        match node {
            {{#variants}}
            ast::{{ast_name}}::{{name}}(inner) => self.emit_{{snake_case_name}}(inner).map(Into::into),
            {{/variants}}
        }
    }
    {{/enums}}
    {{#nodes}}
¶
    pub(crate) fn emit_{{snake_case_name}}(&mut self, node: ast::{{ast_name}}) -> Option<Label<generated::{{name}}>> {
        {{#has_attrs}}
        if self.should_be_excluded(&node) { return None; }
        {{/has_attrs}}
        {{#fields}}
        {{#predicate}}
        let {{name}} = node.{{method}}().is_some();
        {{/predicate}}
        {{#string}}
        let {{name}} = node.try_get_text();
        {{/string}}
        {{#list}}
        let {{name}} = node.{{method}}().filter_map(|x| self.emit_{{snake_case_ty}}(x)).collect();
        {{/list}}
        {{#optional}}
        let {{name}} = node.{{method}}().and_then(|x| self.emit_{{snake_case_ty}}(x));
        {{/optional}}
        {{/fields}}
        let label = self.trap.emit(generated::{{name}} {
            id: TrapId::Star,
            {{#fields}}
            {{name}},
            {{/fields}}
        });
        self.emit_location(label, &node);
        emit_detached!({{name}}, self, node, label);
        self.emit_tokens(&node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    {{/nodes}}
}
