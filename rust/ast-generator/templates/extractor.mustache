//! Generated by `ast-generator`, do not edit by hand.

use super::base::Translator;
use super::mappings::{TextValue, HasTrapClass, Emission};
use crate::generated;
use crate::trap::{Label, TrapId};
use ra_ap_syntax::ast::{
    HasArgList, HasAttrs, HasGenericArgs, HasGenericParams, HasLoopBody, HasModuleItem, HasName,
    HasTypeBounds, HasVisibility, RangeItem,
};
#[rustfmt::skip]
use ra_ap_syntax::{AstNode, ast};

impl Translator<'_> {
    {{#enums}}

    pub(crate) fn emit_{{snake_case_name}}(&mut self, node: &ast::{{ast_name}}) -> Option<Label<generated::{{name}}>> {
        {{>pre_emission}}
        let label = match node {
            {{#variants}}
            ast::{{ast_name}}::{{variant_ast_name}}(inner) => self.emit_{{snake_case_name}}(inner).map(Into::into),
            {{/variants}}
        }?;
        {{>post_emission}}
        Some(label)
    }
    {{/enums}}
    {{#nodes}}

    pub(crate) fn emit_{{snake_case_name}}(&mut self, node: &ast::{{ast_name}}) -> Option<Label<generated::{{name}}>> {
        {{>pre_emission}}
        {{#has_attrs}}
        if self.should_be_excluded(node) { return None; }
        {{/has_attrs}}
        {{#fields}}
        let {{name}} =
            {{#predicate}}
            node.{{method}}().is_some()
            {{/predicate}}
            {{#string}}
            node.try_get_text()
            {{/string}}
            {{#list}}
            node.{{method}}().filter_map(|x| self.emit_{{snake_case_ty}}(&x)).collect()
            {{/list}}
            {{#optional}}
            node.{{method}}().and_then(|x| self.emit_{{snake_case_ty}}(&x))
            {{/optional}}
            {{#body}}
            if self.should_skip_bodies() { None } else { node.{{method}}().and_then(|x| self.emit_{{snake_case_ty}}(&x)) }
            {{/body}}
            ;
        {{/fields}}
        let label = self.trap.emit(generated::{{name}} {
            id: TrapId::Star,
            {{#fields}}
            {{name}},
            {{/fields}}
        });
        self.emit_location(label, node);
        {{>post_emission}}
        self.emit_tokens(node, label.into(), node.syntax().children_with_tokens());
        Some(label)
    }
    {{/nodes}}
}
{{#enums}}
{{>trap_class_mapping}}
{{/enums}}
{{#nodes}}
{{>trap_class_mapping}}
{{/nodes}}
