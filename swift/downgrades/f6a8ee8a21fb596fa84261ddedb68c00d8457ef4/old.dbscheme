// generated by codegen/codegen.py

// from prefix.dbscheme
/**
 * The source location of the snapshot.
 */
sourceLocationPrefix(
  string prefix: string ref
);


// from schema.py

@element =
  @callable
| @file
| @generic_context
| @locatable
| @location
| @type
;

#keyset[id]
element_is_unknown(
  int id: @element ref
);

@callable =
  @abstract_closure_expr
| @abstract_function_decl
;

#keyset[id]
callable_names(
  int id: @callable ref,
  string name: string ref
);

#keyset[id]
callable_self_params(
  int id: @callable ref,
  int self_param: @param_decl_or_none ref
);

#keyset[id, index]
callable_params(
  int id: @callable ref,
  int index: int ref,
  int param: @param_decl_or_none ref
);

#keyset[id]
callable_bodies(
  int id: @callable ref,
  int body: @brace_stmt_or_none ref
);

#keyset[id, index]
callable_captures(
  int id: @callable ref,
  int index: int ref,
  int capture: @captured_decl_or_none ref
);

@file =
  @db_file
;

#keyset[id]
files(
  int id: @file ref,
  string name: string ref
);

@locatable =
  @argument
| @ast_node
| @comment
| @diagnostics
| @error_element
;

#keyset[id]
locatable_locations(
  int id: @locatable ref,
  int location: @location_or_none ref
);

@location =
  @db_location
;

#keyset[id]
locations(
  int id: @location ref,
  int file: @file_or_none ref,
  int start_line: int ref,
  int start_column: int ref,
  int end_line: int ref,
  int end_column: int ref
);

@ast_node =
  @case_label_item
| @condition_element
| @decl
| @expr
| @pattern
| @stmt
| @stmt_condition
| @type_repr
;

comments(
  unique int id: @comment,
  string text: string ref
);

db_files(
  unique int id: @db_file
);

db_locations(
  unique int id: @db_location
);

diagnostics(
  unique int id: @diagnostics,
  string text: string ref,
  int kind: int ref
);

@error_element =
  @error_expr
| @error_type
| @overloaded_decl_ref_expr
| @unresolved_decl_ref_expr
| @unresolved_dot_expr
| @unresolved_member_chain_result_expr
| @unresolved_member_expr
| @unresolved_pattern_expr
| @unresolved_specialize_expr
| @unresolved_type
| @unresolved_type_conversion_expr
| @unspecified_element
;

unspecified_elements(
  unique int id: @unspecified_element,
  string property: string ref,
  string error: string ref
);

#keyset[id]
unspecified_element_parents(
  int id: @unspecified_element ref,
  int parent: @element ref
);

#keyset[id]
unspecified_element_indices(
  int id: @unspecified_element ref,
  int index: int ref
);

@decl =
  @captured_decl
| @enum_case_decl
| @extension_decl
| @if_config_decl
| @import_decl
| @missing_member_decl
| @operator_decl
| @pattern_binding_decl
| @pound_diagnostic_decl
| @precedence_group_decl
| @top_level_code_decl
| @value_decl
;

#keyset[id]
decls(  //dir=decl
  int id: @decl ref,
  int module: @module_decl_or_none ref
);

#keyset[id, index]
decl_members(  //dir=decl
  int id: @decl ref,
  int index: int ref,
  int member: @decl_or_none ref
);

@generic_context =
  @abstract_function_decl
| @extension_decl
| @generic_type_decl
| @subscript_decl
;

#keyset[id, index]
generic_context_generic_type_params(  //dir=decl
  int id: @generic_context ref,
  int index: int ref,
  int generic_type_param: @generic_type_param_decl_or_none ref
);

captured_decls(  //dir=decl
  unique int id: @captured_decl,
  int decl: @value_decl_or_none ref
);

#keyset[id]
captured_decl_is_direct(  //dir=decl
  int id: @captured_decl ref
);

#keyset[id]
captured_decl_is_escaping(  //dir=decl
  int id: @captured_decl ref
);

enum_case_decls(  //dir=decl
  unique int id: @enum_case_decl
);

#keyset[id, index]
enum_case_decl_elements(  //dir=decl
  int id: @enum_case_decl ref,
  int index: int ref,
  int element: @enum_element_decl_or_none ref
);

extension_decls(  //dir=decl
  unique int id: @extension_decl,
  int extended_type_decl: @nominal_type_decl_or_none ref
);

#keyset[id, index]
extension_decl_protocols(  //dir=decl
  int id: @extension_decl ref,
  int index: int ref,
  int protocol: @protocol_decl_or_none ref
);

if_config_decls(  //dir=decl
  unique int id: @if_config_decl
);

#keyset[id, index]
if_config_decl_active_elements(  //dir=decl
  int id: @if_config_decl ref,
  int index: int ref,
  int active_element: @ast_node_or_none ref
);

import_decls(  //dir=decl
  unique int id: @import_decl
);

#keyset[id]
import_decl_is_exported(  //dir=decl
  int id: @import_decl ref
);

#keyset[id]
import_decl_imported_modules(  //dir=decl
  int id: @import_decl ref,
  int imported_module: @module_decl_or_none ref
);

#keyset[id, index]
import_decl_declarations(  //dir=decl
  int id: @import_decl ref,
  int index: int ref,
  int declaration: @value_decl_or_none ref
);

missing_member_decls(  //dir=decl
  unique int id: @missing_member_decl,
  string name: string ref
);

@operator_decl =
  @infix_operator_decl
| @postfix_operator_decl
| @prefix_operator_decl
;

#keyset[id]
operator_decls(  //dir=decl
  int id: @operator_decl ref,
  string name: string ref
);

pattern_binding_decls(  //dir=decl
  unique int id: @pattern_binding_decl
);

#keyset[id, index]
pattern_binding_decl_inits(  //dir=decl
  int id: @pattern_binding_decl ref,
  int index: int ref,
  int init: @expr_or_none ref
);

#keyset[id, index]
pattern_binding_decl_patterns(  //dir=decl
  int id: @pattern_binding_decl ref,
  int index: int ref,
  int pattern: @pattern_or_none ref
);

pound_diagnostic_decls(  //dir=decl
  unique int id: @pound_diagnostic_decl,
  int kind: int ref,
  int message: @string_literal_expr_or_none ref
);

precedence_group_decls(  //dir=decl
  unique int id: @precedence_group_decl
);

top_level_code_decls(  //dir=decl
  unique int id: @top_level_code_decl,
  int body: @brace_stmt_or_none ref
);

@value_decl =
  @abstract_function_decl
| @abstract_storage_decl
| @enum_element_decl
| @type_decl
;

#keyset[id]
value_decls(  //dir=decl
  int id: @value_decl ref,
  int interface_type: @type_or_none ref
);

@abstract_function_decl =
  @constructor_decl
| @destructor_decl
| @func_decl
;

@abstract_storage_decl =
  @subscript_decl
| @var_decl
;

#keyset[id, index]
abstract_storage_decl_accessor_decls(  //dir=decl
  int id: @abstract_storage_decl ref,
  int index: int ref,
  int accessor_decl: @accessor_decl_or_none ref
);

enum_element_decls(  //dir=decl
  unique int id: @enum_element_decl,
  string name: string ref
);

#keyset[id, index]
enum_element_decl_params(  //dir=decl
  int id: @enum_element_decl ref,
  int index: int ref,
  int param: @param_decl_or_none ref
);

infix_operator_decls(  //dir=decl
  unique int id: @infix_operator_decl
);

#keyset[id]
infix_operator_decl_precedence_groups(  //dir=decl
  int id: @infix_operator_decl ref,
  int precedence_group: @precedence_group_decl_or_none ref
);

postfix_operator_decls(  //dir=decl
  unique int id: @postfix_operator_decl
);

prefix_operator_decls(  //dir=decl
  unique int id: @prefix_operator_decl
);

@type_decl =
  @abstract_type_param_decl
| @generic_type_decl
| @module_decl
;

#keyset[id]
type_decls(  //dir=decl
  int id: @type_decl ref,
  string name: string ref
);

#keyset[id, index]
type_decl_base_types(  //dir=decl
  int id: @type_decl ref,
  int index: int ref,
  int base_type: @type_or_none ref
);

@abstract_type_param_decl =
  @associated_type_decl
| @generic_type_param_decl
;

constructor_decls(  //dir=decl
  unique int id: @constructor_decl
);

destructor_decls(  //dir=decl
  unique int id: @destructor_decl
);

@func_decl =
  @accessor_decl
| @concrete_func_decl
;

@generic_type_decl =
  @nominal_type_decl
| @opaque_type_decl
| @type_alias_decl
;

module_decls(  //dir=decl
  unique int id: @module_decl
);

#keyset[id]
module_decl_is_builtin_module(  //dir=decl
  int id: @module_decl ref
);

#keyset[id]
module_decl_is_system_module(  //dir=decl
  int id: @module_decl ref
);

#keyset[id, index]
module_decl_imported_modules(  //dir=decl
  int id: @module_decl ref,
  int index: int ref,
  int imported_module: @module_decl_or_none ref
);

#keyset[id, index]
module_decl_exported_modules(  //dir=decl
  int id: @module_decl ref,
  int index: int ref,
  int exported_module: @module_decl_or_none ref
);

subscript_decls(  //dir=decl
  unique int id: @subscript_decl,
  int element_type: @type_or_none ref
);

#keyset[id, index]
subscript_decl_params(  //dir=decl
  int id: @subscript_decl ref,
  int index: int ref,
  int param: @param_decl_or_none ref
);

@var_decl =
  @concrete_var_decl
| @param_decl
;

#keyset[id]
var_decls(  //dir=decl
  int id: @var_decl ref,
  string name: string ref,
  int type_: @type_or_none ref
);

#keyset[id]
var_decl_attached_property_wrapper_types(  //dir=decl
  int id: @var_decl ref,
  int attached_property_wrapper_type: @type_or_none ref
);

#keyset[id]
var_decl_parent_patterns(  //dir=decl
  int id: @var_decl ref,
  int parent_pattern: @pattern_or_none ref
);

#keyset[id]
var_decl_parent_initializers(  //dir=decl
  int id: @var_decl ref,
  int parent_initializer: @expr_or_none ref
);

#keyset[id]
var_decl_property_wrapper_backing_var_bindings(  //dir=decl
  int id: @var_decl ref,
  int property_wrapper_backing_var_binding: @pattern_binding_decl_or_none ref
);

#keyset[id]
var_decl_property_wrapper_backing_vars(  //dir=decl
  int id: @var_decl ref,
  int property_wrapper_backing_var: @var_decl_or_none ref
);

#keyset[id]
var_decl_property_wrapper_projection_var_bindings(  //dir=decl
  int id: @var_decl ref,
  int property_wrapper_projection_var_binding: @pattern_binding_decl_or_none ref
);

#keyset[id]
var_decl_property_wrapper_projection_vars(  //dir=decl
  int id: @var_decl ref,
  int property_wrapper_projection_var: @var_decl_or_none ref
);

accessor_decls(  //dir=decl
  unique int id: @accessor_decl
);

#keyset[id]
accessor_decl_is_getter(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_setter(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_will_set(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_did_set(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_read(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_modify(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_unsafe_address(  //dir=decl
  int id: @accessor_decl ref
);

#keyset[id]
accessor_decl_is_unsafe_mutable_address(  //dir=decl
  int id: @accessor_decl ref
);

associated_type_decls(  //dir=decl
  unique int id: @associated_type_decl
);

concrete_func_decls(  //dir=decl
  unique int id: @concrete_func_decl
);

concrete_var_decls(  //dir=decl
  unique int id: @concrete_var_decl,
  int introducer_int: int ref
);

generic_type_param_decls(  //dir=decl
  unique int id: @generic_type_param_decl
);

@nominal_type_decl =
  @class_decl
| @enum_decl
| @protocol_decl
| @struct_decl
;

#keyset[id]
nominal_type_decls(  //dir=decl
  int id: @nominal_type_decl ref,
  int type_: @type_or_none ref
);

opaque_type_decls(  //dir=decl
  unique int id: @opaque_type_decl,
  int naming_declaration: @value_decl_or_none ref
);

#keyset[id, index]
opaque_type_decl_opaque_generic_params(  //dir=decl
  int id: @opaque_type_decl ref,
  int index: int ref,
  int opaque_generic_param: @generic_type_param_type_or_none ref
);

param_decls(  //dir=decl
  unique int id: @param_decl
);

#keyset[id]
param_decl_is_inout(  //dir=decl
  int id: @param_decl ref
);

#keyset[id]
param_decl_property_wrapper_local_wrapped_var_bindings(  //dir=decl
  int id: @param_decl ref,
  int property_wrapper_local_wrapped_var_binding: @pattern_binding_decl_or_none ref
);

#keyset[id]
param_decl_property_wrapper_local_wrapped_vars(  //dir=decl
  int id: @param_decl ref,
  int property_wrapper_local_wrapped_var: @var_decl_or_none ref
);

type_alias_decls(  //dir=decl
  unique int id: @type_alias_decl
);

class_decls(  //dir=decl
  unique int id: @class_decl
);

enum_decls(  //dir=decl
  unique int id: @enum_decl
);

protocol_decls(  //dir=decl
  unique int id: @protocol_decl
);

struct_decls(  //dir=decl
  unique int id: @struct_decl
);

arguments(  //dir=expr
  unique int id: @argument,
  string label: string ref,
  int expr: @expr_or_none ref
);

@expr =
  @abstract_closure_expr
| @any_try_expr
| @applied_property_wrapper_expr
| @apply_expr
| @assign_expr
| @bind_optional_expr
| @capture_list_expr
| @collection_expr
| @decl_ref_expr
| @default_argument_expr
| @discard_assignment_expr
| @dot_syntax_base_ignored_expr
| @dynamic_type_expr
| @enum_is_case_expr
| @error_expr
| @explicit_cast_expr
| @force_value_expr
| @identity_expr
| @if_expr
| @implicit_conversion_expr
| @in_out_expr
| @key_path_application_expr
| @key_path_dot_expr
| @key_path_expr
| @lazy_initializer_expr
| @literal_expr
| @lookup_expr
| @make_temporarily_escapable_expr
| @obj_c_selector_expr
| @one_way_expr
| @opaque_value_expr
| @open_existential_expr
| @optional_evaluation_expr
| @other_constructor_decl_ref_expr
| @overloaded_decl_ref_expr
| @property_wrapper_value_placeholder_expr
| @rebind_self_in_constructor_expr
| @sequence_expr
| @super_ref_expr
| @tap_expr
| @tuple_element_expr
| @tuple_expr
| @type_expr
| @unresolved_decl_ref_expr
| @unresolved_dot_expr
| @unresolved_member_expr
| @unresolved_pattern_expr
| @unresolved_specialize_expr
| @vararg_expansion_expr
;

#keyset[id]
expr_types(  //dir=expr
  int id: @expr ref,
  int type_: @type_or_none ref
);

@abstract_closure_expr =
  @auto_closure_expr
| @closure_expr
;

@any_try_expr =
  @force_try_expr
| @optional_try_expr
| @try_expr
;

#keyset[id]
any_try_exprs(  //dir=expr
  int id: @any_try_expr ref,
  int sub_expr: @expr_or_none ref
);

applied_property_wrapper_exprs(  //dir=expr
  unique int id: @applied_property_wrapper_expr,
  int kind: int ref,
  int value: @expr_or_none ref,
  int param: @param_decl_or_none ref
);

@apply_expr =
  @binary_expr
| @call_expr
| @postfix_unary_expr
| @prefix_unary_expr
| @self_apply_expr
;

#keyset[id]
apply_exprs(  //dir=expr
  int id: @apply_expr ref,
  int function: @expr_or_none ref
);

#keyset[id, index]
apply_expr_arguments(  //dir=expr
  int id: @apply_expr ref,
  int index: int ref,
  int argument: @argument_or_none ref
);

assign_exprs(  //dir=expr
  unique int id: @assign_expr,
  int dest: @expr_or_none ref,
  int source: @expr_or_none ref
);

bind_optional_exprs(  //dir=expr
  unique int id: @bind_optional_expr,
  int sub_expr: @expr_or_none ref
);

capture_list_exprs(  //dir=expr
  unique int id: @capture_list_expr,
  int closure_body: @closure_expr_or_none ref
);

#keyset[id, index]
capture_list_expr_binding_decls(  //dir=expr
  int id: @capture_list_expr ref,
  int index: int ref,
  int binding_decl: @pattern_binding_decl_or_none ref
);

@collection_expr =
  @array_expr
| @dictionary_expr
;

decl_ref_exprs(  //dir=expr
  unique int id: @decl_ref_expr,
  int decl: @decl_or_none ref
);

#keyset[id, index]
decl_ref_expr_replacement_types(  //dir=expr
  int id: @decl_ref_expr ref,
  int index: int ref,
  int replacement_type: @type_or_none ref
);

#keyset[id]
decl_ref_expr_has_direct_to_storage_semantics(  //dir=expr
  int id: @decl_ref_expr ref
);

#keyset[id]
decl_ref_expr_has_direct_to_implementation_semantics(  //dir=expr
  int id: @decl_ref_expr ref
);

#keyset[id]
decl_ref_expr_has_ordinary_semantics(  //dir=expr
  int id: @decl_ref_expr ref
);

#keyset[id]
decl_ref_expr_has_distributed_thunk_semantics(  //dir=expr
  int id: @decl_ref_expr ref
);

default_argument_exprs(  //dir=expr
  unique int id: @default_argument_expr,
  int param_decl: @param_decl_or_none ref,
  int param_index: int ref
);

#keyset[id]
default_argument_expr_caller_side_defaults(  //dir=expr
  int id: @default_argument_expr ref,
  int caller_side_default: @expr_or_none ref
);

discard_assignment_exprs(  //dir=expr
  unique int id: @discard_assignment_expr
);

dot_syntax_base_ignored_exprs(  //dir=expr
  unique int id: @dot_syntax_base_ignored_expr,
  int qualifier: @expr_or_none ref,
  int sub_expr: @expr_or_none ref
);

dynamic_type_exprs(  //dir=expr
  unique int id: @dynamic_type_expr,
  int base: @expr_or_none ref
);

enum_is_case_exprs(  //dir=expr
  unique int id: @enum_is_case_expr,
  int sub_expr: @expr_or_none ref,
  int element: @enum_element_decl_or_none ref
);

error_exprs(  //dir=expr
  unique int id: @error_expr
);

@explicit_cast_expr =
  @checked_cast_expr
| @coerce_expr
;

#keyset[id]
explicit_cast_exprs(  //dir=expr
  int id: @explicit_cast_expr ref,
  int sub_expr: @expr_or_none ref
);

force_value_exprs(  //dir=expr
  unique int id: @force_value_expr,
  int sub_expr: @expr_or_none ref
);

@identity_expr =
  @await_expr
| @dot_self_expr
| @paren_expr
| @unresolved_member_chain_result_expr
;

#keyset[id]
identity_exprs(  //dir=expr
  int id: @identity_expr ref,
  int sub_expr: @expr_or_none ref
);

if_exprs(  //dir=expr
  unique int id: @if_expr,
  int condition: @expr_or_none ref,
  int then_expr: @expr_or_none ref,
  int else_expr: @expr_or_none ref
);

@implicit_conversion_expr =
  @abi_safe_conversion_expr
| @any_hashable_erasure_expr
| @archetype_to_super_expr
| @array_to_pointer_expr
| @bridge_from_obj_c_expr
| @bridge_to_obj_c_expr
| @class_metatype_to_object_expr
| @collection_upcast_conversion_expr
| @conditional_bridge_from_obj_c_expr
| @covariant_function_conversion_expr
| @covariant_return_conversion_expr
| @derived_to_base_expr
| @destructure_tuple_expr
| @differentiable_function_expr
| @differentiable_function_extract_original_expr
| @erasure_expr
| @existential_metatype_to_object_expr
| @foreign_object_conversion_expr
| @function_conversion_expr
| @in_out_to_pointer_expr
| @inject_into_optional_expr
| @linear_function_expr
| @linear_function_extract_original_expr
| @linear_to_differentiable_function_expr
| @load_expr
| @metatype_conversion_expr
| @pointer_to_pointer_expr
| @protocol_metatype_to_object_expr
| @string_to_pointer_expr
| @underlying_to_opaque_expr
| @unevaluated_instance_expr
| @unresolved_type_conversion_expr
;

#keyset[id]
implicit_conversion_exprs(  //dir=expr
  int id: @implicit_conversion_expr ref,
  int sub_expr: @expr_or_none ref
);

in_out_exprs(  //dir=expr
  unique int id: @in_out_expr,
  int sub_expr: @expr_or_none ref
);

key_path_application_exprs(  //dir=expr
  unique int id: @key_path_application_expr,
  int base: @expr_or_none ref,
  int key_path: @expr_or_none ref
);

key_path_dot_exprs(  //dir=expr
  unique int id: @key_path_dot_expr
);

key_path_exprs(  //dir=expr
  unique int id: @key_path_expr
);

#keyset[id]
key_path_expr_roots(  //dir=expr
  int id: @key_path_expr ref,
  int root: @type_repr_or_none ref
);

#keyset[id]
key_path_expr_parsed_paths(  //dir=expr
  int id: @key_path_expr ref,
  int parsed_path: @expr_or_none ref
);

lazy_initializer_exprs(  //dir=expr
  unique int id: @lazy_initializer_expr,
  int sub_expr: @expr_or_none ref
);

@literal_expr =
  @builtin_literal_expr
| @interpolated_string_literal_expr
| @nil_literal_expr
| @object_literal_expr
| @regex_literal_expr
;

@lookup_expr =
  @dynamic_lookup_expr
| @member_ref_expr
| @subscript_expr
;

#keyset[id]
lookup_exprs(  //dir=expr
  int id: @lookup_expr ref,
  int base: @expr_or_none ref
);

#keyset[id]
lookup_expr_members(  //dir=expr
  int id: @lookup_expr ref,
  int member: @decl_or_none ref
);

make_temporarily_escapable_exprs(  //dir=expr
  unique int id: @make_temporarily_escapable_expr,
  int escaping_closure: @opaque_value_expr_or_none ref,
  int nonescaping_closure: @expr_or_none ref,
  int sub_expr: @expr_or_none ref
);

obj_c_selector_exprs(  //dir=expr
  unique int id: @obj_c_selector_expr,
  int sub_expr: @expr_or_none ref,
  int method: @abstract_function_decl_or_none ref
);

one_way_exprs(  //dir=expr
  unique int id: @one_way_expr,
  int sub_expr: @expr_or_none ref
);

opaque_value_exprs(  //dir=expr
  unique int id: @opaque_value_expr
);

open_existential_exprs(  //dir=expr
  unique int id: @open_existential_expr,
  int sub_expr: @expr_or_none ref,
  int existential: @expr_or_none ref,
  int opaque_expr: @opaque_value_expr_or_none ref
);

optional_evaluation_exprs(  //dir=expr
  unique int id: @optional_evaluation_expr,
  int sub_expr: @expr_or_none ref
);

other_constructor_decl_ref_exprs(  //dir=expr
  unique int id: @other_constructor_decl_ref_expr,
  int constructor_decl: @constructor_decl_or_none ref
);

overloaded_decl_ref_exprs(  //dir=expr
  unique int id: @overloaded_decl_ref_expr
);

#keyset[id, index]
overloaded_decl_ref_expr_possible_declarations(  //dir=expr
  int id: @overloaded_decl_ref_expr ref,
  int index: int ref,
  int possible_declaration: @value_decl_or_none ref
);

property_wrapper_value_placeholder_exprs(  //dir=expr
  unique int id: @property_wrapper_value_placeholder_expr,
  int placeholder: @opaque_value_expr_or_none ref
);

#keyset[id]
property_wrapper_value_placeholder_expr_wrapped_values(  //dir=expr
  int id: @property_wrapper_value_placeholder_expr ref,
  int wrapped_value: @expr_or_none ref
);

rebind_self_in_constructor_exprs(  //dir=expr
  unique int id: @rebind_self_in_constructor_expr,
  int sub_expr: @expr_or_none ref,
  int self: @var_decl_or_none ref
);

sequence_exprs(  //dir=expr
  unique int id: @sequence_expr
);

#keyset[id, index]
sequence_expr_elements(  //dir=expr
  int id: @sequence_expr ref,
  int index: int ref,
  int element: @expr_or_none ref
);

super_ref_exprs(  //dir=expr
  unique int id: @super_ref_expr,
  int self: @var_decl_or_none ref
);

tap_exprs(  //dir=expr
  unique int id: @tap_expr,
  int body: @brace_stmt_or_none ref,
  int var: @var_decl_or_none ref
);

#keyset[id]
tap_expr_sub_exprs(  //dir=expr
  int id: @tap_expr ref,
  int sub_expr: @expr_or_none ref
);

tuple_element_exprs(  //dir=expr
  unique int id: @tuple_element_expr,
  int sub_expr: @expr_or_none ref,
  int index: int ref
);

tuple_exprs(  //dir=expr
  unique int id: @tuple_expr
);

#keyset[id, index]
tuple_expr_elements(  //dir=expr
  int id: @tuple_expr ref,
  int index: int ref,
  int element: @expr_or_none ref
);

type_exprs(  //dir=expr
  unique int id: @type_expr
);

#keyset[id]
type_expr_type_reprs(  //dir=expr
  int id: @type_expr ref,
  int type_repr: @type_repr_or_none ref
);

unresolved_decl_ref_exprs(  //dir=expr
  unique int id: @unresolved_decl_ref_expr
);

#keyset[id]
unresolved_decl_ref_expr_names(  //dir=expr
  int id: @unresolved_decl_ref_expr ref,
  string name: string ref
);

unresolved_dot_exprs(  //dir=expr
  unique int id: @unresolved_dot_expr,
  int base: @expr_or_none ref,
  string name: string ref
);

unresolved_member_exprs(  //dir=expr
  unique int id: @unresolved_member_expr,
  string name: string ref
);

unresolved_pattern_exprs(  //dir=expr
  unique int id: @unresolved_pattern_expr,
  int sub_pattern: @pattern_or_none ref
);

unresolved_specialize_exprs(  //dir=expr
  unique int id: @unresolved_specialize_expr,
  int sub_expr: @expr_or_none ref
);

vararg_expansion_exprs(  //dir=expr
  unique int id: @vararg_expansion_expr,
  int sub_expr: @expr_or_none ref
);

abi_safe_conversion_exprs(  //dir=expr
  unique int id: @abi_safe_conversion_expr
);

any_hashable_erasure_exprs(  //dir=expr
  unique int id: @any_hashable_erasure_expr
);

archetype_to_super_exprs(  //dir=expr
  unique int id: @archetype_to_super_expr
);

array_exprs(  //dir=expr
  unique int id: @array_expr
);

#keyset[id, index]
array_expr_elements(  //dir=expr
  int id: @array_expr ref,
  int index: int ref,
  int element: @expr_or_none ref
);

array_to_pointer_exprs(  //dir=expr
  unique int id: @array_to_pointer_expr
);

auto_closure_exprs(  //dir=expr
  unique int id: @auto_closure_expr
);

await_exprs(  //dir=expr
  unique int id: @await_expr
);

binary_exprs(  //dir=expr
  unique int id: @binary_expr
);

bridge_from_obj_c_exprs(  //dir=expr
  unique int id: @bridge_from_obj_c_expr
);

bridge_to_obj_c_exprs(  //dir=expr
  unique int id: @bridge_to_obj_c_expr
);

@builtin_literal_expr =
  @boolean_literal_expr
| @magic_identifier_literal_expr
| @number_literal_expr
| @string_literal_expr
;

call_exprs(  //dir=expr
  unique int id: @call_expr
);

@checked_cast_expr =
  @conditional_checked_cast_expr
| @forced_checked_cast_expr
| @is_expr
;

class_metatype_to_object_exprs(  //dir=expr
  unique int id: @class_metatype_to_object_expr
);

closure_exprs(  //dir=expr
  unique int id: @closure_expr
);

coerce_exprs(  //dir=expr
  unique int id: @coerce_expr
);

collection_upcast_conversion_exprs(  //dir=expr
  unique int id: @collection_upcast_conversion_expr
);

conditional_bridge_from_obj_c_exprs(  //dir=expr
  unique int id: @conditional_bridge_from_obj_c_expr
);

covariant_function_conversion_exprs(  //dir=expr
  unique int id: @covariant_function_conversion_expr
);

covariant_return_conversion_exprs(  //dir=expr
  unique int id: @covariant_return_conversion_expr
);

derived_to_base_exprs(  //dir=expr
  unique int id: @derived_to_base_expr
);

destructure_tuple_exprs(  //dir=expr
  unique int id: @destructure_tuple_expr
);

dictionary_exprs(  //dir=expr
  unique int id: @dictionary_expr
);

#keyset[id, index]
dictionary_expr_elements(  //dir=expr
  int id: @dictionary_expr ref,
  int index: int ref,
  int element: @expr_or_none ref
);

differentiable_function_exprs(  //dir=expr
  unique int id: @differentiable_function_expr
);

differentiable_function_extract_original_exprs(  //dir=expr
  unique int id: @differentiable_function_extract_original_expr
);

dot_self_exprs(  //dir=expr
  unique int id: @dot_self_expr
);

@dynamic_lookup_expr =
  @dynamic_member_ref_expr
| @dynamic_subscript_expr
;

erasure_exprs(  //dir=expr
  unique int id: @erasure_expr
);

existential_metatype_to_object_exprs(  //dir=expr
  unique int id: @existential_metatype_to_object_expr
);

force_try_exprs(  //dir=expr
  unique int id: @force_try_expr
);

foreign_object_conversion_exprs(  //dir=expr
  unique int id: @foreign_object_conversion_expr
);

function_conversion_exprs(  //dir=expr
  unique int id: @function_conversion_expr
);

in_out_to_pointer_exprs(  //dir=expr
  unique int id: @in_out_to_pointer_expr
);

inject_into_optional_exprs(  //dir=expr
  unique int id: @inject_into_optional_expr
);

interpolated_string_literal_exprs(  //dir=expr
  unique int id: @interpolated_string_literal_expr
);

#keyset[id]
interpolated_string_literal_expr_interpolation_exprs(  //dir=expr
  int id: @interpolated_string_literal_expr ref,
  int interpolation_expr: @opaque_value_expr_or_none ref
);

#keyset[id]
interpolated_string_literal_expr_interpolation_count_exprs(  //dir=expr
  int id: @interpolated_string_literal_expr ref,
  int interpolation_count_expr: @expr_or_none ref
);

#keyset[id]
interpolated_string_literal_expr_literal_capacity_exprs(  //dir=expr
  int id: @interpolated_string_literal_expr ref,
  int literal_capacity_expr: @expr_or_none ref
);

#keyset[id]
interpolated_string_literal_expr_appending_exprs(  //dir=expr
  int id: @interpolated_string_literal_expr ref,
  int appending_expr: @tap_expr_or_none ref
);

linear_function_exprs(  //dir=expr
  unique int id: @linear_function_expr
);

linear_function_extract_original_exprs(  //dir=expr
  unique int id: @linear_function_extract_original_expr
);

linear_to_differentiable_function_exprs(  //dir=expr
  unique int id: @linear_to_differentiable_function_expr
);

load_exprs(  //dir=expr
  unique int id: @load_expr
);

member_ref_exprs(  //dir=expr
  unique int id: @member_ref_expr
);

#keyset[id]
member_ref_expr_has_direct_to_storage_semantics(  //dir=expr
  int id: @member_ref_expr ref
);

#keyset[id]
member_ref_expr_has_direct_to_implementation_semantics(  //dir=expr
  int id: @member_ref_expr ref
);

#keyset[id]
member_ref_expr_has_ordinary_semantics(  //dir=expr
  int id: @member_ref_expr ref
);

#keyset[id]
member_ref_expr_has_distributed_thunk_semantics(  //dir=expr
  int id: @member_ref_expr ref
);

metatype_conversion_exprs(  //dir=expr
  unique int id: @metatype_conversion_expr
);

nil_literal_exprs(  //dir=expr
  unique int id: @nil_literal_expr
);

object_literal_exprs(  //dir=expr
  unique int id: @object_literal_expr,
  int kind: int ref
);

#keyset[id, index]
object_literal_expr_arguments(  //dir=expr
  int id: @object_literal_expr ref,
  int index: int ref,
  int argument: @argument_or_none ref
);

optional_try_exprs(  //dir=expr
  unique int id: @optional_try_expr
);

paren_exprs(  //dir=expr
  unique int id: @paren_expr
);

pointer_to_pointer_exprs(  //dir=expr
  unique int id: @pointer_to_pointer_expr
);

postfix_unary_exprs(  //dir=expr
  unique int id: @postfix_unary_expr
);

prefix_unary_exprs(  //dir=expr
  unique int id: @prefix_unary_expr
);

protocol_metatype_to_object_exprs(  //dir=expr
  unique int id: @protocol_metatype_to_object_expr
);

regex_literal_exprs(  //dir=expr
  unique int id: @regex_literal_expr,
  string pattern: string ref,
  int version: int ref
);

@self_apply_expr =
  @constructor_ref_call_expr
| @dot_syntax_call_expr
;

#keyset[id]
self_apply_exprs(  //dir=expr
  int id: @self_apply_expr ref,
  int base: @expr_or_none ref
);

string_to_pointer_exprs(  //dir=expr
  unique int id: @string_to_pointer_expr
);

subscript_exprs(  //dir=expr
  unique int id: @subscript_expr
);

#keyset[id, index]
subscript_expr_arguments(  //dir=expr
  int id: @subscript_expr ref,
  int index: int ref,
  int argument: @argument_or_none ref
);

#keyset[id]
subscript_expr_has_direct_to_storage_semantics(  //dir=expr
  int id: @subscript_expr ref
);

#keyset[id]
subscript_expr_has_direct_to_implementation_semantics(  //dir=expr
  int id: @subscript_expr ref
);

#keyset[id]
subscript_expr_has_ordinary_semantics(  //dir=expr
  int id: @subscript_expr ref
);

#keyset[id]
subscript_expr_has_distributed_thunk_semantics(  //dir=expr
  int id: @subscript_expr ref
);

try_exprs(  //dir=expr
  unique int id: @try_expr
);

underlying_to_opaque_exprs(  //dir=expr
  unique int id: @underlying_to_opaque_expr
);

unevaluated_instance_exprs(  //dir=expr
  unique int id: @unevaluated_instance_expr
);

unresolved_member_chain_result_exprs(  //dir=expr
  unique int id: @unresolved_member_chain_result_expr
);

unresolved_type_conversion_exprs(  //dir=expr
  unique int id: @unresolved_type_conversion_expr
);

boolean_literal_exprs(  //dir=expr
  unique int id: @boolean_literal_expr,
  boolean value: boolean ref
);

conditional_checked_cast_exprs(  //dir=expr
  unique int id: @conditional_checked_cast_expr
);

constructor_ref_call_exprs(  //dir=expr
  unique int id: @constructor_ref_call_expr
);

dot_syntax_call_exprs(  //dir=expr
  unique int id: @dot_syntax_call_expr
);

dynamic_member_ref_exprs(  //dir=expr
  unique int id: @dynamic_member_ref_expr
);

dynamic_subscript_exprs(  //dir=expr
  unique int id: @dynamic_subscript_expr
);

forced_checked_cast_exprs(  //dir=expr
  unique int id: @forced_checked_cast_expr
);

is_exprs(  //dir=expr
  unique int id: @is_expr
);

magic_identifier_literal_exprs(  //dir=expr
  unique int id: @magic_identifier_literal_expr,
  string kind: string ref
);

@number_literal_expr =
  @float_literal_expr
| @integer_literal_expr
;

string_literal_exprs(  //dir=expr
  unique int id: @string_literal_expr,
  string value: string ref
);

float_literal_exprs(  //dir=expr
  unique int id: @float_literal_expr,
  string string_value: string ref
);

integer_literal_exprs(  //dir=expr
  unique int id: @integer_literal_expr,
  string string_value: string ref
);

@pattern =
  @any_pattern
| @binding_pattern
| @bool_pattern
| @enum_element_pattern
| @expr_pattern
| @is_pattern
| @named_pattern
| @optional_some_pattern
| @paren_pattern
| @tuple_pattern
| @typed_pattern
;

any_patterns(  //dir=pattern
  unique int id: @any_pattern
);

binding_patterns(  //dir=pattern
  unique int id: @binding_pattern,
  int sub_pattern: @pattern_or_none ref
);

bool_patterns(  //dir=pattern
  unique int id: @bool_pattern,
  boolean value: boolean ref
);

enum_element_patterns(  //dir=pattern
  unique int id: @enum_element_pattern,
  int element: @enum_element_decl_or_none ref
);

#keyset[id]
enum_element_pattern_sub_patterns(  //dir=pattern
  int id: @enum_element_pattern ref,
  int sub_pattern: @pattern_or_none ref
);

expr_patterns(  //dir=pattern
  unique int id: @expr_pattern,
  int sub_expr: @expr_or_none ref
);

is_patterns(  //dir=pattern
  unique int id: @is_pattern
);

#keyset[id]
is_pattern_cast_type_reprs(  //dir=pattern
  int id: @is_pattern ref,
  int cast_type_repr: @type_repr_or_none ref
);

#keyset[id]
is_pattern_sub_patterns(  //dir=pattern
  int id: @is_pattern ref,
  int sub_pattern: @pattern_or_none ref
);

named_patterns(  //dir=pattern
  unique int id: @named_pattern,
  string name: string ref
);

optional_some_patterns(  //dir=pattern
  unique int id: @optional_some_pattern,
  int sub_pattern: @pattern_or_none ref
);

paren_patterns(  //dir=pattern
  unique int id: @paren_pattern,
  int sub_pattern: @pattern_or_none ref
);

tuple_patterns(  //dir=pattern
  unique int id: @tuple_pattern
);

#keyset[id, index]
tuple_pattern_elements(  //dir=pattern
  int id: @tuple_pattern ref,
  int index: int ref,
  int element: @pattern_or_none ref
);

typed_patterns(  //dir=pattern
  unique int id: @typed_pattern,
  int sub_pattern: @pattern_or_none ref
);

#keyset[id]
typed_pattern_type_reprs(  //dir=pattern
  int id: @typed_pattern ref,
  int type_repr: @type_repr_or_none ref
);

case_label_items(  //dir=stmt
  unique int id: @case_label_item,
  int pattern: @pattern_or_none ref
);

#keyset[id]
case_label_item_guards(  //dir=stmt
  int id: @case_label_item ref,
  int guard: @expr_or_none ref
);

condition_elements(  //dir=stmt
  unique int id: @condition_element
);

#keyset[id]
condition_element_booleans(  //dir=stmt
  int id: @condition_element ref,
  int boolean_: @expr_or_none ref
);

#keyset[id]
condition_element_patterns(  //dir=stmt
  int id: @condition_element ref,
  int pattern: @pattern_or_none ref
);

#keyset[id]
condition_element_initializers(  //dir=stmt
  int id: @condition_element ref,
  int initializer: @expr_or_none ref
);

@stmt =
  @brace_stmt
| @break_stmt
| @case_stmt
| @continue_stmt
| @defer_stmt
| @fail_stmt
| @fallthrough_stmt
| @labeled_stmt
| @pound_assert_stmt
| @return_stmt
| @throw_stmt
| @yield_stmt
;

stmt_conditions(  //dir=stmt
  unique int id: @stmt_condition
);

#keyset[id, index]
stmt_condition_elements(  //dir=stmt
  int id: @stmt_condition ref,
  int index: int ref,
  int element: @condition_element_or_none ref
);

brace_stmts(  //dir=stmt
  unique int id: @brace_stmt
);

#keyset[id, index]
brace_stmt_elements(  //dir=stmt
  int id: @brace_stmt ref,
  int index: int ref,
  int element: @ast_node_or_none ref
);

break_stmts(  //dir=stmt
  unique int id: @break_stmt
);

#keyset[id]
break_stmt_target_names(  //dir=stmt
  int id: @break_stmt ref,
  string target_name: string ref
);

#keyset[id]
break_stmt_targets(  //dir=stmt
  int id: @break_stmt ref,
  int target: @stmt_or_none ref
);

case_stmts(  //dir=stmt
  unique int id: @case_stmt,
  int body: @stmt_or_none ref
);

#keyset[id, index]
case_stmt_labels(  //dir=stmt
  int id: @case_stmt ref,
  int index: int ref,
  int label: @case_label_item_or_none ref
);

#keyset[id, index]
case_stmt_variables(  //dir=stmt
  int id: @case_stmt ref,
  int index: int ref,
  int variable: @var_decl_or_none ref
);

continue_stmts(  //dir=stmt
  unique int id: @continue_stmt
);

#keyset[id]
continue_stmt_target_names(  //dir=stmt
  int id: @continue_stmt ref,
  string target_name: string ref
);

#keyset[id]
continue_stmt_targets(  //dir=stmt
  int id: @continue_stmt ref,
  int target: @stmt_or_none ref
);

defer_stmts(  //dir=stmt
  unique int id: @defer_stmt,
  int body: @brace_stmt_or_none ref
);

fail_stmts(  //dir=stmt
  unique int id: @fail_stmt
);

fallthrough_stmts(  //dir=stmt
  unique int id: @fallthrough_stmt,
  int fallthrough_source: @case_stmt_or_none ref,
  int fallthrough_dest: @case_stmt_or_none ref
);

@labeled_stmt =
  @do_catch_stmt
| @do_stmt
| @for_each_stmt
| @labeled_conditional_stmt
| @repeat_while_stmt
| @switch_stmt
;

#keyset[id]
labeled_stmt_labels(  //dir=stmt
  int id: @labeled_stmt ref,
  string label: string ref
);

pound_assert_stmts(  //dir=stmt
  unique int id: @pound_assert_stmt,
  int condition: @expr_or_none ref,
  string message: string ref
);

return_stmts(  //dir=stmt
  unique int id: @return_stmt
);

#keyset[id]
return_stmt_results(  //dir=stmt
  int id: @return_stmt ref,
  int result: @expr_or_none ref
);

throw_stmts(  //dir=stmt
  unique int id: @throw_stmt,
  int sub_expr: @expr_or_none ref
);

yield_stmts(  //dir=stmt
  unique int id: @yield_stmt
);

#keyset[id, index]
yield_stmt_results(  //dir=stmt
  int id: @yield_stmt ref,
  int index: int ref,
  int result: @expr_or_none ref
);

do_catch_stmts(  //dir=stmt
  unique int id: @do_catch_stmt,
  int body: @stmt_or_none ref
);

#keyset[id, index]
do_catch_stmt_catches(  //dir=stmt
  int id: @do_catch_stmt ref,
  int index: int ref,
  int catch: @case_stmt_or_none ref
);

do_stmts(  //dir=stmt
  unique int id: @do_stmt,
  int body: @brace_stmt_or_none ref
);

for_each_stmts(  //dir=stmt
  unique int id: @for_each_stmt,
  int pattern: @pattern_or_none ref,
  int sequence: @expr_or_none ref,
  int body: @brace_stmt_or_none ref
);

#keyset[id]
for_each_stmt_wheres(  //dir=stmt
  int id: @for_each_stmt ref,
  int where: @expr_or_none ref
);

@labeled_conditional_stmt =
  @guard_stmt
| @if_stmt
| @while_stmt
;

#keyset[id]
labeled_conditional_stmts(  //dir=stmt
  int id: @labeled_conditional_stmt ref,
  int condition: @stmt_condition_or_none ref
);

repeat_while_stmts(  //dir=stmt
  unique int id: @repeat_while_stmt,
  int condition: @expr_or_none ref,
  int body: @stmt_or_none ref
);

switch_stmts(  //dir=stmt
  unique int id: @switch_stmt,
  int expr: @expr_or_none ref
);

#keyset[id, index]
switch_stmt_cases(  //dir=stmt
  int id: @switch_stmt ref,
  int index: int ref,
  int case_: @case_stmt_or_none ref
);

guard_stmts(  //dir=stmt
  unique int id: @guard_stmt,
  int body: @brace_stmt_or_none ref
);

if_stmts(  //dir=stmt
  unique int id: @if_stmt,
  int then: @stmt_or_none ref
);

#keyset[id]
if_stmt_elses(  //dir=stmt
  int id: @if_stmt ref,
  int else: @stmt_or_none ref
);

while_stmts(  //dir=stmt
  unique int id: @while_stmt,
  int body: @stmt_or_none ref
);

@type =
  @any_function_type
| @any_generic_type
| @any_metatype_type
| @builtin_type
| @dependent_member_type
| @dynamic_self_type
| @error_type
| @existential_type
| @in_out_type
| @l_value_type
| @module_type
| @parameterized_protocol_type
| @protocol_composition_type
| @reference_storage_type
| @substitutable_type
| @sugar_type
| @tuple_type
| @unresolved_type
;

#keyset[id]
types(  //dir=type
  int id: @type ref,
  string name: string ref,
  int canonical_type: @type_or_none ref
);

type_reprs(  //dir=type
  unique int id: @type_repr,
  int type_: @type_or_none ref
);

@any_function_type =
  @function_type
| @generic_function_type
;

#keyset[id]
any_function_types(  //dir=type
  int id: @any_function_type ref,
  int result: @type_or_none ref
);

#keyset[id, index]
any_function_type_param_types(  //dir=type
  int id: @any_function_type ref,
  int index: int ref,
  int param_type: @type_or_none ref
);

#keyset[id, index]
any_function_type_param_labels(  //dir=type
  int id: @any_function_type ref,
  int index: int ref,
  string param_label: string ref
);

#keyset[id]
any_function_type_is_throwing(  //dir=type
  int id: @any_function_type ref
);

#keyset[id]
any_function_type_is_async(  //dir=type
  int id: @any_function_type ref
);

@any_generic_type =
  @nominal_or_bound_generic_nominal_type
| @unbound_generic_type
;

#keyset[id]
any_generic_types(  //dir=type
  int id: @any_generic_type ref,
  int declaration: @decl_or_none ref
);

#keyset[id]
any_generic_type_parents(  //dir=type
  int id: @any_generic_type ref,
  int parent: @type_or_none ref
);

@any_metatype_type =
  @existential_metatype_type
| @metatype_type
;

@builtin_type =
  @any_builtin_integer_type
| @builtin_bridge_object_type
| @builtin_default_actor_storage_type
| @builtin_executor_type
| @builtin_float_type
| @builtin_job_type
| @builtin_native_object_type
| @builtin_raw_pointer_type
| @builtin_raw_unsafe_continuation_type
| @builtin_unsafe_value_buffer_type
| @builtin_vector_type
;

dependent_member_types(  //dir=type
  unique int id: @dependent_member_type,
  int base_type: @type_or_none ref,
  int associated_type_decl: @associated_type_decl_or_none ref
);

dynamic_self_types(  //dir=type
  unique int id: @dynamic_self_type,
  int static_self_type: @type_or_none ref
);

error_types(  //dir=type
  unique int id: @error_type
);

existential_types(  //dir=type
  unique int id: @existential_type,
  int constraint: @type_or_none ref
);

in_out_types(  //dir=type
  unique int id: @in_out_type,
  int object_type: @type_or_none ref
);

l_value_types(  //dir=type
  unique int id: @l_value_type,
  int object_type: @type_or_none ref
);

module_types(  //dir=type
  unique int id: @module_type,
  int module: @module_decl_or_none ref
);

parameterized_protocol_types(  //dir=type
  unique int id: @parameterized_protocol_type,
  int base: @protocol_type_or_none ref
);

#keyset[id, index]
parameterized_protocol_type_args(  //dir=type
  int id: @parameterized_protocol_type ref,
  int index: int ref,
  int arg: @type_or_none ref
);

protocol_composition_types(  //dir=type
  unique int id: @protocol_composition_type
);

#keyset[id, index]
protocol_composition_type_members(  //dir=type
  int id: @protocol_composition_type ref,
  int index: int ref,
  int member: @type_or_none ref
);

@reference_storage_type =
  @unmanaged_storage_type
| @unowned_storage_type
| @weak_storage_type
;

#keyset[id]
reference_storage_types(  //dir=type
  int id: @reference_storage_type ref,
  int referent_type: @type_or_none ref
);

@substitutable_type =
  @archetype_type
| @generic_type_param_type
;

@sugar_type =
  @paren_type
| @syntax_sugar_type
| @type_alias_type
;

tuple_types(  //dir=type
  unique int id: @tuple_type
);

#keyset[id, index]
tuple_type_types(  //dir=type
  int id: @tuple_type ref,
  int index: int ref,
  int type_: @type_or_none ref
);

#keyset[id, index]
tuple_type_names(  //dir=type
  int id: @tuple_type ref,
  int index: int ref,
  string name: string ref
);

unresolved_types(  //dir=type
  unique int id: @unresolved_type
);

@any_builtin_integer_type =
  @builtin_integer_literal_type
| @builtin_integer_type
;

@archetype_type =
  @opaque_type_archetype_type
| @opened_archetype_type
| @primary_archetype_type
;

#keyset[id]
archetype_types(  //dir=type
  int id: @archetype_type ref,
  int interface_type: @type_or_none ref
);

#keyset[id]
archetype_type_superclasses(  //dir=type
  int id: @archetype_type ref,
  int superclass: @type_or_none ref
);

#keyset[id, index]
archetype_type_protocols(  //dir=type
  int id: @archetype_type ref,
  int index: int ref,
  int protocol: @protocol_decl_or_none ref
);

builtin_bridge_object_types(  //dir=type
  unique int id: @builtin_bridge_object_type
);

builtin_default_actor_storage_types(  //dir=type
  unique int id: @builtin_default_actor_storage_type
);

builtin_executor_types(  //dir=type
  unique int id: @builtin_executor_type
);

builtin_float_types(  //dir=type
  unique int id: @builtin_float_type
);

builtin_job_types(  //dir=type
  unique int id: @builtin_job_type
);

builtin_native_object_types(  //dir=type
  unique int id: @builtin_native_object_type
);

builtin_raw_pointer_types(  //dir=type
  unique int id: @builtin_raw_pointer_type
);

builtin_raw_unsafe_continuation_types(  //dir=type
  unique int id: @builtin_raw_unsafe_continuation_type
);

builtin_unsafe_value_buffer_types(  //dir=type
  unique int id: @builtin_unsafe_value_buffer_type
);

builtin_vector_types(  //dir=type
  unique int id: @builtin_vector_type
);

existential_metatype_types(  //dir=type
  unique int id: @existential_metatype_type
);

function_types(  //dir=type
  unique int id: @function_type
);

generic_function_types(  //dir=type
  unique int id: @generic_function_type
);

#keyset[id, index]
generic_function_type_generic_params(  //dir=type
  int id: @generic_function_type ref,
  int index: int ref,
  int generic_param: @generic_type_param_type_or_none ref
);

generic_type_param_types(  //dir=type
  unique int id: @generic_type_param_type
);

metatype_types(  //dir=type
  unique int id: @metatype_type
);

@nominal_or_bound_generic_nominal_type =
  @bound_generic_type
| @nominal_type
;

paren_types(  //dir=type
  unique int id: @paren_type,
  int type_: @type_or_none ref
);

@syntax_sugar_type =
  @dictionary_type
| @unary_syntax_sugar_type
;

type_alias_types(  //dir=type
  unique int id: @type_alias_type,
  int decl: @type_alias_decl_or_none ref
);

unbound_generic_types(  //dir=type
  unique int id: @unbound_generic_type
);

unmanaged_storage_types(  //dir=type
  unique int id: @unmanaged_storage_type
);

unowned_storage_types(  //dir=type
  unique int id: @unowned_storage_type
);

weak_storage_types(  //dir=type
  unique int id: @weak_storage_type
);

@bound_generic_type =
  @bound_generic_class_type
| @bound_generic_enum_type
| @bound_generic_struct_type
;

#keyset[id, index]
bound_generic_type_arg_types(  //dir=type
  int id: @bound_generic_type ref,
  int index: int ref,
  int arg_type: @type_or_none ref
);

builtin_integer_literal_types(  //dir=type
  unique int id: @builtin_integer_literal_type
);

builtin_integer_types(  //dir=type
  unique int id: @builtin_integer_type
);

#keyset[id]
builtin_integer_type_widths(  //dir=type
  int id: @builtin_integer_type ref,
  int width: int ref
);

dictionary_types(  //dir=type
  unique int id: @dictionary_type,
  int key_type: @type_or_none ref,
  int value_type: @type_or_none ref
);

@nominal_type =
  @class_type
| @enum_type
| @protocol_type
| @struct_type
;

opaque_type_archetype_types(  //dir=type
  unique int id: @opaque_type_archetype_type,
  int declaration: @opaque_type_decl_or_none ref
);

opened_archetype_types(  //dir=type
  unique int id: @opened_archetype_type
);

primary_archetype_types(  //dir=type
  unique int id: @primary_archetype_type
);

@unary_syntax_sugar_type =
  @array_slice_type
| @optional_type
| @variadic_sequence_type
;

#keyset[id]
unary_syntax_sugar_types(  //dir=type
  int id: @unary_syntax_sugar_type ref,
  int base_type: @type_or_none ref
);

array_slice_types(  //dir=type
  unique int id: @array_slice_type
);

bound_generic_class_types(  //dir=type
  unique int id: @bound_generic_class_type
);

bound_generic_enum_types(  //dir=type
  unique int id: @bound_generic_enum_type
);

bound_generic_struct_types(  //dir=type
  unique int id: @bound_generic_struct_type
);

class_types(  //dir=type
  unique int id: @class_type
);

enum_types(  //dir=type
  unique int id: @enum_type
);

optional_types(  //dir=type
  unique int id: @optional_type
);

protocol_types(  //dir=type
  unique int id: @protocol_type
);

struct_types(  //dir=type
  unique int id: @struct_type
);

variadic_sequence_types(  //dir=type
  unique int id: @variadic_sequence_type
);

@abstract_function_decl_or_none =
  @abstract_function_decl
| @unspecified_element
;

@accessor_decl_or_none =
  @accessor_decl
| @unspecified_element
;

@argument_or_none =
  @argument
| @unspecified_element
;

@associated_type_decl_or_none =
  @associated_type_decl
| @unspecified_element
;

@ast_node_or_none =
  @ast_node
| @unspecified_element
;

@brace_stmt_or_none =
  @brace_stmt
| @unspecified_element
;

@captured_decl_or_none =
  @captured_decl
| @unspecified_element
;

@case_label_item_or_none =
  @case_label_item
| @unspecified_element
;

@case_stmt_or_none =
  @case_stmt
| @unspecified_element
;

@closure_expr_or_none =
  @closure_expr
| @unspecified_element
;

@condition_element_or_none =
  @condition_element
| @unspecified_element
;

@constructor_decl_or_none =
  @constructor_decl
| @unspecified_element
;

@decl_or_none =
  @decl
| @unspecified_element
;

@enum_element_decl_or_none =
  @enum_element_decl
| @unspecified_element
;

@expr_or_none =
  @expr
| @unspecified_element
;

@file_or_none =
  @file
| @unspecified_element
;

@generic_type_param_decl_or_none =
  @generic_type_param_decl
| @unspecified_element
;

@generic_type_param_type_or_none =
  @generic_type_param_type
| @unspecified_element
;

@location_or_none =
  @location
| @unspecified_element
;

@module_decl_or_none =
  @module_decl
| @unspecified_element
;

@nominal_type_decl_or_none =
  @nominal_type_decl
| @unspecified_element
;

@opaque_type_decl_or_none =
  @opaque_type_decl
| @unspecified_element
;

@opaque_value_expr_or_none =
  @opaque_value_expr
| @unspecified_element
;

@param_decl_or_none =
  @param_decl
| @unspecified_element
;

@pattern_or_none =
  @pattern
| @unspecified_element
;

@pattern_binding_decl_or_none =
  @pattern_binding_decl
| @unspecified_element
;

@precedence_group_decl_or_none =
  @precedence_group_decl
| @unspecified_element
;

@protocol_decl_or_none =
  @protocol_decl
| @unspecified_element
;

@protocol_type_or_none =
  @protocol_type
| @unspecified_element
;

@stmt_or_none =
  @stmt
| @unspecified_element
;

@stmt_condition_or_none =
  @stmt_condition
| @unspecified_element
;

@string_literal_expr_or_none =
  @string_literal_expr
| @unspecified_element
;

@tap_expr_or_none =
  @tap_expr
| @unspecified_element
;

@type_or_none =
  @type
| @unspecified_element
;

@type_alias_decl_or_none =
  @type_alias_decl
| @unspecified_element
;

@type_repr_or_none =
  @type_repr
| @unspecified_element
;

@value_decl_or_none =
  @unspecified_element
| @value_decl
;

@var_decl_or_none =
  @unspecified_element
| @var_decl
;
