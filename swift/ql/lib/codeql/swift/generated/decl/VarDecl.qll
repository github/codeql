// generated by codegen/codegen.py
private import codeql.swift.generated.Synth
private import codeql.swift.generated.Raw
import codeql.swift.elements.decl.AbstractStorageDecl
import codeql.swift.elements.expr.Expr
import codeql.swift.elements.pattern.Pattern
import codeql.swift.elements.decl.PatternBindingDecl
import codeql.swift.elements.type.Type

module Generated {
  /**
   * A declaration of a variable such as
   * * a local variable in a function:
   * ```
   * func foo() {
   *   var x = 42  // <-
   *   let y = "hello"  // <-
   *   ...
   * }
   * ```
   * * a member of a `struct` or `class`:
   * ```
   * struct S {
   *   var size : Int  // <-
   * }
   * ```
   * * ...
   */
  class VarDecl extends Synth::TVarDecl, AbstractStorageDecl {
    /**
     * Gets the name of this variable declaration.
     */
    string getName() { result = Synth::convertVarDeclToRaw(this).(Raw::VarDecl).getName() }

    /**
     * Gets the type of this variable declaration.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    Type getImmediateType() {
      result = Synth::convertTypeFromRaw(Synth::convertVarDeclToRaw(this).(Raw::VarDecl).getType())
    }

    /**
     * Gets the type of this variable declaration.
     */
    final Type getType() {
      exists(Type immediate |
        immediate = this.getImmediateType() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Gets the attached property wrapper type of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    Type getImmediateAttachedPropertyWrapperType() {
      result =
        Synth::convertTypeFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getAttachedPropertyWrapperType())
    }

    /**
     * Gets the attached property wrapper type of this variable declaration, if it exists.
     */
    final Type getAttachedPropertyWrapperType() {
      exists(Type immediate |
        immediate = this.getImmediateAttachedPropertyWrapperType() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getAttachedPropertyWrapperType()` exists.
     */
    final predicate hasAttachedPropertyWrapperType() {
      exists(this.getAttachedPropertyWrapperType())
    }

    /**
     * Gets the parent pattern of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    Pattern getImmediateParentPattern() {
      result =
        Synth::convertPatternFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getParentPattern())
    }

    /**
     * Gets the parent pattern of this variable declaration, if it exists.
     */
    final Pattern getParentPattern() {
      exists(Pattern immediate |
        immediate = this.getImmediateParentPattern() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getParentPattern()` exists.
     */
    final predicate hasParentPattern() { exists(this.getParentPattern()) }

    /**
     * Gets the parent initializer of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    Expr getImmediateParentInitializer() {
      result =
        Synth::convertExprFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getParentInitializer())
    }

    /**
     * Gets the parent initializer of this variable declaration, if it exists.
     */
    final Expr getParentInitializer() {
      exists(Expr immediate |
        immediate = this.getImmediateParentInitializer() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getParentInitializer()` exists.
     */
    final predicate hasParentInitializer() { exists(this.getParentInitializer()) }

    /**
     * Gets the property wrapper backing variable binding of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    PatternBindingDecl getImmediatePropertyWrapperBackingVarBinding() {
      result =
        Synth::convertPatternBindingDeclFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getPropertyWrapperBackingVarBinding())
    }

    /**
     * Gets the property wrapper backing variable binding of this variable declaration, if it exists.
     *
     * This is the synthesized binding introducing the property wrapper backing variable for this
     * variable, if any. See `getPropertyWrapperBackingVar`.
     */
    final PatternBindingDecl getPropertyWrapperBackingVarBinding() {
      exists(PatternBindingDecl immediate |
        immediate = this.getImmediatePropertyWrapperBackingVarBinding() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getPropertyWrapperBackingVarBinding()` exists.
     */
    final predicate hasPropertyWrapperBackingVarBinding() {
      exists(this.getPropertyWrapperBackingVarBinding())
    }

    /**
     * Gets the property wrapper backing variable of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    VarDecl getImmediatePropertyWrapperBackingVar() {
      result =
        Synth::convertVarDeclFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getPropertyWrapperBackingVar())
    }

    /**
     * Gets the property wrapper backing variable of this variable declaration, if it exists.
     *
     * This is the compiler synthesized variable holding the property wrapper for this variable, if any.
     *
     * For a property wrapper like
     * ```
     * @propertyWrapper struct MyWrapper { ... }
     *
     * struct S {
     *   @MyWrapper var x : Int = 42
     * }
     * ```
     * the compiler synthesizes a variable in `S` along the lines of
     * ```
     *   var _x = MyWrapper(wrappedValue: 42)
     * ```
     * This predicate returns such variable declaration.
     */
    final VarDecl getPropertyWrapperBackingVar() {
      exists(VarDecl immediate |
        immediate = this.getImmediatePropertyWrapperBackingVar() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getPropertyWrapperBackingVar()` exists.
     */
    final predicate hasPropertyWrapperBackingVar() { exists(this.getPropertyWrapperBackingVar()) }

    /**
     * Gets the property wrapper projection variable binding of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    PatternBindingDecl getImmediatePropertyWrapperProjectionVarBinding() {
      result =
        Synth::convertPatternBindingDeclFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getPropertyWrapperProjectionVarBinding())
    }

    /**
     * Gets the property wrapper projection variable binding of this variable declaration, if it exists.
     *
     * This is the synthesized binding introducing the property wrapper projection variable for this
     * variable, if any. See `getPropertyWrapperProjectionVar`.
     */
    final PatternBindingDecl getPropertyWrapperProjectionVarBinding() {
      exists(PatternBindingDecl immediate |
        immediate = this.getImmediatePropertyWrapperProjectionVarBinding() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getPropertyWrapperProjectionVarBinding()` exists.
     */
    final predicate hasPropertyWrapperProjectionVarBinding() {
      exists(this.getPropertyWrapperProjectionVarBinding())
    }

    /**
     * Gets the property wrapper projection variable of this variable declaration, if it exists.
     *
     * This includes nodes from the "hidden" AST. It can be overridden in subclasses to change the
     * behavior of both the `Immediate` and non-`Immediate` versions.
     */
    VarDecl getImmediatePropertyWrapperProjectionVar() {
      result =
        Synth::convertVarDeclFromRaw(Synth::convertVarDeclToRaw(this)
              .(Raw::VarDecl)
              .getPropertyWrapperProjectionVar())
    }

    /**
     * Gets the property wrapper projection variable of this variable declaration, if it exists.
     *
     * If this variable has a property wrapper with a projected value, this is the corresponding
     * synthesized variable holding that projected value, accessible with this variable's name
     * prefixed with `$`.
     *
     * For a property wrapper like
     * ```
     * @propertyWrapper struct MyWrapper {
     *   var projectedValue : Bool
     *   ...
     * }
     *
     * struct S {
     *   @MyWrapper var x : Int = 42
     * }
     * ```
     * ```
     * the compiler synthesizes a variable in `S` along the lines of
     * ```
     *   var $x : Bool { ... }
     * ```
     * This predicate returns such variable declaration.
     */
    final VarDecl getPropertyWrapperProjectionVar() {
      exists(VarDecl immediate |
        immediate = this.getImmediatePropertyWrapperProjectionVar() and
        if exists(this.getResolveStep()) then result = immediate else result = immediate.resolve()
      )
    }

    /**
     * Holds if `getPropertyWrapperProjectionVar()` exists.
     */
    final predicate hasPropertyWrapperProjectionVar() {
      exists(this.getPropertyWrapperProjectionVar())
    }
  }
}
