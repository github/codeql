// generated by {{generator}} from {{source}}
// clang-format off
#pragma once

#include <iostream>
#include <optional>
#include <vector>

#include "{{include_dir}}/{{trap_affix}}Label.h"
#include "./{{trap_affix}}Entries.h"

namespace {{namespace}} {
{{#classes}}

struct {{name}}{{#final}} : Binding<{{name}}Tag>{{#bases}}, {{ref.name}}{{/bases}}{{/final}}{{^final}}{{#has_bases}}: {{#bases}}{{^first}}, {{/first}}{{ref.name}}{{/bases}}{{/has_bases}}{{/final}} {
  {{#fields}}
  {{type}} {{field_name}}{};
  {{/fields}}
  {{#final}}

  friend std::ostream& operator<<(std::ostream& out, const {{name}}& x) {
    x.emit(out);
    return out;
  }
  {{/final}}

 protected:
  void emit({{^final}}{{trap_affix}}Label<{{name}}Tag> id, {{/final}}std::ostream& out) const {
    {{#trap_name}}
    out << {{.}}{{trap_affix}}{id{{#single_fields}}, {{field_name}}{{/single_fields}}} << '\n';
    {{/trap_name}}
    {{#bases}}
    {{ref.name}}::emit(id, out);
    {{/bases}}
    {{#fields}}
    {{#is_predicate}}
    if ({{field_name}}) out << {{trap_name}}{{trap_affix}}{id} << '\n';
    {{/is_predicate}}
    {{#is_optional}}
    {{^is_repeated}}
    if ({{field_name}}) out << {{trap_name}}{{trap_affix}}{id, *{{field_name}}} << '\n';
    {{/is_repeated}}
    {{/is_optional}}
    {{#is_repeated}}
    for (auto i = 0u; i < {{field_name}}.size(); ++i) {
      {{^is_optional}}
      out << {{trap_name}}{{trap_affix}}{id, i, {{field_name}}[i]};
      {{/is_optional}}
      {{#is_optional}}
      if ({{field_name}}[i]) out << {{trap_name}}{{trap_affix}}{id, i, *{{field_name}}[i]};
      {{/is_optional}}
    }
    {{/is_repeated}}
    {{/fields}}
  }
};
{{/classes}}
}
