/*
 * External artifacts
 */

externalDefects(
  unique int id : @externalDefect,
  varchar(900) queryPath : string ref,
  int location : @location_default ref,
  varchar(900) message : string ref,
  float severity : float ref
);

externalMetrics(
  unique int id : @externalMetric,
  varchar(900) queryPath : string ref,
  int location : @location_default ref,
  float value : float ref
);

externalData(
  int id : @externalDataElement,
  varchar(900) path : string ref,
  int column: int ref,
  varchar(900) value : string ref
);

snapshotDate(unique date snapshotDate : date ref);

sourceLocationPrefix(varchar(900) prefix : string ref);

/*
 * Duplicate code
 */

duplicateCode(
  unique int id : @duplication,
  varchar(900) relativePath : string ref,
  int equivClass : int ref);

similarCode(
  unique int id : @similarity,
  varchar(900) relativePath : string ref,
  int equivClass : int ref);

@duplication_or_similarity = @duplication | @similarity

tokens(
  int id : @duplication_or_similarity ref,
  int offset : int ref,
  int beginLine : int ref,
  int beginColumn : int ref,
  int endLine : int ref,
  int endColumn : int ref);

/*
 * Version history
 */

svnentries(
  int id : @svnentry,
  varchar(500) revision : string ref,
  varchar(500) author : string ref,
  date revisionDate : date ref,
  int changeSize : int ref
)

svnaffectedfiles(
  int id : @svnentry ref,
  int file : @file ref,
  varchar(500) action : string ref
)

svnentrymsg(
  int id : @svnentry ref,
  varchar(500) message : string ref
)

svnchurn(
  int commit : @svnentry ref,
  int file : @file ref,
  int churnedLines : int ref
)

/*
 * C++ dbscheme
 */

@location = @location_stmt | @location_expr | @location_default ;

locations_default(unique int id: @location_default,
          int file: @file ref,
          int beginLine: int ref,
          int beginColumn: int ref,
          int endLine: int ref,
          int endColumn: int ref);

locations_stmt(unique int id: @location_stmt,
          int file: @file ref,
          int beginLine: int ref,
          int beginColumn: int ref,
          int endLine: int ref,
          int endColumn: int ref);

locations_expr(unique int id: @location_expr,
          int file: @file ref,
          int beginLine: int ref,
          int beginColumn: int ref,
          int endLine: int ref,
          int endColumn: int ref);

@sourceline = @file | @function | @variable | @enumconstant;

numlines(unique int element_id: @sourceline ref,
         int num_lines: int ref,
         int num_code: int ref,
         int num_comment: int ref
        );
        
diagnostics(unique int id: @diagnostic,
			int severity: int ref,
			varchar(900) error_tag: string ref,
			varchar(900) error_message: string ref,
			int location: @location_default ref);

/*
  fromSource(0) = unknown,
  fromSource(1) = from source,
  fromSource(2) = from library
*/
files(unique int id: @file,
      varchar(900) name: string ref,
      varchar(900) simple: string ref,
      varchar(900) ext: string ref,
      int fromSource: int ref);

folders(unique int id: @folder,
        varchar(900) name: string ref,
        varchar(900) simple: string ref);

@container = @folder | @file 

containerparent(int parent: @container ref,
                unique int child: @container ref);

fileannotations(int id: @file ref,
                int kind: int ref,
                varchar(900) name: string ref,
                varchar(900) value: string ref);

inmacroexpansion(int id: @element ref,
                 int inv: @macroinvocation ref);

macroinvocations(unique int id: @macroinvocation,
          int macro_id: @ppd_define ref,
          int location: @location_default ref);

macroparent(unique int id: @macroinvocation ref,
            int parent_id: @macroinvocation ref);

// a macroinvocation may be part of another location
// the way to find a constant expression that uses a macro
// is thus to find a constant expression that has a location
// to which a macro invocation is bound
macrolocationbind(int id: @macroinvocation ref,
                  int location: @location ref);

/*
  case @function.kind of
    1 = normal
  | 2 = constructor
  | 3 = destructor
  | 4 = conversion
  | 5 = operator
  | 6 = builtin     // GCC built-in functions, e.g. __builtin___memcpy_chk
  ;
*/
functions(unique int id: @function,
          varchar(900) name: string ref,
          int kind: int ref);
          
function_return_type(int id: @function ref, int return_type: @type ref);

purefunctions(unique int id: @function ref);



fun_decls(unique int id: @fun_decl,
          int function: @function ref,
          int type_id: @type ref,
          varchar(900) name: string ref,
          int location: @location_default ref);
fun_def(unique int id: @fun_decl ref);
fun_decl_specifiers(int id: @fun_decl ref,
                    varchar(900) name: string ref)
fun_decl_throws(int fun_decl: @fun_decl ref,
                int index: int ref,
                int type_id: @type ref);
/* an empty throw specification is different from none */
fun_decl_empty_throws(unique int fun_decl: @fun_decl ref);
fun_decl_noexcept(int fun_decl: @fun_decl ref,
                  int constant: @expr ref);
fun_decl_empty_noexcept(int fun_decl: @fun_decl ref);
fun_decl_typedef_type(unique int fun_decl: @fun_decl ref,
                      int typedeftype_id: @usertype ref);

param_decl_bind(unique int id: @var_decl ref,
                int index: int ref,
                int fun_decl: @fun_decl ref);

var_decls(unique int id: @var_decl,
          int variable: @variable ref,
          int type_id: @type ref,
          varchar(900) name: string ref,
          int location: @location_default ref);
var_def(unique int id: @var_decl ref);
var_decl_specifiers(int id: @var_decl ref,
                    varchar(900) name: string ref)

type_decls(unique int id: @type_decl,
           int type_id: @type ref,
           int location: @location_default ref);
type_def(unique int id: @type_decl ref);
type_decl_specifiers(int id: @type_decl ref,
                    varchar(900) name: string ref)

namespace_decls(unique int id: @namespace_decl,
                int namespace_id: @namespace ref,
                int location: @location_default ref,
                int bodylocation: @location_default ref);

usings(unique int id: @using,
       int element_id: @element ref,
       int container: @element ref,
       int location: @location_default ref);

// each function has an ordered list of parameters 
params(unique int id: @parameter,
           int function: @functionorblock ref,
           int index: int ref,
           int type_id: @type ref);

overrides(int new: @function ref, int old: @function ref);

membervariables(unique int id: @membervariable,
          int type_id: @type ref,
          varchar(900) name: string ref);
          
properties(unique int id: @property,
           int type_id: @type ref,
           varchar(900) name: string ref,
           int getter: @function ref);
           
property_setter(int prop: @property ref, int setter: @function ref);
property_synthesis(int prop: @property ref, int ivar: @membervariable ref);
property_attribute(int prop: @property ref, int attr: @attribute ref);
property_decl_location(int prop: @property ref, int loc: @location_default ref);

globalvariables(unique int id: @globalvariable,
          int type_id: @type ref,
          varchar(900) name: string ref);

localvariables(unique int id: @localvariable,
          int type_id: @type ref,
          varchar(900) name: string ref);

autoderivation(unique int var: @variable ref,
               int derivation_type: @type ref);
          
enumconstants(unique int id: @enumconstant,
          int parent: @usertype ref,
          int index: int ref,
          int type_id: @type ref,
          varchar(900) name: string ref,
          int location: @location_default ref);

@variable = @localvariable | @globalvariable | @membervariable | @parameter;


/*
  Built-in types are the fundamental types, i.e., integral, floating, and void.
  kind(1) = error, kind(2) = unknown, kind(3) = void, kind(4) = boolean, 
  kind(5) = char, kind(6) = unsigned char, kind(7) = signed char
  kind(8) = short, kind(9) = unsigned short, kind(10) = signed short
  kind(11) = int, kind(12) = unsigned int, kind(13) = signed int,
  kind(14) = long, kind(15) = unsigned long, kind(16) = signed long,
  kind(17) = long long, kind(18) = unsigned long long, kind(19) = signed long long,
  kind(20) = __int8, kind(21) = __int16, kind(22) = __int32, kind(23) = __int64, // Microsoft specific
  kind(24) = float, kind(25) = double, kind(26) = long double, 
  kind(27) = _Complex float, kind(28) = _Complex double, kind(29) = _Complex long double, //C99 specific
  kind(30) = _Imaginary float, kind(31) = _Imaginary double, kind(32) = _Imaginary long double, //C99 specific
  kind(33) = wchar_t, // MS specific
  kind(34) = decltype(nullptr), // C++11
*/
builtintypes(unique int id: @builtintype,
             varchar(900) name: string ref,
             int kind: int ref,
             int size: int ref,
             int sign: int ref);

pointersize(unique int size: int ref);

/*
  Derived types are types that are directly derived from existing types and
  point to, refer to, transform type data to return a new type.

  case @derivedtype.kind of
    1 = pointer
  | 2 = reference
  | 3 = type_with_specifiers
  | 4 = array
  | 5 = gnu_vector
  | 6 = routineptr
  | 7 = routinereference
  | 8 = rvalue_reference // C++11
  | 9 = type_conforming_to_protocols // ObjC
  | 10 = block
  ;
*/
derivedtypes(unique int id: @derivedtype,
             varchar(900) name: string ref,
             int kind: int ref,
             int type_id: @type ref);

arraysizes(unique int id: @derivedtype ref,
           int num_elements: int ref,
           int bytesize: int ref,
           int alignment: int ref);

typedefbase(unique int id: @usertype ref,
            int type_id: @type ref);

decltypes(unique int id: @decltype,
          int expr: @expr ref,
          int base_type: @type ref,
          boolean parentheses_would_change_meaning: boolean ref);

/*
  case @usertype.kind of
    1 = struct
  | 2 = class
  | 3 = union
  | 4 = enum
  | 5 = typedef
  | 6 = template
  | 7 = template_parameter
  | 8 = template_template_parameter
  | 9 = proxy_class                   // a proxy class associated with a template parameter
  | 10 = objc_class
  | 11 = objc_protocol
  | 12 = objc_category
  ;
*/
usertypes(unique int id: @usertype,
      varchar(900) name: string ref,
      int kind: int ref);

usertypesize(unique int id: @usertype ref,
             int size: int ref,
             int alignment: int ref);

usertype_final(unique int id: @usertype ref);

is_class_template(unique int id: @usertype ref);
class_instantiation(unique int to: @usertype ref,
                    int from: @usertype ref);
class_template_argument(int type_id: @usertype ref,
                    int index: int ref,
                    int arg_type: @type ref);

is_proxy_class_for(unique int id: @usertype ref,
                   unique int templ_param_id: @usertype ref);

is_function_template(unique int id: @function ref);
function_instantiation(unique int to: @function ref,
                    int from: @function ref);
function_template_argument(int function_id: @function ref,
                    int index: int ref,
                    int arg_type: @type ref);
                   
/*
  Fixed point types
  precision(1) = short, precision(2) = default, precision(3) = long
  is_unsigned(1) = unsigned is_unsigned(2) = signed
  is_fract_type(1) = declared with _Fract
  saturating(1) = declared with _Sat
*/
/* TODO
fixedpointtypes(unique int id: @fixedpointtype,
                int precision: int ref,
                int is_unsigned: int ref,
                int is_fract_type: int ref,
                int saturating: int ref);
*/
                
routinetypes(unique int id: @routinetype,
             int return_type: @type ref);

routinetypeargs(int routine: @routinetype ref,
                int index: int ref,
                int type_id: @type ref);

ptrtomembers(unique int id: @ptrtomember,
             int type_id: @type ref,
             int class_id: @type ref);

/*
 specifiers for types, functions, and variables

    "public",
    "protected",
    "private",

    "const",
	"volatile",
	"static",

    "pure",
    "virtual",
    "sealed", // Microsoft
    "__interface", // Microsoft
    "inline",
    "explicit",

    "near", // near far extension 
    "far", // near far extension
    "__ptr32", // Microsoft
    "__ptr64", // Microsoft
    "__sptr", // Microsoft
    "__uptr", // Microsoft
    "dllimport", // Microsoft
    "dllexport", // Microsoft
    "thread", // Microsoft
    "naked", // Microsoft
    "microsoft_inline", // Microsoft
    "forceinline", // Microsoft
    "selectany", // Microsoft
    "nothrow", // Microsoft
    "novtable", // Microsoft
    "noreturn", // Microsoft
    "noinline", // Microsoft
    "noalias", // Microsoft
    "restrict", // Microsoft
*/

/* REMOVE
typerefs(unique int id: @typeref,
         int type_id: @type ref);
*/

specifiers(unique int id: @specifier,
           unique varchar(900) str: string ref);
           
typespecifiers(int type_id: @type ref,
               int spec_id: @specifier ref);

/* REMOVE
typerefspecs(int type_ref_id: @typeref ref,
               int spec_id: @specifier ref);
*/

funspecifiers(int func_id: @function ref,
               int spec_id: @specifier ref);

varspecifiers(int var_id: @accessible ref,
               int spec_id: @specifier ref);

@specifiable = /* REMOVE @typeref |*/ @type | @function | @variable | @enumconstant | @frienddecl;

attributes(unique int id: @attribute,
          int kind: int ref,
          varchar(100) name: string ref,
          varchar(100) name_space: string ref,
          int location: @location_default ref);
          
case @attribute.kind of
  0 = @gnuattribute
| 1 = @stdattribute
| 2 = @declspec
| 3 = @msattribute
| 4 = @alignas
| 5 = @objc_propertyattribute
;

attribute_args(unique int id: @attribute_arg,
               int kind: int ref,
               int attribute: @attribute ref,
               int index: int ref,
               int location: @location_default ref);
               
case @attribute_arg.kind of
  0 = @attribute_arg_empty
| 1 = @attribute_arg_token
| 2 = @attribute_arg_constant
| 3 = @attribute_arg_type
;

attribute_arg_value(unique int arg: @attribute_arg ref, varchar(100) value: string ref);
attribute_arg_type(unique int arg: @attribute_arg ref, int type_id: @type ref);
attribute_arg_name(unique int arg: @attribute_arg ref, varchar(100) name: string ref);

typeattributes(int type_id: @type ref,
               int spec_id: @attribute ref);

funcattributes(int func_id: @function ref,
               int spec_id: @attribute ref);

varattributes(int var_id: @accessible ref,
              int spec_id: @attribute ref);

stmtattributes(int stmt_id: @stmt ref,
               int spec_id: @attribute ref);

@type = @builtintype | @derivedtype | @usertype /* TODO | @fixedpointtype */ | @routinetype | @ptrtomember | @decltype; 
      
member(int parent: @type ref,
       int index: int ref,
       int child: @member ref);

enclosingfunction(unique int child: @usertype ref,
                  int parent: @function ref);

derivations(unique int derivation: @derivation,
            int sub: @type ref,
            int index: int ref,
            int super: @type ref,
            int location: @location_default ref);

derspecifiers(int der_id: @derivation ref,
               int spec_id: @specifier ref);

frienddecls(unique int id: @frienddecl,
            int type_id: @type ref,
            int decl_id: @declaration ref,
            int location: @location_default ref);

conforming_to_protocols(int type_id: @type ref,
                        int protocol: @usertype ref);

@declaredtype =  @usertype ;

@declaration = @function | @declaredtype | @variable | @enumconstant | @frienddecl | @property;

@member = @membervariable | @function | @declaredtype | @enumconstant | @property;

@locatable = @diagnostic | @declaration | @ppd_include | @ppd_define | @macroinvocation /*| @funcall*/ | @xmllocatable | @attribute | @attribute_arg;

@scope = @stmt | @function | @namedscope;
@namedscope = @namespace | @usertype;

@element = @locatable | @file | @folder | @specifier | @type | @expr /* | @typeref */ | @namespace | @initialiser | @stmt | @derivation | @comment | @preprocdirect | @fun_decl | @var_decl | @type_decl | @namespace_decl | @using | @namequalifier | @specialnamequalifyingelement | @externalDefect | @externalMetric;

@exprparent = @element;

comments(unique int id: @comment,
         varchar(900) contents: string ref,
         int location: @location_default ref);

commentbinding(unique int id: @comment ref,
               int element: @element ref);

exprconv(int converted: @expr ref,
         unique int conversion: @expr ref);

compgenerated(unique int id: @element ref);
            

namespaces(unique int id: @namespace,
           varchar(900) name: string ref);

namespacembrs(int parentid: @namespace ref,
             unique int memberid: @namespacembr ref);

@namespacembr = @declaration | @namespace;

exprparents(int expr_id: @expr ref,
            int child_index: int ref,
            int parent_id: @exprparent ref);

/*
case @funbindexpr.kind of
  0 = @normal_call  // a normal call
| 1 = @virtual_call // a virtual call
| 2 = @adl_call     // a call whose target is only found by ADL
;
*/
iscall(unique int caller: @funbindexpr ref, int kind: int ref);

numtemplatearguments(unique int expr_id: @expr ref,
                     int num: int ref);

specialnamequalifyingelements(unique int id: @specialnamequalifyingelement,
                              unique varchar(900) name: string ref);

@namequalifiableelement = @expr | @namequalifier;
@namequalifyingelement = @namespace | @specialnamequalifyingelement | @usertype;

namequalifiers(unique int id: @namequalifier,
               unique int qualifiableelement: @namequalifiableelement ref,
               int qualifyingelement: @namequalifyingelement ref,
               int location: @location_default ref);

varbind(unique int expr: @varbindexpr ref,
        int var: @accessible ref);

funbind(unique int expr: @funbindexpr ref,
          int fun: @function ref);

// the second field is a string representation of the value
// the third field is the actual text in the source or the same as the second field
values(unique int id: @value,
       varchar(900) str: string ref,
       varchar(900) text: string ref);

valuebind(int val: @value ref,
          unique int expr: @expr ref);

objc_string(int lit: @literal ref);

fieldoffsets(unique int id: @variable ref,
             int byteoffset: int ref,
             int bitoffset: int ref);

bitfield(unique int id: @variable ref,
         int bits: int ref,
         int declared_bits: int ref);

/* REMOVE
varrefbind(int var: @variable ref,
           int expr: @varref ref);
*/

/* REMOVE
funrefbind(int fun: @function ref,
           int expr: @funref ref);
*/

/* TODO
memberprefix(int member: @expr ref,
             int prefix: @expr ref);
*/

/*
   kind(1) = mbrcallexpr
   kind(2) = mbrptrcallexpr
   kind(3) = mbrptrmbrcallexpr
   kind(4) = ptrmbrptrmbrcallexpr
   kind(5) = mbrreadexpr // x.y
   kind(6) = mbrptrreadexpr // p->y
   kind(7) = mbrptrmbrreadexpr // x.*pm
   kind(8) = mbrptrmbrptrreadexpr // x->*pm
   kind(9) = staticmbrreadexpr // static x.y
   kind(10) = staticmbrptrreadexpr // static p->y
*/
/* TODO
memberaccess(int member: @expr ref,
             int kind: int ref);
*/

initialisers(unique int init: @initialiser,
             int var: @accessible ref,
             unique int expr: @expr ref,
             int location: @location_expr ref);

exprcontainers(int exp: @expr ref,
             int container: @exprcontainer ref);

@exprcontainer = @function | @variable | @enumconstant | @usertype;

exprs(unique int id: @expr,
            int kind: int ref,
            int typeid: @type ref,
            int location: @location_expr ref);

case @expr.kind of
    1 = @errorexpr
|   2 = @address_of // & AddressOfExpr
|   3 = @reference_to // ReferenceToExpr (implicit?) 
|   4 = @indirect // * PointerDereferenceExpr
|   5 = @ref_indirect // ReferenceDereferenceExpr (implicit?)
// ...
|   8 = @array_to_pointer // (???)
|   9 = @vacuous_destructor_call // VacuousDestructorCall
// ...
|  11 = @assume // Microsoft 
|  12 = @parexpr
|  13 = @arithnegexpr
|  14 = @unaryplusexpr
|  15 = @complementexpr
|  16 = @notexpr
|  17 = @conjugation // GNU ~ operator
|  18 = @realpartexpr // GNU __real
|  19 = @imagpartexpr // GNU __imag
|  20 = @postincrexpr
|  21 = @postdecrexpr
|  22 = @preincrexpr
|  23 = @predecrexpr
|  24 = @conditionalexpr
|  25 = @addexpr
|  26 = @subexpr
|  27 = @mulexpr
|  28 = @divexpr
|  29 = @remexpr
|  30 = @jmulexpr // C99 mul imaginary
|  31 = @jdivexpr // C99 div imaginary
|  32 = @fjaddexpr // C99 add real + imaginary
|  33 = @jfaddexpr // C99 add imaginary + real
|  34 = @fjsubexpr // C99 sub real - imaginary
|  35 = @jfsubexpr // C99 sub imaginary - real
|  36 = @paddexpr // pointer add (pointer + int or int + pointer)
|  37 = @psubexpr // pointer sub (pointer - integer)
|  38 = @pdiffexpr // difference between two pointers
|  39 = @lshiftexpr
|  40 = @rshiftexpr
|  41 = @andexpr
|  42 = @orexpr
|  43 = @xorexpr
|  44 = @eqexpr
|  45 = @neexpr
|  46 = @gtexpr
|  47 = @ltexpr
|  48 = @geexpr
|  49 = @leexpr
|  50 = @minexpr // GNU minimum
|  51 = @maxexpr // GNU maximum
|  52 = @assignexpr
|  53 = @assignaddexpr
|  54 = @assignsubexpr
|  55 = @assignmulexpr
|  56 = @assigndivexpr
|  57 = @assignremexpr
|  58 = @assignlshiftexpr
|  59 = @assignrshiftexpr
|  60 = @assignandexpr
|  61 = @assignorexpr
|  62 = @assignxorexpr
|  63 = @assignpaddexpr // assign pointer add
|  64 = @assignpsubexpr // assign pointer sub
|  65 = @andlogicalexpr
|  66 = @orlogicalexpr
|  67 = @commaexpr
|  68 = @subscriptexpr // access to member of an array, e.g., a[5]
|  69 = @objc_subscriptexpr // ObjC custom subscripting
// ...
|  73 = @virtfunptrexpr
|  74 = @callexpr
|  75 = @msgexpr_normal // Objective C
|  76 = @msgexpr_super  // Objective C
|  77 = @atselectorexpr  // Objective C
|  78 = @atprotocolexpr  // Objective C
|  79 = @vastartexpr
|  80 = @vaargexpr
|  81 = @vaendexpr
|  82 = @vacopyexpr
|  83 = @atencodeexpr  // Objective C
|  84 = @varaccess
|  85 = @thisaccess
|  86 = @objc_box_expr // Objective C
|  87 = @new_expr
|  88 = @delete_expr
|  89 = @throw_expr
|  90 = @condition_decl // a variable declared in a condition, e.g., if(int x = y > 2)
// ...
|  92 = @type_id
|  93 = @runtime_sizeof
|  94 = @runtime_alignof
// ...
|  96 = @expr_stmt // GNU extension
|  97 = @routineexpr
|  98 = @type_operand // used to access a type in certain contexts (haven't found any examples yet....)
|  99 = @offsetofexpr // offsetof ::= type and field
| 100 = @hasassignexpr // __has_assign ::= type
| 101 = @hascopyexpr // __has_copy ::= type
| 102 = @hasnothrowassign // __has_nothrow_assign ::= type
| 103 = @hasnothrowconstr // __has_nothrow_constructor ::= type
| 104 = @hasnothrowcopy // __has_nothrow_copy ::= type
| 105 = @hastrivialassign // __has_trivial_assign ::= type
| 106 = @hastrivialconstr // __has_trivial_constructor ::= type
| 107 = @hastrivialcopy // __has_trivial_copy ::= type
| 108 = @hasuserdestr // __has_user_destructor ::= type
| 109 = @hasvirtualdestr // __has_virtual_desctructor ::= type
| 110 = @isabstractexpr // __is_abstract ::= type
| 111 = @isbaseofexpr // __is_base_of ::= type type
| 112 = @isclassexpr // __is_class ::= type
| 113 = @isconvtoexpr // __is_convertible_to ::= type type
| 114 = @isemptyexpr // __is_empty ::= type
| 115 = @isenumexpr // __is_enum ::= type
| 116 = @ispodexpr // __is_pod ::= type
| 117 = @ispolyexpr // __is_polymorphic ::= type
| 118 = @isunionexpr // __is_union ::= type
| 119 = @typescompexpr // GNU __builtin_types_compatible ::= type type
| 120 = @intaddrexpr // EDG internal builtin, used to implement offsetof
// ...
| 122 = @hastrivialdestructor // __has_trivial_destructor ::= type
| 123 = @literal
| 127 = @aggregateliteral
| 128 = @delete_array_expr
| 129 = @new_array_expr
| 130 = @objc_array_literal
| 131 = @objc_dictionary_literal
// ...
| 200 = @ctordirectinit
| 201 = @ctorvirtualinit
| 202 = @ctorfieldinit
| 203 = @ctordelegatinginit
| 204 = @dtordirectdestruct
| 205 = @dtorvirtualdestruct
| 206 = @dtorfielddestruct
// ...
| 210 = @static_cast
| 211 = @reinterpret_cast
| 212 = @const_cast
| 213 = @dynamic_cast
| 214 = @c_style_cast
| 215 = @lambdaexpr
| 216 = @param_ref
| 217 = @noopexpr
// ...
| 294 = @istriviallyconstructibleexpr
| 295 = @isdestructibleexpr
| 296 = @isnothrowdestructibleexpr
| 297 = @istriviallydestructibleexpr
| 298 = @istriviallyassignableexpr
| 299 = @isnothrowassignableexpr
| 300 = @istrivialexpr
| 301 = @isstandardlayoutexpr
| 302 = @istriviallycopyableexpr
| 303 = @isliteraltypeexpr
| 304 = @hastrivialmoveconstructorexpr
| 305 = @hastrivialmoveassignexpr
| 306 = @hasnothrowmoveassignexpr
| 307 = @isconstructibleexpr
| 308 = @isnothrowconstructibleexpr
| 309 = @hasfinalizerexpr
| 310 = @isdelegateexpr
| 311 = @isinterfaceclassexpr
| 312 = @isrefarrayexpr
| 313 = @isrefclassexpr
| 314 = @issealedexpr
| 315 = @issimplevalueclassexpr
| 316 = @isvalueclassexpr
| 317 = @isfinalexpr
| 319 = @noexceptexpr
;

@ctorinit = @ctordirectinit | @ctorvirtualinit | @ctorfieldinit | @ctordelegatinginit;
@dtordestruct = @dtordirectdestruct | @dtorvirtualdestruct | @dtorfielddestruct;

@msgexpr = @msgexpr_normal | @msgexpr_super;
msgexpr_selector(unique int expr: @msgexpr ref, varchar(64) selector : string ref);
msgexpr_receiver_type(unique int expr: @msgexpr_normal ref, int receiver : @type ref);
msgexpr_for_property(unique int expr: @msgexpr_normal ref);

atselectorexpr_selector(unique int expr: @atselectorexpr ref, varchar(64) selector : string ref);

atprotocolexpr_protocol(unique int expr: @atprotocolexpr ref, int protocol : @usertype ref);

atencodeexpr_type(unique int expr: @atencodeexpr ref, int the_type : @type ref);

condition_decl_bind(unique int expr: @condition_decl ref,
               unique int decl: @declaration ref);

typeid_bind(unique int expr: @type_id ref,
               int type_id: @type ref);

@runtime_sizeof_or_alignof = @runtime_sizeof | @runtime_alignof;

sizeof_bind(unique int expr: @runtime_sizeof_or_alignof ref,
            int type_id: @type ref);

code_block(unique int block: @literal ref,
           unique int routine: @function ref);

lambdas(unique int expr: @lambdaexpr ref,
        varchar(1) default_capture: string ref,
        boolean has_explicit_return_type: boolean ref);
        
lambda_capture(unique int id: @lambdacapture,
               int lambda: @lambdaexpr ref,
               int index: int ref,
               boolean captured_by_reference: boolean ref,
               boolean is_implicit: boolean ref,
               int location: @location_default ref);

@funbindexpr = @routineexpr | @new_expr | @delete_expr | @delete_array_expr | @ctordirectinit | @ctorvirtualinit | @ctordelegatinginit | @dtordirectdestruct | @dtorvirtualdestruct | @msgexpr;

@varbindexpr = @varaccess | @ctorfieldinit | @dtorfielddestruct;
@addressable = @function | @variable ;
@accessible = @addressable | @enumconstant ;
@callable = @function | @variable; // only for variables with routine types


stmts(unique int id: @stmt,
            int kind: int ref,
            int location: @location_stmt ref);

case @stmt.kind of
    1 = @stmt_expr
|   2 = @stmt_if
|   3 = @stmt_while
|   4 = @stmt_goto
|   5 = @stmt_label
|   6 = @stmt_return
|   7 = @stmt_block
|   8 = @stmt_end_test_while // do { ... } while ( ... )
|   9 = @stmt_for
|  10 = @stmt_switch_case
|  11 = @stmt_switch
|  13 = @stmt_asm // "asm" statement or the body of an asm function
|  15 = @stmt_try_block
|  16 = @stmt_microsoft_try // Microsoft
|  17 = @stmt_decl
|  18 = @stmt_set_vla_size // C99
|  19 = @stmt_vla_decl // C99
|  25 = @stmt_assigned_goto // GNU
|  26 = @stmt_empty
|  27 = @stmt_continue
|  28 = @stmt_break
|  29 = @stmt_range_based_for // C++11
|  30 = @stmt_at_autoreleasepool_block // Objective C
|  31 = @stmt_objc_for_in // Objective C
|  32 = @stmt_at_synchronized // Objective C
;

objc_for_in(unique int loop: @stmt_objc_for_in ref,
            int collection: @expr ref,
            int condition: @expr ref,
            int body: @stmt ref);

@stmtparent = @stmt | @expr_stmt ;
stmtparents(unique int id: @stmt ref,
           int index: int ref,
           int parent: @stmtparent ref);

ishandler(unique int block: @stmt_block ref);
isfinally(unique int block: @stmt_block ref);

is_objc_try_stmt(unique int try: @stmt ref);
is_objc_throw(unique int throw: @throw_expr ref);
           
@cfgnode = @stmt | @expr | @function | @initialiser ;      
successors(int from: @cfgnode ref,
           int to: @cfgnode ref);

truecond(unique int from: @cfgnode ref,
         int to: @cfgnode ref);

falsecond(unique int from: @cfgnode ref,
          int to: @cfgnode ref);

stmtfunction(unique int stmt: @stmt ref,
             int fun: @function ref);

stmt_decl_bind(int stmt: @stmt_decl ref,
               int decl: @declaration ref);

@functionorblock = @function | @stmt_block;

blockscope(int block: @stmt_block ref,
            int enclosing: @functionorblock ref);

@jump = @stmt_goto | @stmt_break | @stmt_continue;

@jumporlabel = @jump | @stmt_label | @literal;

jumpinfo(unique int id: @jumporlabel ref,
         varchar(900) str: string ref,
         int target: @stmt ref);

preprocdirects(unique int id: @preprocdirect,
               int kind: int ref,
               int location: @location_default ref);
case @preprocdirect.kind of
   0 = @ppd_if
|  1 = @ppd_ifdef
|  2 = @ppd_ifndef
|  3 = @ppd_elif
|  4 = @ppd_else
|  5 = @ppd_endif
|  6 = @ppd_plain_include
|  7 = @ppd_define
|  8 = @ppd_undef
|  9 = @ppd_line
| 10 = @ppd_error
| 11 = @ppd_pragma
| 12 = @ppd_objc_import
| 13 = @ppd_include_next
| 18 = @ppd_warning
;

@ppd_include = @ppd_plain_include | @ppd_objc_import | @ppd_include_next;

@ppd_branch = @ppd_if | @ppd_ifdef | @ppd_ifndef | @ppd_elif;

preprocpair(int begin : @ppd_branch ref,
            int end : @ppd_endif ref);
            
preproctrue(int branch : @ppd_branch ref);
preprocfalse(int branch : @ppd_branch ref);

preproctext(unique int id: @preprocdirect ref,
       varchar(900) head: string ref,
       varchar(900) body: string ref);

includes(unique int id: @ppd_include ref,
         int included: @file ref);

/* Definitions and uses */

#computed
definitionUsePair(
	int var : @variable ref,
	int def : @cfgnode ref,
	int use : @expr ref);

#computed
definitionReaches(
	int def : @cfgnode ref,
	int node : @cfgnode ref);

#computed
useUsePair(
	int v : @variable ref,
	int first : @expr ref,
	int second : @expr ref);

#computed
directUseUsePair(
	int v : @variable ref,
	int first : @expr ref,
	int second : @expr ref);

/* Nullness information */

#computed
nullCheckExpr(
	int e : @expr ref,
	int var : @variable ref);

#computed
validCheckExpr(
	int e : @expr ref,
	int var : @variable ref);

#computed
checkedNull(
	int var : @variable ref,
	int node : @cfgnode ref);

#computed
checkedValid(
	int var : @variable ref,
	int node : @cfgnode ref);
	
/* compilation dependencies taking #include directives into account */
	
#computed
fileDepends(
	int src : @file ref,
	int tgt : @file ref);

/* XML Files */ 

xmlEncoding  (unique int id: @file ref, varchar(900) encoding: string ref);

xmlDTDs       (unique int id: @xmldtd, 
              varchar(900) root: string ref, 
              varchar(900) publicId: string ref, 
              varchar(900) systemId: string ref,
              int fileid: @file ref); 
             
xmlElements   (unique int id: @xmlelement, 
              varchar(900) name: string ref, 
              int parentid: @xmlparent ref,
              int idx: int ref,
              int fileid: @file ref);            

xmlAttrs      (unique int id: @xmlattribute, 
              int elementid: @xmlelement ref,
              varchar(900) name: string ref, 
              varchar(3600) value: string ref,
              int idx: int ref,
              int fileid: @file ref);

xmlNs         (int id: @xmlnamespace, 
              varchar(900) prefixName: string ref,
              varchar(900) URI: string ref,
              int fileid: @file ref);  
               
xmlHasNs      (int elementId: @xmlnamespaceable ref, 
              int nsId: @xmlnamespace ref,
              int fileid: @file ref);  

xmlComments   (unique int id: @xmlcomment, 
              varchar(3600) text: string ref, 
              int parentid: @xmlparent ref,
              int fileid: @file ref); 
               
xmlChars      (unique int id: @xmlcharacters, 
              varchar(3600) text: string ref, 
              int parentid: @xmlparent ref,
              int idx: int ref,
              int isCDATA: int ref,
              int fileid: @file ref);  
	           	
@xmlparent = @file | @xmlelement;
@xmlnamespaceable = @xmlelement | @xmlattribute;

xmllocations(int xmlElement: @xmllocatable ref,
			int location: @location_default ref);

@xmllocatable = @xmlcharacters | @xmlelement | @xmlcomment | @xmlattribute | @xmldtd | @file | @xmlnamespace;
