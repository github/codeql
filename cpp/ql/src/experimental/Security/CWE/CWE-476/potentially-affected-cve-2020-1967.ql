/**
 * @name Potentially affected by CVE-2020-1967
 * @description Detecting if the code is potentially vulnerable to CVE-2020-1967. 
 * For more details please visit https://www.openssl.org/news/secadv/20200421.txt.
 * @kind problem
 * @problem.severity warning
 * @precision low
 * @id cpp/openssl/potentially-affected-cve-2020-1967
 * @tags security
 * 		external/CVE-2020-1967
 */

import cpp
import semmle.code.cpp.dataflow.DataFlow

/**
 * Determine if the OpenSSL version being compiled with is 1.1.1
 * NOTE: The OpenSSL version used at run time may be a different one.
 * This bug is only present in a very recent version of OpenSSL, and adding this check helps reduce false positives.
 */
predicate isCompiledUsingOpenSSLv1_1_1() {
	exists( Macro m |
		m.getName() = "OPENSSL_VERSION_TEXT" |
		m.getBody().regexpMatch(".*1[.]1[.]1[def].*")
	)
}

/**
 * OpenSSL SSL_CTX_new function, which creates a new SSL_CTX object as framework to establish TLS/SSL enabled connections.
 */
class FunctionToOpenSSLSSL_CTX_new extends Function {
	FunctionToOpenSSLSSL_CTX_new() {
		this.getQualifiedName() = "SSL_CTX_new" and
		this.getLocation().getFile().toString().matches("%openssl/ssl.h")
	}
}

/**
 * A function call to OpenSSL SSL_check_chain.
 */
class FunctionCallToOpenSSL_SSL_check_chain extends FunctionCall {
	FunctionCallToOpenSSL_SSL_check_chain() {
		exists( Function f |
			this = f.getACallToThisFunction() |
			f.getQualifiedName() = "SSL_check_chain" and
			f.getLocation().getFile().toString().matches("%openssl/tls1.h")
		)
	}
}

/**
 * 
 * These are the general-purpose version-flexible SSL/TLS methods, which can be used to negotiate TLSv1.3 and
 * the methods will only understand the TLSv1.3 protocol.
 */
class FunctionToOpenSSL_negotiate_TLS_v1_3_method extends Function {
	FunctionToOpenSSL_negotiate_TLS_v1_3_method() {
		( 
		  this.getQualifiedName() = "TLS_client_method" or
		  this.getQualifiedName() = "TLS_server_method" or
		  this.getQualifiedName() = "TLS_method" 
		) and
		this.getLocation().getFile().toString().matches("%openssl/ssl.h")
	}
}

/**
 * a generic TLS protocol value Flows to the first argument of the context constructor
 */
class SSLCTXnewFromTLSConfig extends DataFlow::Configuration {
	SSLCTXnewFromTLSConfig() {
		this = "SslContextCallTlsProtocolConfig"
	}
  
	override predicate isSource(DataFlow::Node source) {
		exists( FunctionToOpenSSL_negotiate_TLS_v1_3_method f |
			f.getACallToThisFunction() = source.asExpr() 
		)
	}
	
	override predicate isSink(DataFlow::Node sink) {
		exists( Expr e, FunctionToOpenSSLSSL_CTX_new f, FunctionCall fc |
			e = sink.asExpr() |
			fc = f.getACallToThisFunction() and
			fc.getArgument(0) = e
		)
	  }
}

predicate isInitializingTlsLatest( FunctionCall fcTlsMethod, FunctionCall fcContextNew ) {
	exists( SSLCTXnewFromTLSConfig config, DataFlow::Node source, DataFlow::Node sink |
		source.asExpr() = fcTlsMethod |
		config.hasFlow(source, sink) and
			exists( FunctionToOpenSSLSSL_CTX_new f |
				fcContextNew = f.getACallToThisFunction() |
		 		fcContextNew.getArgument(0) = sink.asExpr()
		 	)
 	   )
}

from FunctionCallToOpenSSL_SSL_check_chain sccf, FunctionCall tlsctxinitfc, FunctionCall tlsmethodfc 
where isCompiledUsingOpenSSLv1_1_1() and
	  isInitializingTlsLatest( tlsmethodfc, tlsctxinitfc  ) 
select sccf, "Please verify whether you are affected by CVE-2020-1967. It seems like your code was compiled with OpenSSL 1.1.1,you seem to potentially be enabling TLS by a $@ that flows into a $@, and there is a $@. For more details please visit https://www.openssl.org/news/secadv/20200421.txt ." 
	, tlsmethodfc, tlsmethodfc.toString()    
	, tlsctxinitfc, tlsctxinitfc.toString() 
	, sccf, sccf.toString()
