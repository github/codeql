/**
 * @name Uncontrolled data used in Emscripten run script commands
 * @description Using user-supplied data in Emscripten run script
 *              commands, without proper sanitization, can make code
 *              vulnerable to JavaScript code injection.
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id cpp/emscripten/run-script-injection
 * @tags security
 *       experimental
 *       external/cwe/cwe-094
 */

import cpp
import semmle.code.cpp.dataflow.new.TaintTracking
import DataFlow::PathGraph

class EmscriptenRunScriptTaintConfig extends TaintTracking::Configuration {
  EmscriptenRunScriptTaintConfig() { this = "EmscriptenRunScriptTaintConfig" }

  override predicate isSource(DataFlow::Node source) {
    exists(Parameter p | source.asParameter() = p)
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall fc |
      sink.asExpr() = fc.getArgument(0) and
      (
        fc.getTarget().hasGlobalName("emscripten_run_script") or
        fc.getTarget().hasGlobalName("emscripten_run_script_int") or
        fc.getTarget().hasGlobalName("emscripten_run_script_string") or
        fc.getTarget().hasGlobalName("emscripten_async_run_script") or
        fc.getTarget().hasGlobalName("emscripten_async_load_script")
      ) and
      not sink.asExpr().isConstant()
    )
  }

  override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) {
    exists(FunctionCall fc |
      fc.getTarget().hasGlobalName("TextFormat") and
      fc.getArgument(1) = fromNode.asExpr() and
      fc.getEnclosingFunction() = fromNode.getEnclosingCallable() and
      fc = toNode.asExpr()
    )
  }
}

from EmscriptenRunScriptTaintConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink.getNode(), source, sink,
  "The argument to an Emscripten run script command " + sink +
    "is derived from a function parameter " + source + "."
