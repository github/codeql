<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>
  <overview>
    <p>
      Accessing files using paths constructed from user-controlled data can allow an attacker to access
      unexpected resources. This can result in sensitive information being revealed or deleted, or an
      attacker being able to influence behavior by modifying unexpected files.
    </p>
  </overview>

  <recommendation>
    <p>
      Validate user input before using it to construct a file path, either using an off-the-shelf library
      like the <code>sanitize-filename</code> npm package, or by performing custom validation.
    </p>

    <p>
      Ideally, follow these rules:
    </p>

    <ul>
      <li>Do not allow more than a single "." character.</li>
      <li>Do not allow directory separators such as "/" or "\" (depending on the file system).</li>
      <li>Do not rely on simply replacing problematic sequences such as "../". For example, after
      replacing this in the string ".../...//", the result "../" would be returned.</li>
      <li>Use an allowlist of known good patterns.</li>
    </ul>

    <p>On windows, beware of some pitfalls:</p>
    <ul>
      <li>The <code>path</code> library accepts the forward slash as path separator.</li>
      <li>The <code>path.relative</code> method may return an absolute path, eg.:
      <code>path.relative("foo", "C:\\baz")</code> returns <code>"C:\\baz"</code>.</li>
      <li>
        The <code>path.join</code> method sometimes returns an absolute path, even
        when the first input is relative, eg.: <code>path.join("foo\\..", "C:\\foo")</code> will
        return <code>"C:\\foo"</code>, which is absolute.
      </li>
      <li>
        The <code>path.isAbsolute</code> method returns <code>true</code> for some paths
        that are relative, even if <code>path.resolve</code> treats them as absolute. Eg.:
        <code>path.isAbsolute("C:../../foo")</code> returns <code>true</code>.
      </li>
    </ul>
  </recommendation>


  <example>
    <p>
      In the first example, a file name is read from an HTTP request and then used to access a file.
      However, a malicious user could enter a file name which is an absolute path, such as
      <code>"/etc/passwd"</code>.
    </p>

    <p>
      In the second example, it appears that the user is restricted to opening a file within the
      <code>"user"</code> home directory. However, a malicious user could enter a file name containing
      special characters. For example, the string <code>"../../etc/passwd"</code> will result in the code
      reading the file located at <code>"/home/user/../../etc/passwd"</code>, which is the system's
      password file. This file would then be sent back to the user, giving them access to all the
      system's passwords.
    </p>

    <sample src="examples/TaintedPath.js" />
  </example>

  <references>
    <li>OWASP: <a href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a>.</li>
    <li>npm: <a href="https://www.npmjs.com/package/sanitize-filename">sanitize-filename</a> package.</li>
  </references>
</qhelp>
