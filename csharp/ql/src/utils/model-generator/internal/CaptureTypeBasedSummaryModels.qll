private import csharp
private import dotnet
private import semmle.code.csharp.frameworks.system.collections.Generic as GenericCollections
private import semmle.code.csharp.dataflow.internal.DataFlowPrivate
private import semmle.code.csharp.frameworks.system.linq.Expressions
private import CaptureModelsSpecific as Specific
private import CaptureModels

/**
 * Holds if `t` is a subtype (reflexive/transitive) of `IEnumerable<T>`, where `T` = `tp`.
 */
private predicate genericCollectionType(ValueOrRefType t, TypeParameter tp) {
  exists(ConstructedGeneric t2 |
    t2 = t.getABaseType*() and
    t2.getUnboundDeclaration() instanceof
      GenericCollections::SystemCollectionsGenericIEnumerableTInterface and
    tp = t2.getATypeArgument()
  )
}

/**
 * Holds if `tp` is a type parameter of `generic`.
 */
private predicate unboundGeneric(UnboundGeneric generic, TypeParameter tp) {
  tp = generic.getATypeParameter()
}

/**
 * Holds if `tp` is a type parameter of the immediate type declaring `callable`.
 */
private predicate classTypeParameter(DotNet::Callable callable, TypeParameter tp) {
  unboundGeneric(callable.getDeclaringType(), tp)
}

/**
 * Holds if `tp` is type parameter of `callable` or the type declaring `callable`.
 */
private predicate localTypeParameter(DotNet::Callable callable, TypeParameter tp) {
  classTypeParameter(callable, tp) or unboundGeneric(callable, tp)
}

private predicate constructedGeneric(ConstructedType t, TypeParameter tp) {
  t.getATypeArgument() = tp
}

/**
 * Holds if `callable` has a parameter of type `tp`
 * or collection parameterized over type `tp`.
 */
private predicate parameter(DotNet::Callable callable, string input, TypeParameter tp) {
  exists(Parameter p |
    input = Specific::parameterAccess(p) and
    p = callable.getAParameter() and
    (
      // Parameter of type tp
      p.getType() = tp
      or
      // Parameter is a collection of type tp
      genericCollectionType(p.getType(), tp)
    )
  )
}

/**
 * Gets the string representation of a synthetic field corresponding to `tp`.
 */
private string getSyntheticField(TypeParameter tp) {
  result = ".SyntheticField[ArgType" + tp.getIndex() + "]"
}

/**
 * Gets a models as data string representation of, how a value of type `tp`
 * can be read or stored implicitly in relation to `callable`.
 */
private string implicit(DotNet::Callable callable, TypeParameter tp) {
  classTypeParameter(callable, tp) and
  exists(string access |
    if genericCollectionType(callable.getDeclaringType(), tp)
    then access = ".Element"
    else access = getSyntheticField(tp)
  |
    result = Specific::qualifierString() + access
  )
}

/**
 * Holds if `callable` has a delegate parameter `dt` at parameter position `position`.
 */
private predicate delegate(DotNet::Callable callable, DelegateType dt, int position) {
  exists(Parameter p |
    p = callable.getAParameter() and
    dt = p.getType().(SystemLinqExpressions::DelegateExtType).getDelegateType() and
    position = p.getPosition()
  )
}

/**
 * Gets models as data input/output access relative to the type parameter `tp` in the
 * type `t` in the scope of `callable`.
 *
 * Note: This predicate has to be inlined as `callable` is not related to `return` or `tp`
 * in every disjunction.
 */
pragma[inline]
private string getAccess(DotNet::Callable callable, Type return, TypeParameter tp) {
  return = tp and result = ""
  or
  genericCollectionType(return, tp) and result = ".Element"
  or
  not genericCollectionType(return, tp) and
  (
    constructedGeneric(return, tp)
    or
    callable.getDeclaringType() = return and unboundGeneric(return, tp)
  ) and
  result = getSyntheticField(tp)
}

/**
 * Holds if `input` is a models as data string representation of, how a value of type `tp`
 * (or a generic parameterized over `tp`) can be generated by a delegate parameter of `callable`.
 */
private predicate source(DotNet::Callable callable, string input, TypeParameter tp) {
  exists(DelegateType dt, int position, Type return, string access |
    delegate(callable, dt, position) and
    return = dt.getReturnType() and
    access = getAccess(callable, return, tp) and
    input = "Argument[" + position + "].ReturnValue" + access
  )
}

/**
 * Holds if `input` is a models as data string representation of, how a
 * value of type `tp` (or a generic parameterized over `tp`)
 * can be provided as input to `callable`.
 * This includes
 * (1) The implicit synthetic field(s) of the declaring type of `callable`.
 * (2) The parameters of `callable`.
 * (3) Any delegate parameters of `callable`.
 */
private predicate input(DotNet::Callable callable, string input, TypeParameter tp) {
  input = implicit(callable, tp)
  or
  parameter(callable, input, tp)
  or
  source(callable, input, tp)
}

/**
 * Holds if `callable` returns a value of type `tp` (or a generic parameterized over `tp`) and `output`
 * is a models as data string representation of, how data is routed to the return.
 */
private predicate returns(DotNet::Callable callable, TypeParameter tp, string output) {
  exists(Type return, string access | return = callable.getReturnType() |
    access = getAccess(callable, return, tp) and
    output = "ReturnValue" + access
  )
}

/**
 * Holds if `callable` has a delegate parameter that accepts a value of type `tp`
 * and `output` is the models as data string representation of, how data is routed to
 * the delegate parameter.
 */
private predicate sink(DotNet::Callable callable, TypeParameter tp, string output) {
  exists(DelegateType dt, int position, Type t, Parameter p |
    delegate(callable, dt, position) and
    p = dt.getAParameter() and
    t = p.getType() and
    t = tp and
    output = "Argument[" + position + "]" + ".Parameter[" + p.getPosition() + "]"
  )
}

/**
 * Holds if `output` is a models as data string representation of, how values of type `tp`
 * (or generics parameterized over `tp`) can be routed.
 * This includes
 * (1) The implicit synthetic field(s) of the declaring type of `callable`.
 * (2) The return of `callable`.
 * (3) Any delegate parameters of `callable`.
 */
private predicate output(DotNet::Callable callable, TypeParameter tp, string output) {
  output = implicit(callable, tp)
  or
  returns(callable, tp, output)
  or
  sink(callable, tp, output)
}

/**
 * A class of callables that are relevant generating summaries for based
 * on the Theorems for Free approach.
 */
class TypeBasedFlowTargetApi extends Specific::TargetApiSpecific {
  TypeBasedFlowTargetApi() { Specific::isRelevantForTypeBasedFlowModels(this) }

  /**
   * Gets the string representation of all type based summaries inspired by
   * the Theorems for Free approach.
   *
   * Basic example signatures could be
   * this : T -> \alpha
   * this : \beta -> T
   * where T is type parameter on `this` or on the declaring type of `this`.
   *
   * Important special cases are \alpha = unit (setter),
   * \alpha = T (getter, setter and id) and \beta = unit (getter).
   *
   * Complex example signatures could be
   * this : (T -> S) -> S
   * this : S1 x (S1 -> S2) -> S2
   * where T is type parameter of the class declaring `this` and S, S1 and S2 are type parameters
   * of `this`.
   */
  string getSummaries() {
    exists(TypeParameter tp, string input, string output |
      localTypeParameter(this, tp) and
      input(this, input, tp) and
      output(this, tp, output) and
      input != output
    |
      result = asValueModel(this, input, output)
    )
  }
}

/**
 * Returns the Theorems for Free inspired typed based summaries for `api`.
 */
string captureFlow(TypeBasedFlowTargetApi api) { result = api.getSummaries() }
