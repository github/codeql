private import csharp
private import dotnet
private import semmle.code.csharp.frameworks.system.collections.Generic as GenericCollections
private import semmle.code.csharp.dataflow.internal.DataFlowPrivate
private import semmle.code.csharp.frameworks.system.linq.Expressions
private import semmle.code.csharp.commons.Collections as Collections
private import semmle.code.csharp.dataflow.FlowSummary
private import semmle.code.csharp.dataflow.ExternalFlow

/**
 * Gets the CSV string representation of the qualifier.
 */
private string qualifierString() { result = "Argument[this]" }

private string parameterAccess(Parameter p) {
  if Collections::isCollectionType(p.getType())
  then result = "Argument[" + p.getPosition() + "].Element"
  else result = "Argument[" + p.getPosition() + "]"
}

/**
 * Holds if `t` is a subtype (reflexive/transitive) of `IEnumerable<T>`, where `T` = `tp`.
 */
private predicate genericCollectionType(ValueOrRefType t, TypeParameter tp) {
  exists(ConstructedGeneric t2 |
    t2 = t.getABaseType*() and
    t2.getUnboundDeclaration() instanceof
      GenericCollections::SystemCollectionsGenericIEnumerableTInterface and
    tp = t2.getATypeArgument()
  )
}

/**
 * Holds if `tp` is a type parameter of the immediate type declaring `callable`.
 */
private predicate classTypeParameter(DotNet::Callable callable, TypeParameter tp) {
  callable.getDeclaringType().(UnboundGeneric).getATypeParameter() = tp
}

/**
 * Holds if `tp` is type parameter of `callable` or the type declaring `callable`.
 */
private predicate localTypeParameter(DotNet::Callable callable, TypeParameter tp) {
  classTypeParameter(callable, tp) or callable.(UnboundGeneric).getATypeParameter() = tp
}

private predicate constructedGeneric(ConstructedType t, TypeParameter tp) {
  t.getATypeArgument() = tp
}

/**
 * Holds if `callable` has a parameter of type `tp`
 * or collection parameterized over type `tp`.
 */
private predicate parameter(DotNet::Callable callable, string input, TypeParameter tp) {
  exists(Parameter p |
    input = parameterAccess(p) and
    p = callable.getAParameter() and
    (
      // Parameter of type tp
      p.getType() = tp
      or
      // Parameter is a collection of type tp
      genericCollectionType(p.getType(), tp)
    )
  )
}

/**
 * Gets the string representation of a synthetic field corresponding to `tp`.
 */
private string getSyntheticField(TypeParameter tp) {
  result = ".SyntheticField[ArgType" + tp.getIndex() + "]"
}

/**
 * Gets a models as data string representation of, how a value of type `tp`
 * can be read or stored implicitly in relation to `callable`.
 */
private string implicit(DotNet::Callable callable, TypeParameter tp) {
  classTypeParameter(callable, tp) and
  exists(string access |
    if genericCollectionType(callable.getDeclaringType(), tp)
    then access = ".Element"
    else access = getSyntheticField(tp)
  |
    result = qualifierString() + access
  )
}

/**
 * Holds if `callable` has a delegate parameter `dt` at parameter position `position`.
 */
private predicate delegate(DotNet::Callable callable, DelegateType dt, int position) {
  exists(Parameter p |
    p = callable.getAParameter() and
    dt = p.getType().(SystemLinqExpressions::DelegateExtType).getDelegateType() and
    position = p.getPosition()
  )
}

/**
 * Gets models as data input/output access relative to the type parameter `tp` in the
 * type `t` in the scope of `callable`.
 *
 * Note: This predicate has to be inlined as `callable` is not related to `return` or `tp`
 * in every disjunction.
 */
pragma[inline]
private string getAccess(DotNet::Callable callable, Type return, TypeParameter tp) {
  return = tp and result = ""
  or
  genericCollectionType(return, tp) and result = ".Element"
  or
  not genericCollectionType(return, tp) and
  (
    constructedGeneric(return, tp)
    or
    callable.getDeclaringType() = return and callable.(UnboundGeneric).getATypeParameter() = tp
  ) and
  result = getSyntheticField(tp)
}

/**
 * Holds if `input` is a models as data string representation of, how a value of type `tp`
 * (or a generic parameterized over `tp`) can be generated by a delegate parameter of `callable`.
 */
private predicate source(DotNet::Callable callable, string input, TypeParameter tp) {
  exists(DelegateType dt, int position, Type return, string access |
    delegate(callable, dt, position) and
    return = dt.getReturnType() and
    access = getAccess(callable, return, tp) and
    input = "Argument[" + position + "].ReturnValue" + access
  )
}

/**
 * Holds if `input` is a models as data string representation of, how a
 * value of type `tp` (or a generic parameterized over `tp`)
 * can be provided as input to `callable`.
 * This includes
 * (1) The implicit synthetic field(s) of the declaring type of `callable`.
 * (2) The parameters of `callable`.
 * (3) Any delegate parameters of `callable`.
 */
private predicate input(DotNet::Callable callable, string input, TypeParameter tp) {
  input = implicit(callable, tp)
  or
  parameter(callable, input, tp)
  or
  source(callable, input, tp)
}

/**
 * Holds if `callable` returns a value of type `tp` (or a generic parameterized over `tp`) and `output`
 * is a models as data string representation of, how data is routed to the return.
 */
private predicate returns(DotNet::Callable callable, TypeParameter tp, string output) {
  exists(Type return, string access | return = callable.getReturnType() |
    access = getAccess(callable, return, tp) and
    output = "ReturnValue" + access
  )
}

/**
 * Holds if `callable` has a delegate parameter that accepts a value of type `tp`
 * and `output` is the models as data string representation of, how data is routed to
 * the delegate parameter.
 */
private predicate sink(DotNet::Callable callable, TypeParameter tp, string output) {
  exists(DelegateType dt, int position, Type t, Parameter p |
    delegate(callable, dt, position) and
    p = dt.getAParameter() and
    t = p.getType() and
    t = tp and
    output = "Argument[" + position + "]" + ".Parameter[" + p.getPosition() + "]"
  )
}

/**
 * Holds if `output` is a models as data string representation of, how values of type `tp`
 * (or generics parameterized over `tp`) can be routed.
 * This includes
 * (1) The implicit synthetic field(s) of the declaring type of `callable`.
 * (2) The return of `callable`.
 * (3) Any delegate parameters of `callable`.
 */
private predicate output(DotNet::Callable callable, TypeParameter tp, string output) {
  output = implicit(callable, tp)
  or
  returns(callable, tp, output)
  or
  sink(callable, tp, output)
}

/**
 * Holds if `callable` has type based flow from `input` to `output`.
 *
 * Basic example signatures could be
 * this : T -> \alpha
 * this : \beta -> T
 * where T is type parameter on `this` or on the declaring type of `this`.
 *
 * Important special cases are \alpha = unit (setter),
 * \alpha = T (getter, setter and id) and \beta = unit (getter).
 *
 * Complex example signatures could be
 * this : (T -> S) -> S
 * this : S1 x (S1 -> S2) -> S2
 * where T is type parameter of the class declaring `this` and S, S1 and S2 are type parameters
 * of `this`.
 */
predicate spec(DotNet::Callable callable, string input, string output) {
  exists(TypeParameter tp |
    localTypeParameter(callable, tp) and
    input(callable, input, tp) and
    output(callable, tp, output) and
    input != output
  )
}
