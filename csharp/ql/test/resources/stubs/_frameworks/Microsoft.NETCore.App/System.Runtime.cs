// This file contains auto-generated code.
// Generated from `System.Runtime, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`.

namespace Microsoft
{
    namespace Win32
    {
        namespace SafeHandles
        {
            public abstract class CriticalHandleMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                protected CriticalHandleMinusOneIsInvalid() : base(default(System.IntPtr)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }

            public abstract class CriticalHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                protected CriticalHandleZeroOrMinusOneIsInvalid() : base(default(System.IntPtr)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }

            public class SafeFileHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                public bool IsAsync { get => throw null; }
                public override bool IsInvalid { get => throw null; }
                protected override bool ReleaseHandle() => throw null;
                public SafeFileHandle() : base(default(bool)) => throw null;
                public SafeFileHandle(System.IntPtr preexistingHandle, bool ownsHandle) : base(default(bool)) => throw null;
            }

            public abstract class SafeHandleMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                public override bool IsInvalid { get => throw null; }
                protected SafeHandleMinusOneIsInvalid(bool ownsHandle) : base(default(System.IntPtr), default(bool)) => throw null;
            }

            public abstract class SafeHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                public override bool IsInvalid { get => throw null; }
                protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle) : base(default(System.IntPtr), default(bool)) => throw null;
            }

            public class SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                protected override bool ReleaseHandle() => throw null;
                public SafeWaitHandle() : base(default(bool)) => throw null;
                public SafeWaitHandle(System.IntPtr existingHandle, bool ownsHandle) : base(default(bool)) => throw null;
            }

        }
    }
}
namespace System
{
    public class AccessViolationException : System.SystemException
    {
        public AccessViolationException() => throw null;
        protected AccessViolationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AccessViolationException(string message) => throw null;
        public AccessViolationException(string message, System.Exception innerException) => throw null;
    }

    public delegate void Action();

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);

    public delegate void Action<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);

    public delegate void Action<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);

    public delegate void Action<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);

    public delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);

    public delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);

    public delegate void Action<T1, T2>(T1 arg1, T2 arg2);

    public delegate void Action<T>(T obj);

    public static class Activator
    {
        public static object CreateInstance(System.Type type) => throw null;
        public static object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture) => throw null;
        public static object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static object CreateInstance(System.Type type, object[] args, object[] activationAttributes) => throw null;
        public static object CreateInstance(System.Type type, bool nonPublic) => throw null;
        public static object CreateInstance(System.Type type, params object[] args) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static T CreateInstance<T>() => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
    }

    public class AggregateException : System.Exception
    {
        public AggregateException() => throw null;
        public AggregateException(System.Collections.Generic.IEnumerable<System.Exception> innerExceptions) => throw null;
        protected AggregateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AggregateException(params System.Exception[] innerExceptions) => throw null;
        public AggregateException(string message) => throw null;
        public AggregateException(string message, System.Exception innerException) => throw null;
        public AggregateException(string message, System.Collections.Generic.IEnumerable<System.Exception> innerExceptions) => throw null;
        public AggregateException(string message, params System.Exception[] innerExceptions) => throw null;
        public System.AggregateException Flatten() => throw null;
        public override System.Exception GetBaseException() => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public void Handle(System.Func<System.Exception, bool> predicate) => throw null;
        public System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> InnerExceptions { get => throw null; }
        public override string Message { get => throw null; }
        public override string ToString() => throw null;
    }

    public static class AppContext
    {
        public static string BaseDirectory { get => throw null; }
        public static object GetData(string name) => throw null;
        public static void SetData(string name, object data) => throw null;
        public static void SetSwitch(string switchName, bool isEnabled) => throw null;
        public static string TargetFrameworkName { get => throw null; }
        public static bool TryGetSwitch(string switchName, out bool isEnabled) => throw null;
    }

    public class AppDomain : System.MarshalByRefObject
    {
        public void AppendPrivatePath(string path) => throw null;
        public string ApplyPolicy(string assemblyName) => throw null;
        public event System.AssemblyLoadEventHandler AssemblyLoad;
        public event System.ResolveEventHandler AssemblyResolve;
        public string BaseDirectory { get => throw null; }
        public void ClearPrivatePath() => throw null;
        public void ClearShadowCopyPath() => throw null;
        public static System.AppDomain CreateDomain(string friendlyName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static System.AppDomain CurrentDomain { get => throw null; }
        public event System.EventHandler DomainUnload;
        public string DynamicDirectory { get => throw null; }
        public int ExecuteAssembly(string assemblyFile) => throw null;
        public int ExecuteAssembly(string assemblyFile, string[] args) => throw null;
        public int ExecuteAssembly(string assemblyFile, string[] args, System.Byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) => throw null;
        public int ExecuteAssemblyByName(System.Reflection.AssemblyName assemblyName, params string[] args) => throw null;
        public int ExecuteAssemblyByName(string assemblyName) => throw null;
        public int ExecuteAssemblyByName(string assemblyName, params string[] args) => throw null;
        public event System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
        public string FriendlyName { get => throw null; }
        public System.Reflection.Assembly[] GetAssemblies() => throw null;
        public static int GetCurrentThreadId() => throw null;
        public object GetData(string name) => throw null;
        public int Id { get => throw null; }
        public bool? IsCompatibilitySwitchSet(string value) => throw null;
        public bool IsDefaultAppDomain() => throw null;
        public bool IsFinalizingForUnload() => throw null;
        public bool IsFullyTrusted { get => throw null; }
        public bool IsHomogenous { get => throw null; }
        public System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef) => throw null;
        public System.Reflection.Assembly Load(System.Byte[] rawAssembly) => throw null;
        public System.Reflection.Assembly Load(System.Byte[] rawAssembly, System.Byte[] rawSymbolStore) => throw null;
        public System.Reflection.Assembly Load(string assemblyString) => throw null;
        public static bool MonitoringIsEnabled { get => throw null; set => throw null; }
        public System.Int64 MonitoringSurvivedMemorySize { get => throw null; }
        public static System.Int64 MonitoringSurvivedProcessMemorySize { get => throw null; }
        public System.Int64 MonitoringTotalAllocatedMemorySize { get => throw null; }
        public System.TimeSpan MonitoringTotalProcessorTime { get => throw null; }
        public System.Security.PermissionSet PermissionSet { get => throw null; }
        public event System.EventHandler ProcessExit;
        public event System.ResolveEventHandler ReflectionOnlyAssemblyResolve;
        public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() => throw null;
        public string RelativeSearchPath { get => throw null; }
        public event System.ResolveEventHandler ResourceResolve;
        public void SetCachePath(string path) => throw null;
        public void SetData(string name, object data) => throw null;
        public void SetDynamicBase(string path) => throw null;
        public void SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy policy) => throw null;
        public void SetShadowCopyFiles() => throw null;
        public void SetShadowCopyPath(string path) => throw null;
        public void SetThreadPrincipal(System.Security.Principal.IPrincipal principal) => throw null;
        public System.AppDomainSetup SetupInformation { get => throw null; }
        public bool ShadowCopyFiles { get => throw null; }
        public override string ToString() => throw null;
        public event System.ResolveEventHandler TypeResolve;
        public event System.UnhandledExceptionEventHandler UnhandledException;
        public static void Unload(System.AppDomain domain) => throw null;
    }

    public class AppDomainSetup
    {
        public string ApplicationBase { get => throw null; }
        public string TargetFrameworkName { get => throw null; }
    }

    public class AppDomainUnloadedException : System.SystemException
    {
        public AppDomainUnloadedException() => throw null;
        protected AppDomainUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AppDomainUnloadedException(string message) => throw null;
        public AppDomainUnloadedException(string message, System.Exception innerException) => throw null;
    }

    public class ApplicationException : System.Exception
    {
        public ApplicationException() => throw null;
        protected ApplicationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ApplicationException(string message) => throw null;
        public ApplicationException(string message, System.Exception innerException) => throw null;
    }

    public class ApplicationId
    {
        public ApplicationId(System.Byte[] publicKeyToken, string name, System.Version version, string processorArchitecture, string culture) => throw null;
        public System.ApplicationId Copy() => throw null;
        public string Culture { get => throw null; }
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public string Name { get => throw null; }
        public string ProcessorArchitecture { get => throw null; }
        public System.Byte[] PublicKeyToken { get => throw null; }
        public override string ToString() => throw null;
        public System.Version Version { get => throw null; }
    }

    public struct ArgIterator
    {
        // Stub generator skipped constructor 
        public ArgIterator(System.RuntimeArgumentHandle arglist) => throw null;
        unsafe public ArgIterator(System.RuntimeArgumentHandle arglist, void* ptr) => throw null;
        public void End() => throw null;
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public System.TypedReference GetNextArg() => throw null;
        public System.TypedReference GetNextArg(System.RuntimeTypeHandle rth) => throw null;
        public System.RuntimeTypeHandle GetNextArgType() => throw null;
        public int GetRemainingCount() => throw null;
    }

    public class ArgumentException : System.SystemException
    {
        public ArgumentException() => throw null;
        protected ArgumentException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentException(string message) => throw null;
        public ArgumentException(string message, System.Exception innerException) => throw null;
        public ArgumentException(string message, string paramName) => throw null;
        public ArgumentException(string message, string paramName, System.Exception innerException) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public virtual string ParamName { get => throw null; }
        public static void ThrowIfNullOrEmpty(string argument, string paramName = default(string)) => throw null;
    }

    public class ArgumentNullException : System.ArgumentException
    {
        public ArgumentNullException() => throw null;
        protected ArgumentNullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentNullException(string paramName) => throw null;
        public ArgumentNullException(string message, System.Exception innerException) => throw null;
        public ArgumentNullException(string paramName, string message) => throw null;
        unsafe public static void ThrowIfNull(void* argument, string paramName = default(string)) => throw null;
        public static void ThrowIfNull(object argument, string paramName = default(string)) => throw null;
    }

    public class ArgumentOutOfRangeException : System.ArgumentException
    {
        public virtual object ActualValue { get => throw null; }
        public ArgumentOutOfRangeException() => throw null;
        protected ArgumentOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentOutOfRangeException(string paramName) => throw null;
        public ArgumentOutOfRangeException(string message, System.Exception innerException) => throw null;
        public ArgumentOutOfRangeException(string paramName, object actualValue, string message) => throw null;
        public ArgumentOutOfRangeException(string paramName, string message) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
    }

    public class ArithmeticException : System.SystemException
    {
        public ArithmeticException() => throw null;
        protected ArithmeticException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArithmeticException(string message) => throw null;
        public ArithmeticException(string message, System.Exception innerException) => throw null;
    }

    public abstract class Array : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable
    {
        int System.Collections.IList.Add(object value) => throw null;
        public static System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly<T>(T[] array) => throw null;
        public static int BinarySearch(System.Array array, int index, int length, object value) => throw null;
        public static int BinarySearch(System.Array array, int index, int length, object value, System.Collections.IComparer comparer) => throw null;
        public static int BinarySearch(System.Array array, object value) => throw null;
        public static int BinarySearch(System.Array array, object value, System.Collections.IComparer comparer) => throw null;
        public static int BinarySearch<T>(T[] array, T value) => throw null;
        public static int BinarySearch<T>(T[] array, T value, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static int BinarySearch<T>(T[] array, int index, int length, T value) => throw null;
        public static int BinarySearch<T>(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer) => throw null;
        void System.Collections.IList.Clear() => throw null;
        public static void Clear(System.Array array) => throw null;
        public static void Clear(System.Array array, int index, int length) => throw null;
        public object Clone() => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public static void ConstrainedCopy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) => throw null;
        bool System.Collections.IList.Contains(object value) => throw null;
        public static TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, System.Converter<TInput, TOutput> converter) => throw null;
        public static void Copy(System.Array sourceArray, System.Array destinationArray, int length) => throw null;
        public static void Copy(System.Array sourceArray, System.Array destinationArray, System.Int64 length) => throw null;
        public static void Copy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) => throw null;
        public static void Copy(System.Array sourceArray, System.Int64 sourceIndex, System.Array destinationArray, System.Int64 destinationIndex, System.Int64 length) => throw null;
        public void CopyTo(System.Array array, int index) => throw null;
        public void CopyTo(System.Array array, System.Int64 index) => throw null;
        int System.Collections.ICollection.Count { get => throw null; }
        public static System.Array CreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int length) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int length1, int length2) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int length1, int length2, int length3) => throw null;
        public static System.Array CreateInstance(System.Type elementType, params int[] lengths) => throw null;
        public static System.Array CreateInstance(System.Type elementType, params System.Int64[] lengths) => throw null;
        public static T[] Empty<T>() => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public static bool Exists<T>(T[] array, System.Predicate<T> match) => throw null;
        public static void Fill<T>(T[] array, T value) => throw null;
        public static void Fill<T>(T[] array, T value, int startIndex, int count) => throw null;
        public static T Find<T>(T[] array, System.Predicate<T> match) => throw null;
        public static T[] FindAll<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, int startIndex, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) => throw null;
        public static T FindLast<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, int startIndex, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) => throw null;
        public static void ForEach<T>(T[] array, System.Action<T> action) => throw null;
        public System.Collections.IEnumerator GetEnumerator() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public int GetLength(int dimension) => throw null;
        public System.Int64 GetLongLength(int dimension) => throw null;
        public int GetLowerBound(int dimension) => throw null;
        public int GetUpperBound(int dimension) => throw null;
        public object GetValue(int index) => throw null;
        public object GetValue(int index1, int index2) => throw null;
        public object GetValue(int index1, int index2, int index3) => throw null;
        public object GetValue(System.Int64 index) => throw null;
        public object GetValue(System.Int64 index1, System.Int64 index2) => throw null;
        public object GetValue(System.Int64 index1, System.Int64 index2, System.Int64 index3) => throw null;
        public object GetValue(params int[] indices) => throw null;
        public object GetValue(params System.Int64[] indices) => throw null;
        public static int IndexOf(System.Array array, object value) => throw null;
        public static int IndexOf(System.Array array, object value, int startIndex) => throw null;
        public static int IndexOf(System.Array array, object value, int startIndex, int count) => throw null;
        int System.Collections.IList.IndexOf(object value) => throw null;
        public static int IndexOf<T>(T[] array, T value) => throw null;
        public static int IndexOf<T>(T[] array, T value, int startIndex) => throw null;
        public static int IndexOf<T>(T[] array, T value, int startIndex, int count) => throw null;
        public void Initialize() => throw null;
        void System.Collections.IList.Insert(int index, object value) => throw null;
        public bool IsFixedSize { get => throw null; }
        public bool IsReadOnly { get => throw null; }
        public bool IsSynchronized { get => throw null; }
        object System.Collections.IList.this[int index] { get => throw null; set => throw null; }
        public static int LastIndexOf(System.Array array, object value) => throw null;
        public static int LastIndexOf(System.Array array, object value, int startIndex) => throw null;
        public static int LastIndexOf(System.Array array, object value, int startIndex, int count) => throw null;
        public static int LastIndexOf<T>(T[] array, T value) => throw null;
        public static int LastIndexOf<T>(T[] array, T value, int startIndex) => throw null;
        public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count) => throw null;
        public int Length { get => throw null; }
        public System.Int64 LongLength { get => throw null; }
        public static int MaxLength { get => throw null; }
        public int Rank { get => throw null; }
        void System.Collections.IList.Remove(object value) => throw null;
        void System.Collections.IList.RemoveAt(int index) => throw null;
        public static void Resize<T>(ref T[] array, int newSize) => throw null;
        public static void Reverse(System.Array array) => throw null;
        public static void Reverse(System.Array array, int index, int length) => throw null;
        public static void Reverse<T>(T[] array) => throw null;
        public static void Reverse<T>(T[] array, int index, int length) => throw null;
        public void SetValue(object value, int index) => throw null;
        public void SetValue(object value, int index1, int index2) => throw null;
        public void SetValue(object value, int index1, int index2, int index3) => throw null;
        public void SetValue(object value, System.Int64 index) => throw null;
        public void SetValue(object value, System.Int64 index1, System.Int64 index2) => throw null;
        public void SetValue(object value, System.Int64 index1, System.Int64 index2, System.Int64 index3) => throw null;
        public void SetValue(object value, params int[] indices) => throw null;
        public void SetValue(object value, params System.Int64[] indices) => throw null;
        public static void Sort(System.Array array) => throw null;
        public static void Sort(System.Array keys, System.Array items) => throw null;
        public static void Sort(System.Array keys, System.Array items, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array keys, System.Array items, int index, int length) => throw null;
        public static void Sort(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array array, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array array, int index, int length) => throw null;
        public static void Sort(System.Array array, int index, int length, System.Collections.IComparer comparer) => throw null;
        public static void Sort<T>(T[] array) => throw null;
        public static void Sort<T>(T[] array, System.Comparison<T> comparison) => throw null;
        public static void Sort<T>(T[] array, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static void Sort<T>(T[] array, int index, int length) => throw null;
        public static void Sort<T>(T[] array, int index, int length, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, System.Collections.Generic.IComparer<TKey> comparer) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer<TKey> comparer) => throw null;
        public object SyncRoot { get => throw null; }
        public static bool TrueForAll<T>(T[] array, System.Predicate<T> match) => throw null;
    }

    public struct ArraySegment<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IEnumerable
    {
        public struct Enumerator : System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator, System.IDisposable
        {
            public T Current { get => throw null; }
            object System.Collections.IEnumerator.Current { get => throw null; }
            public void Dispose() => throw null;
            // Stub generator skipped constructor 
            public bool MoveNext() => throw null;
            void System.Collections.IEnumerator.Reset() => throw null;
        }


        public static bool operator !=(System.ArraySegment<T> a, System.ArraySegment<T> b) => throw null;
        public static bool operator ==(System.ArraySegment<T> a, System.ArraySegment<T> b) => throw null;
        void System.Collections.Generic.ICollection<T>.Add(T item) => throw null;
        public T[] Array { get => throw null; }
        // Stub generator skipped constructor 
        public ArraySegment(T[] array) => throw null;
        public ArraySegment(T[] array, int offset, int count) => throw null;
        void System.Collections.Generic.ICollection<T>.Clear() => throw null;
        bool System.Collections.Generic.ICollection<T>.Contains(T item) => throw null;
        public void CopyTo(System.ArraySegment<T> destination) => throw null;
        public void CopyTo(T[] destination) => throw null;
        public void CopyTo(T[] destination, int destinationIndex) => throw null;
        public int Count { get => throw null; }
        public static System.ArraySegment<T> Empty { get => throw null; }
        public bool Equals(System.ArraySegment<T> obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public System.ArraySegment<T>.Enumerator GetEnumerator() => throw null;
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator() => throw null;
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.Generic.IList<T>.IndexOf(T item) => throw null;
        void System.Collections.Generic.IList<T>.Insert(int index, T item) => throw null;
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
        public T this[int index] { get => throw null; set => throw null; }
        T System.Collections.Generic.IList<T>.this[int index] { get => throw null; set => throw null; }
        T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get => throw null; }
        public int Offset { get => throw null; }
        bool System.Collections.Generic.ICollection<T>.Remove(T item) => throw null;
        void System.Collections.Generic.IList<T>.RemoveAt(int index) => throw null;
        public System.ArraySegment<T> Slice(int index) => throw null;
        public System.ArraySegment<T> Slice(int index, int count) => throw null;
        public T[] ToArray() => throw null;
        public static implicit operator System.ArraySegment<T>(T[] array) => throw null;
    }

    public class ArrayTypeMismatchException : System.SystemException
    {
        public ArrayTypeMismatchException() => throw null;
        protected ArrayTypeMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArrayTypeMismatchException(string message) => throw null;
        public ArrayTypeMismatchException(string message, System.Exception innerException) => throw null;
    }

    public class AssemblyLoadEventArgs : System.EventArgs
    {
        public AssemblyLoadEventArgs(System.Reflection.Assembly loadedAssembly) => throw null;
        public System.Reflection.Assembly LoadedAssembly { get => throw null; }
    }

    public delegate void AssemblyLoadEventHandler(object sender, System.AssemblyLoadEventArgs args);

    public delegate void AsyncCallback(System.IAsyncResult ar);

    public abstract class Attribute
    {
        protected Attribute() => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, bool inherit) => throw null;
        public override int GetHashCode() => throw null;
        public virtual bool IsDefaultAttribute() => throw null;
        public static bool IsDefined(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public virtual bool Match(object obj) => throw null;
        public virtual object TypeId { get => throw null; }
    }

    [System.Flags]
    public enum AttributeTargets : int
    {
        All = 32767,
        Assembly = 1,
        Class = 4,
        Constructor = 32,
        Delegate = 4096,
        Enum = 16,
        Event = 512,
        Field = 256,
        GenericParameter = 16384,
        Interface = 1024,
        Method = 64,
        Module = 2,
        Parameter = 2048,
        Property = 128,
        ReturnValue = 8192,
        Struct = 8,
    }

    public class AttributeUsageAttribute : System.Attribute
    {
        public bool AllowMultiple { get => throw null; set => throw null; }
        public AttributeUsageAttribute(System.AttributeTargets validOn) => throw null;
        public bool Inherited { get => throw null; set => throw null; }
        public System.AttributeTargets ValidOn { get => throw null; }
    }

    public class BadImageFormatException : System.SystemException
    {
        public BadImageFormatException() => throw null;
        protected BadImageFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public BadImageFormatException(string message) => throw null;
        public BadImageFormatException(string message, System.Exception inner) => throw null;
        public BadImageFormatException(string message, string fileName) => throw null;
        public BadImageFormatException(string message, string fileName, System.Exception inner) => throw null;
        public string FileName { get => throw null; }
        public string FusionLog { get => throw null; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public override string ToString() => throw null;
    }

    [System.Flags]
    public enum Base64FormattingOptions : int
    {
        InsertLineBreaks = 1,
        None = 0,
    }

    public static class BitConverter
    {
        public static System.Int64 DoubleToInt64Bits(double value) => throw null;
        public static System.UInt64 DoubleToUInt64Bits(double value) => throw null;
        public static System.Byte[] GetBytes(System.Half value) => throw null;
        public static System.Byte[] GetBytes(bool value) => throw null;
        public static System.Byte[] GetBytes(System.Char value) => throw null;
        public static System.Byte[] GetBytes(double value) => throw null;
        public static System.Byte[] GetBytes(float value) => throw null;
        public static System.Byte[] GetBytes(int value) => throw null;
        public static System.Byte[] GetBytes(System.Int64 value) => throw null;
        public static System.Byte[] GetBytes(System.Int16 value) => throw null;
        public static System.Byte[] GetBytes(System.UInt32 value) => throw null;
        public static System.Byte[] GetBytes(System.UInt64 value) => throw null;
        public static System.Byte[] GetBytes(System.UInt16 value) => throw null;
        public static System.Int16 HalfToInt16Bits(System.Half value) => throw null;
        public static System.UInt16 HalfToUInt16Bits(System.Half value) => throw null;
        public static System.Half Int16BitsToHalf(System.Int16 value) => throw null;
        public static float Int32BitsToSingle(int value) => throw null;
        public static double Int64BitsToDouble(System.Int64 value) => throw null;
        public static bool IsLittleEndian;
        public static int SingleToInt32Bits(float value) => throw null;
        public static System.UInt32 SingleToUInt32Bits(float value) => throw null;
        public static bool ToBoolean(System.Byte[] value, int startIndex) => throw null;
        public static bool ToBoolean(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.Char ToChar(System.Byte[] value, int startIndex) => throw null;
        public static System.Char ToChar(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static double ToDouble(System.Byte[] value, int startIndex) => throw null;
        public static double ToDouble(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.Half ToHalf(System.Byte[] value, int startIndex) => throw null;
        public static System.Half ToHalf(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.Int16 ToInt16(System.Byte[] value, int startIndex) => throw null;
        public static System.Int16 ToInt16(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static int ToInt32(System.Byte[] value, int startIndex) => throw null;
        public static int ToInt32(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.Int64 ToInt64(System.Byte[] value, int startIndex) => throw null;
        public static System.Int64 ToInt64(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static float ToSingle(System.Byte[] value, int startIndex) => throw null;
        public static float ToSingle(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static string ToString(System.Byte[] value) => throw null;
        public static string ToString(System.Byte[] value, int startIndex) => throw null;
        public static string ToString(System.Byte[] value, int startIndex, int length) => throw null;
        public static System.UInt16 ToUInt16(System.Byte[] value, int startIndex) => throw null;
        public static System.UInt16 ToUInt16(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.UInt32 ToUInt32(System.Byte[] value, int startIndex) => throw null;
        public static System.UInt32 ToUInt32(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static System.UInt64 ToUInt64(System.Byte[] value, int startIndex) => throw null;
        public static System.UInt64 ToUInt64(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.Half value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, bool value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.Char value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, double value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, float value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, int value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.Int64 value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.Int16 value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.UInt32 value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.UInt64 value) => throw null;
        public static bool TryWriteBytes(System.Span<System.Byte> destination, System.UInt16 value) => throw null;
        public static System.Half UInt16BitsToHalf(System.UInt16 value) => throw null;
        public static float UInt32BitsToSingle(System.UInt32 value) => throw null;
        public static double UInt64BitsToDouble(System.UInt64 value) => throw null;
    }

    public struct Boolean : System.IComparable, System.IComparable<bool>, System.IConvertible, System.IEquatable<bool>
    {
        // Stub generator skipped constructor 
        public int CompareTo(bool value) => throw null;
        public int CompareTo(object obj) => throw null;
        public bool Equals(bool obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public static string FalseString;
        public override int GetHashCode() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool Parse(System.ReadOnlySpan<System.Char> value) => throw null;
        public static bool Parse(string value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static string TrueString;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> value, out bool result) => throw null;
        public static bool TryParse(string value, out bool result) => throw null;
    }

    public static class Buffer
    {
        public static void BlockCopy(System.Array src, int srcOffset, System.Array dst, int dstOffset, int count) => throw null;
        public static int ByteLength(System.Array array) => throw null;
        public static System.Byte GetByte(System.Array array, int index) => throw null;
        unsafe public static void MemoryCopy(void* source, void* destination, System.Int64 destinationSizeInBytes, System.Int64 sourceBytesToCopy) => throw null;
        unsafe public static void MemoryCopy(void* source, void* destination, System.UInt64 destinationSizeInBytes, System.UInt64 sourceBytesToCopy) => throw null;
        public static void SetByte(System.Array array, int index, System.Byte value) => throw null;
    }

    public struct Byte : System.IComparable, System.IComparable<System.Byte>, System.IConvertible, System.IEquatable<System.Byte>, System.IFormattable, System.IParsable<System.Byte>, System.ISpanFormattable, System.ISpanParsable<System.Byte>, System.Numerics.IAdditionOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.IAdditiveIdentity<System.Byte, System.Byte>, System.Numerics.IBinaryInteger<System.Byte>, System.Numerics.IBinaryNumber<System.Byte>, System.Numerics.IBitwiseOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.IComparisonOperators<System.Byte, System.Byte, bool>, System.Numerics.IDecrementOperators<System.Byte>, System.Numerics.IDivisionOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.IEqualityOperators<System.Byte, System.Byte, bool>, System.Numerics.IIncrementOperators<System.Byte>, System.Numerics.IMinMaxValue<System.Byte>, System.Numerics.IModulusOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.IMultiplicativeIdentity<System.Byte, System.Byte>, System.Numerics.IMultiplyOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.INumber<System.Byte>, System.Numerics.INumberBase<System.Byte>, System.Numerics.IShiftOperators<System.Byte, int, System.Byte>, System.Numerics.ISubtractionOperators<System.Byte, System.Byte, System.Byte>, System.Numerics.IUnaryNegationOperators<System.Byte, System.Byte>, System.Numerics.IUnaryPlusOperators<System.Byte, System.Byte>, System.Numerics.IUnsignedNumber<System.Byte>
    {
        static bool System.Numerics.IEqualityOperators<System.Byte, System.Byte, bool>.operator !=(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IModulusOperators<System.Byte, System.Byte, System.Byte>.operator %(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IBitwiseOperators<System.Byte, System.Byte, System.Byte>.operator &(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IMultiplyOperators<System.Byte, System.Byte, System.Byte>.operator *(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IUnaryPlusOperators<System.Byte, System.Byte>.operator +(System.Byte value) => throw null;
        static System.Byte System.Numerics.IAdditionOperators<System.Byte, System.Byte, System.Byte>.operator +(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IIncrementOperators<System.Byte>.operator ++(System.Byte value) => throw null;
        static System.Byte System.Numerics.IUnaryNegationOperators<System.Byte, System.Byte>.operator -(System.Byte value) => throw null;
        static System.Byte System.Numerics.ISubtractionOperators<System.Byte, System.Byte, System.Byte>.operator -(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IDecrementOperators<System.Byte>.operator --(System.Byte value) => throw null;
        static System.Byte System.Numerics.IDivisionOperators<System.Byte, System.Byte, System.Byte>.operator /(System.Byte left, System.Byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Byte, System.Byte, bool>.operator <(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IShiftOperators<System.Byte, int, System.Byte>.operator <<(System.Byte value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Byte, System.Byte, bool>.operator <=(System.Byte left, System.Byte right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Byte, System.Byte, bool>.operator ==(System.Byte left, System.Byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Byte, System.Byte, bool>.operator >(System.Byte left, System.Byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Byte, System.Byte, bool>.operator >=(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IShiftOperators<System.Byte, int, System.Byte>.operator >>(System.Byte value, int shiftAmount) => throw null;
        static System.Byte System.Numerics.IShiftOperators<System.Byte, int, System.Byte>.operator >>>(System.Byte value, int shiftAmount) => throw null;
        public static System.Byte Abs(System.Byte value) => throw null;
        static System.Byte System.Numerics.IAdditiveIdentity<System.Byte, System.Byte>.AdditiveIdentity { get => throw null; }
        static System.Byte System.Numerics.IBinaryNumber<System.Byte>.AllBitsSet { get => throw null; }
        // Stub generator skipped constructor 
        public static System.Byte Clamp(System.Byte value, System.Byte min, System.Byte max) => throw null;
        public int CompareTo(System.Byte value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.Byte CopySign(System.Byte value, System.Byte sign) => throw null;
        static System.Byte System.Numerics.INumberBase<System.Byte>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Byte System.Numerics.INumberBase<System.Byte>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Byte System.Numerics.INumberBase<System.Byte>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.Byte, System.Byte) DivRem(System.Byte left, System.Byte right) => throw null;
        public bool Equals(System.Byte obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Byte>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.Byte>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.Byte value) => throw null;
        public static bool IsComplexNumber(System.Byte value) => throw null;
        public static bool IsEvenInteger(System.Byte value) => throw null;
        public static bool IsFinite(System.Byte value) => throw null;
        public static bool IsImaginaryNumber(System.Byte value) => throw null;
        public static bool IsInfinity(System.Byte value) => throw null;
        public static bool IsInteger(System.Byte value) => throw null;
        public static bool IsNaN(System.Byte value) => throw null;
        public static bool IsNegative(System.Byte value) => throw null;
        public static bool IsNegativeInfinity(System.Byte value) => throw null;
        public static bool IsNormal(System.Byte value) => throw null;
        public static bool IsOddInteger(System.Byte value) => throw null;
        public static bool IsPositive(System.Byte value) => throw null;
        public static bool IsPositiveInfinity(System.Byte value) => throw null;
        public static bool IsPow2(System.Byte value) => throw null;
        public static bool IsRealNumber(System.Byte value) => throw null;
        public static bool IsSubnormal(System.Byte value) => throw null;
        public static bool IsZero(System.Byte value) => throw null;
        public static System.Byte LeadingZeroCount(System.Byte value) => throw null;
        public static System.Byte Log2(System.Byte value) => throw null;
        public static System.Byte Max(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MaxMagnitude(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MaxMagnitudeNumber(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MaxNumber(System.Byte x, System.Byte y) => throw null;
        public const System.Byte MaxValue = default;
        static System.Byte System.Numerics.IMinMaxValue<System.Byte>.MaxValue { get => throw null; }
        public static System.Byte Min(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MinMagnitude(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MinMagnitudeNumber(System.Byte x, System.Byte y) => throw null;
        public static System.Byte MinNumber(System.Byte x, System.Byte y) => throw null;
        public const System.Byte MinValue = default;
        static System.Byte System.Numerics.IMinMaxValue<System.Byte>.MinValue { get => throw null; }
        static System.Byte System.Numerics.IMultiplicativeIdentity<System.Byte, System.Byte>.MultiplicativeIdentity { get => throw null; }
        static System.Byte System.Numerics.INumberBase<System.Byte>.One { get => throw null; }
        public static System.Byte Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Byte Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Byte Parse(string s) => throw null;
        public static System.Byte Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Byte Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Byte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Byte PopCount(System.Byte value) => throw null;
        static int System.Numerics.INumberBase<System.Byte>.Radix { get => throw null; }
        public static System.Byte RotateLeft(System.Byte value, int rotateAmount) => throw null;
        public static System.Byte RotateRight(System.Byte value, int rotateAmount) => throw null;
        public static int Sign(System.Byte value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.Byte TrailingZeroCount(System.Byte value) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertFromChecked<TOther>(TOther value, out System.Byte result) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertFromSaturating<TOther>(TOther value, out System.Byte result) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertFromTruncating<TOther>(TOther value, out System.Byte result) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertToChecked<TOther>(System.Byte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertToSaturating<TOther>(System.Byte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Byte>.TryConvertToTruncating<TOther>(System.Byte value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Byte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Byte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Byte result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Byte result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Byte result) => throw null;
        public static bool TryParse(string s, out System.Byte result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Byte value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Byte value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Byte System.Numerics.INumberBase<System.Byte>.Zero { get => throw null; }
        static System.Byte System.Numerics.IBitwiseOperators<System.Byte, System.Byte, System.Byte>.operator ^(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IMultiplyOperators<System.Byte, System.Byte, System.Byte>.operator checked *(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IAdditionOperators<System.Byte, System.Byte, System.Byte>.operator checked +(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IIncrementOperators<System.Byte>.operator checked ++(System.Byte value) => throw null;
        static System.Byte System.Numerics.IUnaryNegationOperators<System.Byte, System.Byte>.operator checked -(System.Byte value) => throw null;
        static System.Byte System.Numerics.ISubtractionOperators<System.Byte, System.Byte, System.Byte>.operator checked -(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IDecrementOperators<System.Byte>.operator checked --(System.Byte value) => throw null;
        static System.Byte System.Numerics.IBitwiseOperators<System.Byte, System.Byte, System.Byte>.operator |(System.Byte left, System.Byte right) => throw null;
        static System.Byte System.Numerics.IBitwiseOperators<System.Byte, System.Byte, System.Byte>.operator ~(System.Byte value) => throw null;
    }

    public class CLSCompliantAttribute : System.Attribute
    {
        public CLSCompliantAttribute(bool isCompliant) => throw null;
        public bool IsCompliant { get => throw null; }
    }

    public class CannotUnloadAppDomainException : System.SystemException
    {
        public CannotUnloadAppDomainException() => throw null;
        protected CannotUnloadAppDomainException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public CannotUnloadAppDomainException(string message) => throw null;
        public CannotUnloadAppDomainException(string message, System.Exception innerException) => throw null;
    }

    public struct Char : System.IComparable, System.IComparable<System.Char>, System.IConvertible, System.IEquatable<System.Char>, System.IFormattable, System.IParsable<System.Char>, System.ISpanFormattable, System.ISpanParsable<System.Char>, System.Numerics.IAdditionOperators<System.Char, System.Char, System.Char>, System.Numerics.IAdditiveIdentity<System.Char, System.Char>, System.Numerics.IBinaryInteger<System.Char>, System.Numerics.IBinaryNumber<System.Char>, System.Numerics.IBitwiseOperators<System.Char, System.Char, System.Char>, System.Numerics.IComparisonOperators<System.Char, System.Char, bool>, System.Numerics.IDecrementOperators<System.Char>, System.Numerics.IDivisionOperators<System.Char, System.Char, System.Char>, System.Numerics.IEqualityOperators<System.Char, System.Char, bool>, System.Numerics.IIncrementOperators<System.Char>, System.Numerics.IMinMaxValue<System.Char>, System.Numerics.IModulusOperators<System.Char, System.Char, System.Char>, System.Numerics.IMultiplicativeIdentity<System.Char, System.Char>, System.Numerics.IMultiplyOperators<System.Char, System.Char, System.Char>, System.Numerics.INumber<System.Char>, System.Numerics.INumberBase<System.Char>, System.Numerics.IShiftOperators<System.Char, int, System.Char>, System.Numerics.ISubtractionOperators<System.Char, System.Char, System.Char>, System.Numerics.IUnaryNegationOperators<System.Char, System.Char>, System.Numerics.IUnaryPlusOperators<System.Char, System.Char>, System.Numerics.IUnsignedNumber<System.Char>
    {
        static bool System.Numerics.IEqualityOperators<System.Char, System.Char, bool>.operator !=(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IModulusOperators<System.Char, System.Char, System.Char>.operator %(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IBitwiseOperators<System.Char, System.Char, System.Char>.operator &(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IMultiplyOperators<System.Char, System.Char, System.Char>.operator *(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IUnaryPlusOperators<System.Char, System.Char>.operator +(System.Char value) => throw null;
        static System.Char System.Numerics.IAdditionOperators<System.Char, System.Char, System.Char>.operator +(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IIncrementOperators<System.Char>.operator ++(System.Char value) => throw null;
        static System.Char System.Numerics.IUnaryNegationOperators<System.Char, System.Char>.operator -(System.Char value) => throw null;
        static System.Char System.Numerics.ISubtractionOperators<System.Char, System.Char, System.Char>.operator -(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IDecrementOperators<System.Char>.operator --(System.Char value) => throw null;
        static System.Char System.Numerics.IDivisionOperators<System.Char, System.Char, System.Char>.operator /(System.Char left, System.Char right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Char, System.Char, bool>.operator <(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IShiftOperators<System.Char, int, System.Char>.operator <<(System.Char value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Char, System.Char, bool>.operator <=(System.Char left, System.Char right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Char, System.Char, bool>.operator ==(System.Char left, System.Char right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Char, System.Char, bool>.operator >(System.Char left, System.Char right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Char, System.Char, bool>.operator >=(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IShiftOperators<System.Char, int, System.Char>.operator >>(System.Char value, int shiftAmount) => throw null;
        static System.Char System.Numerics.IShiftOperators<System.Char, int, System.Char>.operator >>>(System.Char value, int shiftAmount) => throw null;
        public static System.Char Abs(System.Char value) => throw null;
        static System.Char System.Numerics.IAdditiveIdentity<System.Char, System.Char>.AdditiveIdentity { get => throw null; }
        static System.Char System.Numerics.IBinaryNumber<System.Char>.AllBitsSet { get => throw null; }
        // Stub generator skipped constructor 
        public int CompareTo(System.Char value) => throw null;
        public int CompareTo(object value) => throw null;
        public static string ConvertFromUtf32(int utf32) => throw null;
        public static int ConvertToUtf32(System.Char highSurrogate, System.Char lowSurrogate) => throw null;
        public static int ConvertToUtf32(string s, int index) => throw null;
        public bool Equals(System.Char obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Char>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        public static double GetNumericValue(System.Char c) => throw null;
        public static double GetNumericValue(string s, int index) => throw null;
        int System.Numerics.IBinaryInteger<System.Char>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static System.Globalization.UnicodeCategory GetUnicodeCategory(System.Char c) => throw null;
        public static System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index) => throw null;
        public static bool IsAscii(System.Char c) => throw null;
        public static bool IsAsciiDigit(System.Char c) => throw null;
        public static bool IsAsciiHexDigit(System.Char c) => throw null;
        public static bool IsAsciiHexDigitLower(System.Char c) => throw null;
        public static bool IsAsciiHexDigitUpper(System.Char c) => throw null;
        public static bool IsAsciiLetter(System.Char c) => throw null;
        public static bool IsAsciiLetterLower(System.Char c) => throw null;
        public static bool IsAsciiLetterOrDigit(System.Char c) => throw null;
        public static bool IsAsciiLetterUpper(System.Char c) => throw null;
        public static bool IsBetween(System.Char c, System.Char minInclusive, System.Char maxInclusive) => throw null;
        public static bool IsCanonical(System.Char value) => throw null;
        public static bool IsComplexNumber(System.Char value) => throw null;
        public static bool IsControl(System.Char c) => throw null;
        public static bool IsControl(string s, int index) => throw null;
        public static bool IsDigit(System.Char c) => throw null;
        public static bool IsDigit(string s, int index) => throw null;
        public static bool IsEvenInteger(System.Char value) => throw null;
        public static bool IsFinite(System.Char value) => throw null;
        public static bool IsHighSurrogate(System.Char c) => throw null;
        public static bool IsHighSurrogate(string s, int index) => throw null;
        public static bool IsImaginaryNumber(System.Char value) => throw null;
        public static bool IsInfinity(System.Char value) => throw null;
        public static bool IsInteger(System.Char value) => throw null;
        public static bool IsLetter(System.Char c) => throw null;
        public static bool IsLetter(string s, int index) => throw null;
        public static bool IsLetterOrDigit(System.Char c) => throw null;
        public static bool IsLetterOrDigit(string s, int index) => throw null;
        public static bool IsLowSurrogate(System.Char c) => throw null;
        public static bool IsLowSurrogate(string s, int index) => throw null;
        public static bool IsLower(System.Char c) => throw null;
        public static bool IsLower(string s, int index) => throw null;
        public static bool IsNaN(System.Char value) => throw null;
        public static bool IsNegative(System.Char value) => throw null;
        public static bool IsNegativeInfinity(System.Char value) => throw null;
        public static bool IsNormal(System.Char value) => throw null;
        public static bool IsNumber(System.Char c) => throw null;
        public static bool IsNumber(string s, int index) => throw null;
        public static bool IsOddInteger(System.Char value) => throw null;
        public static bool IsPositive(System.Char value) => throw null;
        public static bool IsPositiveInfinity(System.Char value) => throw null;
        public static bool IsPow2(System.Char value) => throw null;
        public static bool IsPunctuation(System.Char c) => throw null;
        public static bool IsPunctuation(string s, int index) => throw null;
        public static bool IsRealNumber(System.Char value) => throw null;
        public static bool IsSeparator(System.Char c) => throw null;
        public static bool IsSeparator(string s, int index) => throw null;
        public static bool IsSubnormal(System.Char value) => throw null;
        public static bool IsSurrogate(System.Char c) => throw null;
        public static bool IsSurrogate(string s, int index) => throw null;
        public static bool IsSurrogatePair(System.Char highSurrogate, System.Char lowSurrogate) => throw null;
        public static bool IsSurrogatePair(string s, int index) => throw null;
        public static bool IsSymbol(System.Char c) => throw null;
        public static bool IsSymbol(string s, int index) => throw null;
        public static bool IsUpper(System.Char c) => throw null;
        public static bool IsUpper(string s, int index) => throw null;
        public static bool IsWhiteSpace(System.Char c) => throw null;
        public static bool IsWhiteSpace(string s, int index) => throw null;
        public static bool IsZero(System.Char value) => throw null;
        public static System.Char LeadingZeroCount(System.Char value) => throw null;
        public static System.Char Log2(System.Char value) => throw null;
        public static System.Char MaxMagnitude(System.Char x, System.Char y) => throw null;
        public static System.Char MaxMagnitudeNumber(System.Char x, System.Char y) => throw null;
        public const System.Char MaxValue = default;
        static System.Char System.Numerics.IMinMaxValue<System.Char>.MaxValue { get => throw null; }
        public static System.Char MinMagnitude(System.Char x, System.Char y) => throw null;
        public static System.Char MinMagnitudeNumber(System.Char x, System.Char y) => throw null;
        public const System.Char MinValue = default;
        static System.Char System.Numerics.IMinMaxValue<System.Char>.MinValue { get => throw null; }
        static System.Char System.Numerics.IMultiplicativeIdentity<System.Char, System.Char>.MultiplicativeIdentity { get => throw null; }
        static System.Char System.Numerics.INumberBase<System.Char>.One { get => throw null; }
        public static System.Char Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Char Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Char Parse(string s) => throw null;
        public static System.Char Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Char Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Char PopCount(System.Char value) => throw null;
        static int System.Numerics.INumberBase<System.Char>.Radix { get => throw null; }
        public static System.Char RotateLeft(System.Char value, int rotateAmount) => throw null;
        public static System.Char RotateRight(System.Char value, int rotateAmount) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static System.Char ToLower(System.Char c) => throw null;
        public static System.Char ToLower(System.Char c, System.Globalization.CultureInfo culture) => throw null;
        public static System.Char ToLowerInvariant(System.Char c) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public static string ToString(System.Char c) => throw null;
        string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.Char ToUpper(System.Char c) => throw null;
        public static System.Char ToUpper(System.Char c, System.Globalization.CultureInfo culture) => throw null;
        public static System.Char ToUpperInvariant(System.Char c) => throw null;
        public static System.Char TrailingZeroCount(System.Char value) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertFromChecked<TOther>(TOther value, out System.Char result) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertFromSaturating<TOther>(TOther value, out System.Char result) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertFromTruncating<TOther>(TOther value, out System.Char result) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertToChecked<TOther>(System.Char value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertToSaturating<TOther>(System.Char value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Char>.TryConvertToTruncating<TOther>(System.Char value, out TOther result) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Char result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Char result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Char result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Char result) => throw null;
        public static bool TryParse(string s, out System.Char result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Char value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Char value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Char>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Char>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Char System.Numerics.INumberBase<System.Char>.Zero { get => throw null; }
        static System.Char System.Numerics.IBitwiseOperators<System.Char, System.Char, System.Char>.operator ^(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IMultiplyOperators<System.Char, System.Char, System.Char>.operator checked *(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IAdditionOperators<System.Char, System.Char, System.Char>.operator checked +(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IIncrementOperators<System.Char>.operator checked ++(System.Char value) => throw null;
        static System.Char System.Numerics.IUnaryNegationOperators<System.Char, System.Char>.operator checked -(System.Char value) => throw null;
        static System.Char System.Numerics.ISubtractionOperators<System.Char, System.Char, System.Char>.operator checked -(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IDecrementOperators<System.Char>.operator checked --(System.Char value) => throw null;
        static System.Char System.Numerics.IBitwiseOperators<System.Char, System.Char, System.Char>.operator |(System.Char left, System.Char right) => throw null;
        static System.Char System.Numerics.IBitwiseOperators<System.Char, System.Char, System.Char>.operator ~(System.Char value) => throw null;
    }

    public class CharEnumerator : System.Collections.Generic.IEnumerator<System.Char>, System.Collections.IEnumerator, System.ICloneable, System.IDisposable
    {
        public object Clone() => throw null;
        public System.Char Current { get => throw null; }
        object System.Collections.IEnumerator.Current { get => throw null; }
        public void Dispose() => throw null;
        public bool MoveNext() => throw null;
        public void Reset() => throw null;
    }

    public delegate int Comparison<T>(T x, T y);

    public abstract class ContextBoundObject : System.MarshalByRefObject
    {
        protected ContextBoundObject() => throw null;
    }

    public class ContextMarshalException : System.SystemException
    {
        public ContextMarshalException() => throw null;
        protected ContextMarshalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ContextMarshalException(string message) => throw null;
        public ContextMarshalException(string message, System.Exception inner) => throw null;
    }

    public class ContextStaticAttribute : System.Attribute
    {
        public ContextStaticAttribute() => throw null;
    }

    public static class Convert
    {
        public static object ChangeType(object value, System.Type conversionType) => throw null;
        public static object ChangeType(object value, System.Type conversionType, System.IFormatProvider provider) => throw null;
        public static object ChangeType(object value, System.TypeCode typeCode) => throw null;
        public static object ChangeType(object value, System.TypeCode typeCode, System.IFormatProvider provider) => throw null;
        public static object DBNull;
        public static System.Byte[] FromBase64CharArray(System.Char[] inArray, int offset, int length) => throw null;
        public static System.Byte[] FromBase64String(string s) => throw null;
        public static System.Byte[] FromHexString(System.ReadOnlySpan<System.Char> chars) => throw null;
        public static System.Byte[] FromHexString(string s) => throw null;
        public static System.TypeCode GetTypeCode(object value) => throw null;
        public static bool IsDBNull(object value) => throw null;
        public static int ToBase64CharArray(System.Byte[] inArray, int offsetIn, int length, System.Char[] outArray, int offsetOut) => throw null;
        public static int ToBase64CharArray(System.Byte[] inArray, int offsetIn, int length, System.Char[] outArray, int offsetOut, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(System.Byte[] inArray) => throw null;
        public static string ToBase64String(System.Byte[] inArray, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(System.Byte[] inArray, int offset, int length) => throw null;
        public static string ToBase64String(System.Byte[] inArray, int offset, int length, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(System.ReadOnlySpan<System.Byte> bytes, System.Base64FormattingOptions options = default(System.Base64FormattingOptions)) => throw null;
        public static bool ToBoolean(System.DateTime value) => throw null;
        public static bool ToBoolean(bool value) => throw null;
        public static bool ToBoolean(System.Byte value) => throw null;
        public static bool ToBoolean(System.Char value) => throw null;
        public static bool ToBoolean(System.Decimal value) => throw null;
        public static bool ToBoolean(double value) => throw null;
        public static bool ToBoolean(float value) => throw null;
        public static bool ToBoolean(int value) => throw null;
        public static bool ToBoolean(System.Int64 value) => throw null;
        public static bool ToBoolean(object value) => throw null;
        public static bool ToBoolean(object value, System.IFormatProvider provider) => throw null;
        public static bool ToBoolean(System.SByte value) => throw null;
        public static bool ToBoolean(System.Int16 value) => throw null;
        public static bool ToBoolean(string value) => throw null;
        public static bool ToBoolean(string value, System.IFormatProvider provider) => throw null;
        public static bool ToBoolean(System.UInt32 value) => throw null;
        public static bool ToBoolean(System.UInt64 value) => throw null;
        public static bool ToBoolean(System.UInt16 value) => throw null;
        public static System.Byte ToByte(System.DateTime value) => throw null;
        public static System.Byte ToByte(bool value) => throw null;
        public static System.Byte ToByte(System.Byte value) => throw null;
        public static System.Byte ToByte(System.Char value) => throw null;
        public static System.Byte ToByte(System.Decimal value) => throw null;
        public static System.Byte ToByte(double value) => throw null;
        public static System.Byte ToByte(float value) => throw null;
        public static System.Byte ToByte(int value) => throw null;
        public static System.Byte ToByte(System.Int64 value) => throw null;
        public static System.Byte ToByte(object value) => throw null;
        public static System.Byte ToByte(object value, System.IFormatProvider provider) => throw null;
        public static System.Byte ToByte(System.SByte value) => throw null;
        public static System.Byte ToByte(System.Int16 value) => throw null;
        public static System.Byte ToByte(string value) => throw null;
        public static System.Byte ToByte(string value, System.IFormatProvider provider) => throw null;
        public static System.Byte ToByte(string value, int fromBase) => throw null;
        public static System.Byte ToByte(System.UInt32 value) => throw null;
        public static System.Byte ToByte(System.UInt64 value) => throw null;
        public static System.Byte ToByte(System.UInt16 value) => throw null;
        public static System.Char ToChar(System.DateTime value) => throw null;
        public static System.Char ToChar(bool value) => throw null;
        public static System.Char ToChar(System.Byte value) => throw null;
        public static System.Char ToChar(System.Char value) => throw null;
        public static System.Char ToChar(System.Decimal value) => throw null;
        public static System.Char ToChar(double value) => throw null;
        public static System.Char ToChar(float value) => throw null;
        public static System.Char ToChar(int value) => throw null;
        public static System.Char ToChar(System.Int64 value) => throw null;
        public static System.Char ToChar(object value) => throw null;
        public static System.Char ToChar(object value, System.IFormatProvider provider) => throw null;
        public static System.Char ToChar(System.SByte value) => throw null;
        public static System.Char ToChar(System.Int16 value) => throw null;
        public static System.Char ToChar(string value) => throw null;
        public static System.Char ToChar(string value, System.IFormatProvider provider) => throw null;
        public static System.Char ToChar(System.UInt32 value) => throw null;
        public static System.Char ToChar(System.UInt64 value) => throw null;
        public static System.Char ToChar(System.UInt16 value) => throw null;
        public static System.DateTime ToDateTime(System.DateTime value) => throw null;
        public static System.DateTime ToDateTime(bool value) => throw null;
        public static System.DateTime ToDateTime(System.Byte value) => throw null;
        public static System.DateTime ToDateTime(System.Char value) => throw null;
        public static System.DateTime ToDateTime(System.Decimal value) => throw null;
        public static System.DateTime ToDateTime(double value) => throw null;
        public static System.DateTime ToDateTime(float value) => throw null;
        public static System.DateTime ToDateTime(int value) => throw null;
        public static System.DateTime ToDateTime(System.Int64 value) => throw null;
        public static System.DateTime ToDateTime(object value) => throw null;
        public static System.DateTime ToDateTime(object value, System.IFormatProvider provider) => throw null;
        public static System.DateTime ToDateTime(System.SByte value) => throw null;
        public static System.DateTime ToDateTime(System.Int16 value) => throw null;
        public static System.DateTime ToDateTime(string value) => throw null;
        public static System.DateTime ToDateTime(string value, System.IFormatProvider provider) => throw null;
        public static System.DateTime ToDateTime(System.UInt32 value) => throw null;
        public static System.DateTime ToDateTime(System.UInt64 value) => throw null;
        public static System.DateTime ToDateTime(System.UInt16 value) => throw null;
        public static System.Decimal ToDecimal(System.DateTime value) => throw null;
        public static System.Decimal ToDecimal(bool value) => throw null;
        public static System.Decimal ToDecimal(System.Byte value) => throw null;
        public static System.Decimal ToDecimal(System.Char value) => throw null;
        public static System.Decimal ToDecimal(System.Decimal value) => throw null;
        public static System.Decimal ToDecimal(double value) => throw null;
        public static System.Decimal ToDecimal(float value) => throw null;
        public static System.Decimal ToDecimal(int value) => throw null;
        public static System.Decimal ToDecimal(System.Int64 value) => throw null;
        public static System.Decimal ToDecimal(object value) => throw null;
        public static System.Decimal ToDecimal(object value, System.IFormatProvider provider) => throw null;
        public static System.Decimal ToDecimal(System.SByte value) => throw null;
        public static System.Decimal ToDecimal(System.Int16 value) => throw null;
        public static System.Decimal ToDecimal(string value) => throw null;
        public static System.Decimal ToDecimal(string value, System.IFormatProvider provider) => throw null;
        public static System.Decimal ToDecimal(System.UInt32 value) => throw null;
        public static System.Decimal ToDecimal(System.UInt64 value) => throw null;
        public static System.Decimal ToDecimal(System.UInt16 value) => throw null;
        public static double ToDouble(System.DateTime value) => throw null;
        public static double ToDouble(bool value) => throw null;
        public static double ToDouble(System.Byte value) => throw null;
        public static double ToDouble(System.Char value) => throw null;
        public static double ToDouble(System.Decimal value) => throw null;
        public static double ToDouble(double value) => throw null;
        public static double ToDouble(float value) => throw null;
        public static double ToDouble(int value) => throw null;
        public static double ToDouble(System.Int64 value) => throw null;
        public static double ToDouble(object value) => throw null;
        public static double ToDouble(object value, System.IFormatProvider provider) => throw null;
        public static double ToDouble(System.SByte value) => throw null;
        public static double ToDouble(System.Int16 value) => throw null;
        public static double ToDouble(string value) => throw null;
        public static double ToDouble(string value, System.IFormatProvider provider) => throw null;
        public static double ToDouble(System.UInt32 value) => throw null;
        public static double ToDouble(System.UInt64 value) => throw null;
        public static double ToDouble(System.UInt16 value) => throw null;
        public static string ToHexString(System.Byte[] inArray) => throw null;
        public static string ToHexString(System.Byte[] inArray, int offset, int length) => throw null;
        public static string ToHexString(System.ReadOnlySpan<System.Byte> bytes) => throw null;
        public static System.Int16 ToInt16(System.DateTime value) => throw null;
        public static System.Int16 ToInt16(bool value) => throw null;
        public static System.Int16 ToInt16(System.Byte value) => throw null;
        public static System.Int16 ToInt16(System.Char value) => throw null;
        public static System.Int16 ToInt16(System.Decimal value) => throw null;
        public static System.Int16 ToInt16(double value) => throw null;
        public static System.Int16 ToInt16(float value) => throw null;
        public static System.Int16 ToInt16(int value) => throw null;
        public static System.Int16 ToInt16(System.Int64 value) => throw null;
        public static System.Int16 ToInt16(object value) => throw null;
        public static System.Int16 ToInt16(object value, System.IFormatProvider provider) => throw null;
        public static System.Int16 ToInt16(System.SByte value) => throw null;
        public static System.Int16 ToInt16(System.Int16 value) => throw null;
        public static System.Int16 ToInt16(string value) => throw null;
        public static System.Int16 ToInt16(string value, System.IFormatProvider provider) => throw null;
        public static System.Int16 ToInt16(string value, int fromBase) => throw null;
        public static System.Int16 ToInt16(System.UInt32 value) => throw null;
        public static System.Int16 ToInt16(System.UInt64 value) => throw null;
        public static System.Int16 ToInt16(System.UInt16 value) => throw null;
        public static int ToInt32(System.DateTime value) => throw null;
        public static int ToInt32(bool value) => throw null;
        public static int ToInt32(System.Byte value) => throw null;
        public static int ToInt32(System.Char value) => throw null;
        public static int ToInt32(System.Decimal value) => throw null;
        public static int ToInt32(double value) => throw null;
        public static int ToInt32(float value) => throw null;
        public static int ToInt32(int value) => throw null;
        public static int ToInt32(System.Int64 value) => throw null;
        public static int ToInt32(object value) => throw null;
        public static int ToInt32(object value, System.IFormatProvider provider) => throw null;
        public static int ToInt32(System.SByte value) => throw null;
        public static int ToInt32(System.Int16 value) => throw null;
        public static int ToInt32(string value) => throw null;
        public static int ToInt32(string value, System.IFormatProvider provider) => throw null;
        public static int ToInt32(string value, int fromBase) => throw null;
        public static int ToInt32(System.UInt32 value) => throw null;
        public static int ToInt32(System.UInt64 value) => throw null;
        public static int ToInt32(System.UInt16 value) => throw null;
        public static System.Int64 ToInt64(System.DateTime value) => throw null;
        public static System.Int64 ToInt64(bool value) => throw null;
        public static System.Int64 ToInt64(System.Byte value) => throw null;
        public static System.Int64 ToInt64(System.Char value) => throw null;
        public static System.Int64 ToInt64(System.Decimal value) => throw null;
        public static System.Int64 ToInt64(double value) => throw null;
        public static System.Int64 ToInt64(float value) => throw null;
        public static System.Int64 ToInt64(int value) => throw null;
        public static System.Int64 ToInt64(System.Int64 value) => throw null;
        public static System.Int64 ToInt64(object value) => throw null;
        public static System.Int64 ToInt64(object value, System.IFormatProvider provider) => throw null;
        public static System.Int64 ToInt64(System.SByte value) => throw null;
        public static System.Int64 ToInt64(System.Int16 value) => throw null;
        public static System.Int64 ToInt64(string value) => throw null;
        public static System.Int64 ToInt64(string value, System.IFormatProvider provider) => throw null;
        public static System.Int64 ToInt64(string value, int fromBase) => throw null;
        public static System.Int64 ToInt64(System.UInt32 value) => throw null;
        public static System.Int64 ToInt64(System.UInt64 value) => throw null;
        public static System.Int64 ToInt64(System.UInt16 value) => throw null;
        public static System.SByte ToSByte(System.DateTime value) => throw null;
        public static System.SByte ToSByte(bool value) => throw null;
        public static System.SByte ToSByte(System.Byte value) => throw null;
        public static System.SByte ToSByte(System.Char value) => throw null;
        public static System.SByte ToSByte(System.Decimal value) => throw null;
        public static System.SByte ToSByte(double value) => throw null;
        public static System.SByte ToSByte(float value) => throw null;
        public static System.SByte ToSByte(int value) => throw null;
        public static System.SByte ToSByte(System.Int64 value) => throw null;
        public static System.SByte ToSByte(object value) => throw null;
        public static System.SByte ToSByte(object value, System.IFormatProvider provider) => throw null;
        public static System.SByte ToSByte(System.SByte value) => throw null;
        public static System.SByte ToSByte(System.Int16 value) => throw null;
        public static System.SByte ToSByte(string value) => throw null;
        public static System.SByte ToSByte(string value, System.IFormatProvider provider) => throw null;
        public static System.SByte ToSByte(string value, int fromBase) => throw null;
        public static System.SByte ToSByte(System.UInt32 value) => throw null;
        public static System.SByte ToSByte(System.UInt64 value) => throw null;
        public static System.SByte ToSByte(System.UInt16 value) => throw null;
        public static float ToSingle(System.DateTime value) => throw null;
        public static float ToSingle(bool value) => throw null;
        public static float ToSingle(System.Byte value) => throw null;
        public static float ToSingle(System.Char value) => throw null;
        public static float ToSingle(System.Decimal value) => throw null;
        public static float ToSingle(double value) => throw null;
        public static float ToSingle(float value) => throw null;
        public static float ToSingle(int value) => throw null;
        public static float ToSingle(System.Int64 value) => throw null;
        public static float ToSingle(object value) => throw null;
        public static float ToSingle(object value, System.IFormatProvider provider) => throw null;
        public static float ToSingle(System.SByte value) => throw null;
        public static float ToSingle(System.Int16 value) => throw null;
        public static float ToSingle(string value) => throw null;
        public static float ToSingle(string value, System.IFormatProvider provider) => throw null;
        public static float ToSingle(System.UInt32 value) => throw null;
        public static float ToSingle(System.UInt64 value) => throw null;
        public static float ToSingle(System.UInt16 value) => throw null;
        public static string ToString(System.DateTime value) => throw null;
        public static string ToString(System.DateTime value, System.IFormatProvider provider) => throw null;
        public static string ToString(bool value) => throw null;
        public static string ToString(bool value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Byte value) => throw null;
        public static string ToString(System.Byte value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Byte value, int toBase) => throw null;
        public static string ToString(System.Char value) => throw null;
        public static string ToString(System.Char value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Decimal value) => throw null;
        public static string ToString(System.Decimal value, System.IFormatProvider provider) => throw null;
        public static string ToString(double value) => throw null;
        public static string ToString(double value, System.IFormatProvider provider) => throw null;
        public static string ToString(float value) => throw null;
        public static string ToString(float value, System.IFormatProvider provider) => throw null;
        public static string ToString(int value) => throw null;
        public static string ToString(int value, System.IFormatProvider provider) => throw null;
        public static string ToString(int value, int toBase) => throw null;
        public static string ToString(System.Int64 value) => throw null;
        public static string ToString(System.Int64 value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Int64 value, int toBase) => throw null;
        public static string ToString(object value) => throw null;
        public static string ToString(object value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.SByte value) => throw null;
        public static string ToString(System.SByte value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Int16 value) => throw null;
        public static string ToString(System.Int16 value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.Int16 value, int toBase) => throw null;
        public static string ToString(string value) => throw null;
        public static string ToString(string value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.UInt32 value) => throw null;
        public static string ToString(System.UInt32 value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.UInt64 value) => throw null;
        public static string ToString(System.UInt64 value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.UInt16 value) => throw null;
        public static string ToString(System.UInt16 value, System.IFormatProvider provider) => throw null;
        public static System.UInt16 ToUInt16(System.DateTime value) => throw null;
        public static System.UInt16 ToUInt16(bool value) => throw null;
        public static System.UInt16 ToUInt16(System.Byte value) => throw null;
        public static System.UInt16 ToUInt16(System.Char value) => throw null;
        public static System.UInt16 ToUInt16(System.Decimal value) => throw null;
        public static System.UInt16 ToUInt16(double value) => throw null;
        public static System.UInt16 ToUInt16(float value) => throw null;
        public static System.UInt16 ToUInt16(int value) => throw null;
        public static System.UInt16 ToUInt16(System.Int64 value) => throw null;
        public static System.UInt16 ToUInt16(object value) => throw null;
        public static System.UInt16 ToUInt16(object value, System.IFormatProvider provider) => throw null;
        public static System.UInt16 ToUInt16(System.SByte value) => throw null;
        public static System.UInt16 ToUInt16(System.Int16 value) => throw null;
        public static System.UInt16 ToUInt16(string value) => throw null;
        public static System.UInt16 ToUInt16(string value, System.IFormatProvider provider) => throw null;
        public static System.UInt16 ToUInt16(string value, int fromBase) => throw null;
        public static System.UInt16 ToUInt16(System.UInt32 value) => throw null;
        public static System.UInt16 ToUInt16(System.UInt64 value) => throw null;
        public static System.UInt16 ToUInt16(System.UInt16 value) => throw null;
        public static System.UInt32 ToUInt32(System.DateTime value) => throw null;
        public static System.UInt32 ToUInt32(bool value) => throw null;
        public static System.UInt32 ToUInt32(System.Byte value) => throw null;
        public static System.UInt32 ToUInt32(System.Char value) => throw null;
        public static System.UInt32 ToUInt32(System.Decimal value) => throw null;
        public static System.UInt32 ToUInt32(double value) => throw null;
        public static System.UInt32 ToUInt32(float value) => throw null;
        public static System.UInt32 ToUInt32(int value) => throw null;
        public static System.UInt32 ToUInt32(System.Int64 value) => throw null;
        public static System.UInt32 ToUInt32(object value) => throw null;
        public static System.UInt32 ToUInt32(object value, System.IFormatProvider provider) => throw null;
        public static System.UInt32 ToUInt32(System.SByte value) => throw null;
        public static System.UInt32 ToUInt32(System.Int16 value) => throw null;
        public static System.UInt32 ToUInt32(string value) => throw null;
        public static System.UInt32 ToUInt32(string value, System.IFormatProvider provider) => throw null;
        public static System.UInt32 ToUInt32(string value, int fromBase) => throw null;
        public static System.UInt32 ToUInt32(System.UInt32 value) => throw null;
        public static System.UInt32 ToUInt32(System.UInt64 value) => throw null;
        public static System.UInt32 ToUInt32(System.UInt16 value) => throw null;
        public static System.UInt64 ToUInt64(System.DateTime value) => throw null;
        public static System.UInt64 ToUInt64(bool value) => throw null;
        public static System.UInt64 ToUInt64(System.Byte value) => throw null;
        public static System.UInt64 ToUInt64(System.Char value) => throw null;
        public static System.UInt64 ToUInt64(System.Decimal value) => throw null;
        public static System.UInt64 ToUInt64(double value) => throw null;
        public static System.UInt64 ToUInt64(float value) => throw null;
        public static System.UInt64 ToUInt64(int value) => throw null;
        public static System.UInt64 ToUInt64(System.Int64 value) => throw null;
        public static System.UInt64 ToUInt64(object value) => throw null;
        public static System.UInt64 ToUInt64(object value, System.IFormatProvider provider) => throw null;
        public static System.UInt64 ToUInt64(System.SByte value) => throw null;
        public static System.UInt64 ToUInt64(System.Int16 value) => throw null;
        public static System.UInt64 ToUInt64(string value) => throw null;
        public static System.UInt64 ToUInt64(string value, System.IFormatProvider provider) => throw null;
        public static System.UInt64 ToUInt64(string value, int fromBase) => throw null;
        public static System.UInt64 ToUInt64(System.UInt32 value) => throw null;
        public static System.UInt64 ToUInt64(System.UInt64 value) => throw null;
        public static System.UInt64 ToUInt64(System.UInt16 value) => throw null;
        public static bool TryFromBase64Chars(System.ReadOnlySpan<System.Char> chars, System.Span<System.Byte> bytes, out int bytesWritten) => throw null;
        public static bool TryFromBase64String(string s, System.Span<System.Byte> bytes, out int bytesWritten) => throw null;
        public static bool TryToBase64Chars(System.ReadOnlySpan<System.Byte> bytes, System.Span<System.Char> chars, out int charsWritten, System.Base64FormattingOptions options = default(System.Base64FormattingOptions)) => throw null;
    }

    public delegate TOutput Converter<TInput, TOutput>(TInput input);

    public class DBNull : System.IConvertible, System.Runtime.Serialization.ISerializable
    {
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.DBNull Value;
    }

    public struct DateOnly : System.IComparable, System.IComparable<System.DateOnly>, System.IEquatable<System.DateOnly>, System.IFormattable, System.IParsable<System.DateOnly>, System.ISpanFormattable, System.ISpanParsable<System.DateOnly>
    {
        public static bool operator !=(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator <(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator <=(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator ==(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator >(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator >=(System.DateOnly left, System.DateOnly right) => throw null;
        public System.DateOnly AddDays(int value) => throw null;
        public System.DateOnly AddMonths(int value) => throw null;
        public System.DateOnly AddYears(int value) => throw null;
        public int CompareTo(System.DateOnly value) => throw null;
        public int CompareTo(object value) => throw null;
        // Stub generator skipped constructor 
        public DateOnly(int year, int month, int day) => throw null;
        public DateOnly(int year, int month, int day, System.Globalization.Calendar calendar) => throw null;
        public int Day { get => throw null; }
        public int DayNumber { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public bool Equals(System.DateOnly value) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.DateOnly FromDateTime(System.DateTime dateTime) => throw null;
        public static System.DateOnly FromDayNumber(int dayNumber) => throw null;
        public override int GetHashCode() => throw null;
        public static System.DateOnly MaxValue { get => throw null; }
        public static System.DateOnly MinValue { get => throw null; }
        public int Month { get => throw null; }
        public static System.DateOnly Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.DateOnly Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly Parse(string s) => throw null;
        public static System.DateOnly Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.DateOnly Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<System.Char> s, string[] formats) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(string s, string[] formats) => throw null;
        public static System.DateOnly ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(string s, string format) => throw null;
        public static System.DateOnly ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public System.DateTime ToDateTime(System.TimeOnly time) => throw null;
        public System.DateTime ToDateTime(System.TimeOnly time, System.DateTimeKind kind) => throw null;
        public string ToLongDateString() => throw null;
        public string ToShortDateString() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.DateOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.DateOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.DateOnly result) => throw null;
        public static bool TryParse(string s, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string format, out System.DateOnly result) => throw null;
        public int Year { get => throw null; }
    }

    public struct DateTime : System.IComparable, System.IComparable<System.DateTime>, System.IConvertible, System.IEquatable<System.DateTime>, System.IFormattable, System.IParsable<System.DateTime>, System.ISpanFormattable, System.ISpanParsable<System.DateTime>, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.DateTime d1, System.DateTime d2) => throw null;
        public static System.DateTime operator +(System.DateTime d, System.TimeSpan t) => throw null;
        public static System.TimeSpan operator -(System.DateTime d1, System.DateTime d2) => throw null;
        public static System.DateTime operator -(System.DateTime d, System.TimeSpan t) => throw null;
        public static bool operator <(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator <=(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator ==(System.DateTime d1, System.DateTime d2) => throw null;
        public static bool operator >(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator >=(System.DateTime t1, System.DateTime t2) => throw null;
        public System.DateTime Add(System.TimeSpan value) => throw null;
        public System.DateTime AddDays(double value) => throw null;
        public System.DateTime AddHours(double value) => throw null;
        public System.DateTime AddMicroseconds(double value) => throw null;
        public System.DateTime AddMilliseconds(double value) => throw null;
        public System.DateTime AddMinutes(double value) => throw null;
        public System.DateTime AddMonths(int months) => throw null;
        public System.DateTime AddSeconds(double value) => throw null;
        public System.DateTime AddTicks(System.Int64 value) => throw null;
        public System.DateTime AddYears(int value) => throw null;
        public static int Compare(System.DateTime t1, System.DateTime t2) => throw null;
        public int CompareTo(System.DateTime value) => throw null;
        public int CompareTo(object value) => throw null;
        public System.DateTime Date { get => throw null; }
        // Stub generator skipped constructor 
        public DateTime(int year, int month, int day) => throw null;
        public DateTime(int year, int month, int day, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.DateTimeKind kind) => throw null;
        public DateTime(System.Int64 ticks) => throw null;
        public DateTime(System.Int64 ticks, System.DateTimeKind kind) => throw null;
        public int Day { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public static int DaysInMonth(int year, int month) => throw null;
        public bool Equals(System.DateTime value) => throw null;
        public static bool Equals(System.DateTime t1, System.DateTime t2) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.DateTime FromBinary(System.Int64 dateData) => throw null;
        public static System.DateTime FromFileTime(System.Int64 fileTime) => throw null;
        public static System.DateTime FromFileTimeUtc(System.Int64 fileTime) => throw null;
        public static System.DateTime FromOADate(double d) => throw null;
        public string[] GetDateTimeFormats() => throw null;
        public string[] GetDateTimeFormats(System.IFormatProvider provider) => throw null;
        public string[] GetDateTimeFormats(System.Char format) => throw null;
        public string[] GetDateTimeFormats(System.Char format, System.IFormatProvider provider) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public int Hour { get => throw null; }
        public bool IsDaylightSavingTime() => throw null;
        public static bool IsLeapYear(int year) => throw null;
        public System.DateTimeKind Kind { get => throw null; }
        public static System.DateTime MaxValue;
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public static System.DateTime MinValue;
        public int Minute { get => throw null; }
        public int Month { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static System.DateTime Now { get => throw null; }
        public static System.DateTime Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.DateTime Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime Parse(string s) => throw null;
        public static System.DateTime Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.DateTime Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTime ParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime ParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) => throw null;
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider) => throw null;
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) => throw null;
        public int Second { get => throw null; }
        public static System.DateTime SpecifyKind(System.DateTime value, System.DateTimeKind kind) => throw null;
        public System.TimeSpan Subtract(System.DateTime value) => throw null;
        public System.DateTime Subtract(System.TimeSpan value) => throw null;
        public System.Int64 Ticks { get => throw null; }
        public System.TimeSpan TimeOfDay { get => throw null; }
        public System.Int64 ToBinary() => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        public System.Int64 ToFileTime() => throw null;
        public System.Int64 ToFileTimeUtc() => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public System.DateTime ToLocalTime() => throw null;
        public string ToLongDateString() => throw null;
        public string ToLongTimeString() => throw null;
        public double ToOADate() => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        public string ToShortDateString() => throw null;
        public string ToShortTimeString() => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public System.DateTime ToUniversalTime() => throw null;
        public static System.DateTime Today { get => throw null; }
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, out System.DateTime result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.DateTime result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.DateTime result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, out System.DateTime result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.DateTime result) => throw null;
        public static bool TryParse(string s, out System.DateTime result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static System.DateTime UnixEpoch;
        public static System.DateTime UtcNow { get => throw null; }
        public int Year { get => throw null; }
    }

    public enum DateTimeKind : int
    {
        Local = 2,
        Unspecified = 0,
        Utc = 1,
    }

    public struct DateTimeOffset : System.IComparable, System.IComparable<System.DateTimeOffset>, System.IEquatable<System.DateTimeOffset>, System.IFormattable, System.IParsable<System.DateTimeOffset>, System.ISpanFormattable, System.ISpanParsable<System.DateTimeOffset>, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static System.DateTimeOffset operator +(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) => throw null;
        public static System.TimeSpan operator -(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static System.DateTimeOffset operator -(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) => throw null;
        public static bool operator <(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator <=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator ==(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator >(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator >=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public System.DateTimeOffset Add(System.TimeSpan timeSpan) => throw null;
        public System.DateTimeOffset AddDays(double days) => throw null;
        public System.DateTimeOffset AddHours(double hours) => throw null;
        public System.DateTimeOffset AddMicroseconds(double microseconds) => throw null;
        public System.DateTimeOffset AddMilliseconds(double milliseconds) => throw null;
        public System.DateTimeOffset AddMinutes(double minutes) => throw null;
        public System.DateTimeOffset AddMonths(int months) => throw null;
        public System.DateTimeOffset AddSeconds(double seconds) => throw null;
        public System.DateTimeOffset AddTicks(System.Int64 ticks) => throw null;
        public System.DateTimeOffset AddYears(int years) => throw null;
        public static int Compare(System.DateTimeOffset first, System.DateTimeOffset second) => throw null;
        public int CompareTo(System.DateTimeOffset other) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public System.DateTime Date { get => throw null; }
        public System.DateTime DateTime { get => throw null; }
        // Stub generator skipped constructor 
        public DateTimeOffset(System.DateTime dateTime) => throw null;
        public DateTimeOffset(System.DateTime dateTime, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.TimeSpan offset) => throw null;
        public DateTimeOffset(System.Int64 ticks, System.TimeSpan offset) => throw null;
        public int Day { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public bool Equals(System.DateTimeOffset other) => throw null;
        public static bool Equals(System.DateTimeOffset first, System.DateTimeOffset second) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool EqualsExact(System.DateTimeOffset other) => throw null;
        public static System.DateTimeOffset FromFileTime(System.Int64 fileTime) => throw null;
        public static System.DateTimeOffset FromUnixTimeMilliseconds(System.Int64 milliseconds) => throw null;
        public static System.DateTimeOffset FromUnixTimeSeconds(System.Int64 seconds) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public int Hour { get => throw null; }
        public System.DateTime LocalDateTime { get => throw null; }
        public static System.DateTimeOffset MaxValue;
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public static System.DateTimeOffset MinValue;
        public int Minute { get => throw null; }
        public int Month { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static System.DateTimeOffset Now { get => throw null; }
        public System.TimeSpan Offset { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public static System.DateTimeOffset Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.DateTimeOffset Parse(System.ReadOnlySpan<System.Char> input, System.IFormatProvider formatProvider = default(System.IFormatProvider), System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset Parse(string input) => throw null;
        public static System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider) => throw null;
        public static System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTimeOffset ParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset ParseExact(System.ReadOnlySpan<System.Char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public int Second { get => throw null; }
        public System.TimeSpan Subtract(System.DateTimeOffset value) => throw null;
        public System.DateTimeOffset Subtract(System.TimeSpan value) => throw null;
        public System.Int64 Ticks { get => throw null; }
        public System.TimeSpan TimeOfDay { get => throw null; }
        public System.Int64 ToFileTime() => throw null;
        public System.DateTimeOffset ToLocalTime() => throw null;
        public System.DateTimeOffset ToOffset(System.TimeSpan offset) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider formatProvider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public System.DateTimeOffset ToUniversalTime() => throw null;
        public System.Int64 ToUnixTimeMilliseconds() => throw null;
        public System.Int64 ToUnixTimeSeconds() => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> input, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(string input, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static System.DateTimeOffset UnixEpoch;
        public System.DateTime UtcDateTime { get => throw null; }
        public static System.DateTimeOffset UtcNow { get => throw null; }
        public System.Int64 UtcTicks { get => throw null; }
        public int Year { get => throw null; }
        public static implicit operator System.DateTimeOffset(System.DateTime dateTime) => throw null;
    }

    public enum DayOfWeek : int
    {
        Friday = 5,
        Monday = 1,
        Saturday = 6,
        Sunday = 0,
        Thursday = 4,
        Tuesday = 2,
        Wednesday = 3,
    }

    public struct Decimal : System.IComparable, System.IComparable<System.Decimal>, System.IConvertible, System.IEquatable<System.Decimal>, System.IFormattable, System.IParsable<System.Decimal>, System.ISpanFormattable, System.ISpanParsable<System.Decimal>, System.Numerics.IAdditionOperators<System.Decimal, System.Decimal, System.Decimal>, System.Numerics.IAdditiveIdentity<System.Decimal, System.Decimal>, System.Numerics.IComparisonOperators<System.Decimal, System.Decimal, bool>, System.Numerics.IDecrementOperators<System.Decimal>, System.Numerics.IDivisionOperators<System.Decimal, System.Decimal, System.Decimal>, System.Numerics.IEqualityOperators<System.Decimal, System.Decimal, bool>, System.Numerics.IFloatingPoint<System.Decimal>, System.Numerics.IFloatingPointConstants<System.Decimal>, System.Numerics.IIncrementOperators<System.Decimal>, System.Numerics.IMinMaxValue<System.Decimal>, System.Numerics.IModulusOperators<System.Decimal, System.Decimal, System.Decimal>, System.Numerics.IMultiplicativeIdentity<System.Decimal, System.Decimal>, System.Numerics.IMultiplyOperators<System.Decimal, System.Decimal, System.Decimal>, System.Numerics.INumber<System.Decimal>, System.Numerics.INumberBase<System.Decimal>, System.Numerics.ISignedNumber<System.Decimal>, System.Numerics.ISubtractionOperators<System.Decimal, System.Decimal, System.Decimal>, System.Numerics.IUnaryNegationOperators<System.Decimal, System.Decimal>, System.Numerics.IUnaryPlusOperators<System.Decimal, System.Decimal>, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
    {
        static bool System.Numerics.IEqualityOperators<System.Decimal, System.Decimal, bool>.operator !=(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IModulusOperators<System.Decimal, System.Decimal, System.Decimal>.operator %(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IMultiplyOperators<System.Decimal, System.Decimal, System.Decimal>.operator *(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IUnaryPlusOperators<System.Decimal, System.Decimal>.operator +(System.Decimal d) => throw null;
        static System.Decimal System.Numerics.IAdditionOperators<System.Decimal, System.Decimal, System.Decimal>.operator +(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IIncrementOperators<System.Decimal>.operator ++(System.Decimal d) => throw null;
        static System.Decimal System.Numerics.IUnaryNegationOperators<System.Decimal, System.Decimal>.operator -(System.Decimal d) => throw null;
        static System.Decimal System.Numerics.ISubtractionOperators<System.Decimal, System.Decimal, System.Decimal>.operator -(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IDecrementOperators<System.Decimal>.operator --(System.Decimal d) => throw null;
        static System.Decimal System.Numerics.IDivisionOperators<System.Decimal, System.Decimal, System.Decimal>.operator /(System.Decimal d1, System.Decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Decimal, System.Decimal, bool>.operator <(System.Decimal d1, System.Decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Decimal, System.Decimal, bool>.operator <=(System.Decimal d1, System.Decimal d2) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Decimal, System.Decimal, bool>.operator ==(System.Decimal d1, System.Decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Decimal, System.Decimal, bool>.operator >(System.Decimal d1, System.Decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Decimal, System.Decimal, bool>.operator >=(System.Decimal d1, System.Decimal d2) => throw null;
        public static System.Decimal Abs(System.Decimal value) => throw null;
        public static System.Decimal Add(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IAdditiveIdentity<System.Decimal, System.Decimal>.AdditiveIdentity { get => throw null; }
        public static System.Decimal Ceiling(System.Decimal d) => throw null;
        public static System.Decimal Clamp(System.Decimal value, System.Decimal min, System.Decimal max) => throw null;
        public static int Compare(System.Decimal d1, System.Decimal d2) => throw null;
        public int CompareTo(System.Decimal value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.Decimal CopySign(System.Decimal value, System.Decimal sign) => throw null;
        static System.Decimal System.Numerics.INumberBase<System.Decimal>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Decimal System.Numerics.INumberBase<System.Decimal>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Decimal System.Numerics.INumberBase<System.Decimal>.CreateTruncating<TOther>(TOther value) => throw null;
        // Stub generator skipped constructor 
        public Decimal(int[] bits) => throw null;
        public Decimal(System.ReadOnlySpan<int> bits) => throw null;
        public Decimal(double value) => throw null;
        public Decimal(float value) => throw null;
        public Decimal(int value) => throw null;
        public Decimal(int lo, int mid, int hi, bool isNegative, System.Byte scale) => throw null;
        public Decimal(System.Int64 value) => throw null;
        public Decimal(System.UInt32 value) => throw null;
        public Decimal(System.UInt64 value) => throw null;
        public static System.Decimal Divide(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IFloatingPointConstants<System.Decimal>.E { get => throw null; }
        public bool Equals(System.Decimal value) => throw null;
        public static bool Equals(System.Decimal d1, System.Decimal d2) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.Decimal Floor(System.Decimal d) => throw null;
        public static System.Decimal FromOACurrency(System.Int64 cy) => throw null;
        public static int[] GetBits(System.Decimal d) => throw null;
        public static int GetBits(System.Decimal d, System.Span<int> destination) => throw null;
        int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.Decimal value) => throw null;
        public static bool IsComplexNumber(System.Decimal value) => throw null;
        public static bool IsEvenInteger(System.Decimal value) => throw null;
        public static bool IsFinite(System.Decimal value) => throw null;
        public static bool IsImaginaryNumber(System.Decimal value) => throw null;
        public static bool IsInfinity(System.Decimal value) => throw null;
        public static bool IsInteger(System.Decimal value) => throw null;
        public static bool IsNaN(System.Decimal value) => throw null;
        public static bool IsNegative(System.Decimal value) => throw null;
        public static bool IsNegativeInfinity(System.Decimal value) => throw null;
        public static bool IsNormal(System.Decimal value) => throw null;
        public static bool IsOddInteger(System.Decimal value) => throw null;
        public static bool IsPositive(System.Decimal value) => throw null;
        public static bool IsPositiveInfinity(System.Decimal value) => throw null;
        public static bool IsRealNumber(System.Decimal value) => throw null;
        public static bool IsSubnormal(System.Decimal value) => throw null;
        public static bool IsZero(System.Decimal value) => throw null;
        public static System.Decimal Max(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MaxMagnitude(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MaxMagnitudeNumber(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MaxNumber(System.Decimal x, System.Decimal y) => throw null;
        public const System.Decimal MaxValue = default;
        static System.Decimal System.Numerics.IMinMaxValue<System.Decimal>.MaxValue { get => throw null; }
        public static System.Decimal Min(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MinMagnitude(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MinMagnitudeNumber(System.Decimal x, System.Decimal y) => throw null;
        public static System.Decimal MinNumber(System.Decimal x, System.Decimal y) => throw null;
        public const System.Decimal MinValue = default;
        static System.Decimal System.Numerics.IMinMaxValue<System.Decimal>.MinValue { get => throw null; }
        public const System.Decimal MinusOne = default;
        static System.Decimal System.Numerics.IMultiplicativeIdentity<System.Decimal, System.Decimal>.MultiplicativeIdentity { get => throw null; }
        public static System.Decimal Multiply(System.Decimal d1, System.Decimal d2) => throw null;
        public static System.Decimal Negate(System.Decimal d) => throw null;
        static System.Decimal System.Numerics.ISignedNumber<System.Decimal>.NegativeOne { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public const System.Decimal One = default;
        static System.Decimal System.Numerics.INumberBase<System.Decimal>.One { get => throw null; }
        public static System.Decimal Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Decimal Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Decimal Parse(string s) => throw null;
        public static System.Decimal Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Decimal Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Decimal Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static System.Decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Pi { get => throw null; }
        static int System.Numerics.INumberBase<System.Decimal>.Radix { get => throw null; }
        public static System.Decimal Remainder(System.Decimal d1, System.Decimal d2) => throw null;
        public static System.Decimal Round(System.Decimal d) => throw null;
        public static System.Decimal Round(System.Decimal d, System.MidpointRounding mode) => throw null;
        public static System.Decimal Round(System.Decimal d, int decimals) => throw null;
        public static System.Decimal Round(System.Decimal d, int decimals, System.MidpointRounding mode) => throw null;
        public System.Byte Scale { get => throw null; }
        public static int Sign(System.Decimal d) => throw null;
        public static System.Decimal Subtract(System.Decimal d1, System.Decimal d2) => throw null;
        static System.Decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        public static System.Byte ToByte(System.Decimal value) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        public static double ToDouble(System.Decimal d) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        public static System.Int16 ToInt16(System.Decimal value) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        public static int ToInt32(System.Decimal d) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static System.Int64 ToInt64(System.Decimal d) => throw null;
        public static System.Int64 ToOACurrency(System.Decimal value) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        public static System.SByte ToSByte(System.Decimal value) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public static float ToSingle(System.Decimal d) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        public static System.UInt16 ToUInt16(System.Decimal value) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        public static System.UInt32 ToUInt32(System.Decimal d) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.UInt64 ToUInt64(System.Decimal d) => throw null;
        public static System.Decimal Truncate(System.Decimal d) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromChecked<TOther>(TOther value, out System.Decimal result) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromSaturating<TOther>(TOther value, out System.Decimal result) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromTruncating<TOther>(TOther value, out System.Decimal result) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertToChecked<TOther>(System.Decimal value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertToSaturating<TOther>(System.Decimal value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Decimal>.TryConvertToTruncating<TOther>(System.Decimal value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryGetBits(System.Decimal d, System.Span<int> destination, out int valuesWritten) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Decimal result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Decimal result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Decimal result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Decimal result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Decimal result) => throw null;
        public static bool TryParse(string s, out System.Decimal result) => throw null;
        bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        public const System.Decimal Zero = default;
        static System.Decimal System.Numerics.INumberBase<System.Decimal>.Zero { get => throw null; }
        public static explicit operator System.Byte(System.Decimal value) => throw null;
        public static explicit operator System.Char(System.Decimal value) => throw null;
        public static explicit operator System.Int16(System.Decimal value) => throw null;
        public static explicit operator System.Int64(System.Decimal value) => throw null;
        public static explicit operator System.SByte(System.Decimal value) => throw null;
        public static explicit operator System.UInt16(System.Decimal value) => throw null;
        public static explicit operator System.UInt32(System.Decimal value) => throw null;
        public static explicit operator System.UInt64(System.Decimal value) => throw null;
        public static explicit operator double(System.Decimal value) => throw null;
        public static explicit operator float(System.Decimal value) => throw null;
        public static explicit operator int(System.Decimal value) => throw null;
        public static explicit operator System.Decimal(double value) => throw null;
        public static explicit operator System.Decimal(float value) => throw null;
        public static implicit operator System.Decimal(System.Byte value) => throw null;
        public static implicit operator System.Decimal(System.Char value) => throw null;
        public static implicit operator System.Decimal(int value) => throw null;
        public static implicit operator System.Decimal(System.Int64 value) => throw null;
        public static implicit operator System.Decimal(System.SByte value) => throw null;
        public static implicit operator System.Decimal(System.Int16 value) => throw null;
        public static implicit operator System.Decimal(System.UInt32 value) => throw null;
        public static implicit operator System.Decimal(System.UInt64 value) => throw null;
        public static implicit operator System.Decimal(System.UInt16 value) => throw null;
    }

    public abstract class Delegate : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.Delegate d1, System.Delegate d2) => throw null;
        public static bool operator ==(System.Delegate d1, System.Delegate d2) => throw null;
        public virtual object Clone() => throw null;
        public static System.Delegate Combine(System.Delegate a, System.Delegate b) => throw null;
        public static System.Delegate Combine(params System.Delegate[] delegates) => throw null;
        protected virtual System.Delegate CombineImpl(System.Delegate d) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) => throw null;
        protected Delegate(System.Type target, string method) => throw null;
        protected Delegate(object target, string method) => throw null;
        public object DynamicInvoke(params object[] args) => throw null;
        protected virtual object DynamicInvokeImpl(object[] args) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public virtual System.Delegate[] GetInvocationList() => throw null;
        protected virtual System.Reflection.MethodInfo GetMethodImpl() => throw null;
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.Reflection.MethodInfo Method { get => throw null; }
        public static System.Delegate Remove(System.Delegate source, System.Delegate value) => throw null;
        public static System.Delegate RemoveAll(System.Delegate source, System.Delegate value) => throw null;
        protected virtual System.Delegate RemoveImpl(System.Delegate d) => throw null;
        public object Target { get => throw null; }
    }

    public class DivideByZeroException : System.ArithmeticException
    {
        public DivideByZeroException() => throw null;
        protected DivideByZeroException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public DivideByZeroException(string message) => throw null;
        public DivideByZeroException(string message, System.Exception innerException) => throw null;
    }

    public struct Double : System.IComparable, System.IComparable<double>, System.IConvertible, System.IEquatable<double>, System.IFormattable, System.IParsable<double>, System.ISpanFormattable, System.ISpanParsable<double>, System.Numerics.IAdditionOperators<double, double, double>, System.Numerics.IAdditiveIdentity<double, double>, System.Numerics.IBinaryFloatingPointIeee754<double>, System.Numerics.IBinaryNumber<double>, System.Numerics.IBitwiseOperators<double, double, double>, System.Numerics.IComparisonOperators<double, double, bool>, System.Numerics.IDecrementOperators<double>, System.Numerics.IDivisionOperators<double, double, double>, System.Numerics.IEqualityOperators<double, double, bool>, System.Numerics.IExponentialFunctions<double>, System.Numerics.IFloatingPoint<double>, System.Numerics.IFloatingPointConstants<double>, System.Numerics.IFloatingPointIeee754<double>, System.Numerics.IHyperbolicFunctions<double>, System.Numerics.IIncrementOperators<double>, System.Numerics.ILogarithmicFunctions<double>, System.Numerics.IMinMaxValue<double>, System.Numerics.IModulusOperators<double, double, double>, System.Numerics.IMultiplicativeIdentity<double, double>, System.Numerics.IMultiplyOperators<double, double, double>, System.Numerics.INumber<double>, System.Numerics.INumberBase<double>, System.Numerics.IPowerFunctions<double>, System.Numerics.IRootFunctions<double>, System.Numerics.ISignedNumber<double>, System.Numerics.ISubtractionOperators<double, double, double>, System.Numerics.ITrigonometricFunctions<double>, System.Numerics.IUnaryNegationOperators<double, double>, System.Numerics.IUnaryPlusOperators<double, double>
    {
        static bool System.Numerics.IEqualityOperators<double, double, bool>.operator !=(double left, double right) => throw null;
        static double System.Numerics.IModulusOperators<double, double, double>.operator %(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator &(double left, double right) => throw null;
        static double System.Numerics.IMultiplyOperators<double, double, double>.operator *(double left, double right) => throw null;
        static double System.Numerics.IUnaryPlusOperators<double, double>.operator +(double value) => throw null;
        static double System.Numerics.IAdditionOperators<double, double, double>.operator +(double left, double right) => throw null;
        static double System.Numerics.IIncrementOperators<double>.operator ++(double value) => throw null;
        static double System.Numerics.IUnaryNegationOperators<double, double>.operator -(double value) => throw null;
        static double System.Numerics.ISubtractionOperators<double, double, double>.operator -(double left, double right) => throw null;
        static double System.Numerics.IDecrementOperators<double>.operator --(double value) => throw null;
        static double System.Numerics.IDivisionOperators<double, double, double>.operator /(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator <(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator <=(double left, double right) => throw null;
        static bool System.Numerics.IEqualityOperators<double, double, bool>.operator ==(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator >(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator >=(double left, double right) => throw null;
        public static double Abs(double value) => throw null;
        public static double Acos(double x) => throw null;
        public static double AcosPi(double x) => throw null;
        public static double Acosh(double x) => throw null;
        static double System.Numerics.IAdditiveIdentity<double, double>.AdditiveIdentity { get => throw null; }
        static double System.Numerics.IBinaryNumber<double>.AllBitsSet { get => throw null; }
        public static double Asin(double x) => throw null;
        public static double AsinPi(double x) => throw null;
        public static double Asinh(double x) => throw null;
        public static double Atan(double x) => throw null;
        public static double Atan2(double y, double x) => throw null;
        public static double Atan2Pi(double y, double x) => throw null;
        public static double AtanPi(double x) => throw null;
        public static double Atanh(double x) => throw null;
        public static double BitDecrement(double x) => throw null;
        public static double BitIncrement(double x) => throw null;
        public static double Cbrt(double x) => throw null;
        public static double Ceiling(double x) => throw null;
        public static double Clamp(double value, double min, double max) => throw null;
        public int CompareTo(double value) => throw null;
        public int CompareTo(object value) => throw null;
        public static double CopySign(double value, double sign) => throw null;
        public static double Cos(double x) => throw null;
        public static double CosPi(double x) => throw null;
        public static double Cosh(double x) => throw null;
        static double System.Numerics.INumberBase<double>.CreateChecked<TOther>(TOther value) => throw null;
        static double System.Numerics.INumberBase<double>.CreateSaturating<TOther>(TOther value) => throw null;
        static double System.Numerics.INumberBase<double>.CreateTruncating<TOther>(TOther value) => throw null;
        // Stub generator skipped constructor 
        public const double E = default;
        static double System.Numerics.IFloatingPointConstants<double>.E { get => throw null; }
        public const double Epsilon = default;
        static double System.Numerics.IFloatingPointIeee754<double>.Epsilon { get => throw null; }
        public bool Equals(double obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public static double Exp(double x) => throw null;
        public static double Exp10(double x) => throw null;
        public static double Exp10M1(double x) => throw null;
        public static double Exp2(double x) => throw null;
        public static double Exp2M1(double x) => throw null;
        public static double ExpM1(double x) => throw null;
        public static double Floor(double x) => throw null;
        public static double FusedMultiplyAdd(double left, double right, double addend) => throw null;
        int System.Numerics.IFloatingPoint<double>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static double Hypot(double x, double y) => throw null;
        public static int ILogB(double x) => throw null;
        public static double Ieee754Remainder(double left, double right) => throw null;
        public static bool IsCanonical(double value) => throw null;
        public static bool IsComplexNumber(double value) => throw null;
        public static bool IsEvenInteger(double value) => throw null;
        public static bool IsFinite(double d) => throw null;
        public static bool IsImaginaryNumber(double value) => throw null;
        public static bool IsInfinity(double d) => throw null;
        public static bool IsInteger(double value) => throw null;
        public static bool IsNaN(double d) => throw null;
        public static bool IsNegative(double d) => throw null;
        public static bool IsNegativeInfinity(double d) => throw null;
        public static bool IsNormal(double d) => throw null;
        public static bool IsOddInteger(double value) => throw null;
        public static bool IsPositive(double value) => throw null;
        public static bool IsPositiveInfinity(double d) => throw null;
        public static bool IsPow2(double value) => throw null;
        public static bool IsRealNumber(double value) => throw null;
        public static bool IsSubnormal(double d) => throw null;
        public static bool IsZero(double value) => throw null;
        public static double Log(double x) => throw null;
        public static double Log(double x, double newBase) => throw null;
        public static double Log10(double x) => throw null;
        public static double Log10P1(double x) => throw null;
        public static double Log2(double value) => throw null;
        public static double Log2P1(double x) => throw null;
        public static double LogP1(double x) => throw null;
        public static double Max(double x, double y) => throw null;
        public static double MaxMagnitude(double x, double y) => throw null;
        public static double MaxMagnitudeNumber(double x, double y) => throw null;
        public static double MaxNumber(double x, double y) => throw null;
        public const double MaxValue = default;
        static double System.Numerics.IMinMaxValue<double>.MaxValue { get => throw null; }
        public static double Min(double x, double y) => throw null;
        public static double MinMagnitude(double x, double y) => throw null;
        public static double MinMagnitudeNumber(double x, double y) => throw null;
        public static double MinNumber(double x, double y) => throw null;
        public const double MinValue = default;
        static double System.Numerics.IMinMaxValue<double>.MinValue { get => throw null; }
        static double System.Numerics.IMultiplicativeIdentity<double, double>.MultiplicativeIdentity { get => throw null; }
        public const double NaN = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NaN { get => throw null; }
        public const double NegativeInfinity = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NegativeInfinity { get => throw null; }
        static double System.Numerics.ISignedNumber<double>.NegativeOne { get => throw null; }
        public const double NegativeZero = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NegativeZero { get => throw null; }
        static double System.Numerics.INumberBase<double>.One { get => throw null; }
        public static double Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static double Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static double Parse(string s) => throw null;
        public static double Parse(string s, System.IFormatProvider provider) => throw null;
        public static double Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static double Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public const double Pi = default;
        static double System.Numerics.IFloatingPointConstants<double>.Pi { get => throw null; }
        public const double PositiveInfinity = default;
        static double System.Numerics.IFloatingPointIeee754<double>.PositiveInfinity { get => throw null; }
        public static double Pow(double x, double y) => throw null;
        static int System.Numerics.INumberBase<double>.Radix { get => throw null; }
        public static double ReciprocalEstimate(double x) => throw null;
        public static double ReciprocalSqrtEstimate(double x) => throw null;
        public static double RootN(double x, int n) => throw null;
        public static double Round(double x) => throw null;
        public static double Round(double x, System.MidpointRounding mode) => throw null;
        public static double Round(double x, int digits) => throw null;
        public static double Round(double x, int digits, System.MidpointRounding mode) => throw null;
        public static double ScaleB(double x, int n) => throw null;
        public static int Sign(double value) => throw null;
        public static double Sin(double x) => throw null;
        public static (double, double) SinCos(double x) => throw null;
        public static (double, double) SinCosPi(double x) => throw null;
        public static double SinPi(double x) => throw null;
        public static double Sinh(double x) => throw null;
        public static double Sqrt(double x) => throw null;
        public static double Tan(double x) => throw null;
        public static double TanPi(double x) => throw null;
        public static double Tanh(double x) => throw null;
        public const double Tau = default;
        static double System.Numerics.IFloatingPointConstants<double>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static double Truncate(double x) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromChecked<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromSaturating<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromTruncating<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToChecked<TOther>(double value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToSaturating<TOther>(double value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToTruncating<TOther>(double value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out double result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(string s, out double result) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteExponentBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteExponentLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteSignificandBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteSignificandLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static double System.Numerics.INumberBase<double>.Zero { get => throw null; }
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator ^(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator |(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator ~(double value) => throw null;
    }

    public class DuplicateWaitObjectException : System.ArgumentException
    {
        public DuplicateWaitObjectException() => throw null;
        protected DuplicateWaitObjectException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public DuplicateWaitObjectException(string parameterName) => throw null;
        public DuplicateWaitObjectException(string message, System.Exception innerException) => throw null;
        public DuplicateWaitObjectException(string parameterName, string message) => throw null;
    }

    public class EntryPointNotFoundException : System.TypeLoadException
    {
        public EntryPointNotFoundException() => throw null;
        protected EntryPointNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public EntryPointNotFoundException(string message) => throw null;
        public EntryPointNotFoundException(string message, System.Exception inner) => throw null;
    }

    public abstract class Enum : System.IComparable, System.IConvertible, System.IFormattable
    {
        public int CompareTo(object target) => throw null;
        protected Enum() => throw null;
        public override bool Equals(object obj) => throw null;
        public static string Format(System.Type enumType, object value, string format) => throw null;
        public override int GetHashCode() => throw null;
        public static string GetName(System.Type enumType, object value) => throw null;
        public static string GetName<TEnum>(TEnum value) where TEnum : System.Enum => throw null;
        public static string[] GetNames(System.Type enumType) => throw null;
        public static string[] GetNames<TEnum>() where TEnum : System.Enum => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static System.Type GetUnderlyingType(System.Type enumType) => throw null;
        public static System.Array GetValues(System.Type enumType) => throw null;
        public static TEnum[] GetValues<TEnum>() where TEnum : System.Enum => throw null;
        public static System.Array GetValuesAsUnderlyingType(System.Type enumType) => throw null;
        public static System.Array GetValuesAsUnderlyingType<TEnum>() where TEnum : System.Enum => throw null;
        public bool HasFlag(System.Enum flag) => throw null;
        public static bool IsDefined(System.Type enumType, object value) => throw null;
        public static bool IsDefined<TEnum>(TEnum value) where TEnum : System.Enum => throw null;
        public static object Parse(System.Type enumType, System.ReadOnlySpan<System.Char> value) => throw null;
        public static object Parse(System.Type enumType, System.ReadOnlySpan<System.Char> value, bool ignoreCase) => throw null;
        public static object Parse(System.Type enumType, string value) => throw null;
        public static object Parse(System.Type enumType, string value, bool ignoreCase) => throw null;
        public static TEnum Parse<TEnum>(System.ReadOnlySpan<System.Char> value) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(System.ReadOnlySpan<System.Char> value, bool ignoreCase) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(string value) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(string value, bool ignoreCase) where TEnum : struct => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static object ToObject(System.Type enumType, System.Byte value) => throw null;
        public static object ToObject(System.Type enumType, int value) => throw null;
        public static object ToObject(System.Type enumType, System.Int64 value) => throw null;
        public static object ToObject(System.Type enumType, object value) => throw null;
        public static object ToObject(System.Type enumType, System.SByte value) => throw null;
        public static object ToObject(System.Type enumType, System.Int16 value) => throw null;
        public static object ToObject(System.Type enumType, System.UInt32 value) => throw null;
        public static object ToObject(System.Type enumType, System.UInt64 value) => throw null;
        public static object ToObject(System.Type enumType, System.UInt16 value) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static bool TryParse(System.Type enumType, System.ReadOnlySpan<System.Char> value, bool ignoreCase, out object result) => throw null;
        public static bool TryParse(System.Type enumType, System.ReadOnlySpan<System.Char> value, out object result) => throw null;
        public static bool TryParse(System.Type enumType, string value, bool ignoreCase, out object result) => throw null;
        public static bool TryParse(System.Type enumType, string value, out object result) => throw null;
        public static bool TryParse<TEnum>(System.ReadOnlySpan<System.Char> value, bool ignoreCase, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(System.ReadOnlySpan<System.Char> value, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct => throw null;
    }

    public static class Environment
    {
        public enum SpecialFolder : int
        {
            AdminTools = 48,
            ApplicationData = 26,
            CDBurning = 59,
            CommonAdminTools = 47,
            CommonApplicationData = 35,
            CommonDesktopDirectory = 25,
            CommonDocuments = 46,
            CommonMusic = 53,
            CommonOemLinks = 58,
            CommonPictures = 54,
            CommonProgramFiles = 43,
            CommonProgramFilesX86 = 44,
            CommonPrograms = 23,
            CommonStartMenu = 22,
            CommonStartup = 24,
            CommonTemplates = 45,
            CommonVideos = 55,
            Cookies = 33,
            Desktop = 0,
            DesktopDirectory = 16,
            Favorites = 6,
            Fonts = 20,
            History = 34,
            InternetCache = 32,
            LocalApplicationData = 28,
            LocalizedResources = 57,
            MyComputer = 17,
            MyDocuments = 5,
            MyMusic = 13,
            MyPictures = 39,
            MyVideos = 14,
            NetworkShortcuts = 19,
            Personal = 5,
            PrinterShortcuts = 27,
            ProgramFiles = 38,
            ProgramFilesX86 = 42,
            Programs = 2,
            Recent = 8,
            Resources = 56,
            SendTo = 9,
            StartMenu = 11,
            Startup = 7,
            System = 37,
            SystemX86 = 41,
            Templates = 21,
            UserProfile = 40,
            Windows = 36,
        }


        public enum SpecialFolderOption : int
        {
            Create = 32768,
            DoNotVerify = 16384,
            None = 0,
        }


        public static string CommandLine { get => throw null; }
        public static string CurrentDirectory { get => throw null; set => throw null; }
        public static int CurrentManagedThreadId { get => throw null; }
        public static void Exit(int exitCode) => throw null;
        public static int ExitCode { get => throw null; set => throw null; }
        public static string ExpandEnvironmentVariables(string name) => throw null;
        public static void FailFast(string message) => throw null;
        public static void FailFast(string message, System.Exception exception) => throw null;
        public static string[] GetCommandLineArgs() => throw null;
        public static string GetEnvironmentVariable(string variable) => throw null;
        public static string GetEnvironmentVariable(string variable, System.EnvironmentVariableTarget target) => throw null;
        public static System.Collections.IDictionary GetEnvironmentVariables() => throw null;
        public static System.Collections.IDictionary GetEnvironmentVariables(System.EnvironmentVariableTarget target) => throw null;
        public static string GetFolderPath(System.Environment.SpecialFolder folder) => throw null;
        public static string GetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option) => throw null;
        public static string[] GetLogicalDrives() => throw null;
        public static bool HasShutdownStarted { get => throw null; }
        public static bool Is64BitOperatingSystem { get => throw null; }
        public static bool Is64BitProcess { get => throw null; }
        public static string MachineName { get => throw null; }
        public static string NewLine { get => throw null; }
        public static System.OperatingSystem OSVersion { get => throw null; }
        public static int ProcessId { get => throw null; }
        public static string ProcessPath { get => throw null; }
        public static int ProcessorCount { get => throw null; }
        public static void SetEnvironmentVariable(string variable, string value) => throw null;
        public static void SetEnvironmentVariable(string variable, string value, System.EnvironmentVariableTarget target) => throw null;
        public static string StackTrace { get => throw null; }
        public static string SystemDirectory { get => throw null; }
        public static int SystemPageSize { get => throw null; }
        public static int TickCount { get => throw null; }
        public static System.Int64 TickCount64 { get => throw null; }
        public static string UserDomainName { get => throw null; }
        public static bool UserInteractive { get => throw null; }
        public static string UserName { get => throw null; }
        public static System.Version Version { get => throw null; }
        public static System.Int64 WorkingSet { get => throw null; }
    }

    public enum EnvironmentVariableTarget : int
    {
        Machine = 2,
        Process = 0,
        User = 1,
    }

    public class EventArgs
    {
        public static System.EventArgs Empty;
        public EventArgs() => throw null;
    }

    public delegate void EventHandler(object sender, System.EventArgs e);

    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);

    public class Exception : System.Runtime.Serialization.ISerializable
    {
        public virtual System.Collections.IDictionary Data { get => throw null; }
        public Exception() => throw null;
        protected Exception(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public Exception(string message) => throw null;
        public Exception(string message, System.Exception innerException) => throw null;
        public virtual System.Exception GetBaseException() => throw null;
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.Type GetType() => throw null;
        public int HResult { get => throw null; set => throw null; }
        public virtual string HelpLink { get => throw null; set => throw null; }
        public System.Exception InnerException { get => throw null; }
        public virtual string Message { get => throw null; }
        protected event System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> SerializeObjectState;
        public virtual string Source { get => throw null; set => throw null; }
        public virtual string StackTrace { get => throw null; }
        public System.Reflection.MethodBase TargetSite { get => throw null; }
        public override string ToString() => throw null;
    }

    public class ExecutionEngineException : System.SystemException
    {
        public ExecutionEngineException() => throw null;
        public ExecutionEngineException(string message) => throw null;
        public ExecutionEngineException(string message, System.Exception innerException) => throw null;
    }

    public class FieldAccessException : System.MemberAccessException
    {
        public FieldAccessException() => throw null;
        protected FieldAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public FieldAccessException(string message) => throw null;
        public FieldAccessException(string message, System.Exception inner) => throw null;
    }

    public class FileStyleUriParser : System.UriParser
    {
        public FileStyleUriParser() => throw null;
    }

    public class FlagsAttribute : System.Attribute
    {
        public FlagsAttribute() => throw null;
    }

    public class FormatException : System.SystemException
    {
        public FormatException() => throw null;
        protected FormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public FormatException(string message) => throw null;
        public FormatException(string message, System.Exception innerException) => throw null;
    }

    public abstract class FormattableString : System.IFormattable
    {
        public abstract int ArgumentCount { get; }
        public static string CurrentCulture(System.FormattableString formattable) => throw null;
        public abstract string Format { get; }
        protected FormattableString() => throw null;
        public abstract object GetArgument(int index);
        public abstract object[] GetArguments();
        public static string Invariant(System.FormattableString formattable) => throw null;
        public override string ToString() => throw null;
        public abstract string ToString(System.IFormatProvider formatProvider);
        string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider) => throw null;
    }

    public class FtpStyleUriParser : System.UriParser
    {
        public FtpStyleUriParser() => throw null;
    }

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);

    public delegate TResult Func<T1, T2, T3, T4, T5, T6, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);

    public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);

    public delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);

    public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);

    public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);

    public delegate TResult Func<T, TResult>(T arg);

    public delegate TResult Func<TResult>();

    public static class GC
    {
        public static void AddMemoryPressure(System.Int64 bytesAllocated) => throw null;
        public static T[] AllocateArray<T>(int length, bool pinned = default(bool)) => throw null;
        public static T[] AllocateUninitializedArray<T>(int length, bool pinned = default(bool)) => throw null;
        public static void CancelFullGCNotification() => throw null;
        public static void Collect() => throw null;
        public static void Collect(int generation) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode, bool blocking) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode, bool blocking, bool compacting) => throw null;
        public static int CollectionCount(int generation) => throw null;
        public static void EndNoGCRegion() => throw null;
        public static System.Int64 GetAllocatedBytesForCurrentThread() => throw null;
        public static System.Collections.Generic.IReadOnlyDictionary<string, object> GetConfigurationVariables() => throw null;
        public static System.GCMemoryInfo GetGCMemoryInfo() => throw null;
        public static System.GCMemoryInfo GetGCMemoryInfo(System.GCKind kind) => throw null;
        public static int GetGeneration(System.WeakReference wo) => throw null;
        public static int GetGeneration(object obj) => throw null;
        public static System.Int64 GetTotalAllocatedBytes(bool precise = default(bool)) => throw null;
        public static System.Int64 GetTotalMemory(bool forceFullCollection) => throw null;
        public static System.TimeSpan GetTotalPauseDuration() => throw null;
        public static void KeepAlive(object obj) => throw null;
        public static int MaxGeneration { get => throw null; }
        public static void ReRegisterForFinalize(object obj) => throw null;
        public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold) => throw null;
        public static void RemoveMemoryPressure(System.Int64 bytesAllocated) => throw null;
        public static void SuppressFinalize(object obj) => throw null;
        public static bool TryStartNoGCRegion(System.Int64 totalSize) => throw null;
        public static bool TryStartNoGCRegion(System.Int64 totalSize, bool disallowFullBlockingGC) => throw null;
        public static bool TryStartNoGCRegion(System.Int64 totalSize, System.Int64 lohSize) => throw null;
        public static bool TryStartNoGCRegion(System.Int64 totalSize, System.Int64 lohSize, bool disallowFullBlockingGC) => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach() => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach(System.TimeSpan timeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete() => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete(System.TimeSpan timeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout) => throw null;
        public static void WaitForPendingFinalizers() => throw null;
    }

    public enum GCCollectionMode : int
    {
        Aggressive = 3,
        Default = 0,
        Forced = 1,
        Optimized = 2,
    }

    public struct GCGenerationInfo
    {
        public System.Int64 FragmentationAfterBytes { get => throw null; }
        public System.Int64 FragmentationBeforeBytes { get => throw null; }
        // Stub generator skipped constructor 
        public System.Int64 SizeAfterBytes { get => throw null; }
        public System.Int64 SizeBeforeBytes { get => throw null; }
    }

    public enum GCKind : int
    {
        Any = 0,
        Background = 3,
        Ephemeral = 1,
        FullBlocking = 2,
    }

    public struct GCMemoryInfo
    {
        public bool Compacted { get => throw null; }
        public bool Concurrent { get => throw null; }
        public System.Int64 FinalizationPendingCount { get => throw null; }
        public System.Int64 FragmentedBytes { get => throw null; }
        // Stub generator skipped constructor 
        public int Generation { get => throw null; }
        public System.ReadOnlySpan<System.GCGenerationInfo> GenerationInfo { get => throw null; }
        public System.Int64 HeapSizeBytes { get => throw null; }
        public System.Int64 HighMemoryLoadThresholdBytes { get => throw null; }
        public System.Int64 Index { get => throw null; }
        public System.Int64 MemoryLoadBytes { get => throw null; }
        public System.ReadOnlySpan<System.TimeSpan> PauseDurations { get => throw null; }
        public double PauseTimePercentage { get => throw null; }
        public System.Int64 PinnedObjectsCount { get => throw null; }
        public System.Int64 PromotedBytes { get => throw null; }
        public System.Int64 TotalAvailableMemoryBytes { get => throw null; }
        public System.Int64 TotalCommittedBytes { get => throw null; }
    }

    public enum GCNotificationStatus : int
    {
        Canceled = 2,
        Failed = 1,
        NotApplicable = 4,
        Succeeded = 0,
        Timeout = 3,
    }

    public class GenericUriParser : System.UriParser
    {
        public GenericUriParser(System.GenericUriParserOptions options) => throw null;
    }

    [System.Flags]
    public enum GenericUriParserOptions : int
    {
        AllowEmptyAuthority = 2,
        Default = 0,
        DontCompressPath = 128,
        DontConvertPathBackslashes = 64,
        DontUnescapePathDotsAndSlashes = 256,
        GenericAuthority = 1,
        Idn = 512,
        IriParsing = 1024,
        NoFragment = 32,
        NoPort = 8,
        NoQuery = 16,
        NoUserInfo = 4,
    }

    public class GopherStyleUriParser : System.UriParser
    {
        public GopherStyleUriParser() => throw null;
    }

    public struct Guid : System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.IFormattable, System.IParsable<System.Guid>, System.ISpanFormattable, System.ISpanParsable<System.Guid>
    {
        public static bool operator !=(System.Guid a, System.Guid b) => throw null;
        public static bool operator <(System.Guid left, System.Guid right) => throw null;
        public static bool operator <=(System.Guid left, System.Guid right) => throw null;
        public static bool operator ==(System.Guid a, System.Guid b) => throw null;
        public static bool operator >(System.Guid left, System.Guid right) => throw null;
        public static bool operator >=(System.Guid left, System.Guid right) => throw null;
        public int CompareTo(System.Guid value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.Guid Empty;
        public bool Equals(System.Guid g) => throw null;
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        // Stub generator skipped constructor 
        public Guid(System.Byte[] b) => throw null;
        public Guid(System.ReadOnlySpan<System.Byte> b) => throw null;
        public Guid(int a, System.Int16 b, System.Int16 c, System.Byte[] d) => throw null;
        public Guid(int a, System.Int16 b, System.Int16 c, System.Byte d, System.Byte e, System.Byte f, System.Byte g, System.Byte h, System.Byte i, System.Byte j, System.Byte k) => throw null;
        public Guid(string g) => throw null;
        public Guid(System.UInt32 a, System.UInt16 b, System.UInt16 c, System.Byte d, System.Byte e, System.Byte f, System.Byte g, System.Byte h, System.Byte i, System.Byte j, System.Byte k) => throw null;
        public static System.Guid NewGuid() => throw null;
        public static System.Guid Parse(System.ReadOnlySpan<System.Char> input) => throw null;
        public static System.Guid Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Guid Parse(string input) => throw null;
        public static System.Guid Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Guid ParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format) => throw null;
        public static System.Guid ParseExact(string input, string format) => throw null;
        public System.Byte[] ToByteArray() => throw null;
        public override string ToString() => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>)) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Guid result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> input, out System.Guid result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Guid result) => throw null;
        public static bool TryParse(string input, out System.Guid result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, out System.Guid result) => throw null;
        public static bool TryParseExact(string input, string format, out System.Guid result) => throw null;
        public bool TryWriteBytes(System.Span<System.Byte> destination) => throw null;
    }

    public struct Half : System.IComparable, System.IComparable<System.Half>, System.IEquatable<System.Half>, System.IFormattable, System.IParsable<System.Half>, System.ISpanFormattable, System.ISpanParsable<System.Half>, System.Numerics.IAdditionOperators<System.Half, System.Half, System.Half>, System.Numerics.IAdditiveIdentity<System.Half, System.Half>, System.Numerics.IBinaryFloatingPointIeee754<System.Half>, System.Numerics.IBinaryNumber<System.Half>, System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>, System.Numerics.IComparisonOperators<System.Half, System.Half, bool>, System.Numerics.IDecrementOperators<System.Half>, System.Numerics.IDivisionOperators<System.Half, System.Half, System.Half>, System.Numerics.IEqualityOperators<System.Half, System.Half, bool>, System.Numerics.IExponentialFunctions<System.Half>, System.Numerics.IFloatingPoint<System.Half>, System.Numerics.IFloatingPointConstants<System.Half>, System.Numerics.IFloatingPointIeee754<System.Half>, System.Numerics.IHyperbolicFunctions<System.Half>, System.Numerics.IIncrementOperators<System.Half>, System.Numerics.ILogarithmicFunctions<System.Half>, System.Numerics.IMinMaxValue<System.Half>, System.Numerics.IModulusOperators<System.Half, System.Half, System.Half>, System.Numerics.IMultiplicativeIdentity<System.Half, System.Half>, System.Numerics.IMultiplyOperators<System.Half, System.Half, System.Half>, System.Numerics.INumber<System.Half>, System.Numerics.INumberBase<System.Half>, System.Numerics.IPowerFunctions<System.Half>, System.Numerics.IRootFunctions<System.Half>, System.Numerics.ISignedNumber<System.Half>, System.Numerics.ISubtractionOperators<System.Half, System.Half, System.Half>, System.Numerics.ITrigonometricFunctions<System.Half>, System.Numerics.IUnaryNegationOperators<System.Half, System.Half>, System.Numerics.IUnaryPlusOperators<System.Half, System.Half>
    {
        static bool System.Numerics.IEqualityOperators<System.Half, System.Half, bool>.operator !=(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IModulusOperators<System.Half, System.Half, System.Half>.operator %(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator &(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IMultiplyOperators<System.Half, System.Half, System.Half>.operator *(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IUnaryPlusOperators<System.Half, System.Half>.operator +(System.Half value) => throw null;
        static System.Half System.Numerics.IAdditionOperators<System.Half, System.Half, System.Half>.operator +(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IIncrementOperators<System.Half>.operator ++(System.Half value) => throw null;
        static System.Half System.Numerics.IUnaryNegationOperators<System.Half, System.Half>.operator -(System.Half value) => throw null;
        static System.Half System.Numerics.ISubtractionOperators<System.Half, System.Half, System.Half>.operator -(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IDecrementOperators<System.Half>.operator --(System.Half value) => throw null;
        static System.Half System.Numerics.IDivisionOperators<System.Half, System.Half, System.Half>.operator /(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator <(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator <=(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Half, System.Half, bool>.operator ==(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator >(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator >=(System.Half left, System.Half right) => throw null;
        public static System.Half Abs(System.Half value) => throw null;
        public static System.Half Acos(System.Half x) => throw null;
        public static System.Half AcosPi(System.Half x) => throw null;
        public static System.Half Acosh(System.Half x) => throw null;
        static System.Half System.Numerics.IAdditiveIdentity<System.Half, System.Half>.AdditiveIdentity { get => throw null; }
        static System.Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get => throw null; }
        public static System.Half Asin(System.Half x) => throw null;
        public static System.Half AsinPi(System.Half x) => throw null;
        public static System.Half Asinh(System.Half x) => throw null;
        public static System.Half Atan(System.Half x) => throw null;
        public static System.Half Atan2(System.Half y, System.Half x) => throw null;
        public static System.Half Atan2Pi(System.Half y, System.Half x) => throw null;
        public static System.Half AtanPi(System.Half x) => throw null;
        public static System.Half Atanh(System.Half x) => throw null;
        public static System.Half BitDecrement(System.Half x) => throw null;
        public static System.Half BitIncrement(System.Half x) => throw null;
        public static System.Half Cbrt(System.Half x) => throw null;
        public static System.Half Ceiling(System.Half x) => throw null;
        public static System.Half Clamp(System.Half value, System.Half min, System.Half max) => throw null;
        public int CompareTo(System.Half other) => throw null;
        public int CompareTo(object obj) => throw null;
        public static System.Half CopySign(System.Half value, System.Half sign) => throw null;
        public static System.Half Cos(System.Half x) => throw null;
        public static System.Half CosPi(System.Half x) => throw null;
        public static System.Half Cosh(System.Half x) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateTruncating<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.E { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Epsilon { get => throw null; }
        public bool Equals(System.Half other) => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.Half Exp(System.Half x) => throw null;
        public static System.Half Exp10(System.Half x) => throw null;
        public static System.Half Exp10M1(System.Half x) => throw null;
        public static System.Half Exp2(System.Half x) => throw null;
        public static System.Half Exp2M1(System.Half x) => throw null;
        public static System.Half ExpM1(System.Half x) => throw null;
        public static System.Half Floor(System.Half x) => throw null;
        public static System.Half FusedMultiplyAdd(System.Half left, System.Half right, System.Half addend) => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetSignificandByteCount() => throw null;
        // Stub generator skipped constructor 
        public static System.Half Hypot(System.Half x, System.Half y) => throw null;
        public static int ILogB(System.Half x) => throw null;
        public static System.Half Ieee754Remainder(System.Half left, System.Half right) => throw null;
        public static bool IsCanonical(System.Half value) => throw null;
        public static bool IsComplexNumber(System.Half value) => throw null;
        public static bool IsEvenInteger(System.Half value) => throw null;
        public static bool IsFinite(System.Half value) => throw null;
        public static bool IsImaginaryNumber(System.Half value) => throw null;
        public static bool IsInfinity(System.Half value) => throw null;
        public static bool IsInteger(System.Half value) => throw null;
        public static bool IsNaN(System.Half value) => throw null;
        public static bool IsNegative(System.Half value) => throw null;
        public static bool IsNegativeInfinity(System.Half value) => throw null;
        public static bool IsNormal(System.Half value) => throw null;
        public static bool IsOddInteger(System.Half value) => throw null;
        public static bool IsPositive(System.Half value) => throw null;
        public static bool IsPositiveInfinity(System.Half value) => throw null;
        public static bool IsPow2(System.Half value) => throw null;
        public static bool IsRealNumber(System.Half value) => throw null;
        public static bool IsSubnormal(System.Half value) => throw null;
        public static bool IsZero(System.Half value) => throw null;
        public static System.Half Log(System.Half x) => throw null;
        public static System.Half Log(System.Half x, System.Half newBase) => throw null;
        public static System.Half Log10(System.Half x) => throw null;
        public static System.Half Log10P1(System.Half x) => throw null;
        public static System.Half Log2(System.Half value) => throw null;
        public static System.Half Log2P1(System.Half x) => throw null;
        public static System.Half LogP1(System.Half x) => throw null;
        public static System.Half Max(System.Half x, System.Half y) => throw null;
        public static System.Half MaxMagnitude(System.Half x, System.Half y) => throw null;
        public static System.Half MaxMagnitudeNumber(System.Half x, System.Half y) => throw null;
        public static System.Half MaxNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.IMinMaxValue<System.Half>.MaxValue { get => throw null; }
        public static System.Half Min(System.Half x, System.Half y) => throw null;
        public static System.Half MinMagnitude(System.Half x, System.Half y) => throw null;
        public static System.Half MinMagnitudeNumber(System.Half x, System.Half y) => throw null;
        public static System.Half MinNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.IMinMaxValue<System.Half>.MinValue { get => throw null; }
        static System.Half System.Numerics.IMultiplicativeIdentity<System.Half, System.Half>.MultiplicativeIdentity { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NaN { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NegativeInfinity { get => throw null; }
        static System.Half System.Numerics.ISignedNumber<System.Half>.NegativeOne { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NegativeZero { get => throw null; }
        static System.Half System.Numerics.INumberBase<System.Half>.One { get => throw null; }
        public static System.Half Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Half Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Half Parse(string s) => throw null;
        public static System.Half Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Half Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Half Parse(string s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.Pi { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.PositiveInfinity { get => throw null; }
        public static System.Half Pow(System.Half x, System.Half y) => throw null;
        static int System.Numerics.INumberBase<System.Half>.Radix { get => throw null; }
        public static System.Half ReciprocalEstimate(System.Half x) => throw null;
        public static System.Half ReciprocalSqrtEstimate(System.Half x) => throw null;
        public static System.Half RootN(System.Half x, int n) => throw null;
        public static System.Half Round(System.Half x) => throw null;
        public static System.Half Round(System.Half x, System.MidpointRounding mode) => throw null;
        public static System.Half Round(System.Half x, int digits) => throw null;
        public static System.Half Round(System.Half x, int digits, System.MidpointRounding mode) => throw null;
        public static System.Half ScaleB(System.Half x, int n) => throw null;
        public static int Sign(System.Half value) => throw null;
        public static System.Half Sin(System.Half x) => throw null;
        public static (System.Half, System.Half) SinCos(System.Half x) => throw null;
        public static (System.Half, System.Half) SinCosPi(System.Half x) => throw null;
        public static System.Half SinPi(System.Half x) => throw null;
        public static System.Half Sinh(System.Half x) => throw null;
        public static System.Half Sqrt(System.Half x) => throw null;
        public static System.Half Tan(System.Half x) => throw null;
        public static System.Half TanPi(System.Half x) => throw null;
        public static System.Half Tanh(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.Tau { get => throw null; }
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public static System.Half Truncate(System.Half x) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromChecked<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromSaturating<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromTruncating<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToChecked<TOther>(System.Half value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToSaturating<TOther>(System.Half value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToTruncating<TOther>(System.Half value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Half result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(string s, out System.Half result) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.Zero { get => throw null; }
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator ^(System.Half left, System.Half right) => throw null;
        public static explicit operator checked System.Byte(System.Half value) => throw null;
        public static explicit operator checked System.Char(System.Half value) => throw null;
        public static explicit operator checked System.Int128(System.Half value) => throw null;
        public static explicit operator checked System.Int16(System.Half value) => throw null;
        public static explicit operator checked System.Int64(System.Half value) => throw null;
        public static explicit operator checked System.IntPtr(System.Half value) => throw null;
        public static explicit operator checked System.SByte(System.Half value) => throw null;
        public static explicit operator checked System.UInt128(System.Half value) => throw null;
        public static explicit operator checked System.UInt16(System.Half value) => throw null;
        public static explicit operator checked System.UInt32(System.Half value) => throw null;
        public static explicit operator checked System.UInt64(System.Half value) => throw null;
        public static explicit operator checked System.UIntPtr(System.Half value) => throw null;
        public static explicit operator checked int(System.Half value) => throw null;
        public static explicit operator System.Byte(System.Half value) => throw null;
        public static explicit operator System.Char(System.Half value) => throw null;
        public static explicit operator System.Decimal(System.Half value) => throw null;
        public static explicit operator System.Int128(System.Half value) => throw null;
        public static explicit operator System.Int16(System.Half value) => throw null;
        public static explicit operator System.Int64(System.Half value) => throw null;
        public static explicit operator System.IntPtr(System.Half value) => throw null;
        public static explicit operator System.SByte(System.Half value) => throw null;
        public static explicit operator System.UInt128(System.Half value) => throw null;
        public static explicit operator System.UInt16(System.Half value) => throw null;
        public static explicit operator System.UInt32(System.Half value) => throw null;
        public static explicit operator System.UInt64(System.Half value) => throw null;
        public static explicit operator System.UIntPtr(System.Half value) => throw null;
        public static explicit operator double(System.Half value) => throw null;
        public static explicit operator float(System.Half value) => throw null;
        public static explicit operator int(System.Half value) => throw null;
        public static explicit operator System.Half(System.IntPtr value) => throw null;
        public static explicit operator System.Half(System.UIntPtr value) => throw null;
        public static explicit operator System.Half(System.Char value) => throw null;
        public static explicit operator System.Half(System.Decimal value) => throw null;
        public static explicit operator System.Half(double value) => throw null;
        public static explicit operator System.Half(float value) => throw null;
        public static explicit operator System.Half(int value) => throw null;
        public static explicit operator System.Half(System.Int64 value) => throw null;
        public static explicit operator System.Half(System.Int16 value) => throw null;
        public static explicit operator System.Half(System.UInt32 value) => throw null;
        public static explicit operator System.Half(System.UInt64 value) => throw null;
        public static explicit operator System.Half(System.UInt16 value) => throw null;
        public static implicit operator System.Half(System.Byte value) => throw null;
        public static implicit operator System.Half(System.SByte value) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator |(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator ~(System.Half value) => throw null;
    }

    public struct HashCode
    {
        public void Add<T>(T value) => throw null;
        public void Add<T>(T value, System.Collections.Generic.IEqualityComparer<T> comparer) => throw null;
        public void AddBytes(System.ReadOnlySpan<System.Byte> value) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6) => throw null;
        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5) => throw null;
        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4) => throw null;
        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3) => throw null;
        public static int Combine<T1, T2>(T1 value1, T2 value2) => throw null;
        public static int Combine<T1>(T1 value1) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        // Stub generator skipped constructor 
        public int ToHashCode() => throw null;
    }

    public class HttpStyleUriParser : System.UriParser
    {
        public HttpStyleUriParser() => throw null;
    }

    public interface IAsyncDisposable
    {
        System.Threading.Tasks.ValueTask DisposeAsync();
    }

    public interface IAsyncResult
    {
        object AsyncState { get; }
        System.Threading.WaitHandle AsyncWaitHandle { get; }
        bool CompletedSynchronously { get; }
        bool IsCompleted { get; }
    }

    public interface ICloneable
    {
        object Clone();
    }

    public interface IComparable
    {
        int CompareTo(object obj);
    }

    public interface IComparable<T>
    {
        int CompareTo(T other);
    }

    public interface IConvertible
    {
        System.TypeCode GetTypeCode();
        bool ToBoolean(System.IFormatProvider provider);
        System.Byte ToByte(System.IFormatProvider provider);
        System.Char ToChar(System.IFormatProvider provider);
        System.DateTime ToDateTime(System.IFormatProvider provider);
        System.Decimal ToDecimal(System.IFormatProvider provider);
        double ToDouble(System.IFormatProvider provider);
        System.Int16 ToInt16(System.IFormatProvider provider);
        int ToInt32(System.IFormatProvider provider);
        System.Int64 ToInt64(System.IFormatProvider provider);
        System.SByte ToSByte(System.IFormatProvider provider);
        float ToSingle(System.IFormatProvider provider);
        string ToString(System.IFormatProvider provider);
        object ToType(System.Type conversionType, System.IFormatProvider provider);
        System.UInt16 ToUInt16(System.IFormatProvider provider);
        System.UInt32 ToUInt32(System.IFormatProvider provider);
        System.UInt64 ToUInt64(System.IFormatProvider provider);
    }

    public interface ICustomFormatter
    {
        string Format(string format, object arg, System.IFormatProvider formatProvider);
    }

    public interface IDisposable
    {
        void Dispose();
    }

    public interface IEquatable<T>
    {
        bool Equals(T other);
    }

    public interface IFormatProvider
    {
        object GetFormat(System.Type formatType);
    }

    public interface IFormattable
    {
        string ToString(string format, System.IFormatProvider formatProvider);
    }

    public interface IObservable<T>
    {
        System.IDisposable Subscribe(System.IObserver<T> observer);
    }

    public interface IObserver<T>
    {
        void OnCompleted();
        void OnError(System.Exception error);
        void OnNext(T value);
    }

    public interface IParsable<TSelf> where TSelf : System.IParsable<TSelf>
    {
        static abstract TSelf Parse(string s, System.IFormatProvider provider);
        static abstract bool TryParse(string s, System.IFormatProvider provider, out TSelf result);
    }

    public interface IProgress<T>
    {
        void Report(T value);
    }

    public interface ISpanFormattable : System.IFormattable
    {
        bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider);
    }

    public interface ISpanParsable<TSelf> : System.IParsable<TSelf> where TSelf : System.ISpanParsable<TSelf>
    {
        static abstract TSelf Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider);
        static abstract bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out TSelf result);
    }

    public struct Index : System.IEquatable<System.Index>
    {
        public static System.Index End { get => throw null; }
        public bool Equals(System.Index other) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.Index FromEnd(int value) => throw null;
        public static System.Index FromStart(int value) => throw null;
        public override int GetHashCode() => throw null;
        public int GetOffset(int length) => throw null;
        // Stub generator skipped constructor 
        public Index(int value, bool fromEnd = default(bool)) => throw null;
        public bool IsFromEnd { get => throw null; }
        public static System.Index Start { get => throw null; }
        public override string ToString() => throw null;
        public int Value { get => throw null; }
        public static implicit operator System.Index(int value) => throw null;
    }

    public class IndexOutOfRangeException : System.SystemException
    {
        public IndexOutOfRangeException() => throw null;
        public IndexOutOfRangeException(string message) => throw null;
        public IndexOutOfRangeException(string message, System.Exception innerException) => throw null;
    }

    public class InsufficientExecutionStackException : System.SystemException
    {
        public InsufficientExecutionStackException() => throw null;
        public InsufficientExecutionStackException(string message) => throw null;
        public InsufficientExecutionStackException(string message, System.Exception innerException) => throw null;
    }

    public class InsufficientMemoryException : System.OutOfMemoryException
    {
        public InsufficientMemoryException() => throw null;
        public InsufficientMemoryException(string message) => throw null;
        public InsufficientMemoryException(string message, System.Exception innerException) => throw null;
    }

    public struct Int128 : System.IComparable, System.IComparable<System.Int128>, System.IEquatable<System.Int128>, System.IFormattable, System.IParsable<System.Int128>, System.ISpanFormattable, System.ISpanParsable<System.Int128>, System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IAdditiveIdentity<System.Int128, System.Int128>, System.Numerics.IBinaryInteger<System.Int128>, System.Numerics.IBinaryNumber<System.Int128>, System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>, System.Numerics.IDecrementOperators<System.Int128>, System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>, System.Numerics.IIncrementOperators<System.Int128>, System.Numerics.IMinMaxValue<System.Int128>, System.Numerics.IModulusOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IMultiplicativeIdentity<System.Int128, System.Int128>, System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.INumber<System.Int128>, System.Numerics.INumberBase<System.Int128>, System.Numerics.IShiftOperators<System.Int128, int, System.Int128>, System.Numerics.ISignedNumber<System.Int128>, System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>, System.Numerics.IUnaryPlusOperators<System.Int128, System.Int128>
    {
        static bool System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>.operator !=(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IModulusOperators<System.Int128, System.Int128, System.Int128>.operator %(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator &(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>.operator *(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IUnaryPlusOperators<System.Int128, System.Int128>.operator +(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>.operator +(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IIncrementOperators<System.Int128>.operator ++(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>.operator -(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>.operator -(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IDecrementOperators<System.Int128>.operator --(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>.operator /(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator <(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator <<(System.Int128 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator <=(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>.operator ==(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator >(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator >=(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator >>(System.Int128 value, int shiftAmount) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator >>>(System.Int128 value, int shiftAmount) => throw null;
        public static System.Int128 Abs(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IAdditiveIdentity<System.Int128, System.Int128>.AdditiveIdentity { get => throw null; }
        static System.Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get => throw null; }
        public static System.Int128 Clamp(System.Int128 value, System.Int128 min, System.Int128 max) => throw null;
        public int CompareTo(System.Int128 value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.Int128 CopySign(System.Int128 value, System.Int128 sign) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.Int128, System.Int128) DivRem(System.Int128 left, System.Int128 right) => throw null;
        public bool Equals(System.Int128 other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Int128>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.Int128>.GetShortestBitLength() => throw null;
        // Stub generator skipped constructor 
        public Int128(System.UInt64 upper, System.UInt64 lower) => throw null;
        public static bool IsCanonical(System.Int128 value) => throw null;
        public static bool IsComplexNumber(System.Int128 value) => throw null;
        public static bool IsEvenInteger(System.Int128 value) => throw null;
        public static bool IsFinite(System.Int128 value) => throw null;
        public static bool IsImaginaryNumber(System.Int128 value) => throw null;
        public static bool IsInfinity(System.Int128 value) => throw null;
        public static bool IsInteger(System.Int128 value) => throw null;
        public static bool IsNaN(System.Int128 value) => throw null;
        public static bool IsNegative(System.Int128 value) => throw null;
        public static bool IsNegativeInfinity(System.Int128 value) => throw null;
        public static bool IsNormal(System.Int128 value) => throw null;
        public static bool IsOddInteger(System.Int128 value) => throw null;
        public static bool IsPositive(System.Int128 value) => throw null;
        public static bool IsPositiveInfinity(System.Int128 value) => throw null;
        public static bool IsPow2(System.Int128 value) => throw null;
        public static bool IsRealNumber(System.Int128 value) => throw null;
        public static bool IsSubnormal(System.Int128 value) => throw null;
        public static bool IsZero(System.Int128 value) => throw null;
        public static System.Int128 LeadingZeroCount(System.Int128 value) => throw null;
        public static System.Int128 Log2(System.Int128 value) => throw null;
        public static System.Int128 Max(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MaxMagnitude(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MaxMagnitudeNumber(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MaxNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.IMinMaxValue<System.Int128>.MaxValue { get => throw null; }
        public static System.Int128 Min(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MinMagnitude(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MinMagnitudeNumber(System.Int128 x, System.Int128 y) => throw null;
        public static System.Int128 MinNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.IMinMaxValue<System.Int128>.MinValue { get => throw null; }
        static System.Int128 System.Numerics.IMultiplicativeIdentity<System.Int128, System.Int128>.MultiplicativeIdentity { get => throw null; }
        static System.Int128 System.Numerics.ISignedNumber<System.Int128>.NegativeOne { get => throw null; }
        static System.Int128 System.Numerics.INumberBase<System.Int128>.One { get => throw null; }
        public static System.Int128 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Int128 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Int128 Parse(string s) => throw null;
        public static System.Int128 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Int128 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Int128 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Int128 PopCount(System.Int128 value) => throw null;
        static int System.Numerics.INumberBase<System.Int128>.Radix { get => throw null; }
        public static System.Int128 RotateLeft(System.Int128 value, int rotateAmount) => throw null;
        public static System.Int128 RotateRight(System.Int128 value, int rotateAmount) => throw null;
        public static int Sign(System.Int128 value) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public static System.Int128 TrailingZeroCount(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromChecked<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromSaturating<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromTruncating<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToChecked<TOther>(System.Int128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToSaturating<TOther>(System.Int128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToTruncating<TOther>(System.Int128 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Int128 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(string s, out System.Int128 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int128 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int128 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Zero { get => throw null; }
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator ^(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>.operator checked *(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>.operator checked +(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IIncrementOperators<System.Int128>.operator checked ++(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>.operator checked -(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>.operator checked -(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IDecrementOperators<System.Int128>.operator checked --(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>.operator checked /(System.Int128 left, System.Int128 right) => throw null;
        public static explicit operator checked System.Byte(System.Int128 value) => throw null;
        public static explicit operator checked System.Char(System.Int128 value) => throw null;
        public static explicit operator checked System.Int16(System.Int128 value) => throw null;
        public static explicit operator checked System.Int64(System.Int128 value) => throw null;
        public static explicit operator checked System.IntPtr(System.Int128 value) => throw null;
        public static explicit operator checked System.SByte(System.Int128 value) => throw null;
        public static explicit operator checked System.UInt128(System.Int128 value) => throw null;
        public static explicit operator checked System.UInt16(System.Int128 value) => throw null;
        public static explicit operator checked System.UInt32(System.Int128 value) => throw null;
        public static explicit operator checked System.UInt64(System.Int128 value) => throw null;
        public static explicit operator checked System.UIntPtr(System.Int128 value) => throw null;
        public static explicit operator checked int(System.Int128 value) => throw null;
        public static explicit operator checked System.Int128(double value) => throw null;
        public static explicit operator checked System.Int128(float value) => throw null;
        public static explicit operator System.Byte(System.Int128 value) => throw null;
        public static explicit operator System.Char(System.Int128 value) => throw null;
        public static explicit operator System.Decimal(System.Int128 value) => throw null;
        public static explicit operator System.Half(System.Int128 value) => throw null;
        public static explicit operator System.Int16(System.Int128 value) => throw null;
        public static explicit operator System.Int64(System.Int128 value) => throw null;
        public static explicit operator System.IntPtr(System.Int128 value) => throw null;
        public static explicit operator System.SByte(System.Int128 value) => throw null;
        public static explicit operator System.UInt128(System.Int128 value) => throw null;
        public static explicit operator System.UInt16(System.Int128 value) => throw null;
        public static explicit operator System.UInt32(System.Int128 value) => throw null;
        public static explicit operator System.UInt64(System.Int128 value) => throw null;
        public static explicit operator System.UIntPtr(System.Int128 value) => throw null;
        public static explicit operator double(System.Int128 value) => throw null;
        public static explicit operator float(System.Int128 value) => throw null;
        public static explicit operator int(System.Int128 value) => throw null;
        public static explicit operator System.Int128(System.Decimal value) => throw null;
        public static explicit operator System.Int128(double value) => throw null;
        public static explicit operator System.Int128(float value) => throw null;
        public static implicit operator System.Int128(System.IntPtr value) => throw null;
        public static implicit operator System.Int128(System.UIntPtr value) => throw null;
        public static implicit operator System.Int128(System.Byte value) => throw null;
        public static implicit operator System.Int128(System.Char value) => throw null;
        public static implicit operator System.Int128(int value) => throw null;
        public static implicit operator System.Int128(System.Int64 value) => throw null;
        public static implicit operator System.Int128(System.SByte value) => throw null;
        public static implicit operator System.Int128(System.Int16 value) => throw null;
        public static implicit operator System.Int128(System.UInt32 value) => throw null;
        public static implicit operator System.Int128(System.UInt64 value) => throw null;
        public static implicit operator System.Int128(System.UInt16 value) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator |(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator ~(System.Int128 value) => throw null;
    }

    public struct Int16 : System.IComparable, System.IComparable<System.Int16>, System.IConvertible, System.IEquatable<System.Int16>, System.IFormattable, System.IParsable<System.Int16>, System.ISpanFormattable, System.ISpanParsable<System.Int16>, System.Numerics.IAdditionOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.IAdditiveIdentity<System.Int16, System.Int16>, System.Numerics.IBinaryInteger<System.Int16>, System.Numerics.IBinaryNumber<System.Int16>, System.Numerics.IBitwiseOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.IComparisonOperators<System.Int16, System.Int16, bool>, System.Numerics.IDecrementOperators<System.Int16>, System.Numerics.IDivisionOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.IEqualityOperators<System.Int16, System.Int16, bool>, System.Numerics.IIncrementOperators<System.Int16>, System.Numerics.IMinMaxValue<System.Int16>, System.Numerics.IModulusOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.IMultiplicativeIdentity<System.Int16, System.Int16>, System.Numerics.IMultiplyOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.INumber<System.Int16>, System.Numerics.INumberBase<System.Int16>, System.Numerics.IShiftOperators<System.Int16, int, System.Int16>, System.Numerics.ISignedNumber<System.Int16>, System.Numerics.ISubtractionOperators<System.Int16, System.Int16, System.Int16>, System.Numerics.IUnaryNegationOperators<System.Int16, System.Int16>, System.Numerics.IUnaryPlusOperators<System.Int16, System.Int16>
    {
        static bool System.Numerics.IEqualityOperators<System.Int16, System.Int16, bool>.operator !=(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IModulusOperators<System.Int16, System.Int16, System.Int16>.operator %(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IBitwiseOperators<System.Int16, System.Int16, System.Int16>.operator &(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IMultiplyOperators<System.Int16, System.Int16, System.Int16>.operator *(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IUnaryPlusOperators<System.Int16, System.Int16>.operator +(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IAdditionOperators<System.Int16, System.Int16, System.Int16>.operator +(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IIncrementOperators<System.Int16>.operator ++(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IUnaryNegationOperators<System.Int16, System.Int16>.operator -(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.ISubtractionOperators<System.Int16, System.Int16, System.Int16>.operator -(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IDecrementOperators<System.Int16>.operator --(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IDivisionOperators<System.Int16, System.Int16, System.Int16>.operator /(System.Int16 left, System.Int16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int16, System.Int16, bool>.operator <(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IShiftOperators<System.Int16, int, System.Int16>.operator <<(System.Int16 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int16, System.Int16, bool>.operator <=(System.Int16 left, System.Int16 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Int16, System.Int16, bool>.operator ==(System.Int16 left, System.Int16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int16, System.Int16, bool>.operator >(System.Int16 left, System.Int16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int16, System.Int16, bool>.operator >=(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IShiftOperators<System.Int16, int, System.Int16>.operator >>(System.Int16 value, int shiftAmount) => throw null;
        static System.Int16 System.Numerics.IShiftOperators<System.Int16, int, System.Int16>.operator >>>(System.Int16 value, int shiftAmount) => throw null;
        public static System.Int16 Abs(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IAdditiveIdentity<System.Int16, System.Int16>.AdditiveIdentity { get => throw null; }
        static System.Int16 System.Numerics.IBinaryNumber<System.Int16>.AllBitsSet { get => throw null; }
        public static System.Int16 Clamp(System.Int16 value, System.Int16 min, System.Int16 max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.Int16 value) => throw null;
        public static System.Int16 CopySign(System.Int16 value, System.Int16 sign) => throw null;
        static System.Int16 System.Numerics.INumberBase<System.Int16>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Int16 System.Numerics.INumberBase<System.Int16>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Int16 System.Numerics.INumberBase<System.Int16>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.Int16, System.Int16) DivRem(System.Int16 left, System.Int16 right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.Int16 obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Int16>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.Int16>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        // Stub generator skipped constructor 
        public static bool IsCanonical(System.Int16 value) => throw null;
        public static bool IsComplexNumber(System.Int16 value) => throw null;
        public static bool IsEvenInteger(System.Int16 value) => throw null;
        public static bool IsFinite(System.Int16 value) => throw null;
        public static bool IsImaginaryNumber(System.Int16 value) => throw null;
        public static bool IsInfinity(System.Int16 value) => throw null;
        public static bool IsInteger(System.Int16 value) => throw null;
        public static bool IsNaN(System.Int16 value) => throw null;
        public static bool IsNegative(System.Int16 value) => throw null;
        public static bool IsNegativeInfinity(System.Int16 value) => throw null;
        public static bool IsNormal(System.Int16 value) => throw null;
        public static bool IsOddInteger(System.Int16 value) => throw null;
        public static bool IsPositive(System.Int16 value) => throw null;
        public static bool IsPositiveInfinity(System.Int16 value) => throw null;
        public static bool IsPow2(System.Int16 value) => throw null;
        public static bool IsRealNumber(System.Int16 value) => throw null;
        public static bool IsSubnormal(System.Int16 value) => throw null;
        public static bool IsZero(System.Int16 value) => throw null;
        public static System.Int16 LeadingZeroCount(System.Int16 value) => throw null;
        public static System.Int16 Log2(System.Int16 value) => throw null;
        public static System.Int16 Max(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MaxMagnitude(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MaxMagnitudeNumber(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MaxNumber(System.Int16 x, System.Int16 y) => throw null;
        public const System.Int16 MaxValue = default;
        static System.Int16 System.Numerics.IMinMaxValue<System.Int16>.MaxValue { get => throw null; }
        public static System.Int16 Min(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MinMagnitude(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MinMagnitudeNumber(System.Int16 x, System.Int16 y) => throw null;
        public static System.Int16 MinNumber(System.Int16 x, System.Int16 y) => throw null;
        public const System.Int16 MinValue = default;
        static System.Int16 System.Numerics.IMinMaxValue<System.Int16>.MinValue { get => throw null; }
        static System.Int16 System.Numerics.IMultiplicativeIdentity<System.Int16, System.Int16>.MultiplicativeIdentity { get => throw null; }
        static System.Int16 System.Numerics.ISignedNumber<System.Int16>.NegativeOne { get => throw null; }
        static System.Int16 System.Numerics.INumberBase<System.Int16>.One { get => throw null; }
        public static System.Int16 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Int16 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Int16 Parse(string s) => throw null;
        public static System.Int16 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Int16 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Int16 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Int16 PopCount(System.Int16 value) => throw null;
        static int System.Numerics.INumberBase<System.Int16>.Radix { get => throw null; }
        public static System.Int16 RotateLeft(System.Int16 value, int rotateAmount) => throw null;
        public static System.Int16 RotateRight(System.Int16 value, int rotateAmount) => throw null;
        public static int Sign(System.Int16 value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.Int16 TrailingZeroCount(System.Int16 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertFromChecked<TOther>(TOther value, out System.Int16 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertFromSaturating<TOther>(TOther value, out System.Int16 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertFromTruncating<TOther>(TOther value, out System.Int16 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertToChecked<TOther>(System.Int16 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertToSaturating<TOther>(System.Int16 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int16>.TryConvertToTruncating<TOther>(System.Int16 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Int16 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int16 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Int16 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Int16 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int16 result) => throw null;
        public static bool TryParse(string s, out System.Int16 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int16 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int16 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Int16 System.Numerics.INumberBase<System.Int16>.Zero { get => throw null; }
        static System.Int16 System.Numerics.IBitwiseOperators<System.Int16, System.Int16, System.Int16>.operator ^(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IMultiplyOperators<System.Int16, System.Int16, System.Int16>.operator checked *(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IAdditionOperators<System.Int16, System.Int16, System.Int16>.operator checked +(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IIncrementOperators<System.Int16>.operator checked ++(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IUnaryNegationOperators<System.Int16, System.Int16>.operator checked -(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.ISubtractionOperators<System.Int16, System.Int16, System.Int16>.operator checked -(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IDecrementOperators<System.Int16>.operator checked --(System.Int16 value) => throw null;
        static System.Int16 System.Numerics.IBitwiseOperators<System.Int16, System.Int16, System.Int16>.operator |(System.Int16 left, System.Int16 right) => throw null;
        static System.Int16 System.Numerics.IBitwiseOperators<System.Int16, System.Int16, System.Int16>.operator ~(System.Int16 value) => throw null;
    }

    public struct Int32 : System.IComparable, System.IComparable<int>, System.IConvertible, System.IEquatable<int>, System.IFormattable, System.IParsable<int>, System.ISpanFormattable, System.ISpanParsable<int>, System.Numerics.IAdditionOperators<int, int, int>, System.Numerics.IAdditiveIdentity<int, int>, System.Numerics.IBinaryInteger<int>, System.Numerics.IBinaryNumber<int>, System.Numerics.IBitwiseOperators<int, int, int>, System.Numerics.IComparisonOperators<int, int, bool>, System.Numerics.IDecrementOperators<int>, System.Numerics.IDivisionOperators<int, int, int>, System.Numerics.IEqualityOperators<int, int, bool>, System.Numerics.IIncrementOperators<int>, System.Numerics.IMinMaxValue<int>, System.Numerics.IModulusOperators<int, int, int>, System.Numerics.IMultiplicativeIdentity<int, int>, System.Numerics.IMultiplyOperators<int, int, int>, System.Numerics.INumber<int>, System.Numerics.INumberBase<int>, System.Numerics.IShiftOperators<int, int, int>, System.Numerics.ISignedNumber<int>, System.Numerics.ISubtractionOperators<int, int, int>, System.Numerics.IUnaryNegationOperators<int, int>, System.Numerics.IUnaryPlusOperators<int, int>
    {
        static bool System.Numerics.IEqualityOperators<int, int, bool>.operator !=(int left, int right) => throw null;
        static int System.Numerics.IModulusOperators<int, int, int>.operator %(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator &(int left, int right) => throw null;
        static int System.Numerics.IMultiplyOperators<int, int, int>.operator *(int left, int right) => throw null;
        static int System.Numerics.IUnaryPlusOperators<int, int>.operator +(int value) => throw null;
        static int System.Numerics.IAdditionOperators<int, int, int>.operator +(int left, int right) => throw null;
        static int System.Numerics.IIncrementOperators<int>.operator ++(int value) => throw null;
        static int System.Numerics.IUnaryNegationOperators<int, int>.operator -(int value) => throw null;
        static int System.Numerics.ISubtractionOperators<int, int, int>.operator -(int left, int right) => throw null;
        static int System.Numerics.IDecrementOperators<int>.operator --(int value) => throw null;
        static int System.Numerics.IDivisionOperators<int, int, int>.operator /(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator <(int left, int right) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator <<(int value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator <=(int left, int right) => throw null;
        static bool System.Numerics.IEqualityOperators<int, int, bool>.operator ==(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator >(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator >=(int left, int right) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator >>(int value, int shiftAmount) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator >>>(int value, int shiftAmount) => throw null;
        public static int Abs(int value) => throw null;
        static int System.Numerics.IAdditiveIdentity<int, int>.AdditiveIdentity { get => throw null; }
        static int System.Numerics.IBinaryNumber<int>.AllBitsSet { get => throw null; }
        public static int Clamp(int value, int min, int max) => throw null;
        public int CompareTo(int value) => throw null;
        public int CompareTo(object value) => throw null;
        public static int CopySign(int value, int sign) => throw null;
        static int System.Numerics.INumberBase<int>.CreateChecked<TOther>(TOther value) => throw null;
        static int System.Numerics.INumberBase<int>.CreateSaturating<TOther>(TOther value) => throw null;
        static int System.Numerics.INumberBase<int>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (int, int) DivRem(int left, int right) => throw null;
        public bool Equals(int obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<int>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<int>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        // Stub generator skipped constructor 
        public static bool IsCanonical(int value) => throw null;
        public static bool IsComplexNumber(int value) => throw null;
        public static bool IsEvenInteger(int value) => throw null;
        public static bool IsFinite(int value) => throw null;
        public static bool IsImaginaryNumber(int value) => throw null;
        public static bool IsInfinity(int value) => throw null;
        public static bool IsInteger(int value) => throw null;
        public static bool IsNaN(int value) => throw null;
        public static bool IsNegative(int value) => throw null;
        public static bool IsNegativeInfinity(int value) => throw null;
        public static bool IsNormal(int value) => throw null;
        public static bool IsOddInteger(int value) => throw null;
        public static bool IsPositive(int value) => throw null;
        public static bool IsPositiveInfinity(int value) => throw null;
        public static bool IsPow2(int value) => throw null;
        public static bool IsRealNumber(int value) => throw null;
        public static bool IsSubnormal(int value) => throw null;
        public static bool IsZero(int value) => throw null;
        public static int LeadingZeroCount(int value) => throw null;
        public static int Log2(int value) => throw null;
        public static int Max(int x, int y) => throw null;
        public static int MaxMagnitude(int x, int y) => throw null;
        public static int MaxMagnitudeNumber(int x, int y) => throw null;
        public static int MaxNumber(int x, int y) => throw null;
        public const int MaxValue = default;
        static int System.Numerics.IMinMaxValue<int>.MaxValue { get => throw null; }
        public static int Min(int x, int y) => throw null;
        public static int MinMagnitude(int x, int y) => throw null;
        public static int MinMagnitudeNumber(int x, int y) => throw null;
        public static int MinNumber(int x, int y) => throw null;
        public const int MinValue = default;
        static int System.Numerics.IMinMaxValue<int>.MinValue { get => throw null; }
        static int System.Numerics.IMultiplicativeIdentity<int, int>.MultiplicativeIdentity { get => throw null; }
        static int System.Numerics.ISignedNumber<int>.NegativeOne { get => throw null; }
        static int System.Numerics.INumberBase<int>.One { get => throw null; }
        public static int Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static int Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static int Parse(string s) => throw null;
        public static int Parse(string s, System.IFormatProvider provider) => throw null;
        public static int Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static int Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static int PopCount(int value) => throw null;
        static int System.Numerics.INumberBase<int>.Radix { get => throw null; }
        public static int RotateLeft(int value, int rotateAmount) => throw null;
        public static int RotateRight(int value, int rotateAmount) => throw null;
        public static int Sign(int value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static int TrailingZeroCount(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromChecked<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromSaturating<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromTruncating<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToChecked<TOther>(int value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToSaturating<TOther>(int value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToTruncating<TOther>(int value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out int result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(string s, out int result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out int value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out int value) => throw null;
        bool System.Numerics.IBinaryInteger<int>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<int>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static int System.Numerics.INumberBase<int>.Zero { get => throw null; }
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator ^(int left, int right) => throw null;
        static int System.Numerics.IMultiplyOperators<int, int, int>.operator checked *(int left, int right) => throw null;
        static int System.Numerics.IAdditionOperators<int, int, int>.operator checked +(int left, int right) => throw null;
        static int System.Numerics.IIncrementOperators<int>.operator checked ++(int value) => throw null;
        static int System.Numerics.IUnaryNegationOperators<int, int>.operator checked -(int value) => throw null;
        static int System.Numerics.ISubtractionOperators<int, int, int>.operator checked -(int left, int right) => throw null;
        static int System.Numerics.IDecrementOperators<int>.operator checked --(int value) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator |(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator ~(int value) => throw null;
    }

    public struct Int64 : System.IComparable, System.IComparable<System.Int64>, System.IConvertible, System.IEquatable<System.Int64>, System.IFormattable, System.IParsable<System.Int64>, System.ISpanFormattable, System.ISpanParsable<System.Int64>, System.Numerics.IAdditionOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.IAdditiveIdentity<System.Int64, System.Int64>, System.Numerics.IBinaryInteger<System.Int64>, System.Numerics.IBinaryNumber<System.Int64>, System.Numerics.IBitwiseOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.IComparisonOperators<System.Int64, System.Int64, bool>, System.Numerics.IDecrementOperators<System.Int64>, System.Numerics.IDivisionOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.IEqualityOperators<System.Int64, System.Int64, bool>, System.Numerics.IIncrementOperators<System.Int64>, System.Numerics.IMinMaxValue<System.Int64>, System.Numerics.IModulusOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.IMultiplicativeIdentity<System.Int64, System.Int64>, System.Numerics.IMultiplyOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.INumber<System.Int64>, System.Numerics.INumberBase<System.Int64>, System.Numerics.IShiftOperators<System.Int64, int, System.Int64>, System.Numerics.ISignedNumber<System.Int64>, System.Numerics.ISubtractionOperators<System.Int64, System.Int64, System.Int64>, System.Numerics.IUnaryNegationOperators<System.Int64, System.Int64>, System.Numerics.IUnaryPlusOperators<System.Int64, System.Int64>
    {
        static bool System.Numerics.IEqualityOperators<System.Int64, System.Int64, bool>.operator !=(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IModulusOperators<System.Int64, System.Int64, System.Int64>.operator %(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IBitwiseOperators<System.Int64, System.Int64, System.Int64>.operator &(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IMultiplyOperators<System.Int64, System.Int64, System.Int64>.operator *(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IUnaryPlusOperators<System.Int64, System.Int64>.operator +(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IAdditionOperators<System.Int64, System.Int64, System.Int64>.operator +(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IIncrementOperators<System.Int64>.operator ++(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IUnaryNegationOperators<System.Int64, System.Int64>.operator -(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.ISubtractionOperators<System.Int64, System.Int64, System.Int64>.operator -(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IDecrementOperators<System.Int64>.operator --(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IDivisionOperators<System.Int64, System.Int64, System.Int64>.operator /(System.Int64 left, System.Int64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int64, System.Int64, bool>.operator <(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IShiftOperators<System.Int64, int, System.Int64>.operator <<(System.Int64 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int64, System.Int64, bool>.operator <=(System.Int64 left, System.Int64 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Int64, System.Int64, bool>.operator ==(System.Int64 left, System.Int64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int64, System.Int64, bool>.operator >(System.Int64 left, System.Int64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int64, System.Int64, bool>.operator >=(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IShiftOperators<System.Int64, int, System.Int64>.operator >>(System.Int64 value, int shiftAmount) => throw null;
        static System.Int64 System.Numerics.IShiftOperators<System.Int64, int, System.Int64>.operator >>>(System.Int64 value, int shiftAmount) => throw null;
        public static System.Int64 Abs(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IAdditiveIdentity<System.Int64, System.Int64>.AdditiveIdentity { get => throw null; }
        static System.Int64 System.Numerics.IBinaryNumber<System.Int64>.AllBitsSet { get => throw null; }
        public static System.Int64 Clamp(System.Int64 value, System.Int64 min, System.Int64 max) => throw null;
        public int CompareTo(System.Int64 value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.Int64 CopySign(System.Int64 value, System.Int64 sign) => throw null;
        static System.Int64 System.Numerics.INumberBase<System.Int64>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Int64 System.Numerics.INumberBase<System.Int64>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Int64 System.Numerics.INumberBase<System.Int64>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.Int64, System.Int64) DivRem(System.Int64 left, System.Int64 right) => throw null;
        public bool Equals(System.Int64 obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Int64>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.Int64>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        // Stub generator skipped constructor 
        public static bool IsCanonical(System.Int64 value) => throw null;
        public static bool IsComplexNumber(System.Int64 value) => throw null;
        public static bool IsEvenInteger(System.Int64 value) => throw null;
        public static bool IsFinite(System.Int64 value) => throw null;
        public static bool IsImaginaryNumber(System.Int64 value) => throw null;
        public static bool IsInfinity(System.Int64 value) => throw null;
        public static bool IsInteger(System.Int64 value) => throw null;
        public static bool IsNaN(System.Int64 value) => throw null;
        public static bool IsNegative(System.Int64 value) => throw null;
        public static bool IsNegativeInfinity(System.Int64 value) => throw null;
        public static bool IsNormal(System.Int64 value) => throw null;
        public static bool IsOddInteger(System.Int64 value) => throw null;
        public static bool IsPositive(System.Int64 value) => throw null;
        public static bool IsPositiveInfinity(System.Int64 value) => throw null;
        public static bool IsPow2(System.Int64 value) => throw null;
        public static bool IsRealNumber(System.Int64 value) => throw null;
        public static bool IsSubnormal(System.Int64 value) => throw null;
        public static bool IsZero(System.Int64 value) => throw null;
        public static System.Int64 LeadingZeroCount(System.Int64 value) => throw null;
        public static System.Int64 Log2(System.Int64 value) => throw null;
        public static System.Int64 Max(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MaxMagnitude(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MaxMagnitudeNumber(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MaxNumber(System.Int64 x, System.Int64 y) => throw null;
        public const System.Int64 MaxValue = default;
        static System.Int64 System.Numerics.IMinMaxValue<System.Int64>.MaxValue { get => throw null; }
        public static System.Int64 Min(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MinMagnitude(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MinMagnitudeNumber(System.Int64 x, System.Int64 y) => throw null;
        public static System.Int64 MinNumber(System.Int64 x, System.Int64 y) => throw null;
        public const System.Int64 MinValue = default;
        static System.Int64 System.Numerics.IMinMaxValue<System.Int64>.MinValue { get => throw null; }
        static System.Int64 System.Numerics.IMultiplicativeIdentity<System.Int64, System.Int64>.MultiplicativeIdentity { get => throw null; }
        static System.Int64 System.Numerics.ISignedNumber<System.Int64>.NegativeOne { get => throw null; }
        static System.Int64 System.Numerics.INumberBase<System.Int64>.One { get => throw null; }
        public static System.Int64 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.Int64 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.Int64 Parse(string s) => throw null;
        public static System.Int64 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Int64 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.Int64 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.Int64 PopCount(System.Int64 value) => throw null;
        static int System.Numerics.INumberBase<System.Int64>.Radix { get => throw null; }
        public static System.Int64 RotateLeft(System.Int64 value, int rotateAmount) => throw null;
        public static System.Int64 RotateRight(System.Int64 value, int rotateAmount) => throw null;
        public static int Sign(System.Int64 value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.Int64 TrailingZeroCount(System.Int64 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertFromChecked<TOther>(TOther value, out System.Int64 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertFromSaturating<TOther>(TOther value, out System.Int64 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertFromTruncating<TOther>(TOther value, out System.Int64 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertToChecked<TOther>(System.Int64 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertToSaturating<TOther>(System.Int64 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int64>.TryConvertToTruncating<TOther>(System.Int64 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.Int64 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int64 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.Int64 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.Int64 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int64 result) => throw null;
        public static bool TryParse(string s, out System.Int64 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int64 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.Int64 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.Int64 System.Numerics.INumberBase<System.Int64>.Zero { get => throw null; }
        static System.Int64 System.Numerics.IBitwiseOperators<System.Int64, System.Int64, System.Int64>.operator ^(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IMultiplyOperators<System.Int64, System.Int64, System.Int64>.operator checked *(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IAdditionOperators<System.Int64, System.Int64, System.Int64>.operator checked +(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IIncrementOperators<System.Int64>.operator checked ++(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IUnaryNegationOperators<System.Int64, System.Int64>.operator checked -(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.ISubtractionOperators<System.Int64, System.Int64, System.Int64>.operator checked -(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IDecrementOperators<System.Int64>.operator checked --(System.Int64 value) => throw null;
        static System.Int64 System.Numerics.IBitwiseOperators<System.Int64, System.Int64, System.Int64>.operator |(System.Int64 left, System.Int64 right) => throw null;
        static System.Int64 System.Numerics.IBitwiseOperators<System.Int64, System.Int64, System.Int64>.operator ~(System.Int64 value) => throw null;
    }

    public struct IntPtr : System.IComparable, System.IComparable<System.IntPtr>, System.IEquatable<System.IntPtr>, System.IFormattable, System.IParsable<System.IntPtr>, System.ISpanFormattable, System.ISpanParsable<System.IntPtr>, System.Numerics.IAdditionOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.IAdditiveIdentity<System.IntPtr, System.IntPtr>, System.Numerics.IBinaryInteger<System.IntPtr>, System.Numerics.IBinaryNumber<System.IntPtr>, System.Numerics.IBitwiseOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.IComparisonOperators<System.IntPtr, System.IntPtr, bool>, System.Numerics.IDecrementOperators<System.IntPtr>, System.Numerics.IDivisionOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.IEqualityOperators<System.IntPtr, System.IntPtr, bool>, System.Numerics.IIncrementOperators<System.IntPtr>, System.Numerics.IMinMaxValue<System.IntPtr>, System.Numerics.IModulusOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.IMultiplicativeIdentity<System.IntPtr, System.IntPtr>, System.Numerics.IMultiplyOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.INumber<System.IntPtr>, System.Numerics.INumberBase<System.IntPtr>, System.Numerics.IShiftOperators<System.IntPtr, int, System.IntPtr>, System.Numerics.ISignedNumber<System.IntPtr>, System.Numerics.ISubtractionOperators<System.IntPtr, System.IntPtr, System.IntPtr>, System.Numerics.IUnaryNegationOperators<System.IntPtr, System.IntPtr>, System.Numerics.IUnaryPlusOperators<System.IntPtr, System.IntPtr>, System.Runtime.Serialization.ISerializable
    {
        static bool System.Numerics.IEqualityOperators<System.IntPtr, System.IntPtr, bool>.operator !=(System.IntPtr value1, System.IntPtr value2) => throw null;
        static System.IntPtr System.Numerics.IModulusOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator %(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IBitwiseOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator &(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IMultiplyOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator *(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IUnaryPlusOperators<System.IntPtr, System.IntPtr>.operator +(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.IAdditionOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator +(System.IntPtr left, System.IntPtr right) => throw null;
        public static System.IntPtr operator +(System.IntPtr pointer, int offset) => throw null;
        static System.IntPtr System.Numerics.IIncrementOperators<System.IntPtr>.operator ++(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.IUnaryNegationOperators<System.IntPtr, System.IntPtr>.operator -(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.ISubtractionOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator -(System.IntPtr left, System.IntPtr right) => throw null;
        public static System.IntPtr operator -(System.IntPtr pointer, int offset) => throw null;
        static System.IntPtr System.Numerics.IDecrementOperators<System.IntPtr>.operator --(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.IDivisionOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator /(System.IntPtr left, System.IntPtr right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.IntPtr, System.IntPtr, bool>.operator <(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IShiftOperators<System.IntPtr, int, System.IntPtr>.operator <<(System.IntPtr value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.IntPtr, System.IntPtr, bool>.operator <=(System.IntPtr left, System.IntPtr right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.IntPtr, System.IntPtr, bool>.operator ==(System.IntPtr value1, System.IntPtr value2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.IntPtr, System.IntPtr, bool>.operator >(System.IntPtr left, System.IntPtr right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.IntPtr, System.IntPtr, bool>.operator >=(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IShiftOperators<System.IntPtr, int, System.IntPtr>.operator >>(System.IntPtr value, int shiftAmount) => throw null;
        static System.IntPtr System.Numerics.IShiftOperators<System.IntPtr, int, System.IntPtr>.operator >>>(System.IntPtr value, int shiftAmount) => throw null;
        public static System.IntPtr Abs(System.IntPtr value) => throw null;
        public static System.IntPtr Add(System.IntPtr pointer, int offset) => throw null;
        static System.IntPtr System.Numerics.IAdditiveIdentity<System.IntPtr, System.IntPtr>.AdditiveIdentity { get => throw null; }
        static System.IntPtr System.Numerics.IBinaryNumber<System.IntPtr>.AllBitsSet { get => throw null; }
        public static System.IntPtr Clamp(System.IntPtr value, System.IntPtr min, System.IntPtr max) => throw null;
        public int CompareTo(System.IntPtr value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.IntPtr CopySign(System.IntPtr value, System.IntPtr sign) => throw null;
        static System.IntPtr System.Numerics.INumberBase<System.IntPtr>.CreateChecked<TOther>(TOther value) => throw null;
        static System.IntPtr System.Numerics.INumberBase<System.IntPtr>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.IntPtr System.Numerics.INumberBase<System.IntPtr>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.IntPtr, System.IntPtr) DivRem(System.IntPtr left, System.IntPtr right) => throw null;
        public bool Equals(System.IntPtr other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.IntPtr>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IBinaryInteger<System.IntPtr>.GetShortestBitLength() => throw null;
        // Stub generator skipped constructor 
        unsafe public IntPtr(void* value) => throw null;
        public IntPtr(int value) => throw null;
        public IntPtr(System.Int64 value) => throw null;
        public static bool IsCanonical(System.IntPtr value) => throw null;
        public static bool IsComplexNumber(System.IntPtr value) => throw null;
        public static bool IsEvenInteger(System.IntPtr value) => throw null;
        public static bool IsFinite(System.IntPtr value) => throw null;
        public static bool IsImaginaryNumber(System.IntPtr value) => throw null;
        public static bool IsInfinity(System.IntPtr value) => throw null;
        public static bool IsInteger(System.IntPtr value) => throw null;
        public static bool IsNaN(System.IntPtr value) => throw null;
        public static bool IsNegative(System.IntPtr value) => throw null;
        public static bool IsNegativeInfinity(System.IntPtr value) => throw null;
        public static bool IsNormal(System.IntPtr value) => throw null;
        public static bool IsOddInteger(System.IntPtr value) => throw null;
        public static bool IsPositive(System.IntPtr value) => throw null;
        public static bool IsPositiveInfinity(System.IntPtr value) => throw null;
        public static bool IsPow2(System.IntPtr value) => throw null;
        public static bool IsRealNumber(System.IntPtr value) => throw null;
        public static bool IsSubnormal(System.IntPtr value) => throw null;
        public static bool IsZero(System.IntPtr value) => throw null;
        public static System.IntPtr LeadingZeroCount(System.IntPtr value) => throw null;
        public static System.IntPtr Log2(System.IntPtr value) => throw null;
        public static System.IntPtr Max(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MaxMagnitude(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MaxMagnitudeNumber(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MaxNumber(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MaxValue { get => throw null; }
        static System.IntPtr System.Numerics.IMinMaxValue<System.IntPtr>.MaxValue { get => throw null; }
        public static System.IntPtr Min(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MinMagnitude(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MinMagnitudeNumber(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MinNumber(System.IntPtr x, System.IntPtr y) => throw null;
        public static System.IntPtr MinValue { get => throw null; }
        static System.IntPtr System.Numerics.IMinMaxValue<System.IntPtr>.MinValue { get => throw null; }
        static System.IntPtr System.Numerics.IMultiplicativeIdentity<System.IntPtr, System.IntPtr>.MultiplicativeIdentity { get => throw null; }
        static System.IntPtr System.Numerics.ISignedNumber<System.IntPtr>.NegativeOne { get => throw null; }
        static System.IntPtr System.Numerics.INumberBase<System.IntPtr>.One { get => throw null; }
        public static System.IntPtr Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.IntPtr Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.IntPtr Parse(string s) => throw null;
        public static System.IntPtr Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.IntPtr Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.IntPtr Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.IntPtr PopCount(System.IntPtr value) => throw null;
        static int System.Numerics.INumberBase<System.IntPtr>.Radix { get => throw null; }
        public static System.IntPtr RotateLeft(System.IntPtr value, int rotateAmount) => throw null;
        public static System.IntPtr RotateRight(System.IntPtr value, int rotateAmount) => throw null;
        public static int Sign(System.IntPtr value) => throw null;
        public static int Size { get => throw null; }
        public static System.IntPtr Subtract(System.IntPtr pointer, int offset) => throw null;
        public int ToInt32() => throw null;
        public System.Int64 ToInt64() => throw null;
        unsafe public void* ToPointer() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public static System.IntPtr TrailingZeroCount(System.IntPtr value) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertFromChecked<TOther>(TOther value, out System.IntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertFromSaturating<TOther>(TOther value, out System.IntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertFromTruncating<TOther>(TOther value, out System.IntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertToChecked<TOther>(System.IntPtr value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertToSaturating<TOther>(System.IntPtr value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.IntPtr>.TryConvertToTruncating<TOther>(System.IntPtr value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.IntPtr result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.IntPtr result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.IntPtr result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.IntPtr result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.IntPtr result) => throw null;
        public static bool TryParse(string s, out System.IntPtr result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.IntPtr value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.IntPtr value) => throw null;
        bool System.Numerics.IBinaryInteger<System.IntPtr>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.IntPtr>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        public static System.IntPtr Zero;
        static System.IntPtr System.Numerics.INumberBase<System.IntPtr>.Zero { get => throw null; }
        static System.IntPtr System.Numerics.IBitwiseOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator ^(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IMultiplyOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator checked *(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IAdditionOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator checked +(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IIncrementOperators<System.IntPtr>.operator checked ++(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.IUnaryNegationOperators<System.IntPtr, System.IntPtr>.operator checked -(System.IntPtr value) => throw null;
        static System.IntPtr System.Numerics.ISubtractionOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator checked -(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IDecrementOperators<System.IntPtr>.operator checked --(System.IntPtr value) => throw null;
        public static explicit operator System.Int64(System.IntPtr value) => throw null;
        public static explicit operator int(System.IntPtr value) => throw null;
        unsafe public static explicit operator void*(System.IntPtr value) => throw null;
        unsafe public static explicit operator System.IntPtr(void* value) => throw null;
        public static explicit operator System.IntPtr(int value) => throw null;
        public static explicit operator System.IntPtr(System.Int64 value) => throw null;
        static System.IntPtr System.Numerics.IBitwiseOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator |(System.IntPtr left, System.IntPtr right) => throw null;
        static System.IntPtr System.Numerics.IBitwiseOperators<System.IntPtr, System.IntPtr, System.IntPtr>.operator ~(System.IntPtr value) => throw null;
    }

    public class InvalidCastException : System.SystemException
    {
        public InvalidCastException() => throw null;
        protected InvalidCastException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidCastException(string message) => throw null;
        public InvalidCastException(string message, System.Exception innerException) => throw null;
        public InvalidCastException(string message, int errorCode) => throw null;
    }

    public class InvalidOperationException : System.SystemException
    {
        public InvalidOperationException() => throw null;
        protected InvalidOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidOperationException(string message) => throw null;
        public InvalidOperationException(string message, System.Exception innerException) => throw null;
    }

    public class InvalidProgramException : System.SystemException
    {
        public InvalidProgramException() => throw null;
        public InvalidProgramException(string message) => throw null;
        public InvalidProgramException(string message, System.Exception inner) => throw null;
    }

    public class InvalidTimeZoneException : System.Exception
    {
        public InvalidTimeZoneException() => throw null;
        protected InvalidTimeZoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidTimeZoneException(string message) => throw null;
        public InvalidTimeZoneException(string message, System.Exception innerException) => throw null;
    }

    public class Lazy<T, TMetadata> : System.Lazy<T>
    {
        public Lazy(System.Func<T> valueFactory, TMetadata metadata) => throw null;
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, bool isThreadSafe) => throw null;
        public Lazy(TMetadata metadata) => throw null;
        public Lazy(TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(TMetadata metadata, bool isThreadSafe) => throw null;
        public TMetadata Metadata { get => throw null; }
    }

    public class Lazy<T>
    {
        public bool IsValueCreated { get => throw null; }
        public Lazy() => throw null;
        public Lazy(System.Func<T> valueFactory) => throw null;
        public Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(System.Func<T> valueFactory, bool isThreadSafe) => throw null;
        public Lazy(System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(T value) => throw null;
        public Lazy(bool isThreadSafe) => throw null;
        public override string ToString() => throw null;
        public T Value { get => throw null; }
    }

    public class LdapStyleUriParser : System.UriParser
    {
        public LdapStyleUriParser() => throw null;
    }

    public enum LoaderOptimization : int
    {
        DisallowBindings = 4,
        DomainMask = 3,
        MultiDomain = 2,
        MultiDomainHost = 3,
        NotSpecified = 0,
        SingleDomain = 1,
    }

    public class LoaderOptimizationAttribute : System.Attribute
    {
        public LoaderOptimizationAttribute(System.LoaderOptimization value) => throw null;
        public LoaderOptimizationAttribute(System.Byte value) => throw null;
        public System.LoaderOptimization Value { get => throw null; }
    }

    public class MTAThreadAttribute : System.Attribute
    {
        public MTAThreadAttribute() => throw null;
    }

    public abstract class MarshalByRefObject
    {
        public object GetLifetimeService() => throw null;
        public virtual object InitializeLifetimeService() => throw null;
        protected MarshalByRefObject() => throw null;
        protected System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) => throw null;
    }

    public static class Math
    {
        public static System.IntPtr Abs(System.IntPtr value) => throw null;
        public static System.Decimal Abs(System.Decimal value) => throw null;
        public static double Abs(double value) => throw null;
        public static float Abs(float value) => throw null;
        public static int Abs(int value) => throw null;
        public static System.Int64 Abs(System.Int64 value) => throw null;
        public static System.SByte Abs(System.SByte value) => throw null;
        public static System.Int16 Abs(System.Int16 value) => throw null;
        public static double Acos(double d) => throw null;
        public static double Acosh(double d) => throw null;
        public static double Asin(double d) => throw null;
        public static double Asinh(double d) => throw null;
        public static double Atan(double d) => throw null;
        public static double Atan2(double y, double x) => throw null;
        public static double Atanh(double d) => throw null;
        public static System.Int64 BigMul(int a, int b) => throw null;
        public static System.Int64 BigMul(System.Int64 a, System.Int64 b, out System.Int64 low) => throw null;
        public static System.UInt64 BigMul(System.UInt64 a, System.UInt64 b, out System.UInt64 low) => throw null;
        public static double BitDecrement(double x) => throw null;
        public static double BitIncrement(double x) => throw null;
        public static double Cbrt(double d) => throw null;
        public static System.Decimal Ceiling(System.Decimal d) => throw null;
        public static double Ceiling(double a) => throw null;
        public static System.IntPtr Clamp(System.IntPtr value, System.IntPtr min, System.IntPtr max) => throw null;
        public static System.UIntPtr Clamp(System.UIntPtr value, System.UIntPtr min, System.UIntPtr max) => throw null;
        public static System.Byte Clamp(System.Byte value, System.Byte min, System.Byte max) => throw null;
        public static System.Decimal Clamp(System.Decimal value, System.Decimal min, System.Decimal max) => throw null;
        public static double Clamp(double value, double min, double max) => throw null;
        public static float Clamp(float value, float min, float max) => throw null;
        public static int Clamp(int value, int min, int max) => throw null;
        public static System.Int64 Clamp(System.Int64 value, System.Int64 min, System.Int64 max) => throw null;
        public static System.SByte Clamp(System.SByte value, System.SByte min, System.SByte max) => throw null;
        public static System.Int16 Clamp(System.Int16 value, System.Int16 min, System.Int16 max) => throw null;
        public static System.UInt32 Clamp(System.UInt32 value, System.UInt32 min, System.UInt32 max) => throw null;
        public static System.UInt64 Clamp(System.UInt64 value, System.UInt64 min, System.UInt64 max) => throw null;
        public static System.UInt16 Clamp(System.UInt16 value, System.UInt16 min, System.UInt16 max) => throw null;
        public static double CopySign(double x, double y) => throw null;
        public static double Cos(double d) => throw null;
        public static double Cosh(double value) => throw null;
        public static (System.IntPtr, System.IntPtr) DivRem(System.IntPtr left, System.IntPtr right) => throw null;
        public static (System.UIntPtr, System.UIntPtr) DivRem(System.UIntPtr left, System.UIntPtr right) => throw null;
        public static (System.Byte, System.Byte) DivRem(System.Byte left, System.Byte right) => throw null;
        public static (int, int) DivRem(int left, int right) => throw null;
        public static int DivRem(int a, int b, out int result) => throw null;
        public static (System.Int64, System.Int64) DivRem(System.Int64 left, System.Int64 right) => throw null;
        public static System.Int64 DivRem(System.Int64 a, System.Int64 b, out System.Int64 result) => throw null;
        public static (System.SByte, System.SByte) DivRem(System.SByte left, System.SByte right) => throw null;
        public static (System.Int16, System.Int16) DivRem(System.Int16 left, System.Int16 right) => throw null;
        public static (System.UInt32, System.UInt32) DivRem(System.UInt32 left, System.UInt32 right) => throw null;
        public static (System.UInt64, System.UInt64) DivRem(System.UInt64 left, System.UInt64 right) => throw null;
        public static (System.UInt16, System.UInt16) DivRem(System.UInt16 left, System.UInt16 right) => throw null;
        public const double E = default;
        public static double Exp(double d) => throw null;
        public static System.Decimal Floor(System.Decimal d) => throw null;
        public static double Floor(double d) => throw null;
        public static double FusedMultiplyAdd(double x, double y, double z) => throw null;
        public static double IEEERemainder(double x, double y) => throw null;
        public static int ILogB(double x) => throw null;
        public static double Log(double d) => throw null;
        public static double Log(double a, double newBase) => throw null;
        public static double Log10(double d) => throw null;
        public static double Log2(double x) => throw null;
        public static System.IntPtr Max(System.IntPtr val1, System.IntPtr val2) => throw null;
        public static System.UIntPtr Max(System.UIntPtr val1, System.UIntPtr val2) => throw null;
        public static System.Byte Max(System.Byte val1, System.Byte val2) => throw null;
        public static System.Decimal Max(System.Decimal val1, System.Decimal val2) => throw null;
        public static double Max(double val1, double val2) => throw null;
        public static float Max(float val1, float val2) => throw null;
        public static int Max(int val1, int val2) => throw null;
        public static System.Int64 Max(System.Int64 val1, System.Int64 val2) => throw null;
        public static System.SByte Max(System.SByte val1, System.SByte val2) => throw null;
        public static System.Int16 Max(System.Int16 val1, System.Int16 val2) => throw null;
        public static System.UInt32 Max(System.UInt32 val1, System.UInt32 val2) => throw null;
        public static System.UInt64 Max(System.UInt64 val1, System.UInt64 val2) => throw null;
        public static System.UInt16 Max(System.UInt16 val1, System.UInt16 val2) => throw null;
        public static double MaxMagnitude(double x, double y) => throw null;
        public static System.IntPtr Min(System.IntPtr val1, System.IntPtr val2) => throw null;
        public static System.UIntPtr Min(System.UIntPtr val1, System.UIntPtr val2) => throw null;
        public static System.Byte Min(System.Byte val1, System.Byte val2) => throw null;
        public static System.Decimal Min(System.Decimal val1, System.Decimal val2) => throw null;
        public static double Min(double val1, double val2) => throw null;
        public static float Min(float val1, float val2) => throw null;
        public static int Min(int val1, int val2) => throw null;
        public static System.Int64 Min(System.Int64 val1, System.Int64 val2) => throw null;
        public static System.SByte Min(System.SByte val1, System.SByte val2) => throw null;
        public static System.Int16 Min(System.Int16 val1, System.Int16 val2) => throw null;
        public static System.UInt32 Min(System.UInt32 val1, System.UInt32 val2) => throw null;
        public static System.UInt64 Min(System.UInt64 val1, System.UInt64 val2) => throw null;
        public static System.UInt16 Min(System.UInt16 val1, System.UInt16 val2) => throw null;
        public static double MinMagnitude(double x, double y) => throw null;
        public const double PI = default;
        public static double Pow(double x, double y) => throw null;
        public static double ReciprocalEstimate(double d) => throw null;
        public static double ReciprocalSqrtEstimate(double d) => throw null;
        public static System.Decimal Round(System.Decimal d) => throw null;
        public static System.Decimal Round(System.Decimal d, System.MidpointRounding mode) => throw null;
        public static System.Decimal Round(System.Decimal d, int decimals) => throw null;
        public static System.Decimal Round(System.Decimal d, int decimals, System.MidpointRounding mode) => throw null;
        public static double Round(double a) => throw null;
        public static double Round(double value, System.MidpointRounding mode) => throw null;
        public static double Round(double value, int digits) => throw null;
        public static double Round(double value, int digits, System.MidpointRounding mode) => throw null;
        public static double ScaleB(double x, int n) => throw null;
        public static int Sign(System.IntPtr value) => throw null;
        public static int Sign(System.Decimal value) => throw null;
        public static int Sign(double value) => throw null;
        public static int Sign(float value) => throw null;
        public static int Sign(int value) => throw null;
        public static int Sign(System.Int64 value) => throw null;
        public static int Sign(System.SByte value) => throw null;
        public static int Sign(System.Int16 value) => throw null;
        public static double Sin(double a) => throw null;
        public static (double, double) SinCos(double x) => throw null;
        public static double Sinh(double value) => throw null;
        public static double Sqrt(double d) => throw null;
        public static double Tan(double a) => throw null;
        public static double Tanh(double value) => throw null;
        public const double Tau = default;
        public static System.Decimal Truncate(System.Decimal d) => throw null;
        public static double Truncate(double d) => throw null;
    }

    public static class MathF
    {
        public static float Abs(float x) => throw null;
        public static float Acos(float x) => throw null;
        public static float Acosh(float x) => throw null;
        public static float Asin(float x) => throw null;
        public static float Asinh(float x) => throw null;
        public static float Atan(float x) => throw null;
        public static float Atan2(float y, float x) => throw null;
        public static float Atanh(float x) => throw null;
        public static float BitDecrement(float x) => throw null;
        public static float BitIncrement(float x) => throw null;
        public static float Cbrt(float x) => throw null;
        public static float Ceiling(float x) => throw null;
        public static float CopySign(float x, float y) => throw null;
        public static float Cos(float x) => throw null;
        public static float Cosh(float x) => throw null;
        public const float E = default;
        public static float Exp(float x) => throw null;
        public static float Floor(float x) => throw null;
        public static float FusedMultiplyAdd(float x, float y, float z) => throw null;
        public static float IEEERemainder(float x, float y) => throw null;
        public static int ILogB(float x) => throw null;
        public static float Log(float x) => throw null;
        public static float Log(float x, float y) => throw null;
        public static float Log10(float x) => throw null;
        public static float Log2(float x) => throw null;
        public static float Max(float x, float y) => throw null;
        public static float MaxMagnitude(float x, float y) => throw null;
        public static float Min(float x, float y) => throw null;
        public static float MinMagnitude(float x, float y) => throw null;
        public const float PI = default;
        public static float Pow(float x, float y) => throw null;
        public static float ReciprocalEstimate(float x) => throw null;
        public static float ReciprocalSqrtEstimate(float x) => throw null;
        public static float Round(float x) => throw null;
        public static float Round(float x, System.MidpointRounding mode) => throw null;
        public static float Round(float x, int digits) => throw null;
        public static float Round(float x, int digits, System.MidpointRounding mode) => throw null;
        public static float ScaleB(float x, int n) => throw null;
        public static int Sign(float x) => throw null;
        public static float Sin(float x) => throw null;
        public static (float, float) SinCos(float x) => throw null;
        public static float Sinh(float x) => throw null;
        public static float Sqrt(float x) => throw null;
        public static float Tan(float x) => throw null;
        public static float Tanh(float x) => throw null;
        public const float Tau = default;
        public static float Truncate(float x) => throw null;
    }

    public class MemberAccessException : System.SystemException
    {
        public MemberAccessException() => throw null;
        protected MemberAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MemberAccessException(string message) => throw null;
        public MemberAccessException(string message, System.Exception inner) => throw null;
    }

    public struct Memory<T> : System.IEquatable<System.Memory<T>>
    {
        public void CopyTo(System.Memory<T> destination) => throw null;
        public static System.Memory<T> Empty { get => throw null; }
        public bool Equals(System.Memory<T> other) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        // Stub generator skipped constructor 
        public Memory(T[] array) => throw null;
        public Memory(T[] array, int start, int length) => throw null;
        public System.Buffers.MemoryHandle Pin() => throw null;
        public System.Memory<T> Slice(int start) => throw null;
        public System.Memory<T> Slice(int start, int length) => throw null;
        public System.Span<T> Span { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Memory<T> destination) => throw null;
        public static implicit operator System.Memory<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlyMemory<T>(System.Memory<T> memory) => throw null;
        public static implicit operator System.Memory<T>(T[] array) => throw null;
    }

    public class MethodAccessException : System.MemberAccessException
    {
        public MethodAccessException() => throw null;
        protected MethodAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MethodAccessException(string message) => throw null;
        public MethodAccessException(string message, System.Exception inner) => throw null;
    }

    public enum MidpointRounding : int
    {
        AwayFromZero = 1,
        ToEven = 0,
        ToNegativeInfinity = 3,
        ToPositiveInfinity = 4,
        ToZero = 2,
    }

    public class MissingFieldException : System.MissingMemberException, System.Runtime.Serialization.ISerializable
    {
        public override string Message { get => throw null; }
        public MissingFieldException() => throw null;
        protected MissingFieldException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingFieldException(string message) => throw null;
        public MissingFieldException(string message, System.Exception inner) => throw null;
        public MissingFieldException(string className, string fieldName) => throw null;
    }

    public class MissingMemberException : System.MemberAccessException, System.Runtime.Serialization.ISerializable
    {
        protected string ClassName;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        protected string MemberName;
        public override string Message { get => throw null; }
        public MissingMemberException() => throw null;
        protected MissingMemberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingMemberException(string message) => throw null;
        public MissingMemberException(string message, System.Exception inner) => throw null;
        public MissingMemberException(string className, string memberName) => throw null;
        protected System.Byte[] Signature;
    }

    public class MissingMethodException : System.MissingMemberException
    {
        public override string Message { get => throw null; }
        public MissingMethodException() => throw null;
        protected MissingMethodException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingMethodException(string message) => throw null;
        public MissingMethodException(string message, System.Exception inner) => throw null;
        public MissingMethodException(string className, string methodName) => throw null;
    }

    public struct ModuleHandle : System.IEquatable<System.ModuleHandle>
    {
        public static bool operator !=(System.ModuleHandle left, System.ModuleHandle right) => throw null;
        public static bool operator ==(System.ModuleHandle left, System.ModuleHandle right) => throw null;
        public static System.ModuleHandle EmptyHandle;
        public bool Equals(System.ModuleHandle handle) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public System.RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken) => throw null;
        public System.RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken) => throw null;
        public System.RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken) => throw null;
        public int MDStreamVersion { get => throw null; }
        // Stub generator skipped constructor 
        public System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken) => throw null;
        public System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
        public System.RuntimeMethodHandle ResolveMethodHandle(int methodToken) => throw null;
        public System.RuntimeMethodHandle ResolveMethodHandle(int methodToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
        public System.RuntimeTypeHandle ResolveTypeHandle(int typeToken) => throw null;
        public System.RuntimeTypeHandle ResolveTypeHandle(int typeToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
    }

    public abstract class MulticastDelegate : System.Delegate
    {
        public static bool operator !=(System.MulticastDelegate d1, System.MulticastDelegate d2) => throw null;
        public static bool operator ==(System.MulticastDelegate d1, System.MulticastDelegate d2) => throw null;
        protected override System.Delegate CombineImpl(System.Delegate follow) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public override System.Delegate[] GetInvocationList() => throw null;
        protected override System.Reflection.MethodInfo GetMethodImpl() => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        protected MulticastDelegate(System.Type target, string method) : base(default(System.Type), default(string)) => throw null;
        protected MulticastDelegate(object target, string method) : base(default(System.Type), default(string)) => throw null;
        protected override System.Delegate RemoveImpl(System.Delegate value) => throw null;
    }

    public class MulticastNotSupportedException : System.SystemException
    {
        public MulticastNotSupportedException() => throw null;
        public MulticastNotSupportedException(string message) => throw null;
        public MulticastNotSupportedException(string message, System.Exception inner) => throw null;
    }

    public class NetPipeStyleUriParser : System.UriParser
    {
        public NetPipeStyleUriParser() => throw null;
    }

    public class NetTcpStyleUriParser : System.UriParser
    {
        public NetTcpStyleUriParser() => throw null;
    }

    public class NewsStyleUriParser : System.UriParser
    {
        public NewsStyleUriParser() => throw null;
    }

    public class NonSerializedAttribute : System.Attribute
    {
        public NonSerializedAttribute() => throw null;
    }

    public class NotFiniteNumberException : System.ArithmeticException
    {
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotFiniteNumberException() => throw null;
        protected NotFiniteNumberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotFiniteNumberException(double offendingNumber) => throw null;
        public NotFiniteNumberException(string message) => throw null;
        public NotFiniteNumberException(string message, System.Exception innerException) => throw null;
        public NotFiniteNumberException(string message, double offendingNumber) => throw null;
        public NotFiniteNumberException(string message, double offendingNumber, System.Exception innerException) => throw null;
        public double OffendingNumber { get => throw null; }
    }

    public class NotImplementedException : System.SystemException
    {
        public NotImplementedException() => throw null;
        protected NotImplementedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotImplementedException(string message) => throw null;
        public NotImplementedException(string message, System.Exception inner) => throw null;
    }

    public class NotSupportedException : System.SystemException
    {
        public NotSupportedException() => throw null;
        protected NotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotSupportedException(string message) => throw null;
        public NotSupportedException(string message, System.Exception innerException) => throw null;
    }

    public class NullReferenceException : System.SystemException
    {
        public NullReferenceException() => throw null;
        protected NullReferenceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NullReferenceException(string message) => throw null;
        public NullReferenceException(string message, System.Exception innerException) => throw null;
    }

    public static class Nullable
    {
        public static int Compare<T>(T? n1, T? n2) where T : struct => throw null;
        public static bool Equals<T>(T? n1, T? n2) where T : struct => throw null;
        public static System.Type GetUnderlyingType(System.Type nullableType) => throw null;
        public static T GetValueRefOrDefaultRef<T>(T? nullable) where T : struct => throw null;
    }

    public struct Nullable<T> where T : struct
    {
        public override bool Equals(object other) => throw null;
        public override int GetHashCode() => throw null;
        public T GetValueOrDefault() => throw null;
        public T GetValueOrDefault(T defaultValue) => throw null;
        public bool HasValue { get => throw null; }
        // Stub generator skipped constructor 
        public Nullable(T value) => throw null;
        public override string ToString() => throw null;
        public T Value { get => throw null; }
        public static explicit operator T(System.Nullable<T> value) => throw null;
        public static implicit operator System.Nullable<T>(T value) => throw null;
    }

    public class Object
    {
        public virtual bool Equals(object obj) => throw null;
        public static bool Equals(object objA, object objB) => throw null;
        public virtual int GetHashCode() => throw null;
        public System.Type GetType() => throw null;
        protected object MemberwiseClone() => throw null;
        public Object() => throw null;
        public static bool ReferenceEquals(object objA, object objB) => throw null;
        public virtual string ToString() => throw null;
        // ERR: Stub generator didn't handle member: ~Object
    }

    public class ObjectDisposedException : System.InvalidOperationException
    {
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        protected ObjectDisposedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ObjectDisposedException(string objectName) => throw null;
        public ObjectDisposedException(string message, System.Exception innerException) => throw null;
        public ObjectDisposedException(string objectName, string message) => throw null;
        public string ObjectName { get => throw null; }
        public static void ThrowIf(bool condition, System.Type type) => throw null;
        public static void ThrowIf(bool condition, object instance) => throw null;
    }

    public class ObsoleteAttribute : System.Attribute
    {
        public string DiagnosticId { get => throw null; set => throw null; }
        public bool IsError { get => throw null; }
        public string Message { get => throw null; }
        public ObsoleteAttribute() => throw null;
        public ObsoleteAttribute(string message) => throw null;
        public ObsoleteAttribute(string message, bool error) => throw null;
        public string UrlFormat { get => throw null; set => throw null; }
    }

    public class OperatingSystem : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        public object Clone() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool IsAndroid() => throw null;
        public static bool IsAndroidVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsBrowser() => throw null;
        public static bool IsFreeBSD() => throw null;
        public static bool IsFreeBSDVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsIOS() => throw null;
        public static bool IsIOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsLinux() => throw null;
        public static bool IsMacCatalyst() => throw null;
        public static bool IsMacCatalystVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsMacOS() => throw null;
        public static bool IsMacOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsOSPlatform(string platform) => throw null;
        public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsTvOS() => throw null;
        public static bool IsTvOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsWatchOS() => throw null;
        public static bool IsWatchOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsWindows() => throw null;
        public static bool IsWindowsVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public OperatingSystem(System.PlatformID platform, System.Version version) => throw null;
        public System.PlatformID Platform { get => throw null; }
        public string ServicePack { get => throw null; }
        public override string ToString() => throw null;
        public System.Version Version { get => throw null; }
        public string VersionString { get => throw null; }
    }

    public class OperationCanceledException : System.SystemException
    {
        public System.Threading.CancellationToken CancellationToken { get => throw null; }
        public OperationCanceledException() => throw null;
        public OperationCanceledException(System.Threading.CancellationToken token) => throw null;
        protected OperationCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OperationCanceledException(string message) => throw null;
        public OperationCanceledException(string message, System.Threading.CancellationToken token) => throw null;
        public OperationCanceledException(string message, System.Exception innerException) => throw null;
        public OperationCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token) => throw null;
    }

    public class OutOfMemoryException : System.SystemException
    {
        public OutOfMemoryException() => throw null;
        protected OutOfMemoryException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OutOfMemoryException(string message) => throw null;
        public OutOfMemoryException(string message, System.Exception innerException) => throw null;
    }

    public class OverflowException : System.ArithmeticException
    {
        public OverflowException() => throw null;
        protected OverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OverflowException(string message) => throw null;
        public OverflowException(string message, System.Exception innerException) => throw null;
    }

    public class ParamArrayAttribute : System.Attribute
    {
        public ParamArrayAttribute() => throw null;
    }

    public enum PlatformID : int
    {
        MacOSX = 6,
        Other = 7,
        Unix = 4,
        Win32NT = 2,
        Win32S = 0,
        Win32Windows = 1,
        WinCE = 3,
        Xbox = 5,
    }

    public class PlatformNotSupportedException : System.NotSupportedException
    {
        public PlatformNotSupportedException() => throw null;
        protected PlatformNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public PlatformNotSupportedException(string message) => throw null;
        public PlatformNotSupportedException(string message, System.Exception inner) => throw null;
    }

    public delegate bool Predicate<T>(T obj);

    public class Progress<T> : System.IProgress<T>
    {
        protected virtual void OnReport(T value) => throw null;
        public Progress() => throw null;
        public Progress(System.Action<T> handler) => throw null;
        public event System.EventHandler<T> ProgressChanged;
        void System.IProgress<T>.Report(T value) => throw null;
    }

    public class Random
    {
        public virtual int Next() => throw null;
        public virtual int Next(int maxValue) => throw null;
        public virtual int Next(int minValue, int maxValue) => throw null;
        public virtual void NextBytes(System.Byte[] buffer) => throw null;
        public virtual void NextBytes(System.Span<System.Byte> buffer) => throw null;
        public virtual double NextDouble() => throw null;
        public virtual System.Int64 NextInt64() => throw null;
        public virtual System.Int64 NextInt64(System.Int64 maxValue) => throw null;
        public virtual System.Int64 NextInt64(System.Int64 minValue, System.Int64 maxValue) => throw null;
        public virtual float NextSingle() => throw null;
        public Random() => throw null;
        public Random(int Seed) => throw null;
        protected virtual double Sample() => throw null;
        public static System.Random Shared { get => throw null; }
    }

    public struct Range : System.IEquatable<System.Range>
    {
        public static System.Range All { get => throw null; }
        public System.Index End { get => throw null; }
        public static System.Range EndAt(System.Index end) => throw null;
        public bool Equals(System.Range other) => throw null;
        public override bool Equals(object value) => throw null;
        public override int GetHashCode() => throw null;
        public (int, int) GetOffsetAndLength(int length) => throw null;
        // Stub generator skipped constructor 
        public Range(System.Index start, System.Index end) => throw null;
        public System.Index Start { get => throw null; }
        public static System.Range StartAt(System.Index start) => throw null;
        public override string ToString() => throw null;
    }

    public class RankException : System.SystemException
    {
        public RankException() => throw null;
        protected RankException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public RankException(string message) => throw null;
        public RankException(string message, System.Exception innerException) => throw null;
    }

    public struct ReadOnlyMemory<T> : System.IEquatable<System.ReadOnlyMemory<T>>
    {
        public void CopyTo(System.Memory<T> destination) => throw null;
        public static System.ReadOnlyMemory<T> Empty { get => throw null; }
        public bool Equals(System.ReadOnlyMemory<T> other) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        public System.Buffers.MemoryHandle Pin() => throw null;
        // Stub generator skipped constructor 
        public ReadOnlyMemory(T[] array) => throw null;
        public ReadOnlyMemory(T[] array, int start, int length) => throw null;
        public System.ReadOnlyMemory<T> Slice(int start) => throw null;
        public System.ReadOnlyMemory<T> Slice(int start, int length) => throw null;
        public System.ReadOnlySpan<T> Span { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Memory<T> destination) => throw null;
        public static implicit operator System.ReadOnlyMemory<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlyMemory<T>(T[] array) => throw null;
    }

    public struct ReadOnlySpan<T>
    {
        public struct Enumerator
        {
            public T Current { get => throw null; }
            // Stub generator skipped constructor 
            public bool MoveNext() => throw null;
        }


        public static bool operator !=(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right) => throw null;
        public static bool operator ==(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right) => throw null;
        public void CopyTo(System.Span<T> destination) => throw null;
        public static System.ReadOnlySpan<T> Empty { get => throw null; }
        public override bool Equals(object obj) => throw null;
        public System.ReadOnlySpan<T>.Enumerator GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public T GetPinnableReference() => throw null;
        public bool IsEmpty { get => throw null; }
        public T this[int index] { get => throw null; }
        public int Length { get => throw null; }
        // Stub generator skipped constructor 
        public ReadOnlySpan(T reference) => throw null;
        public ReadOnlySpan(T[] array) => throw null;
        public ReadOnlySpan(T[] array, int start, int length) => throw null;
        unsafe public ReadOnlySpan(void* pointer, int length) => throw null;
        public System.ReadOnlySpan<T> Slice(int start) => throw null;
        public System.ReadOnlySpan<T> Slice(int start, int length) => throw null;
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Span<T> destination) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(T[] array) => throw null;
    }

    public class ResolveEventArgs : System.EventArgs
    {
        public string Name { get => throw null; }
        public System.Reflection.Assembly RequestingAssembly { get => throw null; }
        public ResolveEventArgs(string name) => throw null;
        public ResolveEventArgs(string name, System.Reflection.Assembly requestingAssembly) => throw null;
    }

    public delegate System.Reflection.Assembly ResolveEventHandler(object sender, System.ResolveEventArgs args);

    public struct RuntimeArgumentHandle
    {
        // Stub generator skipped constructor 
    }

    public struct RuntimeFieldHandle : System.IEquatable<System.RuntimeFieldHandle>, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) => throw null;
        public static bool operator ==(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) => throw null;
        public bool Equals(System.RuntimeFieldHandle handle) => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.RuntimeFieldHandle FromIntPtr(System.IntPtr value) => throw null;
        public override int GetHashCode() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        // Stub generator skipped constructor 
        public static System.IntPtr ToIntPtr(System.RuntimeFieldHandle value) => throw null;
        public System.IntPtr Value { get => throw null; }
    }

    public struct RuntimeMethodHandle : System.IEquatable<System.RuntimeMethodHandle>, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) => throw null;
        public static bool operator ==(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) => throw null;
        public bool Equals(System.RuntimeMethodHandle handle) => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.RuntimeMethodHandle FromIntPtr(System.IntPtr value) => throw null;
        public System.IntPtr GetFunctionPointer() => throw null;
        public override int GetHashCode() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        // Stub generator skipped constructor 
        public static System.IntPtr ToIntPtr(System.RuntimeMethodHandle value) => throw null;
        public System.IntPtr Value { get => throw null; }
    }

    public struct RuntimeTypeHandle : System.IEquatable<System.RuntimeTypeHandle>, System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.RuntimeTypeHandle left, object right) => throw null;
        public static bool operator !=(object left, System.RuntimeTypeHandle right) => throw null;
        public static bool operator ==(System.RuntimeTypeHandle left, object right) => throw null;
        public static bool operator ==(object left, System.RuntimeTypeHandle right) => throw null;
        public bool Equals(System.RuntimeTypeHandle handle) => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.RuntimeTypeHandle FromIntPtr(System.IntPtr value) => throw null;
        public override int GetHashCode() => throw null;
        public System.ModuleHandle GetModuleHandle() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        // Stub generator skipped constructor 
        public static System.IntPtr ToIntPtr(System.RuntimeTypeHandle value) => throw null;
        public System.IntPtr Value { get => throw null; }
    }

    public struct SByte : System.IComparable, System.IComparable<System.SByte>, System.IConvertible, System.IEquatable<System.SByte>, System.IFormattable, System.IParsable<System.SByte>, System.ISpanFormattable, System.ISpanParsable<System.SByte>, System.Numerics.IAdditionOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.IAdditiveIdentity<System.SByte, System.SByte>, System.Numerics.IBinaryInteger<System.SByte>, System.Numerics.IBinaryNumber<System.SByte>, System.Numerics.IBitwiseOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.IComparisonOperators<System.SByte, System.SByte, bool>, System.Numerics.IDecrementOperators<System.SByte>, System.Numerics.IDivisionOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.IEqualityOperators<System.SByte, System.SByte, bool>, System.Numerics.IIncrementOperators<System.SByte>, System.Numerics.IMinMaxValue<System.SByte>, System.Numerics.IModulusOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.IMultiplicativeIdentity<System.SByte, System.SByte>, System.Numerics.IMultiplyOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.INumber<System.SByte>, System.Numerics.INumberBase<System.SByte>, System.Numerics.IShiftOperators<System.SByte, int, System.SByte>, System.Numerics.ISignedNumber<System.SByte>, System.Numerics.ISubtractionOperators<System.SByte, System.SByte, System.SByte>, System.Numerics.IUnaryNegationOperators<System.SByte, System.SByte>, System.Numerics.IUnaryPlusOperators<System.SByte, System.SByte>
    {
        static bool System.Numerics.IEqualityOperators<System.SByte, System.SByte, bool>.operator !=(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IModulusOperators<System.SByte, System.SByte, System.SByte>.operator %(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IBitwiseOperators<System.SByte, System.SByte, System.SByte>.operator &(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IMultiplyOperators<System.SByte, System.SByte, System.SByte>.operator *(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IUnaryPlusOperators<System.SByte, System.SByte>.operator +(System.SByte value) => throw null;
        static System.SByte System.Numerics.IAdditionOperators<System.SByte, System.SByte, System.SByte>.operator +(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IIncrementOperators<System.SByte>.operator ++(System.SByte value) => throw null;
        static System.SByte System.Numerics.IUnaryNegationOperators<System.SByte, System.SByte>.operator -(System.SByte value) => throw null;
        static System.SByte System.Numerics.ISubtractionOperators<System.SByte, System.SByte, System.SByte>.operator -(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IDecrementOperators<System.SByte>.operator --(System.SByte value) => throw null;
        static System.SByte System.Numerics.IDivisionOperators<System.SByte, System.SByte, System.SByte>.operator /(System.SByte left, System.SByte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.SByte, System.SByte, bool>.operator <(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IShiftOperators<System.SByte, int, System.SByte>.operator <<(System.SByte value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.SByte, System.SByte, bool>.operator <=(System.SByte left, System.SByte right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.SByte, System.SByte, bool>.operator ==(System.SByte left, System.SByte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.SByte, System.SByte, bool>.operator >(System.SByte left, System.SByte right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.SByte, System.SByte, bool>.operator >=(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IShiftOperators<System.SByte, int, System.SByte>.operator >>(System.SByte value, int shiftAmount) => throw null;
        static System.SByte System.Numerics.IShiftOperators<System.SByte, int, System.SByte>.operator >>>(System.SByte value, int shiftAmount) => throw null;
        public static System.SByte Abs(System.SByte value) => throw null;
        static System.SByte System.Numerics.IAdditiveIdentity<System.SByte, System.SByte>.AdditiveIdentity { get => throw null; }
        static System.SByte System.Numerics.IBinaryNumber<System.SByte>.AllBitsSet { get => throw null; }
        public static System.SByte Clamp(System.SByte value, System.SByte min, System.SByte max) => throw null;
        public int CompareTo(object obj) => throw null;
        public int CompareTo(System.SByte value) => throw null;
        public static System.SByte CopySign(System.SByte value, System.SByte sign) => throw null;
        static System.SByte System.Numerics.INumberBase<System.SByte>.CreateChecked<TOther>(TOther value) => throw null;
        static System.SByte System.Numerics.INumberBase<System.SByte>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.SByte System.Numerics.INumberBase<System.SByte>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.SByte, System.SByte) DivRem(System.SByte left, System.SByte right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.SByte obj) => throw null;
        int System.Numerics.IBinaryInteger<System.SByte>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.SByte>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.SByte value) => throw null;
        public static bool IsComplexNumber(System.SByte value) => throw null;
        public static bool IsEvenInteger(System.SByte value) => throw null;
        public static bool IsFinite(System.SByte value) => throw null;
        public static bool IsImaginaryNumber(System.SByte value) => throw null;
        public static bool IsInfinity(System.SByte value) => throw null;
        public static bool IsInteger(System.SByte value) => throw null;
        public static bool IsNaN(System.SByte value) => throw null;
        public static bool IsNegative(System.SByte value) => throw null;
        public static bool IsNegativeInfinity(System.SByte value) => throw null;
        public static bool IsNormal(System.SByte value) => throw null;
        public static bool IsOddInteger(System.SByte value) => throw null;
        public static bool IsPositive(System.SByte value) => throw null;
        public static bool IsPositiveInfinity(System.SByte value) => throw null;
        public static bool IsPow2(System.SByte value) => throw null;
        public static bool IsRealNumber(System.SByte value) => throw null;
        public static bool IsSubnormal(System.SByte value) => throw null;
        public static bool IsZero(System.SByte value) => throw null;
        public static System.SByte LeadingZeroCount(System.SByte value) => throw null;
        public static System.SByte Log2(System.SByte value) => throw null;
        public static System.SByte Max(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MaxMagnitude(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MaxMagnitudeNumber(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MaxNumber(System.SByte x, System.SByte y) => throw null;
        public const System.SByte MaxValue = default;
        static System.SByte System.Numerics.IMinMaxValue<System.SByte>.MaxValue { get => throw null; }
        public static System.SByte Min(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MinMagnitude(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MinMagnitudeNumber(System.SByte x, System.SByte y) => throw null;
        public static System.SByte MinNumber(System.SByte x, System.SByte y) => throw null;
        public const System.SByte MinValue = default;
        static System.SByte System.Numerics.IMinMaxValue<System.SByte>.MinValue { get => throw null; }
        static System.SByte System.Numerics.IMultiplicativeIdentity<System.SByte, System.SByte>.MultiplicativeIdentity { get => throw null; }
        static System.SByte System.Numerics.ISignedNumber<System.SByte>.NegativeOne { get => throw null; }
        static System.SByte System.Numerics.INumberBase<System.SByte>.One { get => throw null; }
        public static System.SByte Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.SByte Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.SByte Parse(string s) => throw null;
        public static System.SByte Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.SByte Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.SByte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.SByte PopCount(System.SByte value) => throw null;
        static int System.Numerics.INumberBase<System.SByte>.Radix { get => throw null; }
        public static System.SByte RotateLeft(System.SByte value, int rotateAmount) => throw null;
        public static System.SByte RotateRight(System.SByte value, int rotateAmount) => throw null;
        // Stub generator skipped constructor 
        public static int Sign(System.SByte value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.SByte TrailingZeroCount(System.SByte value) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertFromChecked<TOther>(TOther value, out System.SByte result) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertFromSaturating<TOther>(TOther value, out System.SByte result) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertFromTruncating<TOther>(TOther value, out System.SByte result) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertToChecked<TOther>(System.SByte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertToSaturating<TOther>(System.SByte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.SByte>.TryConvertToTruncating<TOther>(System.SByte value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.SByte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.SByte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.SByte result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.SByte result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.SByte result) => throw null;
        public static bool TryParse(string s, out System.SByte result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.SByte value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.SByte value) => throw null;
        bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static System.SByte System.Numerics.INumberBase<System.SByte>.Zero { get => throw null; }
        static System.SByte System.Numerics.IBitwiseOperators<System.SByte, System.SByte, System.SByte>.operator ^(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IMultiplyOperators<System.SByte, System.SByte, System.SByte>.operator checked *(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IAdditionOperators<System.SByte, System.SByte, System.SByte>.operator checked +(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IIncrementOperators<System.SByte>.operator checked ++(System.SByte value) => throw null;
        static System.SByte System.Numerics.IUnaryNegationOperators<System.SByte, System.SByte>.operator checked -(System.SByte value) => throw null;
        static System.SByte System.Numerics.ISubtractionOperators<System.SByte, System.SByte, System.SByte>.operator checked -(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IDecrementOperators<System.SByte>.operator checked --(System.SByte value) => throw null;
        static System.SByte System.Numerics.IBitwiseOperators<System.SByte, System.SByte, System.SByte>.operator |(System.SByte left, System.SByte right) => throw null;
        static System.SByte System.Numerics.IBitwiseOperators<System.SByte, System.SByte, System.SByte>.operator ~(System.SByte value) => throw null;
    }

    public class STAThreadAttribute : System.Attribute
    {
        public STAThreadAttribute() => throw null;
    }

    public class SerializableAttribute : System.Attribute
    {
        public SerializableAttribute() => throw null;
    }

    public struct Single : System.IComparable, System.IComparable<float>, System.IConvertible, System.IEquatable<float>, System.IFormattable, System.IParsable<float>, System.ISpanFormattable, System.ISpanParsable<float>, System.Numerics.IAdditionOperators<float, float, float>, System.Numerics.IAdditiveIdentity<float, float>, System.Numerics.IBinaryFloatingPointIeee754<float>, System.Numerics.IBinaryNumber<float>, System.Numerics.IBitwiseOperators<float, float, float>, System.Numerics.IComparisonOperators<float, float, bool>, System.Numerics.IDecrementOperators<float>, System.Numerics.IDivisionOperators<float, float, float>, System.Numerics.IEqualityOperators<float, float, bool>, System.Numerics.IExponentialFunctions<float>, System.Numerics.IFloatingPoint<float>, System.Numerics.IFloatingPointConstants<float>, System.Numerics.IFloatingPointIeee754<float>, System.Numerics.IHyperbolicFunctions<float>, System.Numerics.IIncrementOperators<float>, System.Numerics.ILogarithmicFunctions<float>, System.Numerics.IMinMaxValue<float>, System.Numerics.IModulusOperators<float, float, float>, System.Numerics.IMultiplicativeIdentity<float, float>, System.Numerics.IMultiplyOperators<float, float, float>, System.Numerics.INumber<float>, System.Numerics.INumberBase<float>, System.Numerics.IPowerFunctions<float>, System.Numerics.IRootFunctions<float>, System.Numerics.ISignedNumber<float>, System.Numerics.ISubtractionOperators<float, float, float>, System.Numerics.ITrigonometricFunctions<float>, System.Numerics.IUnaryNegationOperators<float, float>, System.Numerics.IUnaryPlusOperators<float, float>
    {
        static bool System.Numerics.IEqualityOperators<float, float, bool>.operator !=(float left, float right) => throw null;
        static float System.Numerics.IModulusOperators<float, float, float>.operator %(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator &(float left, float right) => throw null;
        static float System.Numerics.IMultiplyOperators<float, float, float>.operator *(float left, float right) => throw null;
        static float System.Numerics.IUnaryPlusOperators<float, float>.operator +(float value) => throw null;
        static float System.Numerics.IAdditionOperators<float, float, float>.operator +(float left, float right) => throw null;
        static float System.Numerics.IIncrementOperators<float>.operator ++(float value) => throw null;
        static float System.Numerics.IUnaryNegationOperators<float, float>.operator -(float value) => throw null;
        static float System.Numerics.ISubtractionOperators<float, float, float>.operator -(float left, float right) => throw null;
        static float System.Numerics.IDecrementOperators<float>.operator --(float value) => throw null;
        static float System.Numerics.IDivisionOperators<float, float, float>.operator /(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator <(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator <=(float left, float right) => throw null;
        static bool System.Numerics.IEqualityOperators<float, float, bool>.operator ==(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator >(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator >=(float left, float right) => throw null;
        public static float Abs(float value) => throw null;
        public static float Acos(float x) => throw null;
        public static float AcosPi(float x) => throw null;
        public static float Acosh(float x) => throw null;
        static float System.Numerics.IAdditiveIdentity<float, float>.AdditiveIdentity { get => throw null; }
        static float System.Numerics.IBinaryNumber<float>.AllBitsSet { get => throw null; }
        public static float Asin(float x) => throw null;
        public static float AsinPi(float x) => throw null;
        public static float Asinh(float x) => throw null;
        public static float Atan(float x) => throw null;
        public static float Atan2(float y, float x) => throw null;
        public static float Atan2Pi(float y, float x) => throw null;
        public static float AtanPi(float x) => throw null;
        public static float Atanh(float x) => throw null;
        public static float BitDecrement(float x) => throw null;
        public static float BitIncrement(float x) => throw null;
        public static float Cbrt(float x) => throw null;
        public static float Ceiling(float x) => throw null;
        public static float Clamp(float value, float min, float max) => throw null;
        public int CompareTo(float value) => throw null;
        public int CompareTo(object value) => throw null;
        public static float CopySign(float value, float sign) => throw null;
        public static float Cos(float x) => throw null;
        public static float CosPi(float x) => throw null;
        public static float Cosh(float x) => throw null;
        static float System.Numerics.INumberBase<float>.CreateChecked<TOther>(TOther value) => throw null;
        static float System.Numerics.INumberBase<float>.CreateSaturating<TOther>(TOther value) => throw null;
        static float System.Numerics.INumberBase<float>.CreateTruncating<TOther>(TOther value) => throw null;
        public const float E = default;
        static float System.Numerics.IFloatingPointConstants<float>.E { get => throw null; }
        public const float Epsilon = default;
        static float System.Numerics.IFloatingPointIeee754<float>.Epsilon { get => throw null; }
        public bool Equals(float obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public static float Exp(float x) => throw null;
        public static float Exp10(float x) => throw null;
        public static float Exp10M1(float x) => throw null;
        public static float Exp2(float x) => throw null;
        public static float Exp2M1(float x) => throw null;
        public static float ExpM1(float x) => throw null;
        public static float Floor(float x) => throw null;
        public static float FusedMultiplyAdd(float left, float right, float addend) => throw null;
        int System.Numerics.IFloatingPoint<float>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static float Hypot(float x, float y) => throw null;
        public static int ILogB(float x) => throw null;
        public static float Ieee754Remainder(float left, float right) => throw null;
        public static bool IsCanonical(float value) => throw null;
        public static bool IsComplexNumber(float value) => throw null;
        public static bool IsEvenInteger(float value) => throw null;
        public static bool IsFinite(float f) => throw null;
        public static bool IsImaginaryNumber(float value) => throw null;
        public static bool IsInfinity(float f) => throw null;
        public static bool IsInteger(float value) => throw null;
        public static bool IsNaN(float f) => throw null;
        public static bool IsNegative(float f) => throw null;
        public static bool IsNegativeInfinity(float f) => throw null;
        public static bool IsNormal(float f) => throw null;
        public static bool IsOddInteger(float value) => throw null;
        public static bool IsPositive(float value) => throw null;
        public static bool IsPositiveInfinity(float f) => throw null;
        public static bool IsPow2(float value) => throw null;
        public static bool IsRealNumber(float value) => throw null;
        public static bool IsSubnormal(float f) => throw null;
        public static bool IsZero(float value) => throw null;
        public static float Log(float x) => throw null;
        public static float Log(float x, float newBase) => throw null;
        public static float Log10(float x) => throw null;
        public static float Log10P1(float x) => throw null;
        public static float Log2(float value) => throw null;
        public static float Log2P1(float x) => throw null;
        public static float LogP1(float x) => throw null;
        public static float Max(float x, float y) => throw null;
        public static float MaxMagnitude(float x, float y) => throw null;
        public static float MaxMagnitudeNumber(float x, float y) => throw null;
        public static float MaxNumber(float x, float y) => throw null;
        public const float MaxValue = default;
        static float System.Numerics.IMinMaxValue<float>.MaxValue { get => throw null; }
        public static float Min(float x, float y) => throw null;
        public static float MinMagnitude(float x, float y) => throw null;
        public static float MinMagnitudeNumber(float x, float y) => throw null;
        public static float MinNumber(float x, float y) => throw null;
        public const float MinValue = default;
        static float System.Numerics.IMinMaxValue<float>.MinValue { get => throw null; }
        static float System.Numerics.IMultiplicativeIdentity<float, float>.MultiplicativeIdentity { get => throw null; }
        public const float NaN = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NaN { get => throw null; }
        public const float NegativeInfinity = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NegativeInfinity { get => throw null; }
        static float System.Numerics.ISignedNumber<float>.NegativeOne { get => throw null; }
        public const float NegativeZero = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NegativeZero { get => throw null; }
        static float System.Numerics.INumberBase<float>.One { get => throw null; }
        public static float Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static float Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static float Parse(string s) => throw null;
        public static float Parse(string s, System.IFormatProvider provider) => throw null;
        public static float Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static float Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public const float Pi = default;
        static float System.Numerics.IFloatingPointConstants<float>.Pi { get => throw null; }
        public const float PositiveInfinity = default;
        static float System.Numerics.IFloatingPointIeee754<float>.PositiveInfinity { get => throw null; }
        public static float Pow(float x, float y) => throw null;
        static int System.Numerics.INumberBase<float>.Radix { get => throw null; }
        public static float ReciprocalEstimate(float x) => throw null;
        public static float ReciprocalSqrtEstimate(float x) => throw null;
        public static float RootN(float x, int n) => throw null;
        public static float Round(float x) => throw null;
        public static float Round(float x, System.MidpointRounding mode) => throw null;
        public static float Round(float x, int digits) => throw null;
        public static float Round(float x, int digits, System.MidpointRounding mode) => throw null;
        public static float ScaleB(float x, int n) => throw null;
        public static int Sign(float value) => throw null;
        public static float Sin(float x) => throw null;
        public static (float, float) SinCos(float x) => throw null;
        public static (float, float) SinCosPi(float x) => throw null;
        public static float SinPi(float x) => throw null;
        // Stub generator skipped constructor 
        public static float Sinh(float x) => throw null;
        public static float Sqrt(float x) => throw null;
        public static float Tan(float x) => throw null;
        public static float TanPi(float x) => throw null;
        public static float Tanh(float x) => throw null;
        public const float Tau = default;
        static float System.Numerics.IFloatingPointConstants<float>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static float Truncate(float x) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromChecked<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromSaturating<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromTruncating<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToChecked<TOther>(float value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToSaturating<TOther>(float value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToTruncating<TOther>(float value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out float result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(string s, out float result) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteExponentBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteExponentLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteSignificandBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteSignificandLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        static float System.Numerics.INumberBase<float>.Zero { get => throw null; }
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator ^(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator |(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator ~(float value) => throw null;
    }

    public struct Span<T>
    {
        public struct Enumerator
        {
            public T Current { get => throw null; }
            // Stub generator skipped constructor 
            public bool MoveNext() => throw null;
        }


        public static bool operator !=(System.Span<T> left, System.Span<T> right) => throw null;
        public static bool operator ==(System.Span<T> left, System.Span<T> right) => throw null;
        public void Clear() => throw null;
        public void CopyTo(System.Span<T> destination) => throw null;
        public static System.Span<T> Empty { get => throw null; }
        public override bool Equals(object obj) => throw null;
        public void Fill(T value) => throw null;
        public System.Span<T>.Enumerator GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public T GetPinnableReference() => throw null;
        public bool IsEmpty { get => throw null; }
        public T this[int index] { get => throw null; }
        public int Length { get => throw null; }
        public System.Span<T> Slice(int start) => throw null;
        public System.Span<T> Slice(int start, int length) => throw null;
        // Stub generator skipped constructor 
        public Span(T[] array) => throw null;
        public Span(T[] array, int start, int length) => throw null;
        unsafe public Span(void* pointer, int length) => throw null;
        public Span(ref T reference) => throw null;
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Span<T> destination) => throw null;
        public static implicit operator System.Span<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(System.Span<T> span) => throw null;
        public static implicit operator System.Span<T>(T[] array) => throw null;
    }

    public class StackOverflowException : System.SystemException
    {
        public StackOverflowException() => throw null;
        public StackOverflowException(string message) => throw null;
        public StackOverflowException(string message, System.Exception innerException) => throw null;
    }

    public class String : System.Collections.Generic.IEnumerable<System.Char>, System.Collections.IEnumerable, System.ICloneable, System.IComparable, System.IComparable<string>, System.IConvertible, System.IEquatable<string>
    {
        public static bool operator !=(string a, string b) => throw null;
        public static bool operator ==(string a, string b) => throw null;
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public System.Char this[int index] { get => throw null; }
        public object Clone() => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, System.StringComparison comparisonType) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public static int Compare(string strA, string strB) => throw null;
        public static int Compare(string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        public static int Compare(string strA, string strB, System.StringComparison comparisonType) => throw null;
        public static int Compare(string strA, string strB, bool ignoreCase) => throw null;
        public static int Compare(string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length) => throw null;
        public static int CompareOrdinal(string strA, string strB) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(string strB) => throw null;
        public static string Concat(System.Collections.Generic.IEnumerable<string> values) => throw null;
        public static string Concat(System.ReadOnlySpan<System.Char> str0, System.ReadOnlySpan<System.Char> str1) => throw null;
        public static string Concat(System.ReadOnlySpan<System.Char> str0, System.ReadOnlySpan<System.Char> str1, System.ReadOnlySpan<System.Char> str2) => throw null;
        public static string Concat(System.ReadOnlySpan<System.Char> str0, System.ReadOnlySpan<System.Char> str1, System.ReadOnlySpan<System.Char> str2, System.ReadOnlySpan<System.Char> str3) => throw null;
        public static string Concat(object arg0) => throw null;
        public static string Concat(object arg0, object arg1) => throw null;
        public static string Concat(object arg0, object arg1, object arg2) => throw null;
        public static string Concat(params object[] args) => throw null;
        public static string Concat(params string[] values) => throw null;
        public static string Concat(string str0, string str1) => throw null;
        public static string Concat(string str0, string str1, string str2) => throw null;
        public static string Concat(string str0, string str1, string str2, string str3) => throw null;
        public static string Concat<T>(System.Collections.Generic.IEnumerable<T> values) => throw null;
        public bool Contains(System.Char value) => throw null;
        public bool Contains(System.Char value, System.StringComparison comparisonType) => throw null;
        public bool Contains(string value) => throw null;
        public bool Contains(string value, System.StringComparison comparisonType) => throw null;
        public static string Copy(string str) => throw null;
        public void CopyTo(System.Span<System.Char> destination) => throw null;
        public void CopyTo(int sourceIndex, System.Char[] destination, int destinationIndex, int count) => throw null;
        public static string Create(System.IFormatProvider provider, System.Span<System.Char> initialBuffer, ref System.Runtime.CompilerServices.DefaultInterpolatedStringHandler handler) => throw null;
        public static string Create(System.IFormatProvider provider, ref System.Runtime.CompilerServices.DefaultInterpolatedStringHandler handler) => throw null;
        public static string Create<TState>(int length, TState state, System.Buffers.SpanAction<System.Char, TState> action) => throw null;
        public static string Empty;
        public bool EndsWith(System.Char value) => throw null;
        public bool EndsWith(string value) => throw null;
        public bool EndsWith(string value, System.StringComparison comparisonType) => throw null;
        public bool EndsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public System.Text.StringRuneEnumerator EnumerateRunes() => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(string value) => throw null;
        public bool Equals(string value, System.StringComparison comparisonType) => throw null;
        public static bool Equals(string a, string b) => throw null;
        public static bool Equals(string a, string b, System.StringComparison comparisonType) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) => throw null;
        public static string Format(System.IFormatProvider provider, string format, params object[] args) => throw null;
        public static string Format(string format, object arg0) => throw null;
        public static string Format(string format, object arg0, object arg1) => throw null;
        public static string Format(string format, object arg0, object arg1, object arg2) => throw null;
        public static string Format(string format, params object[] args) => throw null;
        public System.CharEnumerator GetEnumerator() => throw null;
        System.Collections.Generic.IEnumerator<System.Char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator() => throw null;
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public static int GetHashCode(System.ReadOnlySpan<System.Char> value) => throw null;
        public static int GetHashCode(System.ReadOnlySpan<System.Char> value, System.StringComparison comparisonType) => throw null;
        public int GetHashCode(System.StringComparison comparisonType) => throw null;
        public System.Char GetPinnableReference() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public int IndexOf(System.Char value) => throw null;
        public int IndexOf(System.Char value, System.StringComparison comparisonType) => throw null;
        public int IndexOf(System.Char value, int startIndex) => throw null;
        public int IndexOf(System.Char value, int startIndex, int count) => throw null;
        public int IndexOf(string value) => throw null;
        public int IndexOf(string value, System.StringComparison comparisonType) => throw null;
        public int IndexOf(string value, int startIndex) => throw null;
        public int IndexOf(string value, int startIndex, System.StringComparison comparisonType) => throw null;
        public int IndexOf(string value, int startIndex, int count) => throw null;
        public int IndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) => throw null;
        public int IndexOfAny(System.Char[] anyOf) => throw null;
        public int IndexOfAny(System.Char[] anyOf, int startIndex) => throw null;
        public int IndexOfAny(System.Char[] anyOf, int startIndex, int count) => throw null;
        public string Insert(int startIndex, string value) => throw null;
        public static string Intern(string str) => throw null;
        public static string IsInterned(string str) => throw null;
        public bool IsNormalized() => throw null;
        public bool IsNormalized(System.Text.NormalizationForm normalizationForm) => throw null;
        public static bool IsNullOrEmpty(string value) => throw null;
        public static bool IsNullOrWhiteSpace(string value) => throw null;
        public static string Join(System.Char separator, string[] value, int startIndex, int count) => throw null;
        public static string Join(System.Char separator, params object[] values) => throw null;
        public static string Join(System.Char separator, params string[] value) => throw null;
        public static string Join(string separator, System.Collections.Generic.IEnumerable<string> values) => throw null;
        public static string Join(string separator, string[] value, int startIndex, int count) => throw null;
        public static string Join(string separator, params object[] values) => throw null;
        public static string Join(string separator, params string[] value) => throw null;
        public static string Join<T>(System.Char separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
        public static string Join<T>(string separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
        public int LastIndexOf(System.Char value) => throw null;
        public int LastIndexOf(System.Char value, int startIndex) => throw null;
        public int LastIndexOf(System.Char value, int startIndex, int count) => throw null;
        public int LastIndexOf(string value) => throw null;
        public int LastIndexOf(string value, System.StringComparison comparisonType) => throw null;
        public int LastIndexOf(string value, int startIndex) => throw null;
        public int LastIndexOf(string value, int startIndex, System.StringComparison comparisonType) => throw null;
        public int LastIndexOf(string value, int startIndex, int count) => throw null;
        public int LastIndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) => throw null;
        public int LastIndexOfAny(System.Char[] anyOf) => throw null;
        public int LastIndexOfAny(System.Char[] anyOf, int startIndex) => throw null;
        public int LastIndexOfAny(System.Char[] anyOf, int startIndex, int count) => throw null;
        public int Length { get => throw null; }
        public string Normalize() => throw null;
        public string Normalize(System.Text.NormalizationForm normalizationForm) => throw null;
        public string PadLeft(int totalWidth) => throw null;
        public string PadLeft(int totalWidth, System.Char paddingChar) => throw null;
        public string PadRight(int totalWidth) => throw null;
        public string PadRight(int totalWidth, System.Char paddingChar) => throw null;
        public string Remove(int startIndex) => throw null;
        public string Remove(int startIndex, int count) => throw null;
        public string Replace(System.Char oldChar, System.Char newChar) => throw null;
        public string Replace(string oldValue, string newValue) => throw null;
        public string Replace(string oldValue, string newValue, System.StringComparison comparisonType) => throw null;
        public string Replace(string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public string ReplaceLineEndings() => throw null;
        public string ReplaceLineEndings(string replacementText) => throw null;
        public string[] Split(System.Char[] separator, System.StringSplitOptions options) => throw null;
        public string[] Split(System.Char[] separator, int count) => throw null;
        public string[] Split(System.Char[] separator, int count, System.StringSplitOptions options) => throw null;
        public string[] Split(string[] separator, System.StringSplitOptions options) => throw null;
        public string[] Split(string[] separator, int count, System.StringSplitOptions options) => throw null;
        public string[] Split(System.Char separator, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(System.Char separator, int count, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(params System.Char[] separator) => throw null;
        public string[] Split(string separator, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(string separator, int count, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public bool StartsWith(System.Char value) => throw null;
        public bool StartsWith(string value) => throw null;
        public bool StartsWith(string value, System.StringComparison comparisonType) => throw null;
        public bool StartsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public String(System.Char[] value) => throw null;
        public String(System.Char[] value, int startIndex, int length) => throw null;
        public String(System.ReadOnlySpan<System.Char> value) => throw null;
        unsafe public String(System.Char* value) => throw null;
        unsafe public String(System.Char* value, int startIndex, int length) => throw null;
        public String(System.Char c, int count) => throw null;
        unsafe public String(System.SByte* value) => throw null;
        unsafe public String(System.SByte* value, int startIndex, int length) => throw null;
        unsafe public String(System.SByte* value, int startIndex, int length, System.Text.Encoding enc) => throw null;
        public string Substring(int startIndex) => throw null;
        public string Substring(int startIndex, int length) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        public System.Char[] ToCharArray() => throw null;
        public System.Char[] ToCharArray(int startIndex, int length) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public string ToLower() => throw null;
        public string ToLower(System.Globalization.CultureInfo culture) => throw null;
        public string ToLowerInvariant() => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public string ToUpper() => throw null;
        public string ToUpper(System.Globalization.CultureInfo culture) => throw null;
        public string ToUpperInvariant() => throw null;
        public string Trim() => throw null;
        public string Trim(System.Char trimChar) => throw null;
        public string Trim(params System.Char[] trimChars) => throw null;
        public string TrimEnd() => throw null;
        public string TrimEnd(System.Char trimChar) => throw null;
        public string TrimEnd(params System.Char[] trimChars) => throw null;
        public string TrimStart() => throw null;
        public string TrimStart(System.Char trimChar) => throw null;
        public string TrimStart(params System.Char[] trimChars) => throw null;
        public bool TryCopyTo(System.Span<System.Char> destination) => throw null;
        public static implicit operator System.ReadOnlySpan<System.Char>(string value) => throw null;
    }

    public abstract class StringComparer : System.Collections.Generic.IComparer<string>, System.Collections.Generic.IEqualityComparer<string>, System.Collections.IComparer, System.Collections.IEqualityComparer
    {
        public int Compare(object x, object y) => throw null;
        public abstract int Compare(string x, string y);
        public static System.StringComparer Create(System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        public static System.StringComparer Create(System.Globalization.CultureInfo culture, bool ignoreCase) => throw null;
        public static System.StringComparer CurrentCulture { get => throw null; }
        public static System.StringComparer CurrentCultureIgnoreCase { get => throw null; }
        public bool Equals(object x, object y) => throw null;
        public abstract bool Equals(string x, string y);
        public static System.StringComparer FromComparison(System.StringComparison comparisonType) => throw null;
        public int GetHashCode(object obj) => throw null;
        public abstract int GetHashCode(string obj);
        public static System.StringComparer InvariantCulture { get => throw null; }
        public static System.StringComparer InvariantCultureIgnoreCase { get => throw null; }
        public static bool IsWellKnownCultureAwareComparer(System.Collections.Generic.IEqualityComparer<string> comparer, out System.Globalization.CompareInfo compareInfo, out System.Globalization.CompareOptions compareOptions) => throw null;
        public static bool IsWellKnownOrdinalComparer(System.Collections.Generic.IEqualityComparer<string> comparer, out bool ignoreCase) => throw null;
        public static System.StringComparer Ordinal { get => throw null; }
        public static System.StringComparer OrdinalIgnoreCase { get => throw null; }
        protected StringComparer() => throw null;
    }

    public enum StringComparison : int
    {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }

    public static class StringNormalizationExtensions
    {
        public static bool IsNormalized(this string strInput) => throw null;
        public static bool IsNormalized(this string strInput, System.Text.NormalizationForm normalizationForm) => throw null;
        public static string Normalize(this string strInput) => throw null;
        public static string Normalize(this string strInput, System.Text.NormalizationForm normalizationForm) => throw null;
    }

    [System.Flags]
    public enum StringSplitOptions : int
    {
        None = 0,
        RemoveEmptyEntries = 1,
        TrimEntries = 2,
    }

    public class SystemException : System.Exception
    {
        public SystemException() => throw null;
        protected SystemException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public SystemException(string message) => throw null;
        public SystemException(string message, System.Exception innerException) => throw null;
    }

    public class ThreadStaticAttribute : System.Attribute
    {
        public ThreadStaticAttribute() => throw null;
    }

    public struct TimeOnly : System.IComparable, System.IComparable<System.TimeOnly>, System.IEquatable<System.TimeOnly>, System.IFormattable, System.IParsable<System.TimeOnly>, System.ISpanFormattable, System.ISpanParsable<System.TimeOnly>
    {
        public static bool operator !=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static System.TimeSpan operator -(System.TimeOnly t1, System.TimeOnly t2) => throw null;
        public static bool operator <(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator <=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator ==(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator >(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator >=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public System.TimeOnly Add(System.TimeSpan value) => throw null;
        public System.TimeOnly Add(System.TimeSpan value, out int wrappedDays) => throw null;
        public System.TimeOnly AddHours(double value) => throw null;
        public System.TimeOnly AddHours(double value, out int wrappedDays) => throw null;
        public System.TimeOnly AddMinutes(double value) => throw null;
        public System.TimeOnly AddMinutes(double value, out int wrappedDays) => throw null;
        public int CompareTo(System.TimeOnly value) => throw null;
        public int CompareTo(object value) => throw null;
        public bool Equals(System.TimeOnly value) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.TimeOnly FromDateTime(System.DateTime dateTime) => throw null;
        public static System.TimeOnly FromTimeSpan(System.TimeSpan timeSpan) => throw null;
        public override int GetHashCode() => throw null;
        public int Hour { get => throw null; }
        public bool IsBetween(System.TimeOnly start, System.TimeOnly end) => throw null;
        public static System.TimeOnly MaxValue { get => throw null; }
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public static System.TimeOnly MinValue { get => throw null; }
        public int Minute { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static System.TimeOnly Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.TimeOnly Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly Parse(string s) => throw null;
        public static System.TimeOnly Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.TimeOnly Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<System.Char> s, string[] formats) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(string s, string[] formats) => throw null;
        public static System.TimeOnly ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(string s, string format) => throw null;
        public static System.TimeOnly ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public int Second { get => throw null; }
        public System.Int64 Ticks { get => throw null; }
        // Stub generator skipped constructor 
        public TimeOnly(int hour, int minute) => throw null;
        public TimeOnly(int hour, int minute, int second) => throw null;
        public TimeOnly(int hour, int minute, int second, int millisecond) => throw null;
        public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond) => throw null;
        public TimeOnly(System.Int64 ticks) => throw null;
        public string ToLongTimeString() => throw null;
        public string ToShortTimeString() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public System.TimeSpan ToTimeSpan() => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.TimeOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.TimeOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.TimeOnly result) => throw null;
        public static bool TryParse(string s, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, System.ReadOnlySpan<System.Char> format, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> s, string[] formats, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string format, out System.TimeOnly result) => throw null;
    }

    public struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.IParsable<System.TimeSpan>, System.ISpanFormattable, System.ISpanParsable<System.TimeSpan>
    {
        public static bool operator !=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator *(System.TimeSpan timeSpan, double factor) => throw null;
        public static System.TimeSpan operator *(double factor, System.TimeSpan timeSpan) => throw null;
        public static System.TimeSpan operator +(System.TimeSpan t) => throw null;
        public static System.TimeSpan operator +(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator -(System.TimeSpan t) => throw null;
        public static System.TimeSpan operator -(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static double operator /(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator /(System.TimeSpan timeSpan, double divisor) => throw null;
        public static bool operator <(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator <=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator ==(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator >(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator >=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public System.TimeSpan Add(System.TimeSpan ts) => throw null;
        public static int Compare(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public int CompareTo(System.TimeSpan value) => throw null;
        public int CompareTo(object value) => throw null;
        public int Days { get => throw null; }
        public double Divide(System.TimeSpan ts) => throw null;
        public System.TimeSpan Divide(double divisor) => throw null;
        public System.TimeSpan Duration() => throw null;
        public bool Equals(System.TimeSpan obj) => throw null;
        public static bool Equals(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.TimeSpan FromDays(double value) => throw null;
        public static System.TimeSpan FromHours(double value) => throw null;
        public static System.TimeSpan FromMicroseconds(double value) => throw null;
        public static System.TimeSpan FromMilliseconds(double value) => throw null;
        public static System.TimeSpan FromMinutes(double value) => throw null;
        public static System.TimeSpan FromSeconds(double value) => throw null;
        public static System.TimeSpan FromTicks(System.Int64 value) => throw null;
        public override int GetHashCode() => throw null;
        public int Hours { get => throw null; }
        public static System.TimeSpan MaxValue;
        public int Microseconds { get => throw null; }
        public int Milliseconds { get => throw null; }
        public static System.TimeSpan MinValue;
        public int Minutes { get => throw null; }
        public System.TimeSpan Multiply(double factor) => throw null;
        public int Nanoseconds { get => throw null; }
        public const System.Int64 NanosecondsPerTick = default;
        public System.TimeSpan Negate() => throw null;
        public static System.TimeSpan Parse(System.ReadOnlySpan<System.Char> input, System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public static System.TimeSpan Parse(string s) => throw null;
        public static System.TimeSpan Parse(string input, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles = default(System.Globalization.TimeSpanStyles)) => throw null;
        public static System.TimeSpan ParseExact(System.ReadOnlySpan<System.Char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles = default(System.Globalization.TimeSpanStyles)) => throw null;
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) => throw null;
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) => throw null;
        public int Seconds { get => throw null; }
        public System.TimeSpan Subtract(System.TimeSpan ts) => throw null;
        public System.Int64 Ticks { get => throw null; }
        public const System.Int64 TicksPerDay = default;
        public const System.Int64 TicksPerHour = default;
        public const System.Int64 TicksPerMicrosecond = default;
        public const System.Int64 TicksPerMillisecond = default;
        public const System.Int64 TicksPerMinute = default;
        public const System.Int64 TicksPerSecond = default;
        // Stub generator skipped constructor 
        public TimeSpan(int hours, int minutes, int seconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds) => throw null;
        public TimeSpan(System.Int64 ticks) => throw null;
        public override string ToString() => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public double TotalDays { get => throw null; }
        public double TotalHours { get => throw null; }
        public double TotalMicroseconds { get => throw null; }
        public double TotalMilliseconds { get => throw null; }
        public double TotalMinutes { get => throw null; }
        public double TotalNanoseconds { get => throw null; }
        public double TotalSeconds { get => throw null; }
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> input, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.TimeSpan result) => throw null;
        public static bool TryParse(string input, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParse(string s, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, System.ReadOnlySpan<System.Char> format, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<System.Char> input, string[] formats, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static System.TimeSpan Zero;
    }

    public abstract class TimeZone
    {
        public static System.TimeZone CurrentTimeZone { get => throw null; }
        public abstract string DaylightName { get; }
        public abstract System.Globalization.DaylightTime GetDaylightChanges(int year);
        public abstract System.TimeSpan GetUtcOffset(System.DateTime time);
        public virtual bool IsDaylightSavingTime(System.DateTime time) => throw null;
        public static bool IsDaylightSavingTime(System.DateTime time, System.Globalization.DaylightTime daylightTimes) => throw null;
        public abstract string StandardName { get; }
        protected TimeZone() => throw null;
        public virtual System.DateTime ToLocalTime(System.DateTime time) => throw null;
        public virtual System.DateTime ToUniversalTime(System.DateTime time) => throw null;
    }

    public class TimeZoneInfo : System.IEquatable<System.TimeZoneInfo>, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
    {
        public class AdjustmentRule : System.IEquatable<System.TimeZoneInfo.AdjustmentRule>, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public System.TimeSpan BaseUtcOffsetDelta { get => throw null; }
            public static System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd) => throw null;
            public static System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta) => throw null;
            public System.DateTime DateEnd { get => throw null; }
            public System.DateTime DateStart { get => throw null; }
            public System.TimeSpan DaylightDelta { get => throw null; }
            public System.TimeZoneInfo.TransitionTime DaylightTransitionEnd { get => throw null; }
            public System.TimeZoneInfo.TransitionTime DaylightTransitionStart { get => throw null; }
            public bool Equals(System.TimeZoneInfo.AdjustmentRule other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        }


        public struct TransitionTime : System.IEquatable<System.TimeZoneInfo.TransitionTime>, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public static bool operator !=(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2) => throw null;
            public static bool operator ==(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2) => throw null;
            public static System.TimeZoneInfo.TransitionTime CreateFixedDateRule(System.DateTime timeOfDay, int month, int day) => throw null;
            public static System.TimeZoneInfo.TransitionTime CreateFloatingDateRule(System.DateTime timeOfDay, int month, int week, System.DayOfWeek dayOfWeek) => throw null;
            public int Day { get => throw null; }
            public System.DayOfWeek DayOfWeek { get => throw null; }
            public bool Equals(System.TimeZoneInfo.TransitionTime other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public bool IsFixedDateRule { get => throw null; }
            public int Month { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public System.DateTime TimeOfDay { get => throw null; }
            // Stub generator skipped constructor 
            public int Week { get => throw null; }
        }


        public System.TimeSpan BaseUtcOffset { get => throw null; }
        public static void ClearCachedData() => throw null;
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTimeOffset ConvertTime(System.DateTimeOffset dateTimeOffset, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string destinationTimeZoneId) => throw null;
        public static System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId) => throw null;
        public static System.DateTimeOffset ConvertTimeBySystemTimeZoneId(System.DateTimeOffset dateTimeOffset, string destinationTimeZoneId) => throw null;
        public static System.DateTime ConvertTimeFromUtc(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTimeToUtc(System.DateTime dateTime) => throw null;
        public static System.DateTime ConvertTimeToUtc(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime) => throw null;
        public string DaylightName { get => throw null; }
        public string DisplayName { get => throw null; }
        public bool Equals(System.TimeZoneInfo other) => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.TimeZoneInfo FindSystemTimeZoneById(string id) => throw null;
        public static System.TimeZoneInfo FromSerializedString(string source) => throw null;
        public System.TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules() => throw null;
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTime dateTime) => throw null;
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTimeOffset dateTimeOffset) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones() => throw null;
        public System.TimeSpan GetUtcOffset(System.DateTime dateTime) => throw null;
        public System.TimeSpan GetUtcOffset(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool HasIanaId { get => throw null; }
        public bool HasSameRules(System.TimeZoneInfo other) => throw null;
        public string Id { get => throw null; }
        public bool IsAmbiguousTime(System.DateTime dateTime) => throw null;
        public bool IsAmbiguousTime(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool IsDaylightSavingTime(System.DateTime dateTime) => throw null;
        public bool IsDaylightSavingTime(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool IsInvalidTime(System.DateTime dateTime) => throw null;
        public static System.TimeZoneInfo Local { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public string StandardName { get => throw null; }
        public bool SupportsDaylightSavingTime { get => throw null; }
        public string ToSerializedString() => throw null;
        public override string ToString() => throw null;
        public static bool TryConvertIanaIdToWindowsId(string ianaId, out string windowsId) => throw null;
        public static bool TryConvertWindowsIdToIanaId(string windowsId, out string ianaId) => throw null;
        public static bool TryConvertWindowsIdToIanaId(string windowsId, string region, out string ianaId) => throw null;
        public static System.TimeZoneInfo Utc { get => throw null; }
    }

    public class TimeZoneNotFoundException : System.Exception
    {
        public TimeZoneNotFoundException() => throw null;
        protected TimeZoneNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TimeZoneNotFoundException(string message) => throw null;
        public TimeZoneNotFoundException(string message, System.Exception innerException) => throw null;
    }

    public class TimeoutException : System.SystemException
    {
        public TimeoutException() => throw null;
        protected TimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TimeoutException(string message) => throw null;
        public TimeoutException(string message, System.Exception innerException) => throw null;
    }

    public static class Tuple
    {
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public static System.Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public static System.Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) => throw null;
        public static System.Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2) => throw null;
        public static System.Tuple<T1> Create<T1>(T1 item1) => throw null;
    }

    public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        public T7 Item7 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public TRest Rest { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) => throw null;
    }

    public class Tuple<T1, T2, T3, T4, T5, T6, T7> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        public T7 Item7 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
    }

    public class Tuple<T1, T2, T3, T4, T5, T6> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
    }

    public class Tuple<T1, T2, T3, T4, T5> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
    }

    public class Tuple<T1, T2, T3, T4> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
    }

    public class Tuple<T1, T2, T3> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3) => throw null;
    }

    public class Tuple<T1, T2> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1, T2 item2) => throw null;
    }

    public class Tuple<T1> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.Runtime.CompilerServices.ITuple
    {
        int System.IComparable.CompareTo(object obj) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1 { get => throw null; }
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        public Tuple(T1 item1) => throw null;
    }

    public static class TupleExtensions
    {
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20, out T21 item21) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6>(this System.Tuple<T1, T2, T3, T4, T5, T6> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5>(this System.Tuple<T1, T2, T3, T4, T5> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5) => throw null;
        public static void Deconstruct<T1, T2, T3, T4>(this System.Tuple<T1, T2, T3, T4> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4) => throw null;
        public static void Deconstruct<T1, T2, T3>(this System.Tuple<T1, T2, T3> value, out T1 item1, out T2 item2, out T3 item3) => throw null;
        public static void Deconstruct<T1, T2>(this System.Tuple<T1, T2> value, out T1 item1, out T2 item2) => throw null;
        public static void Deconstruct<T1>(this System.Tuple<T1> value, out T1 item1) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this (T1, T2, T3, T4, T5, T6, T7, T8) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7> ToTuple<T1, T2, T3, T4, T5, T6, T7>(this (T1, T2, T3, T4, T5, T6, T7) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6> ToTuple<T1, T2, T3, T4, T5, T6>(this (T1, T2, T3, T4, T5, T6) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5> ToTuple<T1, T2, T3, T4, T5>(this (T1, T2, T3, T4, T5) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4> ToTuple<T1, T2, T3, T4>(this (T1, T2, T3, T4) value) => throw null;
        public static System.Tuple<T1, T2, T3> ToTuple<T1, T2, T3>(this (T1, T2, T3) value) => throw null;
        public static System.Tuple<T1, T2> ToTuple<T1, T2>(this (T1, T2) value) => throw null;
        public static System.Tuple<T1> ToTuple<T1>(this System.ValueTuple<T1> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7) ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6) ToValueTuple<T1, T2, T3, T4, T5, T6>(this System.Tuple<T1, T2, T3, T4, T5, T6> value) => throw null;
        public static (T1, T2, T3, T4, T5) ToValueTuple<T1, T2, T3, T4, T5>(this System.Tuple<T1, T2, T3, T4, T5> value) => throw null;
        public static (T1, T2, T3, T4) ToValueTuple<T1, T2, T3, T4>(this System.Tuple<T1, T2, T3, T4> value) => throw null;
        public static (T1, T2, T3) ToValueTuple<T1, T2, T3>(this System.Tuple<T1, T2, T3> value) => throw null;
        public static (T1, T2) ToValueTuple<T1, T2>(this System.Tuple<T1, T2> value) => throw null;
        public static System.ValueTuple<T1> ToValueTuple<T1>(this System.Tuple<T1> value) => throw null;
    }

    public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect
    {
        public static bool operator !=(System.Type left, System.Type right) => throw null;
        public static bool operator ==(System.Type left, System.Type right) => throw null;
        public abstract System.Reflection.Assembly Assembly { get; }
        public abstract string AssemblyQualifiedName { get; }
        public System.Reflection.TypeAttributes Attributes { get => throw null; }
        public abstract System.Type BaseType { get; }
        public virtual bool ContainsGenericParameters { get => throw null; }
        public virtual System.Reflection.MethodBase DeclaringMethod { get => throw null; }
        public override System.Type DeclaringType { get => throw null; }
        public static System.Reflection.Binder DefaultBinder { get => throw null; }
        public static System.Char Delimiter;
        public static System.Type[] EmptyTypes;
        public virtual bool Equals(System.Type o) => throw null;
        public override bool Equals(object o) => throw null;
        public static System.Reflection.MemberFilter FilterAttribute;
        public static System.Reflection.MemberFilter FilterName;
        public static System.Reflection.MemberFilter FilterNameIgnoreCase;
        public virtual System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria) => throw null;
        public virtual System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria) => throw null;
        public abstract string FullName { get; }
        public abstract System.Guid GUID { get; }
        public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get => throw null; }
        public virtual int GenericParameterPosition { get => throw null; }
        public virtual System.Type[] GenericTypeArguments { get => throw null; }
        public virtual int GetArrayRank() => throw null;
        protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Type[] types) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Type[] types) => throw null;
        protected abstract System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        public System.Reflection.ConstructorInfo[] GetConstructors() => throw null;
        public abstract System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Reflection.MemberInfo[] GetDefaultMembers() => throw null;
        public abstract System.Type GetElementType();
        public virtual string GetEnumName(object value) => throw null;
        public virtual string[] GetEnumNames() => throw null;
        public virtual System.Type GetEnumUnderlyingType() => throw null;
        public virtual System.Array GetEnumValues() => throw null;
        public virtual System.Array GetEnumValuesAsUnderlyingType() => throw null;
        public System.Reflection.EventInfo GetEvent(string name) => throw null;
        public abstract System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        public virtual System.Reflection.EventInfo[] GetEvents() => throw null;
        public abstract System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.FieldInfo GetField(string name) => throw null;
        public abstract System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.FieldInfo[] GetFields() => throw null;
        public abstract System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Type[] GetGenericArguments() => throw null;
        public virtual System.Type[] GetGenericParameterConstraints() => throw null;
        public virtual System.Type GetGenericTypeDefinition() => throw null;
        public override int GetHashCode() => throw null;
        public System.Type GetInterface(string name) => throw null;
        public abstract System.Type GetInterface(string name, bool ignoreCase);
        public virtual System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType) => throw null;
        public abstract System.Type[] GetInterfaces();
        public System.Reflection.MemberInfo[] GetMember(string name) => throw null;
        public virtual System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public virtual System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr) => throw null;
        public virtual System.Reflection.MemberInfo GetMemberWithSameMetadataDefinitionAs(System.Reflection.MemberInfo member) => throw null;
        public System.Reflection.MemberInfo[] GetMembers() => throw null;
        public abstract System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.MethodInfo GetMethod(string name) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        protected abstract System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        protected virtual System.Reflection.MethodInfo GetMethodImpl(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo[] GetMethods() => throw null;
        public abstract System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        public System.Type GetNestedType(string name) => throw null;
        public abstract System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
        public System.Type[] GetNestedTypes() => throw null;
        public abstract System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.PropertyInfo[] GetProperties() => throw null;
        public abstract System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.PropertyInfo GetProperty(string name) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type[] types) => throw null;
        protected abstract System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        public System.Type GetType() => throw null;
        public static System.Type GetType(string typeName) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase) => throw null;
        public static System.Type GetType(string typeName, bool throwOnError) => throw null;
        public static System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) => throw null;
        public static System.Type[] GetTypeArray(object[] args) => throw null;
        public static System.TypeCode GetTypeCode(System.Type type) => throw null;
        protected virtual System.TypeCode GetTypeCodeImpl() => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, bool throwOnError) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, string server) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, string server, bool throwOnError) => throw null;
        public static System.Type GetTypeFromHandle(System.RuntimeTypeHandle handle) => throw null;
        public static System.Type GetTypeFromProgID(string progID) => throw null;
        public static System.Type GetTypeFromProgID(string progID, bool throwOnError) => throw null;
        public static System.Type GetTypeFromProgID(string progID, string server) => throw null;
        public static System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) => throw null;
        public static System.RuntimeTypeHandle GetTypeHandle(object o) => throw null;
        public bool HasElementType { get => throw null; }
        protected abstract bool HasElementTypeImpl();
        public object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args) => throw null;
        public object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture) => throw null;
        public abstract object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
        public bool IsAbstract { get => throw null; }
        public bool IsAnsiClass { get => throw null; }
        public bool IsArray { get => throw null; }
        protected abstract bool IsArrayImpl();
        public virtual bool IsAssignableFrom(System.Type c) => throw null;
        public bool IsAssignableTo(System.Type targetType) => throw null;
        public bool IsAutoClass { get => throw null; }
        public bool IsAutoLayout { get => throw null; }
        public bool IsByRef { get => throw null; }
        protected abstract bool IsByRefImpl();
        public virtual bool IsByRefLike { get => throw null; }
        public bool IsCOMObject { get => throw null; }
        protected abstract bool IsCOMObjectImpl();
        public bool IsClass { get => throw null; }
        public virtual bool IsConstructedGenericType { get => throw null; }
        public bool IsContextful { get => throw null; }
        protected virtual bool IsContextfulImpl() => throw null;
        public virtual bool IsEnum { get => throw null; }
        public virtual bool IsEnumDefined(object value) => throw null;
        public virtual bool IsEquivalentTo(System.Type other) => throw null;
        public bool IsExplicitLayout { get => throw null; }
        public virtual bool IsGenericMethodParameter { get => throw null; }
        public virtual bool IsGenericParameter { get => throw null; }
        public virtual bool IsGenericType { get => throw null; }
        public virtual bool IsGenericTypeDefinition { get => throw null; }
        public virtual bool IsGenericTypeParameter { get => throw null; }
        public bool IsImport { get => throw null; }
        public virtual bool IsInstanceOfType(object o) => throw null;
        public bool IsInterface { get => throw null; }
        public bool IsLayoutSequential { get => throw null; }
        public bool IsMarshalByRef { get => throw null; }
        protected virtual bool IsMarshalByRefImpl() => throw null;
        public bool IsNested { get => throw null; }
        public bool IsNestedAssembly { get => throw null; }
        public bool IsNestedFamANDAssem { get => throw null; }
        public bool IsNestedFamORAssem { get => throw null; }
        public bool IsNestedFamily { get => throw null; }
        public bool IsNestedPrivate { get => throw null; }
        public bool IsNestedPublic { get => throw null; }
        public bool IsNotPublic { get => throw null; }
        public bool IsPointer { get => throw null; }
        protected abstract bool IsPointerImpl();
        public bool IsPrimitive { get => throw null; }
        protected abstract bool IsPrimitiveImpl();
        public bool IsPublic { get => throw null; }
        public virtual bool IsSZArray { get => throw null; }
        public bool IsSealed { get => throw null; }
        public virtual bool IsSecurityCritical { get => throw null; }
        public virtual bool IsSecuritySafeCritical { get => throw null; }
        public virtual bool IsSecurityTransparent { get => throw null; }
        public virtual bool IsSerializable { get => throw null; }
        public virtual bool IsSignatureType { get => throw null; }
        public bool IsSpecialName { get => throw null; }
        public virtual bool IsSubclassOf(System.Type c) => throw null;
        public virtual bool IsTypeDefinition { get => throw null; }
        public bool IsUnicodeClass { get => throw null; }
        public bool IsValueType { get => throw null; }
        protected virtual bool IsValueTypeImpl() => throw null;
        public virtual bool IsVariableBoundArray { get => throw null; }
        public bool IsVisible { get => throw null; }
        public virtual System.Type MakeArrayType() => throw null;
        public virtual System.Type MakeArrayType(int rank) => throw null;
        public virtual System.Type MakeByRefType() => throw null;
        public static System.Type MakeGenericMethodParameter(int position) => throw null;
        public static System.Type MakeGenericSignatureType(System.Type genericTypeDefinition, params System.Type[] typeArguments) => throw null;
        public virtual System.Type MakeGenericType(params System.Type[] typeArguments) => throw null;
        public virtual System.Type MakePointerType() => throw null;
        public override System.Reflection.MemberTypes MemberType { get => throw null; }
        public static object Missing;
        public abstract System.Reflection.Module Module { get; }
        public abstract string Namespace { get; }
        public override System.Type ReflectedType { get => throw null; }
        public static System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) => throw null;
        public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get => throw null; }
        public override string ToString() => throw null;
        protected Type() => throw null;
        public virtual System.RuntimeTypeHandle TypeHandle { get => throw null; }
        public System.Reflection.ConstructorInfo TypeInitializer { get => throw null; }
        public abstract System.Type UnderlyingSystemType { get; }
    }

    public class TypeAccessException : System.TypeLoadException
    {
        public TypeAccessException() => throw null;
        protected TypeAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeAccessException(string message) => throw null;
        public TypeAccessException(string message, System.Exception inner) => throw null;
    }

    public enum TypeCode : int
    {
        Boolean = 3,
        Byte = 6,
        Char = 4,
        DBNull = 2,
        DateTime = 16,
        Decimal = 15,
        Double = 14,
        Empty = 0,
        Int16 = 7,
        Int32 = 9,
        Int64 = 11,
        Object = 1,
        SByte = 5,
        Single = 13,
        String = 18,
        UInt16 = 8,
        UInt32 = 10,
        UInt64 = 12,
    }

    public class TypeInitializationException : System.SystemException
    {
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeInitializationException(string fullTypeName, System.Exception innerException) => throw null;
        public string TypeName { get => throw null; }
    }

    public class TypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
    {
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public TypeLoadException() => throw null;
        protected TypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeLoadException(string message) => throw null;
        public TypeLoadException(string message, System.Exception inner) => throw null;
        public string TypeName { get => throw null; }
    }

    public class TypeUnloadedException : System.SystemException
    {
        public TypeUnloadedException() => throw null;
        protected TypeUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeUnloadedException(string message) => throw null;
        public TypeUnloadedException(string message, System.Exception innerException) => throw null;
    }

    public struct TypedReference
    {
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public static System.Type GetTargetType(System.TypedReference value) => throw null;
        public static System.TypedReference MakeTypedReference(object target, System.Reflection.FieldInfo[] flds) => throw null;
        public static void SetTypedReference(System.TypedReference target, object value) => throw null;
        public static System.RuntimeTypeHandle TargetTypeToken(System.TypedReference value) => throw null;
        public static object ToObject(System.TypedReference value) => throw null;
        // Stub generator skipped constructor 
    }

    public struct UInt128 : System.IComparable, System.IComparable<System.UInt128>, System.IEquatable<System.UInt128>, System.IFormattable, System.IParsable<System.UInt128>, System.ISpanFormattable, System.ISpanParsable<System.UInt128>, System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IAdditiveIdentity<System.UInt128, System.UInt128>, System.Numerics.IBinaryInteger<System.UInt128>, System.Numerics.IBinaryNumber<System.UInt128>, System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>, System.Numerics.IDecrementOperators<System.UInt128>, System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>, System.Numerics.IIncrementOperators<System.UInt128>, System.Numerics.IMinMaxValue<System.UInt128>, System.Numerics.IModulusOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IMultiplicativeIdentity<System.UInt128, System.UInt128>, System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.INumber<System.UInt128>, System.Numerics.INumberBase<System.UInt128>, System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>, System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>, System.Numerics.IUnaryPlusOperators<System.UInt128, System.UInt128>, System.Numerics.IUnsignedNumber<System.UInt128>
    {
        static bool System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>.operator !=(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IModulusOperators<System.UInt128, System.UInt128, System.UInt128>.operator %(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator &(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>.operator *(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IUnaryPlusOperators<System.UInt128, System.UInt128>.operator +(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>.operator +(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IIncrementOperators<System.UInt128>.operator ++(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>.operator -(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>.operator -(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IDecrementOperators<System.UInt128>.operator --(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>.operator /(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator <(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator <<(System.UInt128 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator <=(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>.operator ==(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator >(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator >=(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator >>(System.UInt128 value, int shiftAmount) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator >>>(System.UInt128 value, int shiftAmount) => throw null;
        public static System.UInt128 Abs(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IAdditiveIdentity<System.UInt128, System.UInt128>.AdditiveIdentity { get => throw null; }
        static System.UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get => throw null; }
        public static System.UInt128 Clamp(System.UInt128 value, System.UInt128 min, System.UInt128 max) => throw null;
        public int CompareTo(System.UInt128 value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.UInt128 CopySign(System.UInt128 value, System.UInt128 sign) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.UInt128, System.UInt128) DivRem(System.UInt128 left, System.UInt128 right) => throw null;
        public bool Equals(System.UInt128 other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.UInt128>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.UInt128>.GetShortestBitLength() => throw null;
        public static bool IsCanonical(System.UInt128 value) => throw null;
        public static bool IsComplexNumber(System.UInt128 value) => throw null;
        public static bool IsEvenInteger(System.UInt128 value) => throw null;
        public static bool IsFinite(System.UInt128 value) => throw null;
        public static bool IsImaginaryNumber(System.UInt128 value) => throw null;
        public static bool IsInfinity(System.UInt128 value) => throw null;
        public static bool IsInteger(System.UInt128 value) => throw null;
        public static bool IsNaN(System.UInt128 value) => throw null;
        public static bool IsNegative(System.UInt128 value) => throw null;
        public static bool IsNegativeInfinity(System.UInt128 value) => throw null;
        public static bool IsNormal(System.UInt128 value) => throw null;
        public static bool IsOddInteger(System.UInt128 value) => throw null;
        public static bool IsPositive(System.UInt128 value) => throw null;
        public static bool IsPositiveInfinity(System.UInt128 value) => throw null;
        public static bool IsPow2(System.UInt128 value) => throw null;
        public static bool IsRealNumber(System.UInt128 value) => throw null;
        public static bool IsSubnormal(System.UInt128 value) => throw null;
        public static bool IsZero(System.UInt128 value) => throw null;
        public static System.UInt128 LeadingZeroCount(System.UInt128 value) => throw null;
        public static System.UInt128 Log2(System.UInt128 value) => throw null;
        public static System.UInt128 Max(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MaxMagnitude(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MaxMagnitudeNumber(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MaxNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.IMinMaxValue<System.UInt128>.MaxValue { get => throw null; }
        public static System.UInt128 Min(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MinMagnitude(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MinMagnitudeNumber(System.UInt128 x, System.UInt128 y) => throw null;
        public static System.UInt128 MinNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.IMinMaxValue<System.UInt128>.MinValue { get => throw null; }
        static System.UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128, System.UInt128>.MultiplicativeIdentity { get => throw null; }
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.One { get => throw null; }
        public static System.UInt128 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.UInt128 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.UInt128 Parse(string s) => throw null;
        public static System.UInt128 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.UInt128 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.UInt128 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.UInt128 PopCount(System.UInt128 value) => throw null;
        static int System.Numerics.INumberBase<System.UInt128>.Radix { get => throw null; }
        public static System.UInt128 RotateLeft(System.UInt128 value, int rotateAmount) => throw null;
        public static System.UInt128 RotateRight(System.UInt128 value, int rotateAmount) => throw null;
        public static int Sign(System.UInt128 value) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public static System.UInt128 TrailingZeroCount(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromChecked<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromSaturating<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromTruncating<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToChecked<TOther>(System.UInt128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToSaturating<TOther>(System.UInt128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToTruncating<TOther>(System.UInt128 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.UInt128 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(string s, out System.UInt128 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt128 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt128 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        // Stub generator skipped constructor 
        public UInt128(System.UInt64 upper, System.UInt64 lower) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Zero { get => throw null; }
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator ^(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked *(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked +(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IIncrementOperators<System.UInt128>.operator checked ++(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>.operator checked -(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked -(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IDecrementOperators<System.UInt128>.operator checked --(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked /(System.UInt128 left, System.UInt128 right) => throw null;
        public static explicit operator checked System.UInt128(System.IntPtr value) => throw null;
        public static explicit operator checked System.Byte(System.UInt128 value) => throw null;
        public static explicit operator checked System.Char(System.UInt128 value) => throw null;
        public static explicit operator checked System.Int128(System.UInt128 value) => throw null;
        public static explicit operator checked System.Int16(System.UInt128 value) => throw null;
        public static explicit operator checked System.Int64(System.UInt128 value) => throw null;
        public static explicit operator checked System.IntPtr(System.UInt128 value) => throw null;
        public static explicit operator checked System.SByte(System.UInt128 value) => throw null;
        public static explicit operator checked System.UInt16(System.UInt128 value) => throw null;
        public static explicit operator checked System.UInt32(System.UInt128 value) => throw null;
        public static explicit operator checked System.UInt64(System.UInt128 value) => throw null;
        public static explicit operator checked System.UIntPtr(System.UInt128 value) => throw null;
        public static explicit operator checked int(System.UInt128 value) => throw null;
        public static explicit operator checked System.UInt128(double value) => throw null;
        public static explicit operator checked System.UInt128(float value) => throw null;
        public static explicit operator checked System.UInt128(int value) => throw null;
        public static explicit operator checked System.UInt128(System.Int64 value) => throw null;
        public static explicit operator checked System.UInt128(System.SByte value) => throw null;
        public static explicit operator checked System.UInt128(System.Int16 value) => throw null;
        public static explicit operator System.UInt128(System.IntPtr value) => throw null;
        public static explicit operator System.Byte(System.UInt128 value) => throw null;
        public static explicit operator System.Char(System.UInt128 value) => throw null;
        public static explicit operator System.Decimal(System.UInt128 value) => throw null;
        public static explicit operator System.Half(System.UInt128 value) => throw null;
        public static explicit operator System.Int128(System.UInt128 value) => throw null;
        public static explicit operator System.Int16(System.UInt128 value) => throw null;
        public static explicit operator System.Int64(System.UInt128 value) => throw null;
        public static explicit operator System.IntPtr(System.UInt128 value) => throw null;
        public static explicit operator System.SByte(System.UInt128 value) => throw null;
        public static explicit operator System.UInt16(System.UInt128 value) => throw null;
        public static explicit operator System.UInt32(System.UInt128 value) => throw null;
        public static explicit operator System.UInt64(System.UInt128 value) => throw null;
        public static explicit operator System.UIntPtr(System.UInt128 value) => throw null;
        public static explicit operator double(System.UInt128 value) => throw null;
        public static explicit operator float(System.UInt128 value) => throw null;
        public static explicit operator int(System.UInt128 value) => throw null;
        public static explicit operator System.UInt128(System.Decimal value) => throw null;
        public static explicit operator System.UInt128(double value) => throw null;
        public static explicit operator System.UInt128(float value) => throw null;
        public static explicit operator System.UInt128(int value) => throw null;
        public static explicit operator System.UInt128(System.Int64 value) => throw null;
        public static explicit operator System.UInt128(System.SByte value) => throw null;
        public static explicit operator System.UInt128(System.Int16 value) => throw null;
        public static implicit operator System.UInt128(System.UIntPtr value) => throw null;
        public static implicit operator System.UInt128(System.Byte value) => throw null;
        public static implicit operator System.UInt128(System.Char value) => throw null;
        public static implicit operator System.UInt128(System.UInt32 value) => throw null;
        public static implicit operator System.UInt128(System.UInt64 value) => throw null;
        public static implicit operator System.UInt128(System.UInt16 value) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator |(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator ~(System.UInt128 value) => throw null;
    }

    public struct UInt16 : System.IComparable, System.IComparable<System.UInt16>, System.IConvertible, System.IEquatable<System.UInt16>, System.IFormattable, System.IParsable<System.UInt16>, System.ISpanFormattable, System.ISpanParsable<System.UInt16>, System.Numerics.IAdditionOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.IAdditiveIdentity<System.UInt16, System.UInt16>, System.Numerics.IBinaryInteger<System.UInt16>, System.Numerics.IBinaryNumber<System.UInt16>, System.Numerics.IBitwiseOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.IComparisonOperators<System.UInt16, System.UInt16, bool>, System.Numerics.IDecrementOperators<System.UInt16>, System.Numerics.IDivisionOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.IEqualityOperators<System.UInt16, System.UInt16, bool>, System.Numerics.IIncrementOperators<System.UInt16>, System.Numerics.IMinMaxValue<System.UInt16>, System.Numerics.IModulusOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.IMultiplicativeIdentity<System.UInt16, System.UInt16>, System.Numerics.IMultiplyOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.INumber<System.UInt16>, System.Numerics.INumberBase<System.UInt16>, System.Numerics.IShiftOperators<System.UInt16, int, System.UInt16>, System.Numerics.ISubtractionOperators<System.UInt16, System.UInt16, System.UInt16>, System.Numerics.IUnaryNegationOperators<System.UInt16, System.UInt16>, System.Numerics.IUnaryPlusOperators<System.UInt16, System.UInt16>, System.Numerics.IUnsignedNumber<System.UInt16>
    {
        static bool System.Numerics.IEqualityOperators<System.UInt16, System.UInt16, bool>.operator !=(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IModulusOperators<System.UInt16, System.UInt16, System.UInt16>.operator %(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IBitwiseOperators<System.UInt16, System.UInt16, System.UInt16>.operator &(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IMultiplyOperators<System.UInt16, System.UInt16, System.UInt16>.operator *(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IUnaryPlusOperators<System.UInt16, System.UInt16>.operator +(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IAdditionOperators<System.UInt16, System.UInt16, System.UInt16>.operator +(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IIncrementOperators<System.UInt16>.operator ++(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IUnaryNegationOperators<System.UInt16, System.UInt16>.operator -(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.ISubtractionOperators<System.UInt16, System.UInt16, System.UInt16>.operator -(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IDecrementOperators<System.UInt16>.operator --(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IDivisionOperators<System.UInt16, System.UInt16, System.UInt16>.operator /(System.UInt16 left, System.UInt16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt16, System.UInt16, bool>.operator <(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IShiftOperators<System.UInt16, int, System.UInt16>.operator <<(System.UInt16 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt16, System.UInt16, bool>.operator <=(System.UInt16 left, System.UInt16 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt16, System.UInt16, bool>.operator ==(System.UInt16 left, System.UInt16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt16, System.UInt16, bool>.operator >(System.UInt16 left, System.UInt16 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt16, System.UInt16, bool>.operator >=(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IShiftOperators<System.UInt16, int, System.UInt16>.operator >>(System.UInt16 value, int shiftAmount) => throw null;
        static System.UInt16 System.Numerics.IShiftOperators<System.UInt16, int, System.UInt16>.operator >>>(System.UInt16 value, int shiftAmount) => throw null;
        public static System.UInt16 Abs(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IAdditiveIdentity<System.UInt16, System.UInt16>.AdditiveIdentity { get => throw null; }
        static System.UInt16 System.Numerics.IBinaryNumber<System.UInt16>.AllBitsSet { get => throw null; }
        public static System.UInt16 Clamp(System.UInt16 value, System.UInt16 min, System.UInt16 max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.UInt16 value) => throw null;
        public static System.UInt16 CopySign(System.UInt16 value, System.UInt16 sign) => throw null;
        static System.UInt16 System.Numerics.INumberBase<System.UInt16>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UInt16 System.Numerics.INumberBase<System.UInt16>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UInt16 System.Numerics.INumberBase<System.UInt16>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.UInt16, System.UInt16) DivRem(System.UInt16 left, System.UInt16 right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.UInt16 obj) => throw null;
        int System.Numerics.IBinaryInteger<System.UInt16>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.UInt16>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.UInt16 value) => throw null;
        public static bool IsComplexNumber(System.UInt16 value) => throw null;
        public static bool IsEvenInteger(System.UInt16 value) => throw null;
        public static bool IsFinite(System.UInt16 value) => throw null;
        public static bool IsImaginaryNumber(System.UInt16 value) => throw null;
        public static bool IsInfinity(System.UInt16 value) => throw null;
        public static bool IsInteger(System.UInt16 value) => throw null;
        public static bool IsNaN(System.UInt16 value) => throw null;
        public static bool IsNegative(System.UInt16 value) => throw null;
        public static bool IsNegativeInfinity(System.UInt16 value) => throw null;
        public static bool IsNormal(System.UInt16 value) => throw null;
        public static bool IsOddInteger(System.UInt16 value) => throw null;
        public static bool IsPositive(System.UInt16 value) => throw null;
        public static bool IsPositiveInfinity(System.UInt16 value) => throw null;
        public static bool IsPow2(System.UInt16 value) => throw null;
        public static bool IsRealNumber(System.UInt16 value) => throw null;
        public static bool IsSubnormal(System.UInt16 value) => throw null;
        public static bool IsZero(System.UInt16 value) => throw null;
        public static System.UInt16 LeadingZeroCount(System.UInt16 value) => throw null;
        public static System.UInt16 Log2(System.UInt16 value) => throw null;
        public static System.UInt16 Max(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MaxMagnitude(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MaxMagnitudeNumber(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MaxNumber(System.UInt16 x, System.UInt16 y) => throw null;
        public const System.UInt16 MaxValue = default;
        static System.UInt16 System.Numerics.IMinMaxValue<System.UInt16>.MaxValue { get => throw null; }
        public static System.UInt16 Min(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MinMagnitude(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MinMagnitudeNumber(System.UInt16 x, System.UInt16 y) => throw null;
        public static System.UInt16 MinNumber(System.UInt16 x, System.UInt16 y) => throw null;
        public const System.UInt16 MinValue = default;
        static System.UInt16 System.Numerics.IMinMaxValue<System.UInt16>.MinValue { get => throw null; }
        static System.UInt16 System.Numerics.IMultiplicativeIdentity<System.UInt16, System.UInt16>.MultiplicativeIdentity { get => throw null; }
        static System.UInt16 System.Numerics.INumberBase<System.UInt16>.One { get => throw null; }
        public static System.UInt16 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.UInt16 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.UInt16 Parse(string s) => throw null;
        public static System.UInt16 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.UInt16 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.UInt16 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.UInt16 PopCount(System.UInt16 value) => throw null;
        static int System.Numerics.INumberBase<System.UInt16>.Radix { get => throw null; }
        public static System.UInt16 RotateLeft(System.UInt16 value, int rotateAmount) => throw null;
        public static System.UInt16 RotateRight(System.UInt16 value, int rotateAmount) => throw null;
        public static int Sign(System.UInt16 value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.UInt16 TrailingZeroCount(System.UInt16 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromChecked<TOther>(TOther value, out System.UInt16 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromSaturating<TOther>(TOther value, out System.UInt16 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromTruncating<TOther>(TOther value, out System.UInt16 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertToChecked<TOther>(System.UInt16 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertToSaturating<TOther>(System.UInt16 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt16>.TryConvertToTruncating<TOther>(System.UInt16 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.UInt16 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt16 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.UInt16 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.UInt16 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt16 result) => throw null;
        public static bool TryParse(string s, out System.UInt16 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt16 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt16 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        // Stub generator skipped constructor 
        static System.UInt16 System.Numerics.INumberBase<System.UInt16>.Zero { get => throw null; }
        static System.UInt16 System.Numerics.IBitwiseOperators<System.UInt16, System.UInt16, System.UInt16>.operator ^(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IMultiplyOperators<System.UInt16, System.UInt16, System.UInt16>.operator checked *(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IAdditionOperators<System.UInt16, System.UInt16, System.UInt16>.operator checked +(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IIncrementOperators<System.UInt16>.operator checked ++(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IUnaryNegationOperators<System.UInt16, System.UInt16>.operator checked -(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.ISubtractionOperators<System.UInt16, System.UInt16, System.UInt16>.operator checked -(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IDecrementOperators<System.UInt16>.operator checked --(System.UInt16 value) => throw null;
        static System.UInt16 System.Numerics.IBitwiseOperators<System.UInt16, System.UInt16, System.UInt16>.operator |(System.UInt16 left, System.UInt16 right) => throw null;
        static System.UInt16 System.Numerics.IBitwiseOperators<System.UInt16, System.UInt16, System.UInt16>.operator ~(System.UInt16 value) => throw null;
    }

    public struct UInt32 : System.IComparable, System.IComparable<System.UInt32>, System.IConvertible, System.IEquatable<System.UInt32>, System.IFormattable, System.IParsable<System.UInt32>, System.ISpanFormattable, System.ISpanParsable<System.UInt32>, System.Numerics.IAdditionOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.IAdditiveIdentity<System.UInt32, System.UInt32>, System.Numerics.IBinaryInteger<System.UInt32>, System.Numerics.IBinaryNumber<System.UInt32>, System.Numerics.IBitwiseOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.IComparisonOperators<System.UInt32, System.UInt32, bool>, System.Numerics.IDecrementOperators<System.UInt32>, System.Numerics.IDivisionOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.IEqualityOperators<System.UInt32, System.UInt32, bool>, System.Numerics.IIncrementOperators<System.UInt32>, System.Numerics.IMinMaxValue<System.UInt32>, System.Numerics.IModulusOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.IMultiplicativeIdentity<System.UInt32, System.UInt32>, System.Numerics.IMultiplyOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.INumber<System.UInt32>, System.Numerics.INumberBase<System.UInt32>, System.Numerics.IShiftOperators<System.UInt32, int, System.UInt32>, System.Numerics.ISubtractionOperators<System.UInt32, System.UInt32, System.UInt32>, System.Numerics.IUnaryNegationOperators<System.UInt32, System.UInt32>, System.Numerics.IUnaryPlusOperators<System.UInt32, System.UInt32>, System.Numerics.IUnsignedNumber<System.UInt32>
    {
        static bool System.Numerics.IEqualityOperators<System.UInt32, System.UInt32, bool>.operator !=(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IModulusOperators<System.UInt32, System.UInt32, System.UInt32>.operator %(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IBitwiseOperators<System.UInt32, System.UInt32, System.UInt32>.operator &(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IMultiplyOperators<System.UInt32, System.UInt32, System.UInt32>.operator *(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IUnaryPlusOperators<System.UInt32, System.UInt32>.operator +(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IAdditionOperators<System.UInt32, System.UInt32, System.UInt32>.operator +(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IIncrementOperators<System.UInt32>.operator ++(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32, System.UInt32>.operator -(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.ISubtractionOperators<System.UInt32, System.UInt32, System.UInt32>.operator -(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IDecrementOperators<System.UInt32>.operator --(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IDivisionOperators<System.UInt32, System.UInt32, System.UInt32>.operator /(System.UInt32 left, System.UInt32 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt32, System.UInt32, bool>.operator <(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IShiftOperators<System.UInt32, int, System.UInt32>.operator <<(System.UInt32 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt32, System.UInt32, bool>.operator <=(System.UInt32 left, System.UInt32 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt32, System.UInt32, bool>.operator ==(System.UInt32 left, System.UInt32 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt32, System.UInt32, bool>.operator >(System.UInt32 left, System.UInt32 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt32, System.UInt32, bool>.operator >=(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IShiftOperators<System.UInt32, int, System.UInt32>.operator >>(System.UInt32 value, int shiftAmount) => throw null;
        static System.UInt32 System.Numerics.IShiftOperators<System.UInt32, int, System.UInt32>.operator >>>(System.UInt32 value, int shiftAmount) => throw null;
        public static System.UInt32 Abs(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IAdditiveIdentity<System.UInt32, System.UInt32>.AdditiveIdentity { get => throw null; }
        static System.UInt32 System.Numerics.IBinaryNumber<System.UInt32>.AllBitsSet { get => throw null; }
        public static System.UInt32 Clamp(System.UInt32 value, System.UInt32 min, System.UInt32 max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.UInt32 value) => throw null;
        public static System.UInt32 CopySign(System.UInt32 value, System.UInt32 sign) => throw null;
        static System.UInt32 System.Numerics.INumberBase<System.UInt32>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UInt32 System.Numerics.INumberBase<System.UInt32>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UInt32 System.Numerics.INumberBase<System.UInt32>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.UInt32, System.UInt32) DivRem(System.UInt32 left, System.UInt32 right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.UInt32 obj) => throw null;
        int System.Numerics.IBinaryInteger<System.UInt32>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.UInt32>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.UInt32 value) => throw null;
        public static bool IsComplexNumber(System.UInt32 value) => throw null;
        public static bool IsEvenInteger(System.UInt32 value) => throw null;
        public static bool IsFinite(System.UInt32 value) => throw null;
        public static bool IsImaginaryNumber(System.UInt32 value) => throw null;
        public static bool IsInfinity(System.UInt32 value) => throw null;
        public static bool IsInteger(System.UInt32 value) => throw null;
        public static bool IsNaN(System.UInt32 value) => throw null;
        public static bool IsNegative(System.UInt32 value) => throw null;
        public static bool IsNegativeInfinity(System.UInt32 value) => throw null;
        public static bool IsNormal(System.UInt32 value) => throw null;
        public static bool IsOddInteger(System.UInt32 value) => throw null;
        public static bool IsPositive(System.UInt32 value) => throw null;
        public static bool IsPositiveInfinity(System.UInt32 value) => throw null;
        public static bool IsPow2(System.UInt32 value) => throw null;
        public static bool IsRealNumber(System.UInt32 value) => throw null;
        public static bool IsSubnormal(System.UInt32 value) => throw null;
        public static bool IsZero(System.UInt32 value) => throw null;
        public static System.UInt32 LeadingZeroCount(System.UInt32 value) => throw null;
        public static System.UInt32 Log2(System.UInt32 value) => throw null;
        public static System.UInt32 Max(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MaxMagnitude(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MaxMagnitudeNumber(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MaxNumber(System.UInt32 x, System.UInt32 y) => throw null;
        public const System.UInt32 MaxValue = default;
        static System.UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MaxValue { get => throw null; }
        public static System.UInt32 Min(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MinMagnitude(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MinMagnitudeNumber(System.UInt32 x, System.UInt32 y) => throw null;
        public static System.UInt32 MinNumber(System.UInt32 x, System.UInt32 y) => throw null;
        public const System.UInt32 MinValue = default;
        static System.UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MinValue { get => throw null; }
        static System.UInt32 System.Numerics.IMultiplicativeIdentity<System.UInt32, System.UInt32>.MultiplicativeIdentity { get => throw null; }
        static System.UInt32 System.Numerics.INumberBase<System.UInt32>.One { get => throw null; }
        public static System.UInt32 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.UInt32 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.UInt32 Parse(string s) => throw null;
        public static System.UInt32 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.UInt32 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.UInt32 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.UInt32 PopCount(System.UInt32 value) => throw null;
        static int System.Numerics.INumberBase<System.UInt32>.Radix { get => throw null; }
        public static System.UInt32 RotateLeft(System.UInt32 value, int rotateAmount) => throw null;
        public static System.UInt32 RotateRight(System.UInt32 value, int rotateAmount) => throw null;
        public static int Sign(System.UInt32 value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.UInt32 TrailingZeroCount(System.UInt32 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromChecked<TOther>(TOther value, out System.UInt32 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromSaturating<TOther>(TOther value, out System.UInt32 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromTruncating<TOther>(TOther value, out System.UInt32 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertToChecked<TOther>(System.UInt32 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertToSaturating<TOther>(System.UInt32 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt32>.TryConvertToTruncating<TOther>(System.UInt32 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.UInt32 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt32 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.UInt32 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.UInt32 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt32 result) => throw null;
        public static bool TryParse(string s, out System.UInt32 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt32 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt32 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        // Stub generator skipped constructor 
        static System.UInt32 System.Numerics.INumberBase<System.UInt32>.Zero { get => throw null; }
        static System.UInt32 System.Numerics.IBitwiseOperators<System.UInt32, System.UInt32, System.UInt32>.operator ^(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IMultiplyOperators<System.UInt32, System.UInt32, System.UInt32>.operator checked *(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IAdditionOperators<System.UInt32, System.UInt32, System.UInt32>.operator checked +(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IIncrementOperators<System.UInt32>.operator checked ++(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32, System.UInt32>.operator checked -(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.ISubtractionOperators<System.UInt32, System.UInt32, System.UInt32>.operator checked -(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IDecrementOperators<System.UInt32>.operator checked --(System.UInt32 value) => throw null;
        static System.UInt32 System.Numerics.IBitwiseOperators<System.UInt32, System.UInt32, System.UInt32>.operator |(System.UInt32 left, System.UInt32 right) => throw null;
        static System.UInt32 System.Numerics.IBitwiseOperators<System.UInt32, System.UInt32, System.UInt32>.operator ~(System.UInt32 value) => throw null;
    }

    public struct UInt64 : System.IComparable, System.IComparable<System.UInt64>, System.IConvertible, System.IEquatable<System.UInt64>, System.IFormattable, System.IParsable<System.UInt64>, System.ISpanFormattable, System.ISpanParsable<System.UInt64>, System.Numerics.IAdditionOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.IAdditiveIdentity<System.UInt64, System.UInt64>, System.Numerics.IBinaryInteger<System.UInt64>, System.Numerics.IBinaryNumber<System.UInt64>, System.Numerics.IBitwiseOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.IComparisonOperators<System.UInt64, System.UInt64, bool>, System.Numerics.IDecrementOperators<System.UInt64>, System.Numerics.IDivisionOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.IEqualityOperators<System.UInt64, System.UInt64, bool>, System.Numerics.IIncrementOperators<System.UInt64>, System.Numerics.IMinMaxValue<System.UInt64>, System.Numerics.IModulusOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.IMultiplicativeIdentity<System.UInt64, System.UInt64>, System.Numerics.IMultiplyOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.INumber<System.UInt64>, System.Numerics.INumberBase<System.UInt64>, System.Numerics.IShiftOperators<System.UInt64, int, System.UInt64>, System.Numerics.ISubtractionOperators<System.UInt64, System.UInt64, System.UInt64>, System.Numerics.IUnaryNegationOperators<System.UInt64, System.UInt64>, System.Numerics.IUnaryPlusOperators<System.UInt64, System.UInt64>, System.Numerics.IUnsignedNumber<System.UInt64>
    {
        static bool System.Numerics.IEqualityOperators<System.UInt64, System.UInt64, bool>.operator !=(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IModulusOperators<System.UInt64, System.UInt64, System.UInt64>.operator %(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IBitwiseOperators<System.UInt64, System.UInt64, System.UInt64>.operator &(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IMultiplyOperators<System.UInt64, System.UInt64, System.UInt64>.operator *(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IUnaryPlusOperators<System.UInt64, System.UInt64>.operator +(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IAdditionOperators<System.UInt64, System.UInt64, System.UInt64>.operator +(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IIncrementOperators<System.UInt64>.operator ++(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IUnaryNegationOperators<System.UInt64, System.UInt64>.operator -(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.ISubtractionOperators<System.UInt64, System.UInt64, System.UInt64>.operator -(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IDecrementOperators<System.UInt64>.operator --(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IDivisionOperators<System.UInt64, System.UInt64, System.UInt64>.operator /(System.UInt64 left, System.UInt64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt64, System.UInt64, bool>.operator <(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IShiftOperators<System.UInt64, int, System.UInt64>.operator <<(System.UInt64 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt64, System.UInt64, bool>.operator <=(System.UInt64 left, System.UInt64 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt64, System.UInt64, bool>.operator ==(System.UInt64 left, System.UInt64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt64, System.UInt64, bool>.operator >(System.UInt64 left, System.UInt64 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt64, System.UInt64, bool>.operator >=(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IShiftOperators<System.UInt64, int, System.UInt64>.operator >>(System.UInt64 value, int shiftAmount) => throw null;
        static System.UInt64 System.Numerics.IShiftOperators<System.UInt64, int, System.UInt64>.operator >>>(System.UInt64 value, int shiftAmount) => throw null;
        public static System.UInt64 Abs(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IAdditiveIdentity<System.UInt64, System.UInt64>.AdditiveIdentity { get => throw null; }
        static System.UInt64 System.Numerics.IBinaryNumber<System.UInt64>.AllBitsSet { get => throw null; }
        public static System.UInt64 Clamp(System.UInt64 value, System.UInt64 min, System.UInt64 max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.UInt64 value) => throw null;
        public static System.UInt64 CopySign(System.UInt64 value, System.UInt64 sign) => throw null;
        static System.UInt64 System.Numerics.INumberBase<System.UInt64>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UInt64 System.Numerics.INumberBase<System.UInt64>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UInt64 System.Numerics.INumberBase<System.UInt64>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.UInt64, System.UInt64) DivRem(System.UInt64 left, System.UInt64 right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.UInt64 obj) => throw null;
        int System.Numerics.IBinaryInteger<System.UInt64>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.UInt64>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool IsCanonical(System.UInt64 value) => throw null;
        public static bool IsComplexNumber(System.UInt64 value) => throw null;
        public static bool IsEvenInteger(System.UInt64 value) => throw null;
        public static bool IsFinite(System.UInt64 value) => throw null;
        public static bool IsImaginaryNumber(System.UInt64 value) => throw null;
        public static bool IsInfinity(System.UInt64 value) => throw null;
        public static bool IsInteger(System.UInt64 value) => throw null;
        public static bool IsNaN(System.UInt64 value) => throw null;
        public static bool IsNegative(System.UInt64 value) => throw null;
        public static bool IsNegativeInfinity(System.UInt64 value) => throw null;
        public static bool IsNormal(System.UInt64 value) => throw null;
        public static bool IsOddInteger(System.UInt64 value) => throw null;
        public static bool IsPositive(System.UInt64 value) => throw null;
        public static bool IsPositiveInfinity(System.UInt64 value) => throw null;
        public static bool IsPow2(System.UInt64 value) => throw null;
        public static bool IsRealNumber(System.UInt64 value) => throw null;
        public static bool IsSubnormal(System.UInt64 value) => throw null;
        public static bool IsZero(System.UInt64 value) => throw null;
        public static System.UInt64 LeadingZeroCount(System.UInt64 value) => throw null;
        public static System.UInt64 Log2(System.UInt64 value) => throw null;
        public static System.UInt64 Max(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MaxMagnitude(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MaxMagnitudeNumber(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MaxNumber(System.UInt64 x, System.UInt64 y) => throw null;
        public const System.UInt64 MaxValue = default;
        static System.UInt64 System.Numerics.IMinMaxValue<System.UInt64>.MaxValue { get => throw null; }
        public static System.UInt64 Min(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MinMagnitude(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MinMagnitudeNumber(System.UInt64 x, System.UInt64 y) => throw null;
        public static System.UInt64 MinNumber(System.UInt64 x, System.UInt64 y) => throw null;
        public const System.UInt64 MinValue = default;
        static System.UInt64 System.Numerics.IMinMaxValue<System.UInt64>.MinValue { get => throw null; }
        static System.UInt64 System.Numerics.IMultiplicativeIdentity<System.UInt64, System.UInt64>.MultiplicativeIdentity { get => throw null; }
        static System.UInt64 System.Numerics.INumberBase<System.UInt64>.One { get => throw null; }
        public static System.UInt64 Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.UInt64 Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.UInt64 Parse(string s) => throw null;
        public static System.UInt64 Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.UInt64 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.UInt64 Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.UInt64 PopCount(System.UInt64 value) => throw null;
        static int System.Numerics.INumberBase<System.UInt64>.Radix { get => throw null; }
        public static System.UInt64 RotateLeft(System.UInt64 value, int rotateAmount) => throw null;
        public static System.UInt64 RotateRight(System.UInt64 value, int rotateAmount) => throw null;
        public static int Sign(System.UInt64 value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        System.Byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        System.Char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        System.Decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        System.Int16 System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        System.Int64 System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        System.SByte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        System.UInt16 System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        System.UInt32 System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        System.UInt64 System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static System.UInt64 TrailingZeroCount(System.UInt64 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromChecked<TOther>(TOther value, out System.UInt64 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromSaturating<TOther>(TOther value, out System.UInt64 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromTruncating<TOther>(TOther value, out System.UInt64 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertToChecked<TOther>(System.UInt64 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertToSaturating<TOther>(System.UInt64 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt64>.TryConvertToTruncating<TOther>(System.UInt64 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.UInt64 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt64 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.UInt64 result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.UInt64 result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt64 result) => throw null;
        public static bool TryParse(string s, out System.UInt64 result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt64 value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UInt64 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        // Stub generator skipped constructor 
        static System.UInt64 System.Numerics.INumberBase<System.UInt64>.Zero { get => throw null; }
        static System.UInt64 System.Numerics.IBitwiseOperators<System.UInt64, System.UInt64, System.UInt64>.operator ^(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IMultiplyOperators<System.UInt64, System.UInt64, System.UInt64>.operator checked *(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IAdditionOperators<System.UInt64, System.UInt64, System.UInt64>.operator checked +(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IIncrementOperators<System.UInt64>.operator checked ++(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IUnaryNegationOperators<System.UInt64, System.UInt64>.operator checked -(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.ISubtractionOperators<System.UInt64, System.UInt64, System.UInt64>.operator checked -(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IDecrementOperators<System.UInt64>.operator checked --(System.UInt64 value) => throw null;
        static System.UInt64 System.Numerics.IBitwiseOperators<System.UInt64, System.UInt64, System.UInt64>.operator |(System.UInt64 left, System.UInt64 right) => throw null;
        static System.UInt64 System.Numerics.IBitwiseOperators<System.UInt64, System.UInt64, System.UInt64>.operator ~(System.UInt64 value) => throw null;
    }

    public struct UIntPtr : System.IComparable, System.IComparable<System.UIntPtr>, System.IEquatable<System.UIntPtr>, System.IFormattable, System.IParsable<System.UIntPtr>, System.ISpanFormattable, System.ISpanParsable<System.UIntPtr>, System.Numerics.IAdditionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.IAdditiveIdentity<System.UIntPtr, System.UIntPtr>, System.Numerics.IBinaryInteger<System.UIntPtr>, System.Numerics.IBinaryNumber<System.UIntPtr>, System.Numerics.IBitwiseOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.IComparisonOperators<System.UIntPtr, System.UIntPtr, bool>, System.Numerics.IDecrementOperators<System.UIntPtr>, System.Numerics.IDivisionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.IEqualityOperators<System.UIntPtr, System.UIntPtr, bool>, System.Numerics.IIncrementOperators<System.UIntPtr>, System.Numerics.IMinMaxValue<System.UIntPtr>, System.Numerics.IModulusOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.IMultiplicativeIdentity<System.UIntPtr, System.UIntPtr>, System.Numerics.IMultiplyOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.INumber<System.UIntPtr>, System.Numerics.INumberBase<System.UIntPtr>, System.Numerics.IShiftOperators<System.UIntPtr, int, System.UIntPtr>, System.Numerics.ISubtractionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>, System.Numerics.IUnaryNegationOperators<System.UIntPtr, System.UIntPtr>, System.Numerics.IUnaryPlusOperators<System.UIntPtr, System.UIntPtr>, System.Numerics.IUnsignedNumber<System.UIntPtr>, System.Runtime.Serialization.ISerializable
    {
        static bool System.Numerics.IEqualityOperators<System.UIntPtr, System.UIntPtr, bool>.operator !=(System.UIntPtr value1, System.UIntPtr value2) => throw null;
        static System.UIntPtr System.Numerics.IModulusOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator %(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IBitwiseOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator &(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IMultiplyOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator *(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IUnaryPlusOperators<System.UIntPtr, System.UIntPtr>.operator +(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.IAdditionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator +(System.UIntPtr left, System.UIntPtr right) => throw null;
        public static System.UIntPtr operator +(System.UIntPtr pointer, int offset) => throw null;
        static System.UIntPtr System.Numerics.IIncrementOperators<System.UIntPtr>.operator ++(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.IUnaryNegationOperators<System.UIntPtr, System.UIntPtr>.operator -(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.ISubtractionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator -(System.UIntPtr left, System.UIntPtr right) => throw null;
        public static System.UIntPtr operator -(System.UIntPtr pointer, int offset) => throw null;
        static System.UIntPtr System.Numerics.IDecrementOperators<System.UIntPtr>.operator --(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.IDivisionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator /(System.UIntPtr left, System.UIntPtr right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UIntPtr, System.UIntPtr, bool>.operator <(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IShiftOperators<System.UIntPtr, int, System.UIntPtr>.operator <<(System.UIntPtr value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UIntPtr, System.UIntPtr, bool>.operator <=(System.UIntPtr left, System.UIntPtr right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UIntPtr, System.UIntPtr, bool>.operator ==(System.UIntPtr value1, System.UIntPtr value2) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UIntPtr, System.UIntPtr, bool>.operator >(System.UIntPtr left, System.UIntPtr right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UIntPtr, System.UIntPtr, bool>.operator >=(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IShiftOperators<System.UIntPtr, int, System.UIntPtr>.operator >>(System.UIntPtr value, int shiftAmount) => throw null;
        static System.UIntPtr System.Numerics.IShiftOperators<System.UIntPtr, int, System.UIntPtr>.operator >>>(System.UIntPtr value, int shiftAmount) => throw null;
        public static System.UIntPtr Abs(System.UIntPtr value) => throw null;
        public static System.UIntPtr Add(System.UIntPtr pointer, int offset) => throw null;
        static System.UIntPtr System.Numerics.IAdditiveIdentity<System.UIntPtr, System.UIntPtr>.AdditiveIdentity { get => throw null; }
        static System.UIntPtr System.Numerics.IBinaryNumber<System.UIntPtr>.AllBitsSet { get => throw null; }
        public static System.UIntPtr Clamp(System.UIntPtr value, System.UIntPtr min, System.UIntPtr max) => throw null;
        public int CompareTo(System.UIntPtr value) => throw null;
        public int CompareTo(object value) => throw null;
        public static System.UIntPtr CopySign(System.UIntPtr value, System.UIntPtr sign) => throw null;
        static System.UIntPtr System.Numerics.INumberBase<System.UIntPtr>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UIntPtr System.Numerics.INumberBase<System.UIntPtr>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UIntPtr System.Numerics.INumberBase<System.UIntPtr>.CreateTruncating<TOther>(TOther value) => throw null;
        public static (System.UIntPtr, System.UIntPtr) DivRem(System.UIntPtr left, System.UIntPtr right) => throw null;
        public bool Equals(System.UIntPtr other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.UIntPtr>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IBinaryInteger<System.UIntPtr>.GetShortestBitLength() => throw null;
        public static bool IsCanonical(System.UIntPtr value) => throw null;
        public static bool IsComplexNumber(System.UIntPtr value) => throw null;
        public static bool IsEvenInteger(System.UIntPtr value) => throw null;
        public static bool IsFinite(System.UIntPtr value) => throw null;
        public static bool IsImaginaryNumber(System.UIntPtr value) => throw null;
        public static bool IsInfinity(System.UIntPtr value) => throw null;
        public static bool IsInteger(System.UIntPtr value) => throw null;
        public static bool IsNaN(System.UIntPtr value) => throw null;
        public static bool IsNegative(System.UIntPtr value) => throw null;
        public static bool IsNegativeInfinity(System.UIntPtr value) => throw null;
        public static bool IsNormal(System.UIntPtr value) => throw null;
        public static bool IsOddInteger(System.UIntPtr value) => throw null;
        public static bool IsPositive(System.UIntPtr value) => throw null;
        public static bool IsPositiveInfinity(System.UIntPtr value) => throw null;
        public static bool IsPow2(System.UIntPtr value) => throw null;
        public static bool IsRealNumber(System.UIntPtr value) => throw null;
        public static bool IsSubnormal(System.UIntPtr value) => throw null;
        public static bool IsZero(System.UIntPtr value) => throw null;
        public static System.UIntPtr LeadingZeroCount(System.UIntPtr value) => throw null;
        public static System.UIntPtr Log2(System.UIntPtr value) => throw null;
        public static System.UIntPtr Max(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MaxMagnitude(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MaxMagnitudeNumber(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MaxNumber(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MaxValue { get => throw null; }
        static System.UIntPtr System.Numerics.IMinMaxValue<System.UIntPtr>.MaxValue { get => throw null; }
        public static System.UIntPtr Min(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MinMagnitude(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MinMagnitudeNumber(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MinNumber(System.UIntPtr x, System.UIntPtr y) => throw null;
        public static System.UIntPtr MinValue { get => throw null; }
        static System.UIntPtr System.Numerics.IMinMaxValue<System.UIntPtr>.MinValue { get => throw null; }
        static System.UIntPtr System.Numerics.IMultiplicativeIdentity<System.UIntPtr, System.UIntPtr>.MultiplicativeIdentity { get => throw null; }
        static System.UIntPtr System.Numerics.INumberBase<System.UIntPtr>.One { get => throw null; }
        public static System.UIntPtr Parse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider) => throw null;
        public static System.UIntPtr Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static System.UIntPtr Parse(string s) => throw null;
        public static System.UIntPtr Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.UIntPtr Parse(string s, System.Globalization.NumberStyles style) => throw null;
        public static System.UIntPtr Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static System.UIntPtr PopCount(System.UIntPtr value) => throw null;
        static int System.Numerics.INumberBase<System.UIntPtr>.Radix { get => throw null; }
        public static System.UIntPtr RotateLeft(System.UIntPtr value, int rotateAmount) => throw null;
        public static System.UIntPtr RotateRight(System.UIntPtr value, int rotateAmount) => throw null;
        public static int Sign(System.UIntPtr value) => throw null;
        public static int Size { get => throw null; }
        public static System.UIntPtr Subtract(System.UIntPtr pointer, int offset) => throw null;
        unsafe public void* ToPointer() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public System.UInt32 ToUInt32() => throw null;
        public System.UInt64 ToUInt64() => throw null;
        public static System.UIntPtr TrailingZeroCount(System.UIntPtr value) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertFromChecked<TOther>(TOther value, out System.UIntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertFromSaturating<TOther>(TOther value, out System.UIntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertFromTruncating<TOther>(TOther value, out System.UIntPtr result) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertToChecked<TOther>(System.UIntPtr value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertToSaturating<TOther>(System.UIntPtr value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UIntPtr>.TryConvertToTruncating<TOther>(System.UIntPtr value, out TOther result) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format = default(System.ReadOnlySpan<System.Char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.IFormatProvider provider, out System.UIntPtr result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UIntPtr result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> s, out System.UIntPtr result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, out System.UIntPtr result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UIntPtr result) => throw null;
        public static bool TryParse(string s, out System.UIntPtr result) => throw null;
        public static bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UIntPtr value) => throw null;
        public static bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out System.UIntPtr value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UIntPtr>.TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UIntPtr>.TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
        // Stub generator skipped constructor 
        unsafe public UIntPtr(void* value) => throw null;
        public UIntPtr(System.UInt32 value) => throw null;
        public UIntPtr(System.UInt64 value) => throw null;
        public static System.UIntPtr Zero;
        static System.UIntPtr System.Numerics.INumberBase<System.UIntPtr>.Zero { get => throw null; }
        static System.UIntPtr System.Numerics.IBitwiseOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator ^(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IMultiplyOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator checked *(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IAdditionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator checked +(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IIncrementOperators<System.UIntPtr>.operator checked ++(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.IUnaryNegationOperators<System.UIntPtr, System.UIntPtr>.operator checked -(System.UIntPtr value) => throw null;
        static System.UIntPtr System.Numerics.ISubtractionOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator checked -(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IDecrementOperators<System.UIntPtr>.operator checked --(System.UIntPtr value) => throw null;
        public static explicit operator System.UInt32(System.UIntPtr value) => throw null;
        public static explicit operator System.UInt64(System.UIntPtr value) => throw null;
        unsafe public static explicit operator void*(System.UIntPtr value) => throw null;
        unsafe public static explicit operator System.UIntPtr(void* value) => throw null;
        public static explicit operator System.UIntPtr(System.UInt32 value) => throw null;
        public static explicit operator System.UIntPtr(System.UInt64 value) => throw null;
        static System.UIntPtr System.Numerics.IBitwiseOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator |(System.UIntPtr left, System.UIntPtr right) => throw null;
        static System.UIntPtr System.Numerics.IBitwiseOperators<System.UIntPtr, System.UIntPtr, System.UIntPtr>.operator ~(System.UIntPtr value) => throw null;
    }

    public class UnauthorizedAccessException : System.SystemException
    {
        public UnauthorizedAccessException() => throw null;
        protected UnauthorizedAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public UnauthorizedAccessException(string message) => throw null;
        public UnauthorizedAccessException(string message, System.Exception inner) => throw null;
    }

    public class UnhandledExceptionEventArgs : System.EventArgs
    {
        public object ExceptionObject { get => throw null; }
        public bool IsTerminating { get => throw null; }
        public UnhandledExceptionEventArgs(object exception, bool isTerminating) => throw null;
    }

    public delegate void UnhandledExceptionEventHandler(object sender, System.UnhandledExceptionEventArgs e);

    public class Uri : System.Runtime.Serialization.ISerializable
    {
        public static bool operator !=(System.Uri uri1, System.Uri uri2) => throw null;
        public static bool operator ==(System.Uri uri1, System.Uri uri2) => throw null;
        public string AbsolutePath { get => throw null; }
        public string AbsoluteUri { get => throw null; }
        public string Authority { get => throw null; }
        protected virtual void Canonicalize() => throw null;
        public static System.UriHostNameType CheckHostName(string name) => throw null;
        public static bool CheckSchemeName(string schemeName) => throw null;
        protected virtual void CheckSecurity() => throw null;
        public static int Compare(System.Uri uri1, System.Uri uri2, System.UriComponents partsToCompare, System.UriFormat compareFormat, System.StringComparison comparisonType) => throw null;
        public string DnsSafeHost { get => throw null; }
        public override bool Equals(object comparand) => throw null;
        protected virtual void Escape() => throw null;
        public static string EscapeDataString(string stringToEscape) => throw null;
        protected static string EscapeString(string str) => throw null;
        public static string EscapeUriString(string stringToEscape) => throw null;
        public string Fragment { get => throw null; }
        public static int FromHex(System.Char digit) => throw null;
        public string GetComponents(System.UriComponents components, System.UriFormat format) => throw null;
        public override int GetHashCode() => throw null;
        public string GetLeftPart(System.UriPartial part) => throw null;
        protected void GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public static string HexEscape(System.Char character) => throw null;
        public static System.Char HexUnescape(string pattern, ref int index) => throw null;
        public string Host { get => throw null; }
        public System.UriHostNameType HostNameType { get => throw null; }
        public string IdnHost { get => throw null; }
        public bool IsAbsoluteUri { get => throw null; }
        protected virtual bool IsBadFileSystemCharacter(System.Char character) => throw null;
        public bool IsBaseOf(System.Uri uri) => throw null;
        public bool IsDefaultPort { get => throw null; }
        protected static bool IsExcludedCharacter(System.Char character) => throw null;
        public bool IsFile { get => throw null; }
        public static bool IsHexDigit(System.Char character) => throw null;
        public static bool IsHexEncoding(string pattern, int index) => throw null;
        public bool IsLoopback { get => throw null; }
        protected virtual bool IsReservedCharacter(System.Char character) => throw null;
        public bool IsUnc { get => throw null; }
        public bool IsWellFormedOriginalString() => throw null;
        public static bool IsWellFormedUriString(string uriString, System.UriKind uriKind) => throw null;
        public string LocalPath { get => throw null; }
        public string MakeRelative(System.Uri toUri) => throw null;
        public System.Uri MakeRelativeUri(System.Uri uri) => throw null;
        public string OriginalString { get => throw null; }
        protected virtual void Parse() => throw null;
        public string PathAndQuery { get => throw null; }
        public int Port { get => throw null; }
        public string Query { get => throw null; }
        public string Scheme { get => throw null; }
        public static string SchemeDelimiter;
        public string[] Segments { get => throw null; }
        public override string ToString() => throw null;
        public static bool TryCreate(System.Uri baseUri, System.Uri relativeUri, out System.Uri result) => throw null;
        public static bool TryCreate(System.Uri baseUri, string relativeUri, out System.Uri result) => throw null;
        public static bool TryCreate(string uriString, System.UriCreationOptions creationOptions, out System.Uri result) => throw null;
        public static bool TryCreate(string uriString, System.UriKind uriKind, out System.Uri result) => throw null;
        protected virtual string Unescape(string path) => throw null;
        public static string UnescapeDataString(string stringToUnescape) => throw null;
        protected Uri(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public Uri(System.Uri baseUri, System.Uri relativeUri) => throw null;
        public Uri(System.Uri baseUri, string relativeUri) => throw null;
        public Uri(System.Uri baseUri, string relativeUri, bool dontEscape) => throw null;
        public Uri(string uriString) => throw null;
        public Uri(string uriString, System.UriCreationOptions creationOptions) => throw null;
        public Uri(string uriString, System.UriKind uriKind) => throw null;
        public Uri(string uriString, bool dontEscape) => throw null;
        public static string UriSchemeFile;
        public static string UriSchemeFtp;
        public static string UriSchemeFtps;
        public static string UriSchemeGopher;
        public static string UriSchemeHttp;
        public static string UriSchemeHttps;
        public static string UriSchemeMailto;
        public static string UriSchemeNetPipe;
        public static string UriSchemeNetTcp;
        public static string UriSchemeNews;
        public static string UriSchemeNntp;
        public static string UriSchemeSftp;
        public static string UriSchemeSsh;
        public static string UriSchemeTelnet;
        public static string UriSchemeWs;
        public static string UriSchemeWss;
        public bool UserEscaped { get => throw null; }
        public string UserInfo { get => throw null; }
    }

    public class UriBuilder
    {
        public override bool Equals(object rparam) => throw null;
        public string Fragment { get => throw null; set => throw null; }
        public override int GetHashCode() => throw null;
        public string Host { get => throw null; set => throw null; }
        public string Password { get => throw null; set => throw null; }
        public string Path { get => throw null; set => throw null; }
        public int Port { get => throw null; set => throw null; }
        public string Query { get => throw null; set => throw null; }
        public string Scheme { get => throw null; set => throw null; }
        public override string ToString() => throw null;
        public System.Uri Uri { get => throw null; }
        public UriBuilder() => throw null;
        public UriBuilder(System.Uri uri) => throw null;
        public UriBuilder(string uri) => throw null;
        public UriBuilder(string schemeName, string hostName) => throw null;
        public UriBuilder(string scheme, string host, int portNumber) => throw null;
        public UriBuilder(string scheme, string host, int port, string pathValue) => throw null;
        public UriBuilder(string scheme, string host, int port, string path, string extraValue) => throw null;
        public string UserName { get => throw null; set => throw null; }
    }

    [System.Flags]
    public enum UriComponents : int
    {
        AbsoluteUri = 127,
        Fragment = 64,
        Host = 4,
        HostAndPort = 132,
        HttpRequestUrl = 61,
        KeepDelimiter = 1073741824,
        NormalizedHost = 256,
        Path = 16,
        PathAndQuery = 48,
        Port = 8,
        Query = 32,
        Scheme = 1,
        SchemeAndServer = 13,
        SerializationInfoString = -2147483648,
        StrongAuthority = 134,
        StrongPort = 128,
        UserInfo = 2,
    }

    public struct UriCreationOptions
    {
        public bool DangerousDisablePathAndQueryCanonicalization { get => throw null; set => throw null; }
        // Stub generator skipped constructor 
    }

    public enum UriFormat : int
    {
        SafeUnescaped = 3,
        Unescaped = 2,
        UriEscaped = 1,
    }

    public class UriFormatException : System.FormatException, System.Runtime.Serialization.ISerializable
    {
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public UriFormatException() => throw null;
        protected UriFormatException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public UriFormatException(string textString) => throw null;
        public UriFormatException(string textString, System.Exception e) => throw null;
    }

    public enum UriHostNameType : int
    {
        Basic = 1,
        Dns = 2,
        IPv4 = 3,
        IPv6 = 4,
        Unknown = 0,
    }

    public enum UriKind : int
    {
        Absolute = 1,
        Relative = 2,
        RelativeOrAbsolute = 0,
    }

    public abstract class UriParser
    {
        protected virtual string GetComponents(System.Uri uri, System.UriComponents components, System.UriFormat format) => throw null;
        protected virtual void InitializeAndValidate(System.Uri uri, out System.UriFormatException parsingError) => throw null;
        protected virtual bool IsBaseOf(System.Uri baseUri, System.Uri relativeUri) => throw null;
        public static bool IsKnownScheme(string schemeName) => throw null;
        protected virtual bool IsWellFormedOriginalString(System.Uri uri) => throw null;
        protected virtual System.UriParser OnNewUri() => throw null;
        protected virtual void OnRegister(string schemeName, int defaultPort) => throw null;
        public static void Register(System.UriParser uriParser, string schemeName, int defaultPort) => throw null;
        protected virtual string Resolve(System.Uri baseUri, System.Uri relativeUri, out System.UriFormatException parsingError) => throw null;
        protected UriParser() => throw null;
    }

    public enum UriPartial : int
    {
        Authority = 1,
        Path = 2,
        Query = 3,
        Scheme = 0,
    }

    public struct ValueTuple : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<System.ValueTuple>, System.IEquatable<System.ValueTuple>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo(System.ValueTuple other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public static System.ValueTuple Create() => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8) Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7) Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public static (T1, T2, T3, T4, T5, T6) Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public static (T1, T2, T3, T4, T5) Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public static (T1, T2, T3, T4) Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public static (T1, T2, T3) Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) => throw null;
        public static (T1, T2) Create<T1, T2>(T1 item1, T2 item2) => throw null;
        public static System.ValueTuple<T1> Create<T1>(T1 item1) => throw null;
        public bool Equals(System.ValueTuple other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
    }

    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.Runtime.CompilerServices.ITuple where TRest : struct
    {
        public int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public TRest Rest;
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) => throw null;
    }

    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2, T3, T4, T5, T6, T7)>, System.IEquatable<(T1, T2, T3, T4, T5, T6, T7)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5, T6, T7) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2, T3, T4, T5, T6, T7) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
    }

    public struct ValueTuple<T1, T2, T3, T4, T5, T6> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2, T3, T4, T5, T6)>, System.IEquatable<(T1, T2, T3, T4, T5, T6)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5, T6) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2, T3, T4, T5, T6) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
    }

    public struct ValueTuple<T1, T2, T3, T4, T5> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2, T3, T4, T5)>, System.IEquatable<(T1, T2, T3, T4, T5)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2, T3, T4, T5) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
    }

    public struct ValueTuple<T1, T2, T3, T4> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2, T3, T4)>, System.IEquatable<(T1, T2, T3, T4)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2, T3, T4) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
    }

    public struct ValueTuple<T1, T2, T3> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2, T3)>, System.IEquatable<(T1, T2, T3)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2, T3) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2, T3 item3) => throw null;
    }

    public struct ValueTuple<T1, T2> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<(T1, T2)>, System.IEquatable<(T1, T2)>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2) other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals((T1, T2) other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        public T2 Item2;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1, T2 item2) => throw null;
    }

    public struct ValueTuple<T1> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable, System.IComparable<System.ValueTuple<T1>>, System.IEquatable<System.ValueTuple<T1>>, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo(System.ValueTuple<T1> other) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public bool Equals(System.ValueTuple<T1> other) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public T1 Item1;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
        // Stub generator skipped constructor 
        public ValueTuple(T1 item1) => throw null;
    }

    public abstract class ValueType
    {
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public override string ToString() => throw null;
        protected ValueType() => throw null;
    }

    public class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version>, System.IEquatable<System.Version>, System.IFormattable, System.ISpanFormattable
    {
        public static bool operator !=(System.Version v1, System.Version v2) => throw null;
        public static bool operator <(System.Version v1, System.Version v2) => throw null;
        public static bool operator <=(System.Version v1, System.Version v2) => throw null;
        public static bool operator ==(System.Version v1, System.Version v2) => throw null;
        public static bool operator >(System.Version v1, System.Version v2) => throw null;
        public static bool operator >=(System.Version v1, System.Version v2) => throw null;
        public int Build { get => throw null; }
        public object Clone() => throw null;
        public int CompareTo(System.Version value) => throw null;
        public int CompareTo(object version) => throw null;
        public bool Equals(System.Version obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public int Major { get => throw null; }
        public System.Int16 MajorRevision { get => throw null; }
        public int Minor { get => throw null; }
        public System.Int16 MinorRevision { get => throw null; }
        public static System.Version Parse(System.ReadOnlySpan<System.Char> input) => throw null;
        public static System.Version Parse(string input) => throw null;
        public int Revision { get => throw null; }
        public override string ToString() => throw null;
        public string ToString(int fieldCount) => throw null;
        string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, int fieldCount, out int charsWritten) => throw null;
        public bool TryFormat(System.Span<System.Char> destination, out int charsWritten) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider) => throw null;
        public static bool TryParse(System.ReadOnlySpan<System.Char> input, out System.Version result) => throw null;
        public static bool TryParse(string input, out System.Version result) => throw null;
        public Version() => throw null;
        public Version(int major, int minor) => throw null;
        public Version(int major, int minor, int build) => throw null;
        public Version(int major, int minor, int build, int revision) => throw null;
        public Version(string version) => throw null;
    }

    public struct Void
    {
    }

    public class WeakReference : System.Runtime.Serialization.ISerializable
    {
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public virtual bool IsAlive { get => throw null; }
        public virtual object Target { get => throw null; set => throw null; }
        public virtual bool TrackResurrection { get => throw null; }
        protected WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public WeakReference(object target) => throw null;
        public WeakReference(object target, bool trackResurrection) => throw null;
        // ERR: Stub generator didn't handle member: ~WeakReference
    }

    public class WeakReference<T> : System.Runtime.Serialization.ISerializable where T : class
    {
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public void SetTarget(T target) => throw null;
        public bool TryGetTarget(out T target) => throw null;
        public WeakReference(T target) => throw null;
        public WeakReference(T target, bool trackResurrection) => throw null;
        // ERR: Stub generator didn't handle member: ~WeakReference
    }

    namespace Buffers
    {
        public abstract class ArrayPool<T>
        {
            protected ArrayPool() => throw null;
            public static System.Buffers.ArrayPool<T> Create() => throw null;
            public static System.Buffers.ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket) => throw null;
            public abstract T[] Rent(int minimumLength);
            public abstract void Return(T[] array, bool clearArray = default(bool));
            public static System.Buffers.ArrayPool<T> Shared { get => throw null; }
        }

        public interface IMemoryOwner<T> : System.IDisposable
        {
            System.Memory<T> Memory { get; }
        }

        public interface IPinnable
        {
            System.Buffers.MemoryHandle Pin(int elementIndex);
            void Unpin();
        }

        public struct MemoryHandle : System.IDisposable
        {
            public void Dispose() => throw null;
            // Stub generator skipped constructor 
            unsafe public MemoryHandle(void* pointer, System.Runtime.InteropServices.GCHandle handle = default(System.Runtime.InteropServices.GCHandle), System.Buffers.IPinnable pinnable = default(System.Buffers.IPinnable)) => throw null;
            unsafe public void* Pointer { get => throw null; }
        }

        public abstract class MemoryManager<T> : System.Buffers.IMemoryOwner<T>, System.Buffers.IPinnable, System.IDisposable
        {
            protected System.Memory<T> CreateMemory(int length) => throw null;
            protected System.Memory<T> CreateMemory(int start, int length) => throw null;
            void System.IDisposable.Dispose() => throw null;
            protected abstract void Dispose(bool disposing);
            public abstract System.Span<T> GetSpan();
            public virtual System.Memory<T> Memory { get => throw null; }
            protected MemoryManager() => throw null;
            public abstract System.Buffers.MemoryHandle Pin(int elementIndex = default(int));
            protected internal virtual bool TryGetArray(out System.ArraySegment<T> segment) => throw null;
            public abstract void Unpin();
        }

        public enum OperationStatus : int
        {
            DestinationTooSmall = 1,
            Done = 0,
            InvalidData = 3,
            NeedMoreData = 2,
        }

        public delegate void ReadOnlySpanAction<T, TArg>(System.ReadOnlySpan<T> span, TArg arg);

        public delegate void SpanAction<T, TArg>(System.Span<T> span, TArg arg);

        namespace Text
        {
            public static class Base64
            {
                public static System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<System.Byte> utf8, System.Span<System.Byte> bytes, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = default(bool)) => throw null;
                public static System.Buffers.OperationStatus DecodeFromUtf8InPlace(System.Span<System.Byte> buffer, out int bytesWritten) => throw null;
                public static System.Buffers.OperationStatus EncodeToUtf8(System.ReadOnlySpan<System.Byte> bytes, System.Span<System.Byte> utf8, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = default(bool)) => throw null;
                public static System.Buffers.OperationStatus EncodeToUtf8InPlace(System.Span<System.Byte> buffer, int dataLength, out int bytesWritten) => throw null;
                public static int GetMaxDecodedFromUtf8Length(int length) => throw null;
                public static int GetMaxEncodedToUtf8Length(int length) => throw null;
            }

        }
    }
    namespace CodeDom
    {
        namespace Compiler
        {
            public class GeneratedCodeAttribute : System.Attribute
            {
                public GeneratedCodeAttribute(string tool, string version) => throw null;
                public string Tool { get => throw null; }
                public string Version { get => throw null; }
            }

            public class IndentedTextWriter : System.IO.TextWriter
            {
                public override void Close() => throw null;
                public const string DefaultTabString = default;
                public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
                public override System.Text.Encoding Encoding { get => throw null; }
                public override void Flush() => throw null;
                public override System.Threading.Tasks.Task FlushAsync() => throw null;
                public int Indent { get => throw null; set => throw null; }
                public IndentedTextWriter(System.IO.TextWriter writer) => throw null;
                public IndentedTextWriter(System.IO.TextWriter writer, string tabString) => throw null;
                public System.IO.TextWriter InnerWriter { get => throw null; }
                public override string NewLine { get => throw null; set => throw null; }
                protected virtual void OutputTabs() => throw null;
                protected virtual System.Threading.Tasks.Task OutputTabsAsync() => throw null;
                public override void Write(System.Char[] buffer) => throw null;
                public override void Write(System.Char[] buffer, int index, int count) => throw null;
                public override void Write(bool value) => throw null;
                public override void Write(System.Char value) => throw null;
                public override void Write(double value) => throw null;
                public override void Write(float value) => throw null;
                public override void Write(int value) => throw null;
                public override void Write(System.Int64 value) => throw null;
                public override void Write(object value) => throw null;
                public override void Write(string s) => throw null;
                public override void Write(string format, object arg0) => throw null;
                public override void Write(string format, object arg0, object arg1) => throw null;
                public override void Write(string format, params object[] arg) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, int index, int count) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.Char value) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
                public override void WriteLine() => throw null;
                public override void WriteLine(System.Char[] buffer) => throw null;
                public override void WriteLine(System.Char[] buffer, int index, int count) => throw null;
                public override void WriteLine(bool value) => throw null;
                public override void WriteLine(System.Char value) => throw null;
                public override void WriteLine(double value) => throw null;
                public override void WriteLine(float value) => throw null;
                public override void WriteLine(int value) => throw null;
                public override void WriteLine(System.Int64 value) => throw null;
                public override void WriteLine(object value) => throw null;
                public override void WriteLine(string s) => throw null;
                public override void WriteLine(string format, object arg0) => throw null;
                public override void WriteLine(string format, object arg0, object arg1) => throw null;
                public override void WriteLine(string format, params object[] arg) => throw null;
                public override void WriteLine(System.UInt32 value) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync() => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, int index, int count) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.Char value) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
                public void WriteLineNoTabs(string s) => throw null;
                public System.Threading.Tasks.Task WriteLineNoTabsAsync(string s) => throw null;
            }

        }
    }
    namespace Collections
    {
        public class ArrayList : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.ICloneable
        {
            public static System.Collections.ArrayList Adapter(System.Collections.IList list) => throw null;
            public virtual int Add(object value) => throw null;
            public virtual void AddRange(System.Collections.ICollection c) => throw null;
            public ArrayList() => throw null;
            public ArrayList(System.Collections.ICollection c) => throw null;
            public ArrayList(int capacity) => throw null;
            public virtual int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer) => throw null;
            public virtual int BinarySearch(object value) => throw null;
            public virtual int BinarySearch(object value, System.Collections.IComparer comparer) => throw null;
            public virtual int Capacity { get => throw null; set => throw null; }
            public virtual void Clear() => throw null;
            public virtual object Clone() => throw null;
            public virtual bool Contains(object item) => throw null;
            public virtual void CopyTo(System.Array array) => throw null;
            public virtual void CopyTo(System.Array array, int arrayIndex) => throw null;
            public virtual void CopyTo(int index, System.Array array, int arrayIndex, int count) => throw null;
            public virtual int Count { get => throw null; }
            public static System.Collections.ArrayList FixedSize(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList FixedSize(System.Collections.IList list) => throw null;
            public virtual System.Collections.IEnumerator GetEnumerator() => throw null;
            public virtual System.Collections.IEnumerator GetEnumerator(int index, int count) => throw null;
            public virtual System.Collections.ArrayList GetRange(int index, int count) => throw null;
            public virtual int IndexOf(object value) => throw null;
            public virtual int IndexOf(object value, int startIndex) => throw null;
            public virtual int IndexOf(object value, int startIndex, int count) => throw null;
            public virtual void Insert(int index, object value) => throw null;
            public virtual void InsertRange(int index, System.Collections.ICollection c) => throw null;
            public virtual bool IsFixedSize { get => throw null; }
            public virtual bool IsReadOnly { get => throw null; }
            public virtual bool IsSynchronized { get => throw null; }
            public virtual object this[int index] { get => throw null; set => throw null; }
            public virtual int LastIndexOf(object value) => throw null;
            public virtual int LastIndexOf(object value, int startIndex) => throw null;
            public virtual int LastIndexOf(object value, int startIndex, int count) => throw null;
            public static System.Collections.ArrayList ReadOnly(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList ReadOnly(System.Collections.IList list) => throw null;
            public virtual void Remove(object obj) => throw null;
            public virtual void RemoveAt(int index) => throw null;
            public virtual void RemoveRange(int index, int count) => throw null;
            public static System.Collections.ArrayList Repeat(object value, int count) => throw null;
            public virtual void Reverse() => throw null;
            public virtual void Reverse(int index, int count) => throw null;
            public virtual void SetRange(int index, System.Collections.ICollection c) => throw null;
            public virtual void Sort() => throw null;
            public virtual void Sort(System.Collections.IComparer comparer) => throw null;
            public virtual void Sort(int index, int count, System.Collections.IComparer comparer) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public static System.Collections.ArrayList Synchronized(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList Synchronized(System.Collections.IList list) => throw null;
            public virtual object[] ToArray() => throw null;
            public virtual System.Array ToArray(System.Type type) => throw null;
            public virtual void TrimToSize() => throw null;
        }

        public class Comparer : System.Collections.IComparer, System.Runtime.Serialization.ISerializable
        {
            public int Compare(object a, object b) => throw null;
            public Comparer(System.Globalization.CultureInfo culture) => throw null;
            public static System.Collections.Comparer Default;
            public static System.Collections.Comparer DefaultInvariant;
            public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        }

        public struct DictionaryEntry
        {
            public void Deconstruct(out object key, out object value) => throw null;
            // Stub generator skipped constructor 
            public DictionaryEntry(object key, object value) => throw null;
            public object Key { get => throw null; set => throw null; }
            public object Value { get => throw null; set => throw null; }
        }

        public class Hashtable : System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.ICloneable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public virtual void Add(object key, object value) => throw null;
            public virtual void Clear() => throw null;
            public virtual object Clone() => throw null;
            public virtual bool Contains(object key) => throw null;
            public virtual bool ContainsKey(object key) => throw null;
            public virtual bool ContainsValue(object value) => throw null;
            public virtual void CopyTo(System.Array array, int arrayIndex) => throw null;
            public virtual int Count { get => throw null; }
            protected System.Collections.IEqualityComparer EqualityComparer { get => throw null; }
            public virtual System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            protected virtual int GetHash(object key) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public Hashtable() => throw null;
            public Hashtable(System.Collections.IDictionary d) => throw null;
            public Hashtable(System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            protected Hashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public Hashtable(int capacity) => throw null;
            public Hashtable(int capacity, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(int capacity, float loadFactor) => throw null;
            public Hashtable(int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public virtual bool IsFixedSize { get => throw null; }
            public virtual bool IsReadOnly { get => throw null; }
            public virtual bool IsSynchronized { get => throw null; }
            public virtual object this[object key] { get => throw null; set => throw null; }
            protected virtual bool KeyEquals(object item, object key) => throw null;
            public virtual System.Collections.ICollection Keys { get => throw null; }
            public virtual void OnDeserialization(object sender) => throw null;
            public virtual void Remove(object key) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public static System.Collections.Hashtable Synchronized(System.Collections.Hashtable table) => throw null;
            public virtual System.Collections.ICollection Values { get => throw null; }
            protected System.Collections.IComparer comparer { get => throw null; set => throw null; }
            protected System.Collections.IHashCodeProvider hcp { get => throw null; set => throw null; }
        }

        public interface ICollection : System.Collections.IEnumerable
        {
            void CopyTo(System.Array array, int index);
            int Count { get; }
            bool IsSynchronized { get; }
            object SyncRoot { get; }
        }

        public interface IComparer
        {
            int Compare(object x, object y);
        }

        public interface IDictionary : System.Collections.ICollection, System.Collections.IEnumerable
        {
            void Add(object key, object value);
            void Clear();
            bool Contains(object key);
            System.Collections.IDictionaryEnumerator GetEnumerator();
            bool IsFixedSize { get; }
            bool IsReadOnly { get; }
            object this[object key] { get; set; }
            System.Collections.ICollection Keys { get; }
            void Remove(object key);
            System.Collections.ICollection Values { get; }
        }

        public interface IDictionaryEnumerator : System.Collections.IEnumerator
        {
            System.Collections.DictionaryEntry Entry { get; }
            object Key { get; }
            object Value { get; }
        }

        public interface IEnumerable
        {
            System.Collections.IEnumerator GetEnumerator();
        }

        public interface IEnumerator
        {
            object Current { get; }
            bool MoveNext();
            void Reset();
        }

        public interface IEqualityComparer
        {
            bool Equals(object x, object y);
            int GetHashCode(object obj);
        }

        public interface IHashCodeProvider
        {
            int GetHashCode(object obj);
        }

        public interface IList : System.Collections.ICollection, System.Collections.IEnumerable
        {
            int Add(object value);
            void Clear();
            bool Contains(object value);
            int IndexOf(object value);
            void Insert(int index, object value);
            bool IsFixedSize { get; }
            bool IsReadOnly { get; }
            object this[int index] { get; set; }
            void Remove(object value);
            void RemoveAt(int index);
        }

        public interface IStructuralComparable
        {
            int CompareTo(object other, System.Collections.IComparer comparer);
        }

        public interface IStructuralEquatable
        {
            bool Equals(object other, System.Collections.IEqualityComparer comparer);
            int GetHashCode(System.Collections.IEqualityComparer comparer);
        }

        namespace Generic
        {
            public interface IAsyncEnumerable<T>
            {
                System.Collections.Generic.IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
            }

            public interface IAsyncEnumerator<T> : System.IAsyncDisposable
            {
                T Current { get; }
                System.Threading.Tasks.ValueTask<bool> MoveNextAsync();
            }

            public interface ICollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                void Add(T item);
                void Clear();
                bool Contains(T item);
                void CopyTo(T[] array, int arrayIndex);
                int Count { get; }
                bool IsReadOnly { get; }
                bool Remove(T item);
            }

            public interface IComparer<T>
            {
                int Compare(T x, T y);
            }

            public interface IDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                void Add(TKey key, TValue value);
                bool ContainsKey(TKey key);
                TValue this[TKey key] { get; set; }
                System.Collections.Generic.ICollection<TKey> Keys { get; }
                bool Remove(TKey key);
                bool TryGetValue(TKey key, out TValue value);
                System.Collections.Generic.ICollection<TValue> Values { get; }
            }

            public interface IEnumerable<T> : System.Collections.IEnumerable
            {
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
            }

            public interface IEnumerator<T> : System.Collections.IEnumerator, System.IDisposable
            {
                T Current { get; }
            }

            public interface IEqualityComparer<T>
            {
                bool Equals(T x, T y);
                int GetHashCode(T obj);
            }

            public interface IList<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int IndexOf(T item);
                void Insert(int index, T item);
                T this[int index] { get; set; }
                void RemoveAt(int index);
            }

            public interface IReadOnlyCollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int Count { get; }
            }

            public interface IReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                bool ContainsKey(TKey key);
                TValue this[TKey key] { get; }
                System.Collections.Generic.IEnumerable<TKey> Keys { get; }
                bool TryGetValue(TKey key, out TValue value);
                System.Collections.Generic.IEnumerable<TValue> Values { get; }
            }

            public interface IReadOnlyList<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.IEnumerable
            {
                T this[int index] { get; }
            }

            public interface IReadOnlySet<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.IEnumerable
            {
                bool Contains(T item);
                bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
                bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
            }

            public interface ISet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                bool Add(T item);
                void ExceptWith(System.Collections.Generic.IEnumerable<T> other);
                void IntersectWith(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
                bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
                void SymmetricExceptWith(System.Collections.Generic.IEnumerable<T> other);
                void UnionWith(System.Collections.Generic.IEnumerable<T> other);
            }

            public class KeyNotFoundException : System.SystemException
            {
                public KeyNotFoundException() => throw null;
                protected KeyNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public KeyNotFoundException(string message) => throw null;
                public KeyNotFoundException(string message, System.Exception innerException) => throw null;
            }

            public static class KeyValuePair
            {
                public static System.Collections.Generic.KeyValuePair<TKey, TValue> Create<TKey, TValue>(TKey key, TValue value) => throw null;
            }

            public struct KeyValuePair<TKey, TValue>
            {
                public void Deconstruct(out TKey key, out TValue value) => throw null;
                public TKey Key { get => throw null; }
                // Stub generator skipped constructor 
                public KeyValuePair(TKey key, TValue value) => throw null;
                public override string ToString() => throw null;
                public TValue Value { get => throw null; }
            }

        }
        namespace ObjectModel
        {
            public class Collection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
            {
                public void Add(T item) => throw null;
                int System.Collections.IList.Add(object value) => throw null;
                public void Clear() => throw null;
                protected virtual void ClearItems() => throw null;
                public Collection() => throw null;
                public Collection(System.Collections.Generic.IList<T> list) => throw null;
                public bool Contains(T item) => throw null;
                bool System.Collections.IList.Contains(object value) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                public void CopyTo(T[] array, int index) => throw null;
                public int Count { get => throw null; }
                public System.Collections.Generic.IEnumerator<T> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public int IndexOf(T item) => throw null;
                int System.Collections.IList.IndexOf(object value) => throw null;
                public void Insert(int index, T item) => throw null;
                void System.Collections.IList.Insert(int index, object value) => throw null;
                protected virtual void InsertItem(int index, T item) => throw null;
                bool System.Collections.IList.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
                bool System.Collections.IList.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                public T this[int index] { get => throw null; set => throw null; }
                object System.Collections.IList.this[int index] { get => throw null; set => throw null; }
                protected System.Collections.Generic.IList<T> Items { get => throw null; }
                public bool Remove(T item) => throw null;
                void System.Collections.IList.Remove(object value) => throw null;
                public void RemoveAt(int index) => throw null;
                protected virtual void RemoveItem(int index) => throw null;
                protected virtual void SetItem(int index, T item) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
            }

            public class ReadOnlyCollection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
            {
                void System.Collections.Generic.ICollection<T>.Add(T value) => throw null;
                int System.Collections.IList.Add(object value) => throw null;
                void System.Collections.Generic.ICollection<T>.Clear() => throw null;
                void System.Collections.IList.Clear() => throw null;
                public bool Contains(T value) => throw null;
                bool System.Collections.IList.Contains(object value) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                public void CopyTo(T[] array, int index) => throw null;
                public int Count { get => throw null; }
                public System.Collections.Generic.IEnumerator<T> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public int IndexOf(T value) => throw null;
                int System.Collections.IList.IndexOf(object value) => throw null;
                void System.Collections.Generic.IList<T>.Insert(int index, T value) => throw null;
                void System.Collections.IList.Insert(int index, object value) => throw null;
                bool System.Collections.IList.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
                bool System.Collections.IList.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                public T this[int index] { get => throw null; }
                T System.Collections.Generic.IList<T>.this[int index] { get => throw null; set => throw null; }
                object System.Collections.IList.this[int index] { get => throw null; set => throw null; }
                protected System.Collections.Generic.IList<T> Items { get => throw null; }
                public ReadOnlyCollection(System.Collections.Generic.IList<T> list) => throw null;
                bool System.Collections.Generic.ICollection<T>.Remove(T value) => throw null;
                void System.Collections.IList.Remove(object value) => throw null;
                void System.Collections.Generic.IList<T>.RemoveAt(int index) => throw null;
                void System.Collections.IList.RemoveAt(int index) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
            }

            public class ReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
            {
                public class KeyCollection : System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IEnumerable<TKey>, System.Collections.Generic.IReadOnlyCollection<TKey>, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    void System.Collections.Generic.ICollection<TKey>.Add(TKey item) => throw null;
                    void System.Collections.Generic.ICollection<TKey>.Clear() => throw null;
                    bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item) => throw null;
                    void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                    public void CopyTo(TKey[] array, int arrayIndex) => throw null;
                    public int Count { get => throw null; }
                    public System.Collections.Generic.IEnumerator<TKey> GetEnumerator() => throw null;
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                    bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get => throw null; }
                    bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                    bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item) => throw null;
                    object System.Collections.ICollection.SyncRoot { get => throw null; }
                }


                public class ValueCollection : System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IEnumerable<TValue>, System.Collections.Generic.IReadOnlyCollection<TValue>, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    void System.Collections.Generic.ICollection<TValue>.Add(TValue item) => throw null;
                    void System.Collections.Generic.ICollection<TValue>.Clear() => throw null;
                    bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item) => throw null;
                    void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                    public void CopyTo(TValue[] array, int arrayIndex) => throw null;
                    public int Count { get => throw null; }
                    public System.Collections.Generic.IEnumerator<TValue> GetEnumerator() => throw null;
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                    bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get => throw null; }
                    bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                    bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item) => throw null;
                    object System.Collections.ICollection.SyncRoot { get => throw null; }
                }


                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                void System.Collections.Generic.IDictionary<TKey, TValue>.Add(TKey key, TValue value) => throw null;
                void System.Collections.IDictionary.Add(object key, object value) => throw null;
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Clear() => throw null;
                void System.Collections.IDictionary.Clear() => throw null;
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                bool System.Collections.IDictionary.Contains(object key) => throw null;
                public bool ContainsKey(TKey key) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) => throw null;
                public int Count { get => throw null; }
                protected System.Collections.Generic.IDictionary<TKey, TValue> Dictionary { get => throw null; }
                public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() => throw null;
                System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                bool System.Collections.IDictionary.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.IsReadOnly { get => throw null; }
                bool System.Collections.IDictionary.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                public TValue this[TKey key] { get => throw null; }
                TValue System.Collections.Generic.IDictionary<TKey, TValue>.this[TKey key] { get => throw null; set => throw null; }
                object System.Collections.IDictionary.this[object key] { get => throw null; set => throw null; }
                public System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.KeyCollection Keys { get => throw null; }
                System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey, TValue>.Keys { get => throw null; }
                System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Keys { get => throw null; }
                System.Collections.ICollection System.Collections.IDictionary.Keys { get => throw null; }
                public ReadOnlyDictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary) => throw null;
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                bool System.Collections.Generic.IDictionary<TKey, TValue>.Remove(TKey key) => throw null;
                void System.Collections.IDictionary.Remove(object key) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
                public bool TryGetValue(TKey key, out TValue value) => throw null;
                public System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.ValueCollection Values { get => throw null; }
                System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey, TValue>.Values { get => throw null; }
                System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Values { get => throw null; }
                System.Collections.ICollection System.Collections.IDictionary.Values { get => throw null; }
            }

        }
    }
    namespace ComponentModel
    {
        public class DefaultValueAttribute : System.Attribute
        {
            public DefaultValueAttribute(System.Type type, string value) => throw null;
            public DefaultValueAttribute(bool value) => throw null;
            public DefaultValueAttribute(System.Byte value) => throw null;
            public DefaultValueAttribute(System.Char value) => throw null;
            public DefaultValueAttribute(double value) => throw null;
            public DefaultValueAttribute(float value) => throw null;
            public DefaultValueAttribute(int value) => throw null;
            public DefaultValueAttribute(System.Int64 value) => throw null;
            public DefaultValueAttribute(object value) => throw null;
            public DefaultValueAttribute(System.SByte value) => throw null;
            public DefaultValueAttribute(System.Int16 value) => throw null;
            public DefaultValueAttribute(string value) => throw null;
            public DefaultValueAttribute(System.UInt32 value) => throw null;
            public DefaultValueAttribute(System.UInt64 value) => throw null;
            public DefaultValueAttribute(System.UInt16 value) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            protected void SetValue(object value) => throw null;
            public virtual object Value { get => throw null; }
        }

        public class EditorBrowsableAttribute : System.Attribute
        {
            public EditorBrowsableAttribute() => throw null;
            public EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState state) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public System.ComponentModel.EditorBrowsableState State { get => throw null; }
        }

        public enum EditorBrowsableState : int
        {
            Advanced = 2,
            Always = 0,
            Never = 1,
        }

    }
    namespace Configuration
    {
        namespace Assemblies
        {
            public enum AssemblyHashAlgorithm : int
            {
                MD5 = 32771,
                None = 0,
                SHA1 = 32772,
                SHA256 = 32780,
                SHA384 = 32781,
                SHA512 = 32782,
            }

            public enum AssemblyVersionCompatibility : int
            {
                SameDomain = 3,
                SameMachine = 1,
                SameProcess = 2,
            }

        }
    }
    namespace Diagnostics
    {
        public class ConditionalAttribute : System.Attribute
        {
            public string ConditionString { get => throw null; }
            public ConditionalAttribute(string conditionString) => throw null;
        }

        public static class Debug
        {
            public struct AssertInterpolatedStringHandler
            {
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                // Stub generator skipped constructor 
                public AssertInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool shouldAppend) => throw null;
            }


            public struct WriteIfInterpolatedStringHandler
            {
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                // Stub generator skipped constructor 
                public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool shouldAppend) => throw null;
            }


            public static void Assert(bool condition) => throw null;
            public static void Assert(bool condition, ref System.Diagnostics.Debug.AssertInterpolatedStringHandler message) => throw null;
            public static void Assert(bool condition, ref System.Diagnostics.Debug.AssertInterpolatedStringHandler message, ref System.Diagnostics.Debug.AssertInterpolatedStringHandler detailMessage) => throw null;
            public static void Assert(bool condition, string message) => throw null;
            public static void Assert(bool condition, string message, string detailMessage) => throw null;
            public static void Assert(bool condition, string message, string detailMessageFormat, params object[] args) => throw null;
            public static bool AutoFlush { get => throw null; set => throw null; }
            public static void Close() => throw null;
            public static void Fail(string message) => throw null;
            public static void Fail(string message, string detailMessage) => throw null;
            public static void Flush() => throw null;
            public static void Indent() => throw null;
            public static int IndentLevel { get => throw null; set => throw null; }
            public static int IndentSize { get => throw null; set => throw null; }
            public static void Print(string message) => throw null;
            public static void Print(string format, params object[] args) => throw null;
            public static void Unindent() => throw null;
            public static void Write(object value) => throw null;
            public static void Write(object value, string category) => throw null;
            public static void Write(string message) => throw null;
            public static void Write(string message, string category) => throw null;
            public static void WriteIf(bool condition, object value) => throw null;
            public static void WriteIf(bool condition, object value, string category) => throw null;
            public static void WriteIf(bool condition, ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message) => throw null;
            public static void WriteIf(bool condition, ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message, string category) => throw null;
            public static void WriteIf(bool condition, string message) => throw null;
            public static void WriteIf(bool condition, string message, string category) => throw null;
            public static void WriteLine(object value) => throw null;
            public static void WriteLine(object value, string category) => throw null;
            public static void WriteLine(string message) => throw null;
            public static void WriteLine(string format, params object[] args) => throw null;
            public static void WriteLine(string message, string category) => throw null;
            public static void WriteLineIf(bool condition, object value) => throw null;
            public static void WriteLineIf(bool condition, object value, string category) => throw null;
            public static void WriteLineIf(bool condition, ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message) => throw null;
            public static void WriteLineIf(bool condition, ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message, string category) => throw null;
            public static void WriteLineIf(bool condition, string message) => throw null;
            public static void WriteLineIf(bool condition, string message, string category) => throw null;
        }

        public class DebuggableAttribute : System.Attribute
        {
            [System.Flags]
            public enum DebuggingModes : int
            {
                Default = 1,
                DisableOptimizations = 256,
                EnableEditAndContinue = 4,
                IgnoreSymbolStoreSequencePoints = 2,
                None = 0,
            }


            public DebuggableAttribute(System.Diagnostics.DebuggableAttribute.DebuggingModes modes) => throw null;
            public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled) => throw null;
            public System.Diagnostics.DebuggableAttribute.DebuggingModes DebuggingFlags { get => throw null; }
            public bool IsJITOptimizerDisabled { get => throw null; }
            public bool IsJITTrackingEnabled { get => throw null; }
        }

        public static class Debugger
        {
            public static void Break() => throw null;
            public static string DefaultCategory;
            public static bool IsAttached { get => throw null; }
            public static bool IsLogging() => throw null;
            public static bool Launch() => throw null;
            public static void Log(int level, string category, string message) => throw null;
            public static void NotifyOfCrossThreadDependency() => throw null;
        }

        public class DebuggerBrowsableAttribute : System.Attribute
        {
            public DebuggerBrowsableAttribute(System.Diagnostics.DebuggerBrowsableState state) => throw null;
            public System.Diagnostics.DebuggerBrowsableState State { get => throw null; }
        }

        public enum DebuggerBrowsableState : int
        {
            Collapsed = 2,
            Never = 0,
            RootHidden = 3,
        }

        public class DebuggerDisplayAttribute : System.Attribute
        {
            public DebuggerDisplayAttribute(string value) => throw null;
            public string Name { get => throw null; set => throw null; }
            public System.Type Target { get => throw null; set => throw null; }
            public string TargetTypeName { get => throw null; set => throw null; }
            public string Type { get => throw null; set => throw null; }
            public string Value { get => throw null; }
        }

        public class DebuggerHiddenAttribute : System.Attribute
        {
            public DebuggerHiddenAttribute() => throw null;
        }

        public class DebuggerNonUserCodeAttribute : System.Attribute
        {
            public DebuggerNonUserCodeAttribute() => throw null;
        }

        public class DebuggerStepThroughAttribute : System.Attribute
        {
            public DebuggerStepThroughAttribute() => throw null;
        }

        public class DebuggerStepperBoundaryAttribute : System.Attribute
        {
            public DebuggerStepperBoundaryAttribute() => throw null;
        }

        public class DebuggerTypeProxyAttribute : System.Attribute
        {
            public DebuggerTypeProxyAttribute(System.Type type) => throw null;
            public DebuggerTypeProxyAttribute(string typeName) => throw null;
            public string ProxyTypeName { get => throw null; }
            public System.Type Target { get => throw null; set => throw null; }
            public string TargetTypeName { get => throw null; set => throw null; }
        }

        public class DebuggerVisualizerAttribute : System.Attribute
        {
            public DebuggerVisualizerAttribute(System.Type visualizer) => throw null;
            public DebuggerVisualizerAttribute(System.Type visualizer, System.Type visualizerObjectSource) => throw null;
            public DebuggerVisualizerAttribute(System.Type visualizer, string visualizerObjectSourceTypeName) => throw null;
            public DebuggerVisualizerAttribute(string visualizerTypeName) => throw null;
            public DebuggerVisualizerAttribute(string visualizerTypeName, System.Type visualizerObjectSource) => throw null;
            public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName) => throw null;
            public string Description { get => throw null; set => throw null; }
            public System.Type Target { get => throw null; set => throw null; }
            public string TargetTypeName { get => throw null; set => throw null; }
            public string VisualizerObjectSourceTypeName { get => throw null; }
            public string VisualizerTypeName { get => throw null; }
        }

        public class StackTraceHiddenAttribute : System.Attribute
        {
            public StackTraceHiddenAttribute() => throw null;
        }

        public class Stopwatch
        {
            public System.TimeSpan Elapsed { get => throw null; }
            public System.Int64 ElapsedMilliseconds { get => throw null; }
            public System.Int64 ElapsedTicks { get => throw null; }
            public static System.Int64 Frequency;
            public static System.TimeSpan GetElapsedTime(System.Int64 startingTimestamp) => throw null;
            public static System.TimeSpan GetElapsedTime(System.Int64 startingTimestamp, System.Int64 endingTimestamp) => throw null;
            public static System.Int64 GetTimestamp() => throw null;
            public static bool IsHighResolution;
            public bool IsRunning { get => throw null; }
            public void Reset() => throw null;
            public void Restart() => throw null;
            public void Start() => throw null;
            public static System.Diagnostics.Stopwatch StartNew() => throw null;
            public void Stop() => throw null;
            public Stopwatch() => throw null;
        }

        public class UnreachableException : System.Exception
        {
            public UnreachableException() => throw null;
            public UnreachableException(string message) => throw null;
            public UnreachableException(string message, System.Exception innerException) => throw null;
        }

        namespace CodeAnalysis
        {
            public partial class AllowNullAttribute : System.Attribute
            {
                public AllowNullAttribute() => throw null;
            }

            public class ConstantExpectedAttribute : System.Attribute
            {
                public ConstantExpectedAttribute() => throw null;
                public object Max { get => throw null; set => throw null; }
                public object Min { get => throw null; set => throw null; }
            }

            public class DisallowNullAttribute : System.Attribute
            {
                public DisallowNullAttribute() => throw null;
            }

            public class DoesNotReturnAttribute : System.Attribute
            {
                public DoesNotReturnAttribute() => throw null;
            }

            public partial class DoesNotReturnIfAttribute : System.Attribute
            {
                public DoesNotReturnIfAttribute(bool parameterValue) => throw null;
                public bool ParameterValue { get => throw null; }
            }

            public class DynamicDependencyAttribute : System.Attribute
            {
                public string AssemblyName { get => throw null; }
                public string Condition { get => throw null; set => throw null; }
                public DynamicDependencyAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes, System.Type type) => throw null;
                public DynamicDependencyAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName) => throw null;
                public DynamicDependencyAttribute(string memberSignature) => throw null;
                public DynamicDependencyAttribute(string memberSignature, System.Type type) => throw null;
                public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName) => throw null;
                public string MemberSignature { get => throw null; }
                public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes MemberTypes { get => throw null; }
                public System.Type Type { get => throw null; }
                public string TypeName { get => throw null; }
            }

            [System.Flags]
            public enum DynamicallyAccessedMemberTypes : int
            {
                All = -1,
                Interfaces = 8192,
                NonPublicConstructors = 4,
                NonPublicEvents = 4096,
                NonPublicFields = 64,
                NonPublicMethods = 16,
                NonPublicNestedTypes = 256,
                NonPublicProperties = 1024,
                None = 0,
                PublicConstructors = 3,
                PublicEvents = 2048,
                PublicFields = 32,
                PublicMethods = 8,
                PublicNestedTypes = 128,
                PublicParameterlessConstructor = 1,
                PublicProperties = 512,
            }

            public class DynamicallyAccessedMembersAttribute : System.Attribute
            {
                public DynamicallyAccessedMembersAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes) => throw null;
                public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes MemberTypes { get => throw null; }
            }

            public class ExcludeFromCodeCoverageAttribute : System.Attribute
            {
                public ExcludeFromCodeCoverageAttribute() => throw null;
                public string Justification { get => throw null; set => throw null; }
            }

            public partial class MaybeNullAttribute : System.Attribute
            {
                public MaybeNullAttribute() => throw null;
            }

            public class MaybeNullWhenAttribute : System.Attribute
            {
                public MaybeNullWhenAttribute(bool returnValue) => throw null;
                public bool ReturnValue { get => throw null; }
            }

            public class MemberNotNullAttribute : System.Attribute
            {
                public MemberNotNullAttribute(params string[] members) => throw null;
                public MemberNotNullAttribute(string member) => throw null;
                public string[] Members { get => throw null; }
            }

            public class MemberNotNullWhenAttribute : System.Attribute
            {
                public MemberNotNullWhenAttribute(bool returnValue, params string[] members) => throw null;
                public MemberNotNullWhenAttribute(bool returnValue, string member) => throw null;
                public string[] Members { get => throw null; }
                public bool ReturnValue { get => throw null; }
            }

            public partial class NotNullAttribute : System.Attribute
            {
                public NotNullAttribute() => throw null;
            }

            public class NotNullIfNotNullAttribute : System.Attribute
            {
                public NotNullIfNotNullAttribute(string parameterName) => throw null;
                public string ParameterName { get => throw null; }
            }

            public partial class NotNullWhenAttribute : System.Attribute
            {
                public NotNullWhenAttribute(bool returnValue) => throw null;
                public bool ReturnValue { get => throw null; }
            }

            public class RequiresAssemblyFilesAttribute : System.Attribute
            {
                public string Message { get => throw null; }
                public RequiresAssemblyFilesAttribute() => throw null;
                public RequiresAssemblyFilesAttribute(string message) => throw null;
                public string Url { get => throw null; set => throw null; }
            }

            public class RequiresDynamicCodeAttribute : System.Attribute
            {
                public string Message { get => throw null; }
                public RequiresDynamicCodeAttribute(string message) => throw null;
                public string Url { get => throw null; set => throw null; }
            }

            public class RequiresUnreferencedCodeAttribute : System.Attribute
            {
                public string Message { get => throw null; }
                public RequiresUnreferencedCodeAttribute(string message) => throw null;
                public string Url { get => throw null; set => throw null; }
            }

            public class SetsRequiredMembersAttribute : System.Attribute
            {
                public SetsRequiredMembersAttribute() => throw null;
            }

            public class StringSyntaxAttribute : System.Attribute
            {
                public object[] Arguments { get => throw null; }
                public const string CompositeFormat = default;
                public const string DateOnlyFormat = default;
                public const string DateTimeFormat = default;
                public const string EnumFormat = default;
                public const string GuidFormat = default;
                public const string Json = default;
                public const string NumericFormat = default;
                public const string Regex = default;
                public StringSyntaxAttribute(string syntax) => throw null;
                public StringSyntaxAttribute(string syntax, params object[] arguments) => throw null;
                public string Syntax { get => throw null; }
                public const string TimeOnlyFormat = default;
                public const string TimeSpanFormat = default;
                public const string Uri = default;
                public const string Xml = default;
            }

            public class SuppressMessageAttribute : System.Attribute
            {
                public string Category { get => throw null; }
                public string CheckId { get => throw null; }
                public string Justification { get => throw null; set => throw null; }
                public string MessageId { get => throw null; set => throw null; }
                public string Scope { get => throw null; set => throw null; }
                public SuppressMessageAttribute(string category, string checkId) => throw null;
                public string Target { get => throw null; set => throw null; }
            }

            public class UnconditionalSuppressMessageAttribute : System.Attribute
            {
                public string Category { get => throw null; }
                public string CheckId { get => throw null; }
                public string Justification { get => throw null; set => throw null; }
                public string MessageId { get => throw null; set => throw null; }
                public string Scope { get => throw null; set => throw null; }
                public string Target { get => throw null; set => throw null; }
                public UnconditionalSuppressMessageAttribute(string category, string checkId) => throw null;
            }

            public class UnscopedRefAttribute : System.Attribute
            {
                public UnscopedRefAttribute() => throw null;
            }

        }
    }
    namespace Globalization
    {
        public abstract class Calendar : System.ICloneable
        {
            public virtual System.DateTime AddDays(System.DateTime time, int days) => throw null;
            public virtual System.DateTime AddHours(System.DateTime time, int hours) => throw null;
            public virtual System.DateTime AddMilliseconds(System.DateTime time, double milliseconds) => throw null;
            public virtual System.DateTime AddMinutes(System.DateTime time, int minutes) => throw null;
            public abstract System.DateTime AddMonths(System.DateTime time, int months);
            public virtual System.DateTime AddSeconds(System.DateTime time, int seconds) => throw null;
            public virtual System.DateTime AddWeeks(System.DateTime time, int weeks) => throw null;
            public abstract System.DateTime AddYears(System.DateTime time, int years);
            public virtual System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            protected Calendar() => throw null;
            public virtual object Clone() => throw null;
            public const int CurrentEra = default;
            protected virtual int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public abstract int[] Eras { get; }
            public abstract int GetDayOfMonth(System.DateTime time);
            public abstract System.DayOfWeek GetDayOfWeek(System.DateTime time);
            public abstract int GetDayOfYear(System.DateTime time);
            public virtual int GetDaysInMonth(int year, int month) => throw null;
            public abstract int GetDaysInMonth(int year, int month, int era);
            public virtual int GetDaysInYear(int year) => throw null;
            public abstract int GetDaysInYear(int year, int era);
            public abstract int GetEra(System.DateTime time);
            public virtual int GetHour(System.DateTime time) => throw null;
            public virtual int GetLeapMonth(int year) => throw null;
            public virtual int GetLeapMonth(int year, int era) => throw null;
            public virtual double GetMilliseconds(System.DateTime time) => throw null;
            public virtual int GetMinute(System.DateTime time) => throw null;
            public abstract int GetMonth(System.DateTime time);
            public virtual int GetMonthsInYear(int year) => throw null;
            public abstract int GetMonthsInYear(int year, int era);
            public virtual int GetSecond(System.DateTime time) => throw null;
            public virtual int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public abstract int GetYear(System.DateTime time);
            public virtual bool IsLeapDay(int year, int month, int day) => throw null;
            public abstract bool IsLeapDay(int year, int month, int day, int era);
            public virtual bool IsLeapMonth(int year, int month) => throw null;
            public abstract bool IsLeapMonth(int year, int month, int era);
            public virtual bool IsLeapYear(int year) => throw null;
            public abstract bool IsLeapYear(int year, int era);
            public bool IsReadOnly { get => throw null; }
            public virtual System.DateTime MaxSupportedDateTime { get => throw null; }
            public virtual System.DateTime MinSupportedDateTime { get => throw null; }
            public static System.Globalization.Calendar ReadOnly(System.Globalization.Calendar calendar) => throw null;
            public virtual System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) => throw null;
            public abstract System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            public virtual int ToFourDigitYear(int year) => throw null;
            public virtual int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public enum CalendarAlgorithmType : int
        {
            LunarCalendar = 2,
            LunisolarCalendar = 3,
            SolarCalendar = 1,
            Unknown = 0,
        }

        public enum CalendarWeekRule : int
        {
            FirstDay = 0,
            FirstFourDayWeek = 2,
            FirstFullWeek = 1,
        }

        public static class CharUnicodeInfo
        {
            public static int GetDecimalDigitValue(System.Char ch) => throw null;
            public static int GetDecimalDigitValue(string s, int index) => throw null;
            public static int GetDigitValue(System.Char ch) => throw null;
            public static int GetDigitValue(string s, int index) => throw null;
            public static double GetNumericValue(System.Char ch) => throw null;
            public static double GetNumericValue(string s, int index) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(System.Char ch) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(int codePoint) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index) => throw null;
        }

        public class ChineseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            public const int ChineseEra = default;
            public ChineseLunisolarCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }

        public class CompareInfo : System.Runtime.Serialization.IDeserializationCallback
        {
            public int Compare(System.ReadOnlySpan<System.Char> string1, System.ReadOnlySpan<System.Char> string2, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2) => throw null;
            public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options) => throw null;
            public int Compare(string string1, int offset1, string string2, int offset2) => throw null;
            public int Compare(string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options) => throw null;
            public int Compare(string string1, string string2) => throw null;
            public int Compare(string string1, string string2, System.Globalization.CompareOptions options) => throw null;
            public override bool Equals(object value) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(int culture) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(int culture, System.Reflection.Assembly assembly) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(string name) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(string name, System.Reflection.Assembly assembly) => throw null;
            public override int GetHashCode() => throw null;
            public int GetHashCode(System.ReadOnlySpan<System.Char> source, System.Globalization.CompareOptions options) => throw null;
            public int GetHashCode(string source, System.Globalization.CompareOptions options) => throw null;
            public int GetSortKey(System.ReadOnlySpan<System.Char> source, System.Span<System.Byte> destination, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public System.Globalization.SortKey GetSortKey(string source) => throw null;
            public System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options) => throw null;
            public int GetSortKeyLength(System.ReadOnlySpan<System.Char> source, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> value, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public int IndexOf(System.ReadOnlySpan<System.Char> source, System.Text.Rune value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(string source, System.Char value) => throw null;
            public int IndexOf(string source, System.Char value, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, System.Char value, int startIndex) => throw null;
            public int IndexOf(string source, System.Char value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, System.Char value, int startIndex, int count) => throw null;
            public int IndexOf(string source, System.Char value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value) => throw null;
            public int IndexOf(string source, string value, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value, int startIndex) => throw null;
            public int IndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value, int startIndex, int count) => throw null;
            public int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public bool IsPrefix(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> prefix, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public bool IsPrefix(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> prefix, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public bool IsPrefix(string source, string prefix) => throw null;
            public bool IsPrefix(string source, string prefix, System.Globalization.CompareOptions options) => throw null;
            public static bool IsSortable(System.ReadOnlySpan<System.Char> text) => throw null;
            public static bool IsSortable(System.Text.Rune value) => throw null;
            public static bool IsSortable(System.Char ch) => throw null;
            public static bool IsSortable(string text) => throw null;
            public bool IsSuffix(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> suffix, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public bool IsSuffix(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> suffix, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public bool IsSuffix(string source, string suffix) => throw null;
            public bool IsSuffix(string source, string suffix, System.Globalization.CompareOptions options) => throw null;
            public int LCID { get => throw null; }
            public int LastIndexOf(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int LastIndexOf(System.ReadOnlySpan<System.Char> source, System.ReadOnlySpan<System.Char> value, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public int LastIndexOf(System.ReadOnlySpan<System.Char> source, System.Text.Rune value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int LastIndexOf(string source, System.Char value) => throw null;
            public int LastIndexOf(string source, System.Char value, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, System.Char value, int startIndex) => throw null;
            public int LastIndexOf(string source, System.Char value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, System.Char value, int startIndex, int count) => throw null;
            public int LastIndexOf(string source, System.Char value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value) => throw null;
            public int LastIndexOf(string source, string value, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value, int startIndex) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, int count) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public string Name { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public override string ToString() => throw null;
            public System.Globalization.SortVersion Version { get => throw null; }
        }

        [System.Flags]
        public enum CompareOptions : int
        {
            IgnoreCase = 1,
            IgnoreKanaType = 8,
            IgnoreNonSpace = 2,
            IgnoreSymbols = 4,
            IgnoreWidth = 16,
            None = 0,
            Ordinal = 1073741824,
            OrdinalIgnoreCase = 268435456,
            StringSort = 536870912,
        }

        public class CultureInfo : System.ICloneable, System.IFormatProvider
        {
            public virtual System.Globalization.Calendar Calendar { get => throw null; }
            public void ClearCachedData() => throw null;
            public virtual object Clone() => throw null;
            public virtual System.Globalization.CompareInfo CompareInfo { get => throw null; }
            public static System.Globalization.CultureInfo CreateSpecificCulture(string name) => throw null;
            public CultureInfo(int culture) => throw null;
            public CultureInfo(int culture, bool useUserOverride) => throw null;
            public CultureInfo(string name) => throw null;
            public CultureInfo(string name, bool useUserOverride) => throw null;
            public System.Globalization.CultureTypes CultureTypes { get => throw null; }
            public static System.Globalization.CultureInfo CurrentCulture { get => throw null; set => throw null; }
            public static System.Globalization.CultureInfo CurrentUICulture { get => throw null; set => throw null; }
            public virtual System.Globalization.DateTimeFormatInfo DateTimeFormat { get => throw null; set => throw null; }
            public static System.Globalization.CultureInfo DefaultThreadCurrentCulture { get => throw null; set => throw null; }
            public static System.Globalization.CultureInfo DefaultThreadCurrentUICulture { get => throw null; set => throw null; }
            public virtual string DisplayName { get => throw null; }
            public virtual string EnglishName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public System.Globalization.CultureInfo GetConsoleFallbackUICulture() => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(int culture) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name, bool predefinedOnly) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name, string altName) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag(string name) => throw null;
            public static System.Globalization.CultureInfo[] GetCultures(System.Globalization.CultureTypes types) => throw null;
            public virtual object GetFormat(System.Type formatType) => throw null;
            public override int GetHashCode() => throw null;
            public string IetfLanguageTag { get => throw null; }
            public static System.Globalization.CultureInfo InstalledUICulture { get => throw null; }
            public static System.Globalization.CultureInfo InvariantCulture { get => throw null; }
            public virtual bool IsNeutralCulture { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public virtual int KeyboardLayoutId { get => throw null; }
            public virtual int LCID { get => throw null; }
            public virtual string Name { get => throw null; }
            public virtual string NativeName { get => throw null; }
            public virtual System.Globalization.NumberFormatInfo NumberFormat { get => throw null; set => throw null; }
            public virtual System.Globalization.Calendar[] OptionalCalendars { get => throw null; }
            public virtual System.Globalization.CultureInfo Parent { get => throw null; }
            public static System.Globalization.CultureInfo ReadOnly(System.Globalization.CultureInfo ci) => throw null;
            public virtual System.Globalization.TextInfo TextInfo { get => throw null; }
            public virtual string ThreeLetterISOLanguageName { get => throw null; }
            public virtual string ThreeLetterWindowsLanguageName { get => throw null; }
            public override string ToString() => throw null;
            public virtual string TwoLetterISOLanguageName { get => throw null; }
            public bool UseUserOverride { get => throw null; }
        }

        public class CultureNotFoundException : System.ArgumentException
        {
            public CultureNotFoundException() => throw null;
            protected CultureNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public CultureNotFoundException(string message) => throw null;
            public CultureNotFoundException(string message, System.Exception innerException) => throw null;
            public CultureNotFoundException(string message, int invalidCultureId, System.Exception innerException) => throw null;
            public CultureNotFoundException(string paramName, int invalidCultureId, string message) => throw null;
            public CultureNotFoundException(string paramName, string message) => throw null;
            public CultureNotFoundException(string message, string invalidCultureName, System.Exception innerException) => throw null;
            public CultureNotFoundException(string paramName, string invalidCultureName, string message) => throw null;
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual int? InvalidCultureId { get => throw null; }
            public virtual string InvalidCultureName { get => throw null; }
            public override string Message { get => throw null; }
        }

        [System.Flags]
        public enum CultureTypes : int
        {
            AllCultures = 7,
            FrameworkCultures = 64,
            InstalledWin32Cultures = 4,
            NeutralCultures = 1,
            ReplacementCultures = 16,
            SpecificCultures = 2,
            UserCustomCulture = 8,
            WindowsOnlyCultures = 32,
        }

        public class DateTimeFormatInfo : System.ICloneable, System.IFormatProvider
        {
            public string AMDesignator { get => throw null; set => throw null; }
            public string[] AbbreviatedDayNames { get => throw null; set => throw null; }
            public string[] AbbreviatedMonthGenitiveNames { get => throw null; set => throw null; }
            public string[] AbbreviatedMonthNames { get => throw null; set => throw null; }
            public System.Globalization.Calendar Calendar { get => throw null; set => throw null; }
            public System.Globalization.CalendarWeekRule CalendarWeekRule { get => throw null; set => throw null; }
            public object Clone() => throw null;
            public static System.Globalization.DateTimeFormatInfo CurrentInfo { get => throw null; }
            public string DateSeparator { get => throw null; set => throw null; }
            public DateTimeFormatInfo() => throw null;
            public string[] DayNames { get => throw null; set => throw null; }
            public System.DayOfWeek FirstDayOfWeek { get => throw null; set => throw null; }
            public string FullDateTimePattern { get => throw null; set => throw null; }
            public string GetAbbreviatedDayName(System.DayOfWeek dayofweek) => throw null;
            public string GetAbbreviatedEraName(int era) => throw null;
            public string GetAbbreviatedMonthName(int month) => throw null;
            public string[] GetAllDateTimePatterns() => throw null;
            public string[] GetAllDateTimePatterns(System.Char format) => throw null;
            public string GetDayName(System.DayOfWeek dayofweek) => throw null;
            public int GetEra(string eraName) => throw null;
            public string GetEraName(int era) => throw null;
            public object GetFormat(System.Type formatType) => throw null;
            public static System.Globalization.DateTimeFormatInfo GetInstance(System.IFormatProvider provider) => throw null;
            public string GetMonthName(int month) => throw null;
            public string GetShortestDayName(System.DayOfWeek dayOfWeek) => throw null;
            public static System.Globalization.DateTimeFormatInfo InvariantInfo { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public string LongDatePattern { get => throw null; set => throw null; }
            public string LongTimePattern { get => throw null; set => throw null; }
            public string MonthDayPattern { get => throw null; set => throw null; }
            public string[] MonthGenitiveNames { get => throw null; set => throw null; }
            public string[] MonthNames { get => throw null; set => throw null; }
            public string NativeCalendarName { get => throw null; }
            public string PMDesignator { get => throw null; set => throw null; }
            public string RFC1123Pattern { get => throw null; }
            public static System.Globalization.DateTimeFormatInfo ReadOnly(System.Globalization.DateTimeFormatInfo dtfi) => throw null;
            public void SetAllDateTimePatterns(string[] patterns, System.Char format) => throw null;
            public string ShortDatePattern { get => throw null; set => throw null; }
            public string ShortTimePattern { get => throw null; set => throw null; }
            public string[] ShortestDayNames { get => throw null; set => throw null; }
            public string SortableDateTimePattern { get => throw null; }
            public string TimeSeparator { get => throw null; set => throw null; }
            public string UniversalSortableDateTimePattern { get => throw null; }
            public string YearMonthPattern { get => throw null; set => throw null; }
        }

        [System.Flags]
        public enum DateTimeStyles : int
        {
            AdjustToUniversal = 16,
            AllowInnerWhite = 4,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowWhiteSpaces = 7,
            AssumeLocal = 32,
            AssumeUniversal = 64,
            NoCurrentDateDefault = 8,
            None = 0,
            RoundtripKind = 128,
        }

        public class DaylightTime
        {
            public DaylightTime(System.DateTime start, System.DateTime end, System.TimeSpan delta) => throw null;
            public System.TimeSpan Delta { get => throw null; }
            public System.DateTime End { get => throw null; }
            public System.DateTime Start { get => throw null; }
        }

        public enum DigitShapes : int
        {
            Context = 0,
            NativeNational = 2,
            None = 1,
        }

        public abstract class EastAsianLunisolarCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            internal EastAsianLunisolarCalendar() => throw null;
            public int GetCelestialStem(int sexagenaryYear) => throw null;
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public virtual int GetSexagenaryYear(System.DateTime time) => throw null;
            public int GetTerrestrialBranch(int sexagenaryYear) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public static class GlobalizationExtensions
        {
            public static System.StringComparer GetStringComparer(this System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options) => throw null;
        }

        public class GregorianCalendar : System.Globalization.Calendar
        {
            public const int ADEra = default;
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public virtual System.Globalization.GregorianCalendarTypes CalendarType { get => throw null; set => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public GregorianCalendar() => throw null;
            public GregorianCalendar(System.Globalization.GregorianCalendarTypes type) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public enum GregorianCalendarTypes : int
        {
            Arabic = 10,
            Localized = 1,
            MiddleEastFrench = 9,
            TransliteratedEnglish = 11,
            TransliteratedFrench = 12,
            USEnglish = 2,
        }

        public class HebrewCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public HebrewCalendar() => throw null;
            public static int HebrewEra;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class HijriCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public int HijriAdjustment { get => throw null; set => throw null; }
            public HijriCalendar() => throw null;
            public static int HijriEra;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public static class ISOWeek
        {
            public static int GetWeekOfYear(System.DateTime date) => throw null;
            public static int GetWeeksInYear(int year) => throw null;
            public static int GetYear(System.DateTime date) => throw null;
            public static System.DateTime GetYearEnd(int year) => throw null;
            public static System.DateTime GetYearStart(int year) => throw null;
            public static System.DateTime ToDateTime(int year, int week, System.DayOfWeek dayOfWeek) => throw null;
        }

        public class IdnMapping
        {
            public bool AllowUnassigned { get => throw null; set => throw null; }
            public override bool Equals(object obj) => throw null;
            public string GetAscii(string unicode) => throw null;
            public string GetAscii(string unicode, int index) => throw null;
            public string GetAscii(string unicode, int index, int count) => throw null;
            public override int GetHashCode() => throw null;
            public string GetUnicode(string ascii) => throw null;
            public string GetUnicode(string ascii, int index) => throw null;
            public string GetUnicode(string ascii, int index, int count) => throw null;
            public IdnMapping() => throw null;
            public bool UseStd3AsciiRules { get => throw null; set => throw null; }
        }

        public class JapaneseCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public JapaneseCalendar() => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class JapaneseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public const int JapaneseEra = default;
            public JapaneseLunisolarCalendar() => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }

        public class JulianCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public JulianCalendar() => throw null;
            public static int JulianEra;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class KoreanCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public KoreanCalendar() => throw null;
            public const int KoreanEra = default;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class KoreanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public const int GregorianEra = default;
            public KoreanLunisolarCalendar() => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }

        public class NumberFormatInfo : System.ICloneable, System.IFormatProvider
        {
            public object Clone() => throw null;
            public int CurrencyDecimalDigits { get => throw null; set => throw null; }
            public string CurrencyDecimalSeparator { get => throw null; set => throw null; }
            public string CurrencyGroupSeparator { get => throw null; set => throw null; }
            public int[] CurrencyGroupSizes { get => throw null; set => throw null; }
            public int CurrencyNegativePattern { get => throw null; set => throw null; }
            public int CurrencyPositivePattern { get => throw null; set => throw null; }
            public string CurrencySymbol { get => throw null; set => throw null; }
            public static System.Globalization.NumberFormatInfo CurrentInfo { get => throw null; }
            public System.Globalization.DigitShapes DigitSubstitution { get => throw null; set => throw null; }
            public object GetFormat(System.Type formatType) => throw null;
            public static System.Globalization.NumberFormatInfo GetInstance(System.IFormatProvider formatProvider) => throw null;
            public static System.Globalization.NumberFormatInfo InvariantInfo { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public string NaNSymbol { get => throw null; set => throw null; }
            public string[] NativeDigits { get => throw null; set => throw null; }
            public string NegativeInfinitySymbol { get => throw null; set => throw null; }
            public string NegativeSign { get => throw null; set => throw null; }
            public int NumberDecimalDigits { get => throw null; set => throw null; }
            public string NumberDecimalSeparator { get => throw null; set => throw null; }
            public NumberFormatInfo() => throw null;
            public string NumberGroupSeparator { get => throw null; set => throw null; }
            public int[] NumberGroupSizes { get => throw null; set => throw null; }
            public int NumberNegativePattern { get => throw null; set => throw null; }
            public string PerMilleSymbol { get => throw null; set => throw null; }
            public int PercentDecimalDigits { get => throw null; set => throw null; }
            public string PercentDecimalSeparator { get => throw null; set => throw null; }
            public string PercentGroupSeparator { get => throw null; set => throw null; }
            public int[] PercentGroupSizes { get => throw null; set => throw null; }
            public int PercentNegativePattern { get => throw null; set => throw null; }
            public int PercentPositivePattern { get => throw null; set => throw null; }
            public string PercentSymbol { get => throw null; set => throw null; }
            public string PositiveInfinitySymbol { get => throw null; set => throw null; }
            public string PositiveSign { get => throw null; set => throw null; }
            public static System.Globalization.NumberFormatInfo ReadOnly(System.Globalization.NumberFormatInfo nfi) => throw null;
        }

        [System.Flags]
        public enum NumberStyles : int
        {
            AllowCurrencySymbol = 256,
            AllowDecimalPoint = 32,
            AllowExponent = 128,
            AllowHexSpecifier = 512,
            AllowLeadingSign = 4,
            AllowLeadingWhite = 1,
            AllowParentheses = 16,
            AllowThousands = 64,
            AllowTrailingSign = 8,
            AllowTrailingWhite = 2,
            Any = 511,
            Currency = 383,
            Float = 167,
            HexNumber = 515,
            Integer = 7,
            None = 0,
            Number = 111,
        }

        public class PersianCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public PersianCalendar() => throw null;
            public static int PersianEra;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class RegionInfo
        {
            public virtual string CurrencyEnglishName { get => throw null; }
            public virtual string CurrencyNativeName { get => throw null; }
            public virtual string CurrencySymbol { get => throw null; }
            public static System.Globalization.RegionInfo CurrentRegion { get => throw null; }
            public virtual string DisplayName { get => throw null; }
            public virtual string EnglishName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public virtual int GeoId { get => throw null; }
            public override int GetHashCode() => throw null;
            public virtual string ISOCurrencySymbol { get => throw null; }
            public virtual bool IsMetric { get => throw null; }
            public virtual string Name { get => throw null; }
            public virtual string NativeName { get => throw null; }
            public RegionInfo(int culture) => throw null;
            public RegionInfo(string name) => throw null;
            public virtual string ThreeLetterISORegionName { get => throw null; }
            public virtual string ThreeLetterWindowsRegionName { get => throw null; }
            public override string ToString() => throw null;
            public virtual string TwoLetterISORegionName { get => throw null; }
        }

        public class SortKey
        {
            public static int Compare(System.Globalization.SortKey sortkey1, System.Globalization.SortKey sortkey2) => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public System.Byte[] KeyData { get => throw null; }
            public string OriginalString { get => throw null; }
            public override string ToString() => throw null;
        }

        public class SortVersion : System.IEquatable<System.Globalization.SortVersion>
        {
            public static bool operator !=(System.Globalization.SortVersion left, System.Globalization.SortVersion right) => throw null;
            public static bool operator ==(System.Globalization.SortVersion left, System.Globalization.SortVersion right) => throw null;
            public bool Equals(System.Globalization.SortVersion other) => throw null;
            public override bool Equals(object obj) => throw null;
            public int FullVersion { get => throw null; }
            public override int GetHashCode() => throw null;
            public System.Guid SortId { get => throw null; }
            public SortVersion(int fullVersion, System.Guid sortId) => throw null;
        }

        public class StringInfo
        {
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public static string GetNextTextElement(string str) => throw null;
            public static string GetNextTextElement(string str, int index) => throw null;
            public static int GetNextTextElementLength(System.ReadOnlySpan<System.Char> str) => throw null;
            public static int GetNextTextElementLength(string str) => throw null;
            public static int GetNextTextElementLength(string str, int index) => throw null;
            public static System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str) => throw null;
            public static System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str, int index) => throw null;
            public int LengthInTextElements { get => throw null; }
            public static int[] ParseCombiningCharacters(string str) => throw null;
            public string String { get => throw null; set => throw null; }
            public StringInfo() => throw null;
            public StringInfo(string value) => throw null;
            public string SubstringByTextElements(int startingTextElement) => throw null;
            public string SubstringByTextElements(int startingTextElement, int lengthInTextElements) => throw null;
        }

        public class TaiwanCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public TaiwanCalendar() => throw null;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        public class TaiwanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public TaiwanLunisolarCalendar() => throw null;
        }

        public class TextElementEnumerator : System.Collections.IEnumerator
        {
            public object Current { get => throw null; }
            public int ElementIndex { get => throw null; }
            public string GetTextElement() => throw null;
            public bool MoveNext() => throw null;
            public void Reset() => throw null;
        }

        public class TextInfo : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback
        {
            public int ANSICodePage { get => throw null; }
            public object Clone() => throw null;
            public string CultureName { get => throw null; }
            public int EBCDICCodePage { get => throw null; }
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsReadOnly { get => throw null; }
            public bool IsRightToLeft { get => throw null; }
            public int LCID { get => throw null; }
            public string ListSeparator { get => throw null; set => throw null; }
            public int MacCodePage { get => throw null; }
            public int OEMCodePage { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public static System.Globalization.TextInfo ReadOnly(System.Globalization.TextInfo textInfo) => throw null;
            public System.Char ToLower(System.Char c) => throw null;
            public string ToLower(string str) => throw null;
            public override string ToString() => throw null;
            public string ToTitleCase(string str) => throw null;
            public System.Char ToUpper(System.Char c) => throw null;
            public string ToUpper(string str) => throw null;
        }

        public class ThaiBuddhistCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public ThaiBuddhistCalendar() => throw null;
            public const int ThaiBuddhistEra = default;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
        }

        [System.Flags]
        public enum TimeSpanStyles : int
        {
            AssumeNegative = 1,
            None = 0,
        }

        public class UmAlQuraCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set => throw null; }
            public UmAlQuraCalendar() => throw null;
            public const int UmAlQuraEra = default;
        }

        public enum UnicodeCategory : int
        {
            ClosePunctuation = 21,
            ConnectorPunctuation = 18,
            Control = 14,
            CurrencySymbol = 26,
            DashPunctuation = 19,
            DecimalDigitNumber = 8,
            EnclosingMark = 7,
            FinalQuotePunctuation = 23,
            Format = 15,
            InitialQuotePunctuation = 22,
            LetterNumber = 9,
            LineSeparator = 12,
            LowercaseLetter = 1,
            MathSymbol = 25,
            ModifierLetter = 3,
            ModifierSymbol = 27,
            NonSpacingMark = 5,
            OpenPunctuation = 20,
            OtherLetter = 4,
            OtherNotAssigned = 29,
            OtherNumber = 10,
            OtherPunctuation = 24,
            OtherSymbol = 28,
            ParagraphSeparator = 13,
            PrivateUse = 17,
            SpaceSeparator = 11,
            SpacingCombiningMark = 6,
            Surrogate = 16,
            TitlecaseLetter = 2,
            UppercaseLetter = 0,
        }

    }
    namespace IO
    {
        public class BinaryReader : System.IDisposable
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public BinaryReader(System.IO.Stream input) => throw null;
            public BinaryReader(System.IO.Stream input, System.Text.Encoding encoding) => throw null;
            public BinaryReader(System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen) => throw null;
            public virtual void Close() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            protected virtual void FillBuffer(int numBytes) => throw null;
            public virtual int PeekChar() => throw null;
            public virtual int Read() => throw null;
            public virtual int Read(System.Byte[] buffer, int index, int count) => throw null;
            public virtual int Read(System.Char[] buffer, int index, int count) => throw null;
            public virtual int Read(System.Span<System.Byte> buffer) => throw null;
            public virtual int Read(System.Span<System.Char> buffer) => throw null;
            public int Read7BitEncodedInt() => throw null;
            public System.Int64 Read7BitEncodedInt64() => throw null;
            public virtual bool ReadBoolean() => throw null;
            public virtual System.Byte ReadByte() => throw null;
            public virtual System.Byte[] ReadBytes(int count) => throw null;
            public virtual System.Char ReadChar() => throw null;
            public virtual System.Char[] ReadChars(int count) => throw null;
            public virtual System.Decimal ReadDecimal() => throw null;
            public virtual double ReadDouble() => throw null;
            public virtual System.Half ReadHalf() => throw null;
            public virtual System.Int16 ReadInt16() => throw null;
            public virtual int ReadInt32() => throw null;
            public virtual System.Int64 ReadInt64() => throw null;
            public virtual System.SByte ReadSByte() => throw null;
            public virtual float ReadSingle() => throw null;
            public virtual string ReadString() => throw null;
            public virtual System.UInt16 ReadUInt16() => throw null;
            public virtual System.UInt32 ReadUInt32() => throw null;
            public virtual System.UInt64 ReadUInt64() => throw null;
        }

        public class BinaryWriter : System.IAsyncDisposable, System.IDisposable
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            protected BinaryWriter() => throw null;
            public BinaryWriter(System.IO.Stream output) => throw null;
            public BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding) => throw null;
            public BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding, bool leaveOpen) => throw null;
            public virtual void Close() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public virtual void Flush() => throw null;
            public static System.IO.BinaryWriter Null;
            protected System.IO.Stream OutStream;
            public virtual System.Int64 Seek(int offset, System.IO.SeekOrigin origin) => throw null;
            public virtual void Write(System.Byte[] buffer) => throw null;
            public virtual void Write(System.Byte[] buffer, int index, int count) => throw null;
            public virtual void Write(System.Char[] chars) => throw null;
            public virtual void Write(System.Char[] chars, int index, int count) => throw null;
            public virtual void Write(System.Half value) => throw null;
            public virtual void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public virtual void Write(System.ReadOnlySpan<System.Char> chars) => throw null;
            public virtual void Write(bool value) => throw null;
            public virtual void Write(System.Byte value) => throw null;
            public virtual void Write(System.Char ch) => throw null;
            public virtual void Write(System.Decimal value) => throw null;
            public virtual void Write(double value) => throw null;
            public virtual void Write(float value) => throw null;
            public virtual void Write(int value) => throw null;
            public virtual void Write(System.Int64 value) => throw null;
            public virtual void Write(System.SByte value) => throw null;
            public virtual void Write(System.Int16 value) => throw null;
            public virtual void Write(string value) => throw null;
            public virtual void Write(System.UInt32 value) => throw null;
            public virtual void Write(System.UInt64 value) => throw null;
            public virtual void Write(System.UInt16 value) => throw null;
            public void Write7BitEncodedInt(int value) => throw null;
            public void Write7BitEncodedInt64(System.Int64 value) => throw null;
        }

        public class BufferedStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public int BufferSize { get => throw null; }
            public BufferedStream(System.IO.Stream stream) => throw null;
            public BufferedStream(System.IO.Stream stream, int bufferSize) => throw null;
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public override void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Int64 Length { get => throw null; }
            public override System.Int64 Position { get => throw null; set => throw null; }
            public override int Read(System.Byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<System.Byte> destination) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin origin) => throw null;
            public override void SetLength(System.Int64 value) => throw null;
            public System.IO.Stream UnderlyingStream { get => throw null; }
            public override void Write(System.Byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(System.Byte value) => throw null;
        }

        public static class Directory
        {
            public static System.IO.DirectoryInfo CreateDirectory(string path) => throw null;
            public static System.IO.DirectoryInfo CreateDirectory(string path, System.IO.UnixFileMode unixCreateMode) => throw null;
            public static System.IO.FileSystemInfo CreateSymbolicLink(string path, string pathToTarget) => throw null;
            public static System.IO.DirectoryInfo CreateTempSubdirectory(string prefix = default(string)) => throw null;
            public static void Delete(string path) => throw null;
            public static void Delete(string path, bool recursive) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.DateTime GetCreationTime(string path) => throw null;
            public static System.DateTime GetCreationTimeUtc(string path) => throw null;
            public static string GetCurrentDirectory() => throw null;
            public static string[] GetDirectories(string path) => throw null;
            public static string[] GetDirectories(string path, string searchPattern) => throw null;
            public static string[] GetDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetDirectories(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static string GetDirectoryRoot(string path) => throw null;
            public static string[] GetFileSystemEntries(string path) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static string[] GetFiles(string path) => throw null;
            public static string[] GetFiles(string path, string searchPattern) => throw null;
            public static string[] GetFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetFiles(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.DateTime GetLastAccessTime(string path) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(string path) => throw null;
            public static System.DateTime GetLastWriteTime(string path) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(string path) => throw null;
            public static string[] GetLogicalDrives() => throw null;
            public static System.IO.DirectoryInfo GetParent(string path) => throw null;
            public static void Move(string sourceDirName, string destDirName) => throw null;
            public static System.IO.FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget) => throw null;
            public static void SetCreationTime(string path, System.DateTime creationTime) => throw null;
            public static void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc) => throw null;
            public static void SetCurrentDirectory(string path) => throw null;
            public static void SetLastAccessTime(string path, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastWriteTime(string path, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc) => throw null;
        }

        public class DirectoryInfo : System.IO.FileSystemInfo
        {
            public void Create() => throw null;
            public System.IO.DirectoryInfo CreateSubdirectory(string path) => throw null;
            public override void Delete() => throw null;
            public void Delete(bool recursive) => throw null;
            public DirectoryInfo(string path) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public override bool Exists { get => throw null; }
            public System.IO.DirectoryInfo[] GetDirectories() => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern) => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos() => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.IO.FileInfo[] GetFiles() => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern) => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public void MoveTo(string destDirName) => throw null;
            public override string Name { get => throw null; }
            public System.IO.DirectoryInfo Parent { get => throw null; }
            public System.IO.DirectoryInfo Root { get => throw null; }
            public override string ToString() => throw null;
        }

        public class DirectoryNotFoundException : System.IO.IOException
        {
            public DirectoryNotFoundException() => throw null;
            protected DirectoryNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public DirectoryNotFoundException(string message) => throw null;
            public DirectoryNotFoundException(string message, System.Exception innerException) => throw null;
        }

        public class EndOfStreamException : System.IO.IOException
        {
            public EndOfStreamException() => throw null;
            protected EndOfStreamException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public EndOfStreamException(string message) => throw null;
            public EndOfStreamException(string message, System.Exception innerException) => throw null;
        }

        public class EnumerationOptions
        {
            public System.IO.FileAttributes AttributesToSkip { get => throw null; set => throw null; }
            public int BufferSize { get => throw null; set => throw null; }
            public EnumerationOptions() => throw null;
            public bool IgnoreInaccessible { get => throw null; set => throw null; }
            public System.IO.MatchCasing MatchCasing { get => throw null; set => throw null; }
            public System.IO.MatchType MatchType { get => throw null; set => throw null; }
            public int MaxRecursionDepth { get => throw null; set => throw null; }
            public bool RecurseSubdirectories { get => throw null; set => throw null; }
            public bool ReturnSpecialDirectories { get => throw null; set => throw null; }
        }

        public static class File
        {
            public static void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents) => throw null;
            public static void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void AppendAllText(string path, string contents) => throw null;
            public static void AppendAllText(string path, string contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.IO.StreamWriter AppendText(string path) => throw null;
            public static void Copy(string sourceFileName, string destFileName) => throw null;
            public static void Copy(string sourceFileName, string destFileName, bool overwrite) => throw null;
            public static System.IO.FileStream Create(string path) => throw null;
            public static System.IO.FileStream Create(string path, int bufferSize) => throw null;
            public static System.IO.FileStream Create(string path, int bufferSize, System.IO.FileOptions options) => throw null;
            public static System.IO.FileSystemInfo CreateSymbolicLink(string path, string pathToTarget) => throw null;
            public static System.IO.StreamWriter CreateText(string path) => throw null;
            public static void Decrypt(string path) => throw null;
            public static void Delete(string path) => throw null;
            public static void Encrypt(string path) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.IO.FileAttributes GetAttributes(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.IO.FileAttributes GetAttributes(string path) => throw null;
            public static System.DateTime GetCreationTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetCreationTime(string path) => throw null;
            public static System.DateTime GetCreationTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetCreationTimeUtc(string path) => throw null;
            public static System.DateTime GetLastAccessTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastAccessTime(string path) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(string path) => throw null;
            public static System.DateTime GetLastWriteTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastWriteTime(string path) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(string path) => throw null;
            public static System.IO.UnixFileMode GetUnixFileMode(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.IO.UnixFileMode GetUnixFileMode(string path) => throw null;
            public static void Move(string sourceFileName, string destFileName) => throw null;
            public static void Move(string sourceFileName, string destFileName, bool overwrite) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileStreamOptions options) => throw null;
            public static Microsoft.Win32.SafeHandles.SafeFileHandle OpenHandle(string path, System.IO.FileMode mode = default(System.IO.FileMode), System.IO.FileAccess access = default(System.IO.FileAccess), System.IO.FileShare share = default(System.IO.FileShare), System.IO.FileOptions options = default(System.IO.FileOptions), System.Int64 preallocationSize = default(System.Int64)) => throw null;
            public static System.IO.FileStream OpenRead(string path) => throw null;
            public static System.IO.StreamReader OpenText(string path) => throw null;
            public static System.IO.FileStream OpenWrite(string path) => throw null;
            public static System.Byte[] ReadAllBytes(string path) => throw null;
            public static System.Threading.Tasks.Task<System.Byte[]> ReadAllBytesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static string[] ReadAllLines(string path) => throw null;
            public static string[] ReadAllLines(string path, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task<string[]> ReadAllLinesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task<string[]> ReadAllLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static string ReadAllText(string path) => throw null;
            public static string ReadAllText(string path, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Collections.Generic.IEnumerable<string> ReadLines(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> ReadLines(string path, System.Text.Encoding encoding) => throw null;
            public static System.Collections.Generic.IAsyncEnumerable<string> ReadLinesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Collections.Generic.IAsyncEnumerable<string> ReadLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) => throw null;
            public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) => throw null;
            public static System.IO.FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget) => throw null;
            public static void SetAttributes(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.IO.FileAttributes fileAttributes) => throw null;
            public static void SetAttributes(string path, System.IO.FileAttributes fileAttributes) => throw null;
            public static void SetCreationTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime creationTime) => throw null;
            public static void SetCreationTime(string path, System.DateTime creationTime) => throw null;
            public static void SetCreationTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime creationTimeUtc) => throw null;
            public static void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc) => throw null;
            public static void SetLastAccessTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTime(string path, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastWriteTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTime(string path, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastWriteTimeUtc) => throw null;
            public static void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc) => throw null;
            public static void SetUnixFileMode(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.IO.UnixFileMode mode) => throw null;
            public static void SetUnixFileMode(string path, System.IO.UnixFileMode mode) => throw null;
            public static void WriteAllBytes(string path, System.Byte[] bytes) => throw null;
            public static System.Threading.Tasks.Task WriteAllBytesAsync(string path, System.Byte[] bytes, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents) => throw null;
            public static void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding) => throw null;
            public static void WriteAllLines(string path, string[] contents) => throw null;
            public static void WriteAllLines(string path, string[] contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void WriteAllText(string path, string contents) => throw null;
            public static void WriteAllText(string path, string contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }

        [System.Flags]
        public enum FileAccess : int
        {
            Read = 1,
            ReadWrite = 3,
            Write = 2,
        }

        [System.Flags]
        public enum FileAttributes : int
        {
            Archive = 32,
            Compressed = 2048,
            Device = 64,
            Directory = 16,
            Encrypted = 16384,
            Hidden = 2,
            IntegrityStream = 32768,
            NoScrubData = 131072,
            Normal = 128,
            NotContentIndexed = 8192,
            Offline = 4096,
            ReadOnly = 1,
            ReparsePoint = 1024,
            SparseFile = 512,
            System = 4,
            Temporary = 256,
        }

        public class FileInfo : System.IO.FileSystemInfo
        {
            public System.IO.StreamWriter AppendText() => throw null;
            public System.IO.FileInfo CopyTo(string destFileName) => throw null;
            public System.IO.FileInfo CopyTo(string destFileName, bool overwrite) => throw null;
            public System.IO.FileStream Create() => throw null;
            public System.IO.StreamWriter CreateText() => throw null;
            public void Decrypt() => throw null;
            public override void Delete() => throw null;
            public System.IO.DirectoryInfo Directory { get => throw null; }
            public string DirectoryName { get => throw null; }
            public void Encrypt() => throw null;
            public override bool Exists { get => throw null; }
            public FileInfo(string fileName) => throw null;
            public bool IsReadOnly { get => throw null; set => throw null; }
            public System.Int64 Length { get => throw null; }
            public void MoveTo(string destFileName) => throw null;
            public void MoveTo(string destFileName, bool overwrite) => throw null;
            public override string Name { get => throw null; }
            public System.IO.FileStream Open(System.IO.FileMode mode) => throw null;
            public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public System.IO.FileStream Open(System.IO.FileStreamOptions options) => throw null;
            public System.IO.FileStream OpenRead() => throw null;
            public System.IO.StreamReader OpenText() => throw null;
            public System.IO.FileStream OpenWrite() => throw null;
            public System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) => throw null;
            public System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) => throw null;
        }

        public class FileLoadException : System.IO.IOException
        {
            public FileLoadException() => throw null;
            protected FileLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public FileLoadException(string message) => throw null;
            public FileLoadException(string message, System.Exception inner) => throw null;
            public FileLoadException(string message, string fileName) => throw null;
            public FileLoadException(string message, string fileName, System.Exception inner) => throw null;
            public string FileName { get => throw null; }
            public string FusionLog { get => throw null; }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public override string Message { get => throw null; }
            public override string ToString() => throw null;
        }

        public enum FileMode : int
        {
            Append = 6,
            Create = 2,
            CreateNew = 1,
            Open = 3,
            OpenOrCreate = 4,
            Truncate = 5,
        }

        public class FileNotFoundException : System.IO.IOException
        {
            public string FileName { get => throw null; }
            public FileNotFoundException() => throw null;
            protected FileNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public FileNotFoundException(string message) => throw null;
            public FileNotFoundException(string message, System.Exception innerException) => throw null;
            public FileNotFoundException(string message, string fileName) => throw null;
            public FileNotFoundException(string message, string fileName, System.Exception innerException) => throw null;
            public string FusionLog { get => throw null; }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public override string Message { get => throw null; }
            public override string ToString() => throw null;
        }

        [System.Flags]
        public enum FileOptions : int
        {
            Asynchronous = 1073741824,
            DeleteOnClose = 67108864,
            Encrypted = 16384,
            None = 0,
            RandomAccess = 268435456,
            SequentialScan = 134217728,
            WriteThrough = -2147483648,
        }

        [System.Flags]
        public enum FileShare : int
        {
            Delete = 4,
            Inheritable = 16,
            None = 0,
            Read = 1,
            ReadWrite = 3,
            Write = 2,
        }

        public class FileStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public FileStream(System.IntPtr handle, System.IO.FileAccess access) => throw null;
            public FileStream(System.IntPtr handle, System.IO.FileAccess access, bool ownsHandle) => throw null;
            public FileStream(System.IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize) => throw null;
            public FileStream(System.IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync) => throw null;
            public FileStream(string path, System.IO.FileMode mode) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync) => throw null;
            public FileStream(string path, System.IO.FileStreamOptions options) => throw null;
            public override void Flush() => throw null;
            public virtual void Flush(bool flushToDisk) => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.IntPtr Handle { get => throw null; }
            public virtual bool IsAsync { get => throw null; }
            public override System.Int64 Length { get => throw null; }
            public virtual void Lock(System.Int64 position, System.Int64 length) => throw null;
            public virtual string Name { get => throw null; }
            public override System.Int64 Position { get => throw null; set => throw null; }
            public override int Read(System.Byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get => throw null; }
            public override System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin origin) => throw null;
            public override void SetLength(System.Int64 value) => throw null;
            public virtual void Unlock(System.Int64 position, System.Int64 length) => throw null;
            public override void Write(System.Byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(System.Byte value) => throw null;
            // ERR: Stub generator didn't handle member: ~FileStream
        }

        public class FileStreamOptions
        {
            public System.IO.FileAccess Access { get => throw null; set => throw null; }
            public int BufferSize { get => throw null; set => throw null; }
            public FileStreamOptions() => throw null;
            public System.IO.FileMode Mode { get => throw null; set => throw null; }
            public System.IO.FileOptions Options { get => throw null; set => throw null; }
            public System.Int64 PreallocationSize { get => throw null; set => throw null; }
            public System.IO.FileShare Share { get => throw null; set => throw null; }
            public System.IO.UnixFileMode? UnixCreateMode { get => throw null; set => throw null; }
        }

        public abstract class FileSystemInfo : System.MarshalByRefObject, System.Runtime.Serialization.ISerializable
        {
            public System.IO.FileAttributes Attributes { get => throw null; set => throw null; }
            public void CreateAsSymbolicLink(string pathToTarget) => throw null;
            public System.DateTime CreationTime { get => throw null; set => throw null; }
            public System.DateTime CreationTimeUtc { get => throw null; set => throw null; }
            public abstract void Delete();
            public abstract bool Exists { get; }
            public string Extension { get => throw null; }
            protected FileSystemInfo() => throw null;
            protected FileSystemInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual string FullName { get => throw null; }
            protected string FullPath;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.DateTime LastAccessTime { get => throw null; set => throw null; }
            public System.DateTime LastAccessTimeUtc { get => throw null; set => throw null; }
            public System.DateTime LastWriteTime { get => throw null; set => throw null; }
            public System.DateTime LastWriteTimeUtc { get => throw null; set => throw null; }
            public string LinkTarget { get => throw null; }
            public abstract string Name { get; }
            protected string OriginalPath;
            public void Refresh() => throw null;
            public System.IO.FileSystemInfo ResolveLinkTarget(bool returnFinalTarget) => throw null;
            public override string ToString() => throw null;
            public System.IO.UnixFileMode UnixFileMode { get => throw null; set => throw null; }
        }

        public enum HandleInheritability : int
        {
            Inheritable = 1,
            None = 0,
        }

        public class IOException : System.SystemException
        {
            public IOException() => throw null;
            protected IOException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public IOException(string message) => throw null;
            public IOException(string message, System.Exception innerException) => throw null;
            public IOException(string message, int hresult) => throw null;
        }

        public class InvalidDataException : System.SystemException
        {
            public InvalidDataException() => throw null;
            public InvalidDataException(string message) => throw null;
            public InvalidDataException(string message, System.Exception innerException) => throw null;
        }

        public enum MatchCasing : int
        {
            CaseInsensitive = 2,
            CaseSensitive = 1,
            PlatformDefault = 0,
        }

        public enum MatchType : int
        {
            Simple = 0,
            Win32 = 1,
        }

        public class MemoryStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public virtual int Capacity { get => throw null; set => throw null; }
            public override void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.Byte[] GetBuffer() => throw null;
            public override System.Int64 Length { get => throw null; }
            public MemoryStream() => throw null;
            public MemoryStream(System.Byte[] buffer) => throw null;
            public MemoryStream(System.Byte[] buffer, bool writable) => throw null;
            public MemoryStream(System.Byte[] buffer, int index, int count) => throw null;
            public MemoryStream(System.Byte[] buffer, int index, int count, bool writable) => throw null;
            public MemoryStream(System.Byte[] buffer, int index, int count, bool writable, bool publiclyVisible) => throw null;
            public MemoryStream(int capacity) => throw null;
            public override System.Int64 Position { get => throw null; set => throw null; }
            public override int Read(System.Byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin loc) => throw null;
            public override void SetLength(System.Int64 value) => throw null;
            public virtual System.Byte[] ToArray() => throw null;
            public virtual bool TryGetBuffer(out System.ArraySegment<System.Byte> buffer) => throw null;
            public override void Write(System.Byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(System.Byte value) => throw null;
            public virtual void WriteTo(System.IO.Stream stream) => throw null;
        }

        public static class Path
        {
            public static System.Char AltDirectorySeparatorChar;
            public static string ChangeExtension(string path, string extension) => throw null;
            public static string Combine(params string[] paths) => throw null;
            public static string Combine(string path1, string path2) => throw null;
            public static string Combine(string path1, string path2, string path3) => throw null;
            public static string Combine(string path1, string path2, string path3, string path4) => throw null;
            public static System.Char DirectorySeparatorChar;
            public static bool EndsInDirectorySeparator(System.ReadOnlySpan<System.Char> path) => throw null;
            public static bool EndsInDirectorySeparator(string path) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.ReadOnlySpan<System.Char> GetDirectoryName(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string GetDirectoryName(string path) => throw null;
            public static System.ReadOnlySpan<System.Char> GetExtension(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string GetExtension(string path) => throw null;
            public static System.ReadOnlySpan<System.Char> GetFileName(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string GetFileName(string path) => throw null;
            public static System.ReadOnlySpan<System.Char> GetFileNameWithoutExtension(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string GetFileNameWithoutExtension(string path) => throw null;
            public static string GetFullPath(string path) => throw null;
            public static string GetFullPath(string path, string basePath) => throw null;
            public static System.Char[] GetInvalidFileNameChars() => throw null;
            public static System.Char[] GetInvalidPathChars() => throw null;
            public static System.ReadOnlySpan<System.Char> GetPathRoot(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string GetPathRoot(string path) => throw null;
            public static string GetRandomFileName() => throw null;
            public static string GetRelativePath(string relativeTo, string path) => throw null;
            public static string GetTempFileName() => throw null;
            public static string GetTempPath() => throw null;
            public static bool HasExtension(System.ReadOnlySpan<System.Char> path) => throw null;
            public static bool HasExtension(string path) => throw null;
            public static System.Char[] InvalidPathChars;
            public static bool IsPathFullyQualified(System.ReadOnlySpan<System.Char> path) => throw null;
            public static bool IsPathFullyQualified(string path) => throw null;
            public static bool IsPathRooted(System.ReadOnlySpan<System.Char> path) => throw null;
            public static bool IsPathRooted(string path) => throw null;
            public static string Join(System.ReadOnlySpan<System.Char> path1, System.ReadOnlySpan<System.Char> path2) => throw null;
            public static string Join(System.ReadOnlySpan<System.Char> path1, System.ReadOnlySpan<System.Char> path2, System.ReadOnlySpan<System.Char> path3) => throw null;
            public static string Join(System.ReadOnlySpan<System.Char> path1, System.ReadOnlySpan<System.Char> path2, System.ReadOnlySpan<System.Char> path3, System.ReadOnlySpan<System.Char> path4) => throw null;
            public static string Join(params string[] paths) => throw null;
            public static string Join(string path1, string path2) => throw null;
            public static string Join(string path1, string path2, string path3) => throw null;
            public static string Join(string path1, string path2, string path3, string path4) => throw null;
            public static System.Char PathSeparator;
            public static System.ReadOnlySpan<System.Char> TrimEndingDirectorySeparator(System.ReadOnlySpan<System.Char> path) => throw null;
            public static string TrimEndingDirectorySeparator(string path) => throw null;
            public static bool TryJoin(System.ReadOnlySpan<System.Char> path1, System.ReadOnlySpan<System.Char> path2, System.ReadOnlySpan<System.Char> path3, System.Span<System.Char> destination, out int charsWritten) => throw null;
            public static bool TryJoin(System.ReadOnlySpan<System.Char> path1, System.ReadOnlySpan<System.Char> path2, System.Span<System.Char> destination, out int charsWritten) => throw null;
            public static System.Char VolumeSeparatorChar;
        }

        public class PathTooLongException : System.IO.IOException
        {
            public PathTooLongException() => throw null;
            protected PathTooLongException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public PathTooLongException(string message) => throw null;
            public PathTooLongException(string message, System.Exception innerException) => throw null;
        }

        public static class RandomAccess
        {
            public static System.Int64 GetLength(Microsoft.Win32.SafeHandles.SafeFileHandle handle) => throw null;
            public static System.Int64 Read(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.Memory<System.Byte>> buffers, System.Int64 fileOffset) => throw null;
            public static int Read(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Span<System.Byte> buffer, System.Int64 fileOffset) => throw null;
            public static System.Threading.Tasks.ValueTask<System.Int64> ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.Memory<System.Byte>> buffers, System.Int64 fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.ValueTask<int> ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Memory<System.Byte> buffer, System.Int64 fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void SetLength(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Int64 length) => throw null;
            public static void Write(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.ReadOnlyMemory<System.Byte>> buffers, System.Int64 fileOffset) => throw null;
            public static void Write(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.ReadOnlySpan<System.Byte> buffer, System.Int64 fileOffset) => throw null;
            public static System.Threading.Tasks.ValueTask WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.ReadOnlyMemory<System.Byte>> buffers, System.Int64 fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.ValueTask WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.ReadOnlyMemory<System.Byte> buffer, System.Int64 fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }

        public enum SearchOption : int
        {
            AllDirectories = 1,
            TopDirectoryOnly = 0,
        }

        public enum SeekOrigin : int
        {
            Begin = 0,
            Current = 1,
            End = 2,
        }

        public abstract class Stream : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
        {
            public virtual System.IAsyncResult BeginRead(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public virtual System.IAsyncResult BeginWrite(System.Byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public abstract bool CanRead { get; }
            public abstract bool CanSeek { get; }
            public virtual bool CanTimeout { get => throw null; }
            public abstract bool CanWrite { get; }
            public virtual void Close() => throw null;
            public void CopyTo(System.IO.Stream destination) => throw null;
            public virtual void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, System.Threading.CancellationToken cancellationToken) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize) => throw null;
            public virtual System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            protected virtual System.Threading.WaitHandle CreateWaitHandle() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public virtual int EndRead(System.IAsyncResult asyncResult) => throw null;
            public virtual void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public abstract void Flush();
            public System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public abstract System.Int64 Length { get; }
            public static System.IO.Stream Null;
            protected virtual void ObjectInvariant() => throw null;
            public abstract System.Int64 Position { get; set; }
            public abstract int Read(System.Byte[] buffer, int offset, int count);
            public virtual int Read(System.Span<System.Byte> buffer) => throw null;
            public System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public int ReadAtLeast(System.Span<System.Byte> buffer, int minimumBytes, bool throwOnEndOfStream = default(bool)) => throw null;
            public System.Threading.Tasks.ValueTask<int> ReadAtLeastAsync(System.Memory<System.Byte> buffer, int minimumBytes, bool throwOnEndOfStream = default(bool), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadByte() => throw null;
            public void ReadExactly(System.Byte[] buffer, int offset, int count) => throw null;
            public void ReadExactly(System.Span<System.Byte> buffer) => throw null;
            public System.Threading.Tasks.ValueTask ReadExactlyAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public System.Threading.Tasks.ValueTask ReadExactlyAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadTimeout { get => throw null; set => throw null; }
            public abstract System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin origin);
            public abstract void SetLength(System.Int64 value);
            protected Stream() => throw null;
            public static System.IO.Stream Synchronized(System.IO.Stream stream) => throw null;
            protected static void ValidateBufferArguments(System.Byte[] buffer, int offset, int count) => throw null;
            protected static void ValidateCopyToArguments(System.IO.Stream destination, int bufferSize) => throw null;
            public abstract void Write(System.Byte[] buffer, int offset, int count);
            public virtual void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual void WriteByte(System.Byte value) => throw null;
            public virtual int WriteTimeout { get => throw null; set => throw null; }
        }

        public class StreamReader : System.IO.TextReader
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public override void Close() => throw null;
            public virtual System.Text.Encoding CurrentEncoding { get => throw null; }
            public void DiscardBufferedData() => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public bool EndOfStream { get => throw null; }
            public static System.IO.StreamReader Null;
            public override int Peek() => throw null;
            public override int Read() => throw null;
            public override int Read(System.Char[] buffer, int index, int count) => throw null;
            public override int Read(System.Span<System.Char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadBlock(System.Char[] buffer, int index, int count) => throw null;
            public override int ReadBlock(System.Span<System.Char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadBlockAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override string ReadLine() => throw null;
            public override System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public override System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override string ReadToEnd() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public StreamReader(System.IO.Stream stream) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding = default(System.Text.Encoding), bool detectEncodingFromByteOrderMarks = default(bool), int bufferSize = default(int), bool leaveOpen = default(bool)) => throw null;
            public StreamReader(System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(string path) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize) => throw null;
            public StreamReader(string path, System.IO.FileStreamOptions options) => throw null;
            public StreamReader(string path, bool detectEncodingFromByteOrderMarks) => throw null;
        }

        public class StreamWriter : System.IO.TextWriter
        {
            public virtual bool AutoFlush { get => throw null; set => throw null; }
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public override void Close() => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override System.Text.Encoding Encoding { get => throw null; }
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync() => throw null;
            public static System.IO.StreamWriter Null;
            public StreamWriter(System.IO.Stream stream) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding = default(System.Text.Encoding), int bufferSize = default(int), bool leaveOpen = default(bool)) => throw null;
            public StreamWriter(string path) => throw null;
            public StreamWriter(string path, System.Text.Encoding encoding, System.IO.FileStreamOptions options) => throw null;
            public StreamWriter(string path, System.IO.FileStreamOptions options) => throw null;
            public StreamWriter(string path, bool append) => throw null;
            public StreamWriter(string path, bool append, System.Text.Encoding encoding) => throw null;
            public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize) => throw null;
            public override void Write(System.Char[] buffer) => throw null;
            public override void Write(System.Char[] buffer, int index, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public override void Write(System.Char value) => throw null;
            public override void Write(string value) => throw null;
            public override void Write(string format, object arg0) => throw null;
            public override void Write(string format, object arg0, object arg1) => throw null;
            public override void Write(string format, object arg0, object arg1, object arg2) => throw null;
            public override void Write(string format, params object[] arg) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Char value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public override void WriteLine(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public override void WriteLine(string value) => throw null;
            public override void WriteLine(string format, object arg0) => throw null;
            public override void WriteLine(string format, object arg0, object arg1) => throw null;
            public override void WriteLine(string format, object arg0, object arg1, object arg2) => throw null;
            public override void WriteLine(string format, params object[] arg) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync() => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Char value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
        }

        public class StringReader : System.IO.TextReader
        {
            public override void Close() => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override int Peek() => throw null;
            public override int Read() => throw null;
            public override int Read(System.Char[] buffer, int index, int count) => throw null;
            public override int Read(System.Span<System.Char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadBlock(System.Span<System.Char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadBlockAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override string ReadLine() => throw null;
            public override System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public override System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override string ReadToEnd() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public StringReader(string s) => throw null;
        }

        public class StringWriter : System.IO.TextWriter
        {
            public override void Close() => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Text.Encoding Encoding { get => throw null; }
            public override System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.Text.StringBuilder GetStringBuilder() => throw null;
            public StringWriter() => throw null;
            public StringWriter(System.IFormatProvider formatProvider) => throw null;
            public StringWriter(System.Text.StringBuilder sb) => throw null;
            public StringWriter(System.Text.StringBuilder sb, System.IFormatProvider formatProvider) => throw null;
            public override string ToString() => throw null;
            public override void Write(System.Char[] buffer, int index, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public override void Write(System.Text.StringBuilder value) => throw null;
            public override void Write(System.Char value) => throw null;
            public override void Write(string value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Char value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public override void WriteLine(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public override void WriteLine(System.Text.StringBuilder value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Char value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
        }

        public abstract class TextReader : System.MarshalByRefObject, System.IDisposable
        {
            public virtual void Close() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public static System.IO.TextReader Null;
            public virtual int Peek() => throw null;
            public virtual int Read() => throw null;
            public virtual int Read(System.Char[] buffer, int index, int count) => throw null;
            public virtual int Read(System.Span<System.Char> buffer) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadAsync(System.Char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadBlock(System.Char[] buffer, int index, int count) => throw null;
            public virtual int ReadBlock(System.Span<System.Char> buffer) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadBlockAsync(System.Char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual string ReadLine() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public virtual System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual string ReadToEnd() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public static System.IO.TextReader Synchronized(System.IO.TextReader reader) => throw null;
            protected TextReader() => throw null;
        }

        public abstract class TextWriter : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
        {
            public virtual void Close() => throw null;
            protected System.Char[] CoreNewLine;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public abstract System.Text.Encoding Encoding { get; }
            public virtual void Flush() => throw null;
            public virtual System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.IFormatProvider FormatProvider { get => throw null; }
            public virtual string NewLine { get => throw null; set => throw null; }
            public static System.IO.TextWriter Null;
            public static System.IO.TextWriter Synchronized(System.IO.TextWriter writer) => throw null;
            protected TextWriter() => throw null;
            protected TextWriter(System.IFormatProvider formatProvider) => throw null;
            public virtual void Write(System.Char[] buffer) => throw null;
            public virtual void Write(System.Char[] buffer, int index, int count) => throw null;
            public virtual void Write(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public virtual void Write(System.Text.StringBuilder value) => throw null;
            public virtual void Write(bool value) => throw null;
            public virtual void Write(System.Char value) => throw null;
            public virtual void Write(System.Decimal value) => throw null;
            public virtual void Write(double value) => throw null;
            public virtual void Write(float value) => throw null;
            public virtual void Write(int value) => throw null;
            public virtual void Write(System.Int64 value) => throw null;
            public virtual void Write(object value) => throw null;
            public virtual void Write(string value) => throw null;
            public virtual void Write(string format, object arg0) => throw null;
            public virtual void Write(string format, object arg0, object arg1) => throw null;
            public virtual void Write(string format, object arg0, object arg1, object arg2) => throw null;
            public virtual void Write(string format, params object[] arg) => throw null;
            public virtual void Write(System.UInt32 value) => throw null;
            public virtual void Write(System.UInt64 value) => throw null;
            public System.Threading.Tasks.Task WriteAsync(System.Char[] buffer) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.Char value) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public virtual void WriteLine() => throw null;
            public virtual void WriteLine(System.Char[] buffer) => throw null;
            public virtual void WriteLine(System.Char[] buffer, int index, int count) => throw null;
            public virtual void WriteLine(System.ReadOnlySpan<System.Char> buffer) => throw null;
            public virtual void WriteLine(System.Text.StringBuilder value) => throw null;
            public virtual void WriteLine(bool value) => throw null;
            public virtual void WriteLine(System.Char value) => throw null;
            public virtual void WriteLine(System.Decimal value) => throw null;
            public virtual void WriteLine(double value) => throw null;
            public virtual void WriteLine(float value) => throw null;
            public virtual void WriteLine(int value) => throw null;
            public virtual void WriteLine(System.Int64 value) => throw null;
            public virtual void WriteLine(object value) => throw null;
            public virtual void WriteLine(string value) => throw null;
            public virtual void WriteLine(string format, object arg0) => throw null;
            public virtual void WriteLine(string format, object arg0, object arg1) => throw null;
            public virtual void WriteLine(string format, object arg0, object arg1, object arg2) => throw null;
            public virtual void WriteLine(string format, params object[] arg) => throw null;
            public virtual void WriteLine(System.UInt32 value) => throw null;
            public virtual void WriteLine(System.UInt64 value) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync() => throw null;
            public System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.Char value) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
        }

        [System.Flags]
        public enum UnixFileMode : int
        {
            GroupExecute = 8,
            GroupRead = 32,
            GroupWrite = 16,
            None = 0,
            OtherExecute = 1,
            OtherRead = 4,
            OtherWrite = 2,
            SetGroup = 1024,
            SetUser = 2048,
            StickyBit = 512,
            UserExecute = 64,
            UserRead = 256,
            UserWrite = 128,
        }

        public class UnmanagedMemoryStream : System.IO.Stream
        {
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public System.Int64 Capacity { get => throw null; }
            protected override void Dispose(bool disposing) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            protected void Initialize(System.Runtime.InteropServices.SafeBuffer buffer, System.Int64 offset, System.Int64 length, System.IO.FileAccess access) => throw null;
            unsafe protected void Initialize(System.Byte* pointer, System.Int64 length, System.Int64 capacity, System.IO.FileAccess access) => throw null;
            public override System.Int64 Length { get => throw null; }
            public override System.Int64 Position { get => throw null; set => throw null; }
            unsafe public System.Byte* PositionPointer { get => throw null; set => throw null; }
            public override int Read(System.Byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin loc) => throw null;
            public override void SetLength(System.Int64 value) => throw null;
            protected UnmanagedMemoryStream() => throw null;
            public UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, System.Int64 offset, System.Int64 length) => throw null;
            public UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, System.Int64 offset, System.Int64 length, System.IO.FileAccess access) => throw null;
            unsafe public UnmanagedMemoryStream(System.Byte* pointer, System.Int64 length) => throw null;
            unsafe public UnmanagedMemoryStream(System.Byte* pointer, System.Int64 length, System.Int64 capacity, System.IO.FileAccess access) => throw null;
            public override void Write(System.Byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<System.Byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(System.Byte value) => throw null;
        }

        namespace Enumeration
        {
            public struct FileSystemEntry
            {
                public System.IO.FileAttributes Attributes { get => throw null; }
                public System.DateTimeOffset CreationTimeUtc { get => throw null; }
                public System.ReadOnlySpan<System.Char> Directory { get => throw null; }
                public System.ReadOnlySpan<System.Char> FileName { get => throw null; }
                // Stub generator skipped constructor 
                public bool IsDirectory { get => throw null; }
                public bool IsHidden { get => throw null; }
                public System.DateTimeOffset LastAccessTimeUtc { get => throw null; }
                public System.DateTimeOffset LastWriteTimeUtc { get => throw null; }
                public System.Int64 Length { get => throw null; }
                public System.ReadOnlySpan<System.Char> OriginalRootDirectory { get => throw null; }
                public System.ReadOnlySpan<System.Char> RootDirectory { get => throw null; }
                public System.IO.FileSystemInfo ToFileSystemInfo() => throw null;
                public string ToFullPath() => throw null;
                public string ToSpecifiedFullPath() => throw null;
            }

            public class FileSystemEnumerable<TResult> : System.Collections.Generic.IEnumerable<TResult>, System.Collections.IEnumerable
            {
                public delegate bool FindPredicate(ref System.IO.Enumeration.FileSystemEntry entry);


                public delegate TResult FindTransform(ref System.IO.Enumeration.FileSystemEntry entry);


                public FileSystemEnumerable(string directory, System.IO.Enumeration.FileSystemEnumerable<TResult>.FindTransform transform, System.IO.EnumerationOptions options = default(System.IO.EnumerationOptions)) => throw null;
                public System.Collections.Generic.IEnumerator<TResult> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public System.IO.Enumeration.FileSystemEnumerable<TResult>.FindPredicate ShouldIncludePredicate { get => throw null; set => throw null; }
                public System.IO.Enumeration.FileSystemEnumerable<TResult>.FindPredicate ShouldRecursePredicate { get => throw null; set => throw null; }
            }

            public abstract class FileSystemEnumerator<TResult> : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Collections.Generic.IEnumerator<TResult>, System.Collections.IEnumerator, System.IDisposable
            {
                protected virtual bool ContinueOnError(int error) => throw null;
                public TResult Current { get => throw null; }
                object System.Collections.IEnumerator.Current { get => throw null; }
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public FileSystemEnumerator(string directory, System.IO.EnumerationOptions options = default(System.IO.EnumerationOptions)) => throw null;
                public bool MoveNext() => throw null;
                protected virtual void OnDirectoryFinished(System.ReadOnlySpan<System.Char> directory) => throw null;
                public void Reset() => throw null;
                protected virtual bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry) => throw null;
                protected virtual bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry) => throw null;
                protected abstract TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
            }

            public static class FileSystemName
            {
                public static bool MatchesSimpleExpression(System.ReadOnlySpan<System.Char> expression, System.ReadOnlySpan<System.Char> name, bool ignoreCase = default(bool)) => throw null;
                public static bool MatchesWin32Expression(System.ReadOnlySpan<System.Char> expression, System.ReadOnlySpan<System.Char> name, bool ignoreCase = default(bool)) => throw null;
                public static string TranslateWin32Expression(string expression) => throw null;
            }

        }
    }
    namespace Net
    {
        public static class WebUtility
        {
            public static string HtmlDecode(string value) => throw null;
            public static void HtmlDecode(string value, System.IO.TextWriter output) => throw null;
            public static string HtmlEncode(string value) => throw null;
            public static void HtmlEncode(string value, System.IO.TextWriter output) => throw null;
            public static string UrlDecode(string encodedValue) => throw null;
            public static System.Byte[] UrlDecodeToBytes(System.Byte[] encodedValue, int offset, int count) => throw null;
            public static string UrlEncode(string value) => throw null;
            public static System.Byte[] UrlEncodeToBytes(System.Byte[] value, int offset, int count) => throw null;
        }

    }
    namespace Numerics
    {
        public static class BitOperations
        {
            public static bool IsPow2(System.IntPtr value) => throw null;
            public static bool IsPow2(System.UIntPtr value) => throw null;
            public static bool IsPow2(int value) => throw null;
            public static bool IsPow2(System.Int64 value) => throw null;
            public static bool IsPow2(System.UInt32 value) => throw null;
            public static bool IsPow2(System.UInt64 value) => throw null;
            public static int LeadingZeroCount(System.UIntPtr value) => throw null;
            public static int LeadingZeroCount(System.UInt32 value) => throw null;
            public static int LeadingZeroCount(System.UInt64 value) => throw null;
            public static int Log2(System.UIntPtr value) => throw null;
            public static int Log2(System.UInt32 value) => throw null;
            public static int Log2(System.UInt64 value) => throw null;
            public static int PopCount(System.UIntPtr value) => throw null;
            public static int PopCount(System.UInt32 value) => throw null;
            public static int PopCount(System.UInt64 value) => throw null;
            public static System.UIntPtr RotateLeft(System.UIntPtr value, int offset) => throw null;
            public static System.UInt32 RotateLeft(System.UInt32 value, int offset) => throw null;
            public static System.UInt64 RotateLeft(System.UInt64 value, int offset) => throw null;
            public static System.UIntPtr RotateRight(System.UIntPtr value, int offset) => throw null;
            public static System.UInt32 RotateRight(System.UInt32 value, int offset) => throw null;
            public static System.UInt64 RotateRight(System.UInt64 value, int offset) => throw null;
            public static System.UIntPtr RoundUpToPowerOf2(System.UIntPtr value) => throw null;
            public static System.UInt32 RoundUpToPowerOf2(System.UInt32 value) => throw null;
            public static System.UInt64 RoundUpToPowerOf2(System.UInt64 value) => throw null;
            public static int TrailingZeroCount(System.IntPtr value) => throw null;
            public static int TrailingZeroCount(System.UIntPtr value) => throw null;
            public static int TrailingZeroCount(int value) => throw null;
            public static int TrailingZeroCount(System.Int64 value) => throw null;
            public static int TrailingZeroCount(System.UInt32 value) => throw null;
            public static int TrailingZeroCount(System.UInt64 value) => throw null;
        }

        public interface IAdditionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IAdditionOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator +(TSelf left, TOther right);
            static virtual TResult operator checked +(TSelf left, TOther right) => throw null;
        }

        public interface IAdditiveIdentity<TSelf, TResult> where TSelf : System.Numerics.IAdditiveIdentity<TSelf, TResult>
        {
            static abstract TResult AdditiveIdentity { get; }
        }

        public interface IBinaryFloatingPointIeee754<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBinaryNumber<TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IExponentialFunctions<TSelf>, System.Numerics.IFloatingPoint<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IFloatingPointIeee754<TSelf>, System.Numerics.IHyperbolicFunctions<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.ILogarithmicFunctions<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.IPowerFunctions<TSelf>, System.Numerics.IRootFunctions<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.ITrigonometricFunctions<TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IBinaryFloatingPointIeee754<TSelf>
        {
        }

        public interface IBinaryInteger<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBinaryNumber<TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.IShiftOperators<TSelf, int, TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IBinaryInteger<TSelf>
        {
            static virtual (TSelf, TSelf) DivRem(TSelf left, TSelf right) => throw null;
            int GetByteCount();
            int GetShortestBitLength();
            static virtual TSelf LeadingZeroCount(TSelf value) => throw null;
            static abstract TSelf PopCount(TSelf value);
            static virtual TSelf ReadBigEndian(System.Byte[] source, bool isUnsigned) => throw null;
            static virtual TSelf ReadBigEndian(System.Byte[] source, int startIndex, bool isUnsigned) => throw null;
            static virtual TSelf ReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(System.Byte[] source, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(System.Byte[] source, int startIndex, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned) => throw null;
            static virtual TSelf RotateLeft(TSelf value, int rotateAmount) => throw null;
            static virtual TSelf RotateRight(TSelf value, int rotateAmount) => throw null;
            static abstract TSelf TrailingZeroCount(TSelf value);
            static abstract bool TryReadBigEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out TSelf value);
            static abstract bool TryReadLittleEndian(System.ReadOnlySpan<System.Byte> source, bool isUnsigned, out TSelf value);
            bool TryWriteBigEndian(System.Span<System.Byte> destination, out int bytesWritten);
            bool TryWriteLittleEndian(System.Span<System.Byte> destination, out int bytesWritten);
            int WriteBigEndian(System.Byte[] destination) => throw null;
            int WriteBigEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteBigEndian(System.Span<System.Byte> destination) => throw null;
            int WriteLittleEndian(System.Byte[] destination) => throw null;
            int WriteLittleEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteLittleEndian(System.Span<System.Byte> destination) => throw null;
        }

        public interface IBinaryNumber<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IBinaryNumber<TSelf>
        {
            static virtual TSelf AllBitsSet { get => throw null; }
            static abstract bool IsPow2(TSelf value);
            static abstract TSelf Log2(TSelf value);
        }

        public interface IBitwiseOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IBitwiseOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator &(TSelf left, TOther right);
            static abstract TResult operator ^(TSelf left, TOther right);
            static abstract TResult operator |(TSelf left, TOther right);
            static abstract TResult operator ~(TSelf value);
        }

        public interface IComparisonOperators<TSelf, TOther, TResult> : System.Numerics.IEqualityOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IComparisonOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator <(TSelf left, TOther right);
            static abstract TResult operator <=(TSelf left, TOther right);
            static abstract TResult operator >(TSelf left, TOther right);
            static abstract TResult operator >=(TSelf left, TOther right);
        }

        public interface IDecrementOperators<TSelf> where TSelf : System.Numerics.IDecrementOperators<TSelf>
        {
            static abstract TSelf operator --(TSelf value);
            static virtual TSelf operator checked --(TSelf value) => throw null;
        }

        public interface IDivisionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IDivisionOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator /(TSelf left, TOther right);
            static virtual TResult operator checked /(TSelf left, TOther right) => throw null;
        }

        public interface IEqualityOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IEqualityOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator !=(TSelf left, TOther right);
            static abstract TResult operator ==(TSelf left, TOther right);
        }

        public interface IExponentialFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IExponentialFunctions<TSelf>
        {
            static abstract TSelf Exp(TSelf x);
            static abstract TSelf Exp10(TSelf x);
            static virtual TSelf Exp10M1(TSelf x) => throw null;
            static abstract TSelf Exp2(TSelf x);
            static virtual TSelf Exp2M1(TSelf x) => throw null;
            static virtual TSelf ExpM1(TSelf x) => throw null;
        }

        public interface IFloatingPoint<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IFloatingPoint<TSelf>
        {
            static virtual TSelf Ceiling(TSelf x) => throw null;
            static virtual TSelf Floor(TSelf x) => throw null;
            int GetExponentByteCount();
            int GetExponentShortestBitLength();
            int GetSignificandBitLength();
            int GetSignificandByteCount();
            static virtual TSelf Round(TSelf x) => throw null;
            static virtual TSelf Round(TSelf x, System.MidpointRounding mode) => throw null;
            static virtual TSelf Round(TSelf x, int digits) => throw null;
            static abstract TSelf Round(TSelf x, int digits, System.MidpointRounding mode);
            static virtual TSelf Truncate(TSelf x) => throw null;
            bool TryWriteExponentBigEndian(System.Span<System.Byte> destination, out int bytesWritten);
            bool TryWriteExponentLittleEndian(System.Span<System.Byte> destination, out int bytesWritten);
            bool TryWriteSignificandBigEndian(System.Span<System.Byte> destination, out int bytesWritten);
            bool TryWriteSignificandLittleEndian(System.Span<System.Byte> destination, out int bytesWritten);
            int WriteExponentBigEndian(System.Byte[] destination) => throw null;
            int WriteExponentBigEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteExponentBigEndian(System.Span<System.Byte> destination) => throw null;
            int WriteExponentLittleEndian(System.Byte[] destination) => throw null;
            int WriteExponentLittleEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteExponentLittleEndian(System.Span<System.Byte> destination) => throw null;
            int WriteSignificandBigEndian(System.Byte[] destination) => throw null;
            int WriteSignificandBigEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteSignificandBigEndian(System.Span<System.Byte> destination) => throw null;
            int WriteSignificandLittleEndian(System.Byte[] destination) => throw null;
            int WriteSignificandLittleEndian(System.Byte[] destination, int startIndex) => throw null;
            int WriteSignificandLittleEndian(System.Span<System.Byte> destination) => throw null;
        }

        public interface IFloatingPointConstants<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IFloatingPointConstants<TSelf>
        {
            static abstract TSelf E { get; }
            static abstract TSelf Pi { get; }
            static abstract TSelf Tau { get; }
        }

        public interface IFloatingPointIeee754<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IExponentialFunctions<TSelf>, System.Numerics.IFloatingPoint<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IHyperbolicFunctions<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.ILogarithmicFunctions<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.IPowerFunctions<TSelf>, System.Numerics.IRootFunctions<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.ITrigonometricFunctions<TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IFloatingPointIeee754<TSelf>
        {
            static abstract TSelf Atan2(TSelf y, TSelf x);
            static abstract TSelf Atan2Pi(TSelf y, TSelf x);
            static abstract TSelf BitDecrement(TSelf x);
            static abstract TSelf BitIncrement(TSelf x);
            static abstract TSelf Epsilon { get; }
            static abstract TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend);
            static abstract int ILogB(TSelf x);
            static abstract TSelf Ieee754Remainder(TSelf left, TSelf right);
            static abstract TSelf NaN { get; }
            static abstract TSelf NegativeInfinity { get; }
            static abstract TSelf NegativeZero { get; }
            static abstract TSelf PositiveInfinity { get; }
            static virtual TSelf ReciprocalEstimate(TSelf x) => throw null;
            static virtual TSelf ReciprocalSqrtEstimate(TSelf x) => throw null;
            static abstract TSelf ScaleB(TSelf x, int n);
        }

        public interface IHyperbolicFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IHyperbolicFunctions<TSelf>
        {
            static abstract TSelf Acosh(TSelf x);
            static abstract TSelf Asinh(TSelf x);
            static abstract TSelf Atanh(TSelf x);
            static abstract TSelf Cosh(TSelf x);
            static abstract TSelf Sinh(TSelf x);
            static abstract TSelf Tanh(TSelf x);
        }

        public interface IIncrementOperators<TSelf> where TSelf : System.Numerics.IIncrementOperators<TSelf>
        {
            static abstract TSelf operator ++(TSelf value);
            static virtual TSelf operator checked ++(TSelf value) => throw null;
        }

        public interface ILogarithmicFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.ILogarithmicFunctions<TSelf>
        {
            static abstract TSelf Log(TSelf x);
            static abstract TSelf Log(TSelf x, TSelf newBase);
            static abstract TSelf Log10(TSelf x);
            static virtual TSelf Log10P1(TSelf x) => throw null;
            static abstract TSelf Log2(TSelf x);
            static virtual TSelf Log2P1(TSelf x) => throw null;
            static virtual TSelf LogP1(TSelf x) => throw null;
        }

        public interface IMinMaxValue<TSelf> where TSelf : System.Numerics.IMinMaxValue<TSelf>
        {
            static abstract TSelf MaxValue { get; }
            static abstract TSelf MinValue { get; }
        }

        public interface IModulusOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IModulusOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator %(TSelf left, TOther right);
        }

        public interface IMultiplicativeIdentity<TSelf, TResult> where TSelf : System.Numerics.IMultiplicativeIdentity<TSelf, TResult>
        {
            static abstract TResult MultiplicativeIdentity { get; }
        }

        public interface IMultiplyOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IMultiplyOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator *(TSelf left, TOther right);
            static virtual TResult operator checked *(TSelf left, TOther right) => throw null;
        }

        public interface INumber<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.INumber<TSelf>
        {
            static virtual TSelf Clamp(TSelf value, TSelf min, TSelf max) => throw null;
            static virtual TSelf CopySign(TSelf value, TSelf sign) => throw null;
            static virtual TSelf Max(TSelf x, TSelf y) => throw null;
            static virtual TSelf MaxNumber(TSelf x, TSelf y) => throw null;
            static virtual TSelf Min(TSelf x, TSelf y) => throw null;
            static virtual TSelf MinNumber(TSelf x, TSelf y) => throw null;
            static virtual int Sign(TSelf value) => throw null;
        }

        public interface INumberBase<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.INumberBase<TSelf>
        {
            static abstract TSelf Abs(TSelf value);
            static virtual TSelf CreateChecked<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            static virtual TSelf CreateSaturating<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            static virtual TSelf CreateTruncating<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            static abstract bool IsCanonical(TSelf value);
            static abstract bool IsComplexNumber(TSelf value);
            static abstract bool IsEvenInteger(TSelf value);
            static abstract bool IsFinite(TSelf value);
            static abstract bool IsImaginaryNumber(TSelf value);
            static abstract bool IsInfinity(TSelf value);
            static abstract bool IsInteger(TSelf value);
            static abstract bool IsNaN(TSelf value);
            static abstract bool IsNegative(TSelf value);
            static abstract bool IsNegativeInfinity(TSelf value);
            static abstract bool IsNormal(TSelf value);
            static abstract bool IsOddInteger(TSelf value);
            static abstract bool IsPositive(TSelf value);
            static abstract bool IsPositiveInfinity(TSelf value);
            static abstract bool IsRealNumber(TSelf value);
            static abstract bool IsSubnormal(TSelf value);
            static abstract bool IsZero(TSelf value);
            static abstract TSelf MaxMagnitude(TSelf x, TSelf y);
            static abstract TSelf MaxMagnitudeNumber(TSelf x, TSelf y);
            static abstract TSelf MinMagnitude(TSelf x, TSelf y);
            static abstract TSelf MinMagnitudeNumber(TSelf x, TSelf y);
            static abstract TSelf One { get; }
            static abstract TSelf Parse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
            static abstract TSelf Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
            static abstract int Radix { get; }
            static abstract bool TryConvertFromChecked<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryConvertFromSaturating<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryConvertFromTruncating<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryConvertToChecked<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryConvertToSaturating<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryConvertToTruncating<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            static abstract bool TryParse(System.ReadOnlySpan<System.Char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out TSelf result);
            static abstract bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out TSelf result);
            static abstract TSelf Zero { get; }
        }

        public interface IPowerFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IPowerFunctions<TSelf>
        {
            static abstract TSelf Pow(TSelf x, TSelf y);
        }

        public interface IRootFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IRootFunctions<TSelf>
        {
            static abstract TSelf Cbrt(TSelf x);
            static abstract TSelf Hypot(TSelf x, TSelf y);
            static abstract TSelf RootN(TSelf x, int n);
            static abstract TSelf Sqrt(TSelf x);
        }

        public interface IShiftOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IShiftOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator <<(TSelf value, TOther shiftAmount);
            static abstract TResult operator >>(TSelf value, TOther shiftAmount);
            static abstract TResult operator >>>(TSelf value, TOther shiftAmount);
        }

        public interface ISignedNumber<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.ISignedNumber<TSelf>
        {
            static abstract TSelf NegativeOne { get; }
        }

        public interface ISubtractionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.ISubtractionOperators<TSelf, TOther, TResult>
        {
            static abstract TResult operator -(TSelf left, TOther right);
            static virtual TResult operator checked -(TSelf left, TOther right) => throw null;
        }

        public interface ITrigonometricFunctions<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.ITrigonometricFunctions<TSelf>
        {
            static abstract TSelf Acos(TSelf x);
            static abstract TSelf AcosPi(TSelf x);
            static abstract TSelf Asin(TSelf x);
            static abstract TSelf AsinPi(TSelf x);
            static abstract TSelf Atan(TSelf x);
            static abstract TSelf AtanPi(TSelf x);
            static abstract TSelf Cos(TSelf x);
            static abstract TSelf CosPi(TSelf x);
            static abstract TSelf Sin(TSelf x);
            static abstract (TSelf, TSelf) SinCos(TSelf x);
            static abstract (TSelf, TSelf) SinCosPi(TSelf x);
            static abstract TSelf SinPi(TSelf x);
            static abstract TSelf Tan(TSelf x);
            static abstract TSelf TanPi(TSelf x);
        }

        public interface IUnaryNegationOperators<TSelf, TResult> where TSelf : System.Numerics.IUnaryNegationOperators<TSelf, TResult>
        {
            static abstract TResult operator -(TSelf value);
            static virtual TResult operator checked -(TSelf value) => throw null;
        }

        public interface IUnaryPlusOperators<TSelf, TResult> where TSelf : System.Numerics.IUnaryPlusOperators<TSelf, TResult>
        {
            static abstract TResult operator +(TSelf value);
        }

        public interface IUnsignedNumber<TSelf> : System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.IUnsignedNumber<TSelf>
        {
        }

    }
    namespace Reflection
    {
        public class AmbiguousMatchException : System.SystemException
        {
            public AmbiguousMatchException() => throw null;
            public AmbiguousMatchException(string message) => throw null;
            public AmbiguousMatchException(string message, System.Exception inner) => throw null;
        }

        public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable
        {
            public static bool operator !=(System.Reflection.Assembly left, System.Reflection.Assembly right) => throw null;
            public static bool operator ==(System.Reflection.Assembly left, System.Reflection.Assembly right) => throw null;
            protected Assembly() => throw null;
            public virtual string CodeBase { get => throw null; }
            public object CreateInstance(string typeName) => throw null;
            public object CreateInstance(string typeName, bool ignoreCase) => throw null;
            public virtual object CreateInstance(string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
            public static string CreateQualifiedName(string assemblyName, string typeName) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> DefinedTypes { get => throw null; }
            public virtual System.Reflection.MethodInfo EntryPoint { get => throw null; }
            public override bool Equals(object o) => throw null;
            public virtual string EscapedCodeBase { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Type> ExportedTypes { get => throw null; }
            public virtual string FullName { get => throw null; }
            public static System.Reflection.Assembly GetAssembly(System.Type type) => throw null;
            public static System.Reflection.Assembly GetCallingAssembly() => throw null;
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public static System.Reflection.Assembly GetEntryAssembly() => throw null;
            public static System.Reflection.Assembly GetExecutingAssembly() => throw null;
            public virtual System.Type[] GetExportedTypes() => throw null;
            public virtual System.IO.FileStream GetFile(string name) => throw null;
            public virtual System.IO.FileStream[] GetFiles() => throw null;
            public virtual System.IO.FileStream[] GetFiles(bool getResourceModules) => throw null;
            public virtual System.Type[] GetForwardedTypes() => throw null;
            public override int GetHashCode() => throw null;
            public System.Reflection.Module[] GetLoadedModules() => throw null;
            public virtual System.Reflection.Module[] GetLoadedModules(bool getResourceModules) => throw null;
            public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) => throw null;
            public virtual string[] GetManifestResourceNames() => throw null;
            public virtual System.IO.Stream GetManifestResourceStream(System.Type type, string name) => throw null;
            public virtual System.IO.Stream GetManifestResourceStream(string name) => throw null;
            public virtual System.Reflection.Module GetModule(string name) => throw null;
            public System.Reflection.Module[] GetModules() => throw null;
            public virtual System.Reflection.Module[] GetModules(bool getResourceModules) => throw null;
            public virtual System.Reflection.AssemblyName GetName() => throw null;
            public virtual System.Reflection.AssemblyName GetName(bool copiedName) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies() => throw null;
            public virtual System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture) => throw null;
            public virtual System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version) => throw null;
            public virtual System.Type GetType(string name) => throw null;
            public virtual System.Type GetType(string name, bool throwOnError) => throw null;
            public virtual System.Type GetType(string name, bool throwOnError, bool ignoreCase) => throw null;
            public virtual System.Type[] GetTypes() => throw null;
            public virtual bool GlobalAssemblyCache { get => throw null; }
            public virtual System.Int64 HostContext { get => throw null; }
            public virtual string ImageRuntimeVersion { get => throw null; }
            public virtual bool IsCollectible { get => throw null; }
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public virtual bool IsDynamic { get => throw null; }
            public bool IsFullyTrusted { get => throw null; }
            public static System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef) => throw null;
            public static System.Reflection.Assembly Load(System.Byte[] rawAssembly) => throw null;
            public static System.Reflection.Assembly Load(System.Byte[] rawAssembly, System.Byte[] rawSymbolStore) => throw null;
            public static System.Reflection.Assembly Load(string assemblyString) => throw null;
            public static System.Reflection.Assembly LoadFile(string path) => throw null;
            public static System.Reflection.Assembly LoadFrom(string assemblyFile) => throw null;
            public static System.Reflection.Assembly LoadFrom(string assemblyFile, System.Byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) => throw null;
            public System.Reflection.Module LoadModule(string moduleName, System.Byte[] rawModule) => throw null;
            public virtual System.Reflection.Module LoadModule(string moduleName, System.Byte[] rawModule, System.Byte[] rawSymbolStore) => throw null;
            public static System.Reflection.Assembly LoadWithPartialName(string partialName) => throw null;
            public virtual string Location { get => throw null; }
            public virtual System.Reflection.Module ManifestModule { get => throw null; }
            public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.Module> Modules { get => throw null; }
            public virtual bool ReflectionOnly { get => throw null; }
            public static System.Reflection.Assembly ReflectionOnlyLoad(System.Byte[] rawAssembly) => throw null;
            public static System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) => throw null;
            public static System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) => throw null;
            public virtual System.Security.SecurityRuleSet SecurityRuleSet { get => throw null; }
            public override string ToString() => throw null;
            public static System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) => throw null;
        }

        public class AssemblyAlgorithmIdAttribute : System.Attribute
        {
            public System.UInt32 AlgorithmId { get => throw null; }
            public AssemblyAlgorithmIdAttribute(System.Configuration.Assemblies.AssemblyHashAlgorithm algorithmId) => throw null;
            public AssemblyAlgorithmIdAttribute(System.UInt32 algorithmId) => throw null;
        }

        public class AssemblyCompanyAttribute : System.Attribute
        {
            public AssemblyCompanyAttribute(string company) => throw null;
            public string Company { get => throw null; }
        }

        public class AssemblyConfigurationAttribute : System.Attribute
        {
            public AssemblyConfigurationAttribute(string configuration) => throw null;
            public string Configuration { get => throw null; }
        }

        public enum AssemblyContentType : int
        {
            Default = 0,
            WindowsRuntime = 1,
        }

        public class AssemblyCopyrightAttribute : System.Attribute
        {
            public AssemblyCopyrightAttribute(string copyright) => throw null;
            public string Copyright { get => throw null; }
        }

        public class AssemblyCultureAttribute : System.Attribute
        {
            public AssemblyCultureAttribute(string culture) => throw null;
            public string Culture { get => throw null; }
        }

        public class AssemblyDefaultAliasAttribute : System.Attribute
        {
            public AssemblyDefaultAliasAttribute(string defaultAlias) => throw null;
            public string DefaultAlias { get => throw null; }
        }

        public class AssemblyDelaySignAttribute : System.Attribute
        {
            public AssemblyDelaySignAttribute(bool delaySign) => throw null;
            public bool DelaySign { get => throw null; }
        }

        public class AssemblyDescriptionAttribute : System.Attribute
        {
            public AssemblyDescriptionAttribute(string description) => throw null;
            public string Description { get => throw null; }
        }

        public class AssemblyFileVersionAttribute : System.Attribute
        {
            public AssemblyFileVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }

        public class AssemblyFlagsAttribute : System.Attribute
        {
            public int AssemblyFlags { get => throw null; }
            public AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags assemblyFlags) => throw null;
            public AssemblyFlagsAttribute(int assemblyFlags) => throw null;
            public AssemblyFlagsAttribute(System.UInt32 flags) => throw null;
            public System.UInt32 Flags { get => throw null; }
        }

        public class AssemblyInformationalVersionAttribute : System.Attribute
        {
            public AssemblyInformationalVersionAttribute(string informationalVersion) => throw null;
            public string InformationalVersion { get => throw null; }
        }

        public class AssemblyKeyFileAttribute : System.Attribute
        {
            public AssemblyKeyFileAttribute(string keyFile) => throw null;
            public string KeyFile { get => throw null; }
        }

        public class AssemblyKeyNameAttribute : System.Attribute
        {
            public AssemblyKeyNameAttribute(string keyName) => throw null;
            public string KeyName { get => throw null; }
        }

        public class AssemblyMetadataAttribute : System.Attribute
        {
            public AssemblyMetadataAttribute(string key, string value) => throw null;
            public string Key { get => throw null; }
            public string Value { get => throw null; }
        }

        public class AssemblyName : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public AssemblyName() => throw null;
            public AssemblyName(string assemblyName) => throw null;
            public object Clone() => throw null;
            public string CodeBase { get => throw null; set => throw null; }
            public System.Reflection.AssemblyContentType ContentType { get => throw null; set => throw null; }
            public System.Globalization.CultureInfo CultureInfo { get => throw null; set => throw null; }
            public string CultureName { get => throw null; set => throw null; }
            public string EscapedCodeBase { get => throw null; }
            public System.Reflection.AssemblyNameFlags Flags { get => throw null; set => throw null; }
            public string FullName { get => throw null; }
            public static System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) => throw null;
            public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.Byte[] GetPublicKey() => throw null;
            public System.Byte[] GetPublicKeyToken() => throw null;
            public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get => throw null; set => throw null; }
            public System.Reflection.StrongNameKeyPair KeyPair { get => throw null; set => throw null; }
            public string Name { get => throw null; set => throw null; }
            public void OnDeserialization(object sender) => throw null;
            public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get => throw null; set => throw null; }
            public static bool ReferenceMatchesDefinition(System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition) => throw null;
            public void SetPublicKey(System.Byte[] publicKey) => throw null;
            public void SetPublicKeyToken(System.Byte[] publicKeyToken) => throw null;
            public override string ToString() => throw null;
            public System.Version Version { get => throw null; set => throw null; }
            public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get => throw null; set => throw null; }
        }

        [System.Flags]
        public enum AssemblyNameFlags : int
        {
            EnableJITcompileOptimizer = 16384,
            EnableJITcompileTracking = 32768,
            None = 0,
            PublicKey = 1,
            Retargetable = 256,
        }

        public class AssemblyNameProxy : System.MarshalByRefObject
        {
            public AssemblyNameProxy() => throw null;
            public System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) => throw null;
        }

        public class AssemblyProductAttribute : System.Attribute
        {
            public AssemblyProductAttribute(string product) => throw null;
            public string Product { get => throw null; }
        }

        public class AssemblySignatureKeyAttribute : System.Attribute
        {
            public AssemblySignatureKeyAttribute(string publicKey, string countersignature) => throw null;
            public string Countersignature { get => throw null; }
            public string PublicKey { get => throw null; }
        }

        public class AssemblyTitleAttribute : System.Attribute
        {
            public AssemblyTitleAttribute(string title) => throw null;
            public string Title { get => throw null; }
        }

        public class AssemblyTrademarkAttribute : System.Attribute
        {
            public AssemblyTrademarkAttribute(string trademark) => throw null;
            public string Trademark { get => throw null; }
        }

        public class AssemblyVersionAttribute : System.Attribute
        {
            public AssemblyVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }

        public abstract class Binder
        {
            public abstract System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);
            public abstract System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);
            protected Binder() => throw null;
            public abstract object ChangeType(object value, System.Type type, System.Globalization.CultureInfo culture);
            public abstract void ReorderArgumentArray(ref object[] args, object state);
            public abstract System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            public abstract System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
        }

        [System.Flags]
        public enum BindingFlags : int
        {
            CreateInstance = 512,
            DeclaredOnly = 2,
            Default = 0,
            DoNotWrapExceptions = 33554432,
            ExactBinding = 65536,
            FlattenHierarchy = 64,
            GetField = 1024,
            GetProperty = 4096,
            IgnoreCase = 1,
            IgnoreReturn = 16777216,
            Instance = 4,
            InvokeMethod = 256,
            NonPublic = 32,
            OptionalParamBinding = 262144,
            Public = 16,
            PutDispProperty = 16384,
            PutRefDispProperty = 32768,
            SetField = 2048,
            SetProperty = 8192,
            Static = 8,
            SuppressChangeType = 131072,
        }

        [System.Flags]
        public enum CallingConventions : int
        {
            Any = 3,
            ExplicitThis = 64,
            HasThis = 32,
            Standard = 1,
            VarArgs = 2,
        }

        public abstract class ConstructorInfo : System.Reflection.MethodBase
        {
            public static bool operator !=(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right) => throw null;
            public static bool operator ==(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right) => throw null;
            protected ConstructorInfo() => throw null;
            public static string ConstructorName;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public abstract object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            public object Invoke(object[] parameters) => throw null;
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static string TypeConstructorName;
        }

        public class CustomAttributeData
        {
            public virtual System.Type AttributeType { get => throw null; }
            public virtual System.Reflection.ConstructorInfo Constructor { get => throw null; }
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ConstructorArguments { get => throw null; }
            protected CustomAttributeData() => throw null;
            public override bool Equals(object obj) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Assembly target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.MemberInfo target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Module target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.ParameterInfo target) => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> NamedArguments { get => throw null; }
            public override string ToString() => throw null;
        }

        public static class CustomAttributeExtensions
        {
            public static System.Attribute GetCustomAttribute(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.Assembly element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.MemberInfo element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.MemberInfo element, bool inherit) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.Module element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.ParameterInfo element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.ParameterInfo element, bool inherit) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Assembly element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Module element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.Assembly element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.MemberInfo element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.MemberInfo element, bool inherit) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.Module element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.ParameterInfo element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.ParameterInfo element, bool inherit) where T : System.Attribute => throw null;
            public static bool IsDefined(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static bool IsDefined(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        }

        public class CustomAttributeFormatException : System.FormatException
        {
            public CustomAttributeFormatException() => throw null;
            protected CustomAttributeFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public CustomAttributeFormatException(string message) => throw null;
            public CustomAttributeFormatException(string message, System.Exception inner) => throw null;
        }

        public struct CustomAttributeNamedArgument : System.IEquatable<System.Reflection.CustomAttributeNamedArgument>
        {
            public static bool operator !=(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right) => throw null;
            public static bool operator ==(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right) => throw null;
            // Stub generator skipped constructor 
            public CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, System.Reflection.CustomAttributeTypedArgument typedArgument) => throw null;
            public CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, object value) => throw null;
            public bool Equals(System.Reflection.CustomAttributeNamedArgument other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsField { get => throw null; }
            public System.Reflection.MemberInfo MemberInfo { get => throw null; }
            public string MemberName { get => throw null; }
            public override string ToString() => throw null;
            public System.Reflection.CustomAttributeTypedArgument TypedValue { get => throw null; }
        }

        public struct CustomAttributeTypedArgument : System.IEquatable<System.Reflection.CustomAttributeTypedArgument>
        {
            public static bool operator !=(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right) => throw null;
            public static bool operator ==(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right) => throw null;
            public System.Type ArgumentType { get => throw null; }
            // Stub generator skipped constructor 
            public CustomAttributeTypedArgument(System.Type argumentType, object value) => throw null;
            public CustomAttributeTypedArgument(object value) => throw null;
            public bool Equals(System.Reflection.CustomAttributeTypedArgument other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public override string ToString() => throw null;
            public object Value { get => throw null; }
        }

        public class DefaultMemberAttribute : System.Attribute
        {
            public DefaultMemberAttribute(string memberName) => throw null;
            public string MemberName { get => throw null; }
        }

        [System.Flags]
        public enum EventAttributes : int
        {
            None = 0,
            RTSpecialName = 1024,
            ReservedMask = 1024,
            SpecialName = 512,
        }

        public abstract class EventInfo : System.Reflection.MemberInfo
        {
            public static bool operator !=(System.Reflection.EventInfo left, System.Reflection.EventInfo right) => throw null;
            public static bool operator ==(System.Reflection.EventInfo left, System.Reflection.EventInfo right) => throw null;
            public virtual void AddEventHandler(object target, System.Delegate handler) => throw null;
            public virtual System.Reflection.MethodInfo AddMethod { get => throw null; }
            public abstract System.Reflection.EventAttributes Attributes { get; }
            public override bool Equals(object obj) => throw null;
            public virtual System.Type EventHandlerType { get => throw null; }
            protected EventInfo() => throw null;
            public System.Reflection.MethodInfo GetAddMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            public override int GetHashCode() => throw null;
            public System.Reflection.MethodInfo[] GetOtherMethods() => throw null;
            public virtual System.Reflection.MethodInfo[] GetOtherMethods(bool nonPublic) => throw null;
            public System.Reflection.MethodInfo GetRaiseMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            public System.Reflection.MethodInfo GetRemoveMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            public virtual bool IsMulticast { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public virtual System.Reflection.MethodInfo RaiseMethod { get => throw null; }
            public virtual void RemoveEventHandler(object target, System.Delegate handler) => throw null;
            public virtual System.Reflection.MethodInfo RemoveMethod { get => throw null; }
        }

        public class ExceptionHandlingClause
        {
            public virtual System.Type CatchType { get => throw null; }
            protected ExceptionHandlingClause() => throw null;
            public virtual int FilterOffset { get => throw null; }
            public virtual System.Reflection.ExceptionHandlingClauseOptions Flags { get => throw null; }
            public virtual int HandlerLength { get => throw null; }
            public virtual int HandlerOffset { get => throw null; }
            public override string ToString() => throw null;
            public virtual int TryLength { get => throw null; }
            public virtual int TryOffset { get => throw null; }
        }

        [System.Flags]
        public enum ExceptionHandlingClauseOptions : int
        {
            Clause = 0,
            Fault = 4,
            Filter = 1,
            Finally = 2,
        }

        [System.Flags]
        public enum FieldAttributes : int
        {
            Assembly = 3,
            FamANDAssem = 2,
            FamORAssem = 5,
            Family = 4,
            FieldAccessMask = 7,
            HasDefault = 32768,
            HasFieldMarshal = 4096,
            HasFieldRVA = 256,
            InitOnly = 32,
            Literal = 64,
            NotSerialized = 128,
            PinvokeImpl = 8192,
            Private = 1,
            PrivateScope = 0,
            Public = 6,
            RTSpecialName = 1024,
            ReservedMask = 38144,
            SpecialName = 512,
            Static = 16,
        }

        public abstract class FieldInfo : System.Reflection.MemberInfo
        {
            public static bool operator !=(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right) => throw null;
            public static bool operator ==(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right) => throw null;
            public abstract System.Reflection.FieldAttributes Attributes { get; }
            public override bool Equals(object obj) => throw null;
            public abstract System.RuntimeFieldHandle FieldHandle { get; }
            protected FieldInfo() => throw null;
            public abstract System.Type FieldType { get; }
            public static System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle) => throw null;
            public static System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle, System.RuntimeTypeHandle declaringType) => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public virtual object GetRawConstantValue() => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public abstract object GetValue(object obj);
            public virtual object GetValueDirect(System.TypedReference obj) => throw null;
            public bool IsAssembly { get => throw null; }
            public bool IsFamily { get => throw null; }
            public bool IsFamilyAndAssembly { get => throw null; }
            public bool IsFamilyOrAssembly { get => throw null; }
            public bool IsInitOnly { get => throw null; }
            public bool IsLiteral { get => throw null; }
            public bool IsNotSerialized { get => throw null; }
            public bool IsPinvokeImpl { get => throw null; }
            public bool IsPrivate { get => throw null; }
            public bool IsPublic { get => throw null; }
            public virtual bool IsSecurityCritical { get => throw null; }
            public virtual bool IsSecuritySafeCritical { get => throw null; }
            public virtual bool IsSecurityTransparent { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public bool IsStatic { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public void SetValue(object obj, object value) => throw null;
            public abstract void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            public virtual void SetValueDirect(System.TypedReference obj, object value) => throw null;
        }

        [System.Flags]
        public enum GenericParameterAttributes : int
        {
            Contravariant = 2,
            Covariant = 1,
            DefaultConstructorConstraint = 16,
            None = 0,
            NotNullableValueTypeConstraint = 8,
            ReferenceTypeConstraint = 4,
            SpecialConstraintMask = 28,
            VarianceMask = 3,
        }

        public interface ICustomAttributeProvider
        {
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            object[] GetCustomAttributes(bool inherit);
            bool IsDefined(System.Type attributeType, bool inherit);
        }

        public interface IReflect
        {
            System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            System.Type UnderlyingSystemType { get; }
        }

        public interface IReflectableType
        {
            System.Reflection.TypeInfo GetTypeInfo();
        }

        public enum ImageFileMachine : int
        {
            AMD64 = 34404,
            ARM = 452,
            I386 = 332,
            IA64 = 512,
        }

        public struct InterfaceMapping
        {
            // Stub generator skipped constructor 
            public System.Reflection.MethodInfo[] InterfaceMethods;
            public System.Type InterfaceType;
            public System.Reflection.MethodInfo[] TargetMethods;
            public System.Type TargetType;
        }

        public static class IntrospectionExtensions
        {
            public static System.Reflection.TypeInfo GetTypeInfo(this System.Type type) => throw null;
        }

        public class InvalidFilterCriteriaException : System.ApplicationException
        {
            public InvalidFilterCriteriaException() => throw null;
            protected InvalidFilterCriteriaException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public InvalidFilterCriteriaException(string message) => throw null;
            public InvalidFilterCriteriaException(string message, System.Exception inner) => throw null;
        }

        public class LocalVariableInfo
        {
            public virtual bool IsPinned { get => throw null; }
            public virtual int LocalIndex { get => throw null; }
            public virtual System.Type LocalType { get => throw null; }
            protected LocalVariableInfo() => throw null;
            public override string ToString() => throw null;
        }

        public class ManifestResourceInfo
        {
            public virtual string FileName { get => throw null; }
            public ManifestResourceInfo(System.Reflection.Assembly containingAssembly, string containingFileName, System.Reflection.ResourceLocation resourceLocation) => throw null;
            public virtual System.Reflection.Assembly ReferencedAssembly { get => throw null; }
            public virtual System.Reflection.ResourceLocation ResourceLocation { get => throw null; }
        }

        public delegate bool MemberFilter(System.Reflection.MemberInfo m, object filterCriteria);

        public abstract class MemberInfo : System.Reflection.ICustomAttributeProvider
        {
            public static bool operator !=(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right) => throw null;
            public static bool operator ==(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public abstract System.Type DeclaringType { get; }
            public override bool Equals(object obj) => throw null;
            public abstract object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            public abstract object[] GetCustomAttributes(bool inherit);
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public override int GetHashCode() => throw null;
            public virtual bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other) => throw null;
            public virtual bool IsCollectible { get => throw null; }
            public abstract bool IsDefined(System.Type attributeType, bool inherit);
            protected MemberInfo() => throw null;
            public abstract System.Reflection.MemberTypes MemberType { get; }
            public virtual int MetadataToken { get => throw null; }
            public virtual System.Reflection.Module Module { get => throw null; }
            public abstract string Name { get; }
            public abstract System.Type ReflectedType { get; }
        }

        [System.Flags]
        public enum MemberTypes : int
        {
            All = 191,
            Constructor = 1,
            Custom = 64,
            Event = 2,
            Field = 4,
            Method = 8,
            NestedType = 128,
            Property = 16,
            TypeInfo = 32,
        }

        [System.Flags]
        public enum MethodAttributes : int
        {
            Abstract = 1024,
            Assembly = 3,
            CheckAccessOnOverride = 512,
            FamANDAssem = 2,
            FamORAssem = 5,
            Family = 4,
            Final = 32,
            HasSecurity = 16384,
            HideBySig = 128,
            MemberAccessMask = 7,
            NewSlot = 256,
            PinvokeImpl = 8192,
            Private = 1,
            PrivateScope = 0,
            Public = 6,
            RTSpecialName = 4096,
            RequireSecObject = 32768,
            ReservedMask = 53248,
            ReuseSlot = 0,
            SpecialName = 2048,
            Static = 16,
            UnmanagedExport = 8,
            Virtual = 64,
            VtableLayoutMask = 256,
        }

        public abstract class MethodBase : System.Reflection.MemberInfo
        {
            public static bool operator !=(System.Reflection.MethodBase left, System.Reflection.MethodBase right) => throw null;
            public static bool operator ==(System.Reflection.MethodBase left, System.Reflection.MethodBase right) => throw null;
            public abstract System.Reflection.MethodAttributes Attributes { get; }
            public virtual System.Reflection.CallingConventions CallingConvention { get => throw null; }
            public virtual bool ContainsGenericParameters { get => throw null; }
            public override bool Equals(object obj) => throw null;
            public static System.Reflection.MethodBase GetCurrentMethod() => throw null;
            public virtual System.Type[] GetGenericArguments() => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Reflection.MethodBody GetMethodBody() => throw null;
            public static System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle) => throw null;
            public static System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle, System.RuntimeTypeHandle declaringType) => throw null;
            public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            public abstract System.Reflection.ParameterInfo[] GetParameters();
            public abstract object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            public object Invoke(object obj, object[] parameters) => throw null;
            public bool IsAbstract { get => throw null; }
            public bool IsAssembly { get => throw null; }
            public virtual bool IsConstructedGenericMethod { get => throw null; }
            public bool IsConstructor { get => throw null; }
            public bool IsFamily { get => throw null; }
            public bool IsFamilyAndAssembly { get => throw null; }
            public bool IsFamilyOrAssembly { get => throw null; }
            public bool IsFinal { get => throw null; }
            public virtual bool IsGenericMethod { get => throw null; }
            public virtual bool IsGenericMethodDefinition { get => throw null; }
            public bool IsHideBySig { get => throw null; }
            public bool IsPrivate { get => throw null; }
            public bool IsPublic { get => throw null; }
            public virtual bool IsSecurityCritical { get => throw null; }
            public virtual bool IsSecuritySafeCritical { get => throw null; }
            public virtual bool IsSecurityTransparent { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public bool IsStatic { get => throw null; }
            public bool IsVirtual { get => throw null; }
            protected MethodBase() => throw null;
            public abstract System.RuntimeMethodHandle MethodHandle { get; }
            public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get => throw null; }
        }

        public class MethodBody
        {
            public virtual System.Collections.Generic.IList<System.Reflection.ExceptionHandlingClause> ExceptionHandlingClauses { get => throw null; }
            public virtual System.Byte[] GetILAsByteArray() => throw null;
            public virtual bool InitLocals { get => throw null; }
            public virtual int LocalSignatureMetadataToken { get => throw null; }
            public virtual System.Collections.Generic.IList<System.Reflection.LocalVariableInfo> LocalVariables { get => throw null; }
            public virtual int MaxStackSize { get => throw null; }
            protected MethodBody() => throw null;
        }

        public enum MethodImplAttributes : int
        {
            AggressiveInlining = 256,
            AggressiveOptimization = 512,
            CodeTypeMask = 3,
            ForwardRef = 16,
            IL = 0,
            InternalCall = 4096,
            Managed = 0,
            ManagedMask = 4,
            MaxMethodImplVal = 65535,
            Native = 1,
            NoInlining = 8,
            NoOptimization = 64,
            OPTIL = 2,
            PreserveSig = 128,
            Runtime = 3,
            Synchronized = 32,
            Unmanaged = 4,
        }

        public abstract class MethodInfo : System.Reflection.MethodBase
        {
            public static bool operator !=(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right) => throw null;
            public static bool operator ==(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right) => throw null;
            public virtual System.Delegate CreateDelegate(System.Type delegateType) => throw null;
            public virtual System.Delegate CreateDelegate(System.Type delegateType, object target) => throw null;
            public T CreateDelegate<T>() where T : System.Delegate => throw null;
            public T CreateDelegate<T>(object target) where T : System.Delegate => throw null;
            public override bool Equals(object obj) => throw null;
            public abstract System.Reflection.MethodInfo GetBaseDefinition();
            public override System.Type[] GetGenericArguments() => throw null;
            public virtual System.Reflection.MethodInfo GetGenericMethodDefinition() => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Reflection.MethodInfo MakeGenericMethod(params System.Type[] typeArguments) => throw null;
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            protected MethodInfo() => throw null;
            public virtual System.Reflection.ParameterInfo ReturnParameter { get => throw null; }
            public virtual System.Type ReturnType { get => throw null; }
            public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
        }

        public class Missing : System.Runtime.Serialization.ISerializable
        {
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public static System.Reflection.Missing Value;
        }

        public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable
        {
            public static bool operator !=(System.Reflection.Module left, System.Reflection.Module right) => throw null;
            public static bool operator ==(System.Reflection.Module left, System.Reflection.Module right) => throw null;
            public virtual System.Reflection.Assembly Assembly { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public override bool Equals(object o) => throw null;
            public static System.Reflection.TypeFilter FilterTypeName;
            public static System.Reflection.TypeFilter FilterTypeNameIgnoreCase;
            public virtual System.Type[] FindTypes(System.Reflection.TypeFilter filter, object filterCriteria) => throw null;
            public virtual string FullyQualifiedName { get => throw null; }
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public System.Reflection.FieldInfo GetField(string name) => throw null;
            public virtual System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public System.Reflection.FieldInfo[] GetFields() => throw null;
            public virtual System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingFlags) => throw null;
            public override int GetHashCode() => throw null;
            public System.Reflection.MethodInfo GetMethod(string name) => throw null;
            public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types) => throw null;
            protected virtual System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public System.Reflection.MethodInfo[] GetMethods() => throw null;
            public virtual System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingFlags) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual void GetPEKind(out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine) => throw null;
            public virtual System.Type GetType(string className) => throw null;
            public virtual System.Type GetType(string className, bool ignoreCase) => throw null;
            public virtual System.Type GetType(string className, bool throwOnError, bool ignoreCase) => throw null;
            public virtual System.Type[] GetTypes() => throw null;
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public virtual bool IsResource() => throw null;
            public virtual int MDStreamVersion { get => throw null; }
            public virtual int MetadataToken { get => throw null; }
            protected Module() => throw null;
            public System.ModuleHandle ModuleHandle { get => throw null; }
            public virtual System.Guid ModuleVersionId { get => throw null; }
            public virtual string Name { get => throw null; }
            public System.Reflection.FieldInfo ResolveField(int metadataToken) => throw null;
            public virtual System.Reflection.FieldInfo ResolveField(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public System.Reflection.MemberInfo ResolveMember(int metadataToken) => throw null;
            public virtual System.Reflection.MemberInfo ResolveMember(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public System.Reflection.MethodBase ResolveMethod(int metadataToken) => throw null;
            public virtual System.Reflection.MethodBase ResolveMethod(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public virtual System.Byte[] ResolveSignature(int metadataToken) => throw null;
            public virtual string ResolveString(int metadataToken) => throw null;
            public System.Type ResolveType(int metadataToken) => throw null;
            public virtual System.Type ResolveType(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public virtual string ScopeName { get => throw null; }
            public override string ToString() => throw null;
        }

        public delegate System.Reflection.Module ModuleResolveEventHandler(object sender, System.ResolveEventArgs e);

        public class NullabilityInfo
        {
            public System.Reflection.NullabilityInfo ElementType { get => throw null; }
            public System.Reflection.NullabilityInfo[] GenericTypeArguments { get => throw null; }
            public System.Reflection.NullabilityState ReadState { get => throw null; }
            public System.Type Type { get => throw null; }
            public System.Reflection.NullabilityState WriteState { get => throw null; }
        }

        public class NullabilityInfoContext
        {
            public System.Reflection.NullabilityInfo Create(System.Reflection.EventInfo eventInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.FieldInfo fieldInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.ParameterInfo parameterInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.PropertyInfo propertyInfo) => throw null;
            public NullabilityInfoContext() => throw null;
        }

        public enum NullabilityState : int
        {
            NotNull = 1,
            Nullable = 2,
            Unknown = 0,
        }

        public class ObfuscateAssemblyAttribute : System.Attribute
        {
            public bool AssemblyIsPrivate { get => throw null; }
            public ObfuscateAssemblyAttribute(bool assemblyIsPrivate) => throw null;
            public bool StripAfterObfuscation { get => throw null; set => throw null; }
        }

        public class ObfuscationAttribute : System.Attribute
        {
            public bool ApplyToMembers { get => throw null; set => throw null; }
            public bool Exclude { get => throw null; set => throw null; }
            public string Feature { get => throw null; set => throw null; }
            public ObfuscationAttribute() => throw null;
            public bool StripAfterObfuscation { get => throw null; set => throw null; }
        }

        [System.Flags]
        public enum ParameterAttributes : int
        {
            HasDefault = 4096,
            HasFieldMarshal = 8192,
            In = 1,
            Lcid = 4,
            None = 0,
            Optional = 16,
            Out = 2,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 61440,
            Retval = 8,
        }

        public class ParameterInfo : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.IObjectReference
        {
            public virtual System.Reflection.ParameterAttributes Attributes { get => throw null; }
            protected System.Reflection.ParameterAttributes AttrsImpl;
            protected System.Type ClassImpl;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public virtual object DefaultValue { get => throw null; }
            protected object DefaultValueImpl;
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public object GetRealObject(System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public virtual bool HasDefaultValue { get => throw null; }
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public bool IsIn { get => throw null; }
            public bool IsLcid { get => throw null; }
            public bool IsOptional { get => throw null; }
            public bool IsOut { get => throw null; }
            public bool IsRetval { get => throw null; }
            public virtual System.Reflection.MemberInfo Member { get => throw null; }
            protected System.Reflection.MemberInfo MemberImpl;
            public virtual int MetadataToken { get => throw null; }
            public virtual string Name { get => throw null; }
            protected string NameImpl;
            protected ParameterInfo() => throw null;
            public virtual System.Type ParameterType { get => throw null; }
            public virtual int Position { get => throw null; }
            protected int PositionImpl;
            public virtual object RawDefaultValue { get => throw null; }
            public override string ToString() => throw null;
        }

        public struct ParameterModifier
        {
            public bool this[int index] { get => throw null; set => throw null; }
            // Stub generator skipped constructor 
            public ParameterModifier(int parameterCount) => throw null;
        }

        public class Pointer : System.Runtime.Serialization.ISerializable
        {
            unsafe public static object Box(void* ptr, System.Type type) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            unsafe public static void* Unbox(object ptr) => throw null;
        }

        [System.Flags]
        public enum PortableExecutableKinds : int
        {
            ILOnly = 1,
            NotAPortableExecutableImage = 0,
            PE32Plus = 4,
            Preferred32Bit = 16,
            Required32Bit = 2,
            Unmanaged32Bit = 8,
        }

        public enum ProcessorArchitecture : int
        {
            Amd64 = 4,
            Arm = 5,
            IA64 = 3,
            MSIL = 1,
            None = 0,
            X86 = 2,
        }

        [System.Flags]
        public enum PropertyAttributes : int
        {
            HasDefault = 4096,
            None = 0,
            RTSpecialName = 1024,
            Reserved2 = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 62464,
            SpecialName = 512,
        }

        public abstract class PropertyInfo : System.Reflection.MemberInfo
        {
            public static bool operator !=(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right) => throw null;
            public static bool operator ==(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right) => throw null;
            public abstract System.Reflection.PropertyAttributes Attributes { get; }
            public abstract bool CanRead { get; }
            public abstract bool CanWrite { get; }
            public override bool Equals(object obj) => throw null;
            public System.Reflection.MethodInfo[] GetAccessors() => throw null;
            public abstract System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
            public virtual object GetConstantValue() => throw null;
            public System.Reflection.MethodInfo GetGetMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            public override int GetHashCode() => throw null;
            public abstract System.Reflection.ParameterInfo[] GetIndexParameters();
            public virtual System.Reflection.MethodInfo GetMethod { get => throw null; }
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public virtual object GetRawConstantValue() => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public System.Reflection.MethodInfo GetSetMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            public object GetValue(object obj) => throw null;
            public abstract object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            public virtual object GetValue(object obj, object[] index) => throw null;
            public bool IsSpecialName { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            protected PropertyInfo() => throw null;
            public abstract System.Type PropertyType { get; }
            public virtual System.Reflection.MethodInfo SetMethod { get => throw null; }
            public void SetValue(object obj, object value) => throw null;
            public abstract void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            public virtual void SetValue(object obj, object value, object[] index) => throw null;
        }

        public abstract class ReflectionContext
        {
            public virtual System.Reflection.TypeInfo GetTypeForObject(object value) => throw null;
            public abstract System.Reflection.Assembly MapAssembly(System.Reflection.Assembly assembly);
            public abstract System.Reflection.TypeInfo MapType(System.Reflection.TypeInfo type);
            protected ReflectionContext() => throw null;
        }

        public class ReflectionTypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
        {
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.Exception[] LoaderExceptions { get => throw null; }
            public override string Message { get => throw null; }
            public ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions) => throw null;
            public ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions, string message) => throw null;
            public override string ToString() => throw null;
            public System.Type[] Types { get => throw null; }
        }

        [System.Flags]
        public enum ResourceAttributes : int
        {
            Private = 2,
            Public = 1,
        }

        [System.Flags]
        public enum ResourceLocation : int
        {
            ContainedInAnotherAssembly = 2,
            ContainedInManifestFile = 4,
            Embedded = 1,
        }

        public static class RuntimeReflectionExtensions
        {
            public static System.Reflection.MethodInfo GetMethodInfo(this System.Delegate del) => throw null;
            public static System.Reflection.MethodInfo GetRuntimeBaseDefinition(this System.Reflection.MethodInfo method) => throw null;
            public static System.Reflection.EventInfo GetRuntimeEvent(this System.Type type, string name) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> GetRuntimeEvents(this System.Type type) => throw null;
            public static System.Reflection.FieldInfo GetRuntimeField(this System.Type type, string name) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> GetRuntimeFields(this System.Type type) => throw null;
            public static System.Reflection.InterfaceMapping GetRuntimeInterfaceMap(this System.Reflection.TypeInfo typeInfo, System.Type interfaceType) => throw null;
            public static System.Reflection.MethodInfo GetRuntimeMethod(this System.Type type, string name, System.Type[] parameters) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetRuntimeMethods(this System.Type type) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetRuntimeProperties(this System.Type type) => throw null;
            public static System.Reflection.PropertyInfo GetRuntimeProperty(this System.Type type, string name) => throw null;
        }

        public class StrongNameKeyPair : System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public System.Byte[] PublicKey { get => throw null; }
            public StrongNameKeyPair(System.Byte[] keyPairArray) => throw null;
            public StrongNameKeyPair(System.IO.FileStream keyPairFile) => throw null;
            protected StrongNameKeyPair(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public StrongNameKeyPair(string keyPairContainer) => throw null;
        }

        public class TargetException : System.ApplicationException
        {
            public TargetException() => throw null;
            protected TargetException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public TargetException(string message) => throw null;
            public TargetException(string message, System.Exception inner) => throw null;
        }

        public class TargetInvocationException : System.ApplicationException
        {
            public TargetInvocationException(System.Exception inner) => throw null;
            public TargetInvocationException(string message, System.Exception inner) => throw null;
        }

        public class TargetParameterCountException : System.ApplicationException
        {
            public TargetParameterCountException() => throw null;
            public TargetParameterCountException(string message) => throw null;
            public TargetParameterCountException(string message, System.Exception inner) => throw null;
        }

        [System.Flags]
        public enum TypeAttributes : int
        {
            Abstract = 128,
            AnsiClass = 0,
            AutoClass = 131072,
            AutoLayout = 0,
            BeforeFieldInit = 1048576,
            Class = 0,
            ClassSemanticsMask = 32,
            CustomFormatClass = 196608,
            CustomFormatMask = 12582912,
            ExplicitLayout = 16,
            HasSecurity = 262144,
            Import = 4096,
            Interface = 32,
            LayoutMask = 24,
            NestedAssembly = 5,
            NestedFamANDAssem = 6,
            NestedFamORAssem = 7,
            NestedFamily = 4,
            NestedPrivate = 3,
            NestedPublic = 2,
            NotPublic = 0,
            Public = 1,
            RTSpecialName = 2048,
            ReservedMask = 264192,
            Sealed = 256,
            SequentialLayout = 8,
            Serializable = 8192,
            SpecialName = 1024,
            StringFormatMask = 196608,
            UnicodeClass = 65536,
            VisibilityMask = 7,
            WindowsRuntime = 16384,
        }

        public class TypeDelegator : System.Reflection.TypeInfo
        {
            public override System.Reflection.Assembly Assembly { get => throw null; }
            public override string AssemblyQualifiedName { get => throw null; }
            public override System.Type BaseType { get => throw null; }
            public override string FullName { get => throw null; }
            public override System.Guid GUID { get => throw null; }
            protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl() => throw null;
            protected override System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public override System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public override object[] GetCustomAttributes(bool inherit) => throw null;
            public override System.Type GetElementType() => throw null;
            public override System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.EventInfo[] GetEvents() => throw null;
            public override System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type GetInterface(string name, bool ignoreCase) => throw null;
            public override System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType) => throw null;
            public override System.Type[] GetInterfaces() => throw null;
            public override System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.MemberInfo GetMemberWithSameMetadataDefinitionAs(System.Reflection.MemberInfo member) => throw null;
            public override System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr) => throw null;
            protected override System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public override System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr) => throw null;
            protected override System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            protected override bool HasElementTypeImpl() => throw null;
            public override object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters) => throw null;
            protected override bool IsArrayImpl() => throw null;
            public override bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo) => throw null;
            protected override bool IsByRefImpl() => throw null;
            public override bool IsByRefLike { get => throw null; }
            protected override bool IsCOMObjectImpl() => throw null;
            public override bool IsCollectible { get => throw null; }
            public override bool IsConstructedGenericType { get => throw null; }
            public override bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public override bool IsGenericMethodParameter { get => throw null; }
            public override bool IsGenericTypeParameter { get => throw null; }
            protected override bool IsPointerImpl() => throw null;
            protected override bool IsPrimitiveImpl() => throw null;
            public override bool IsSZArray { get => throw null; }
            public override bool IsTypeDefinition { get => throw null; }
            protected override bool IsValueTypeImpl() => throw null;
            public override bool IsVariableBoundArray { get => throw null; }
            public override int MetadataToken { get => throw null; }
            public override System.Reflection.Module Module { get => throw null; }
            public override string Name { get => throw null; }
            public override string Namespace { get => throw null; }
            protected TypeDelegator() => throw null;
            public TypeDelegator(System.Type delegatingType) => throw null;
            public override System.RuntimeTypeHandle TypeHandle { get => throw null; }
            public override System.Type UnderlyingSystemType { get => throw null; }
            protected System.Type typeImpl;
        }

        public delegate bool TypeFilter(System.Type m, object filterCriteria);

        public abstract class TypeInfo : System.Type, System.Reflection.IReflectableType
        {
            public virtual System.Type AsType() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo> DeclaredConstructors { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> DeclaredEvents { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> DeclaredFields { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo> DeclaredMembers { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> DeclaredMethods { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> DeclaredNestedTypes { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> DeclaredProperties { get => throw null; }
            public virtual System.Type[] GenericTypeParameters { get => throw null; }
            public virtual System.Reflection.EventInfo GetDeclaredEvent(string name) => throw null;
            public virtual System.Reflection.FieldInfo GetDeclaredField(string name) => throw null;
            public virtual System.Reflection.MethodInfo GetDeclaredMethod(string name) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetDeclaredMethods(string name) => throw null;
            public virtual System.Reflection.TypeInfo GetDeclaredNestedType(string name) => throw null;
            public virtual System.Reflection.PropertyInfo GetDeclaredProperty(string name) => throw null;
            System.Reflection.TypeInfo System.Reflection.IReflectableType.GetTypeInfo() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Type> ImplementedInterfaces { get => throw null; }
            public virtual bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo) => throw null;
            protected TypeInfo() => throw null;
        }

    }
    namespace Resources
    {
        public interface IResourceReader : System.Collections.IEnumerable, System.IDisposable
        {
            void Close();
            System.Collections.IDictionaryEnumerator GetEnumerator();
        }

        public class MissingManifestResourceException : System.SystemException
        {
            public MissingManifestResourceException() => throw null;
            protected MissingManifestResourceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public MissingManifestResourceException(string message) => throw null;
            public MissingManifestResourceException(string message, System.Exception inner) => throw null;
        }

        public class MissingSatelliteAssemblyException : System.SystemException
        {
            public string CultureName { get => throw null; }
            public MissingSatelliteAssemblyException() => throw null;
            protected MissingSatelliteAssemblyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public MissingSatelliteAssemblyException(string message) => throw null;
            public MissingSatelliteAssemblyException(string message, System.Exception inner) => throw null;
            public MissingSatelliteAssemblyException(string message, string cultureName) => throw null;
        }

        public class NeutralResourcesLanguageAttribute : System.Attribute
        {
            public string CultureName { get => throw null; }
            public System.Resources.UltimateResourceFallbackLocation Location { get => throw null; }
            public NeutralResourcesLanguageAttribute(string cultureName) => throw null;
            public NeutralResourcesLanguageAttribute(string cultureName, System.Resources.UltimateResourceFallbackLocation location) => throw null;
        }

        public class ResourceManager
        {
            public virtual string BaseName { get => throw null; }
            public static System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, System.Type usingResourceSet) => throw null;
            protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get => throw null; set => throw null; }
            protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage(System.Reflection.Assembly a) => throw null;
            public virtual object GetObject(string name) => throw null;
            public virtual object GetObject(string name, System.Globalization.CultureInfo culture) => throw null;
            protected virtual string GetResourceFileName(System.Globalization.CultureInfo culture) => throw null;
            public virtual System.Resources.ResourceSet GetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) => throw null;
            protected static System.Version GetSatelliteContractVersion(System.Reflection.Assembly a) => throw null;
            public System.IO.UnmanagedMemoryStream GetStream(string name) => throw null;
            public System.IO.UnmanagedMemoryStream GetStream(string name, System.Globalization.CultureInfo culture) => throw null;
            public virtual string GetString(string name) => throw null;
            public virtual string GetString(string name, System.Globalization.CultureInfo culture) => throw null;
            public static int HeaderVersionNumber;
            public virtual bool IgnoreCase { get => throw null; set => throw null; }
            protected virtual System.Resources.ResourceSet InternalGetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) => throw null;
            public static int MagicNumber;
            protected System.Reflection.Assembly MainAssembly;
            public virtual void ReleaseAllResources() => throw null;
            protected ResourceManager() => throw null;
            public ResourceManager(System.Type resourceSource) => throw null;
            public ResourceManager(string baseName, System.Reflection.Assembly assembly) => throw null;
            public ResourceManager(string baseName, System.Reflection.Assembly assembly, System.Type usingResourceSet) => throw null;
            public virtual System.Type ResourceSetType { get => throw null; }
        }

        public class ResourceReader : System.Collections.IEnumerable, System.IDisposable, System.Resources.IResourceReader
        {
            public void Close() => throw null;
            public void Dispose() => throw null;
            public System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public void GetResourceData(string resourceName, out string resourceType, out System.Byte[] resourceData) => throw null;
            public ResourceReader(System.IO.Stream stream) => throw null;
            public ResourceReader(string fileName) => throw null;
        }

        public class ResourceSet : System.Collections.IEnumerable, System.IDisposable
        {
            public virtual void Close() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Type GetDefaultReader() => throw null;
            public virtual System.Type GetDefaultWriter() => throw null;
            public virtual System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public virtual object GetObject(string name) => throw null;
            public virtual object GetObject(string name, bool ignoreCase) => throw null;
            public virtual string GetString(string name) => throw null;
            public virtual string GetString(string name, bool ignoreCase) => throw null;
            protected virtual void ReadResources() => throw null;
            protected ResourceSet() => throw null;
            public ResourceSet(System.Resources.IResourceReader reader) => throw null;
            public ResourceSet(System.IO.Stream stream) => throw null;
            public ResourceSet(string fileName) => throw null;
        }

        public class SatelliteContractVersionAttribute : System.Attribute
        {
            public SatelliteContractVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }

        public enum UltimateResourceFallbackLocation : int
        {
            MainAssembly = 0,
            Satellite = 1,
        }

    }
    namespace Runtime
    {
        public class AmbiguousImplementationException : System.Exception
        {
            public AmbiguousImplementationException() => throw null;
            public AmbiguousImplementationException(string message) => throw null;
            public AmbiguousImplementationException(string message, System.Exception innerException) => throw null;
        }

        public class AssemblyTargetedPatchBandAttribute : System.Attribute
        {
            public AssemblyTargetedPatchBandAttribute(string targetedPatchBand) => throw null;
            public string TargetedPatchBand { get => throw null; }
        }

        public static class ControlledExecution
        {
            public static void Run(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
        }

        public struct DependentHandle : System.IDisposable
        {
            public object Dependent { get => throw null; set => throw null; }
            // Stub generator skipped constructor 
            public DependentHandle(object target, object dependent) => throw null;
            public void Dispose() => throw null;
            public bool IsAllocated { get => throw null; }
            public object Target { get => throw null; set => throw null; }
            public (object, object) TargetAndDependent { get => throw null; }
        }

        public enum GCLargeObjectHeapCompactionMode : int
        {
            CompactOnce = 2,
            Default = 1,
        }

        public enum GCLatencyMode : int
        {
            Batch = 0,
            Interactive = 1,
            LowLatency = 2,
            NoGCRegion = 4,
            SustainedLowLatency = 3,
        }

        public static class GCSettings
        {
            public static bool IsServerGC { get => throw null; }
            public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get => throw null; set => throw null; }
            public static System.Runtime.GCLatencyMode LatencyMode { get => throw null; set => throw null; }
        }

        public static class JitInfo
        {
            public static System.TimeSpan GetCompilationTime(bool currentThread = default(bool)) => throw null;
            public static System.Int64 GetCompiledILBytes(bool currentThread = default(bool)) => throw null;
            public static System.Int64 GetCompiledMethodCount(bool currentThread = default(bool)) => throw null;
        }

        public class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
        {
            public void Dispose() => throw null;
            public MemoryFailPoint(int sizeInMegabytes) => throw null;
            // ERR: Stub generator didn't handle member: ~MemoryFailPoint
        }

        public static class ProfileOptimization
        {
            public static void SetProfileRoot(string directoryPath) => throw null;
            public static void StartProfile(string profile) => throw null;
        }

        public class TargetedPatchingOptOutAttribute : System.Attribute
        {
            public string Reason { get => throw null; }
            public TargetedPatchingOptOutAttribute(string reason) => throw null;
        }

        namespace CompilerServices
        {
            public class AccessedThroughPropertyAttribute : System.Attribute
            {
                public AccessedThroughPropertyAttribute(string propertyName) => throw null;
                public string PropertyName { get => throw null; }
            }

            public struct AsyncIteratorMethodBuilder
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void Complete() => throw null;
                public static System.Runtime.CompilerServices.AsyncIteratorMethodBuilder Create() => throw null;
                public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
            }

            public class AsyncIteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public AsyncIteratorStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }

            public class AsyncMethodBuilderAttribute : System.Attribute
            {
                public AsyncMethodBuilderAttribute(System.Type builderType) => throw null;
                public System.Type BuilderType { get => throw null; }
            }

            public class AsyncStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public AsyncStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }

            public struct AsyncTaskMethodBuilder
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.Task Task { get => throw null; }
            }

            public struct AsyncTaskMethodBuilder<TResult>
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.Task<TResult> Task { get => throw null; }
            }

            public struct AsyncValueTaskMethodBuilder
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask Task { get => throw null; }
            }

            public struct AsyncValueTaskMethodBuilder<TResult>
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<TResult> Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask<TResult> Task { get => throw null; }
            }

            public struct AsyncVoidMethodBuilder
            {
                // Stub generator skipped constructor 
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
            }

            public class CallConvCdecl
            {
                public CallConvCdecl() => throw null;
            }

            public class CallConvFastcall
            {
                public CallConvFastcall() => throw null;
            }

            public class CallConvMemberFunction
            {
                public CallConvMemberFunction() => throw null;
            }

            public class CallConvStdcall
            {
                public CallConvStdcall() => throw null;
            }

            public class CallConvSuppressGCTransition
            {
                public CallConvSuppressGCTransition() => throw null;
            }

            public class CallConvThiscall
            {
                public CallConvThiscall() => throw null;
            }

            public class CallerArgumentExpressionAttribute : System.Attribute
            {
                public CallerArgumentExpressionAttribute(string parameterName) => throw null;
                public string ParameterName { get => throw null; }
            }

            public class CallerFilePathAttribute : System.Attribute
            {
                public CallerFilePathAttribute() => throw null;
            }

            public class CallerLineNumberAttribute : System.Attribute
            {
                public CallerLineNumberAttribute() => throw null;
            }

            public class CallerMemberNameAttribute : System.Attribute
            {
                public CallerMemberNameAttribute() => throw null;
            }

            [System.Flags]
            public enum CompilationRelaxations : int
            {
                NoStringInterning = 8,
            }

            public class CompilationRelaxationsAttribute : System.Attribute
            {
                public int CompilationRelaxations { get => throw null; }
                public CompilationRelaxationsAttribute(System.Runtime.CompilerServices.CompilationRelaxations relaxations) => throw null;
                public CompilationRelaxationsAttribute(int relaxations) => throw null;
            }

            public class CompilerFeatureRequiredAttribute : System.Attribute
            {
                public CompilerFeatureRequiredAttribute(string featureName) => throw null;
                public string FeatureName { get => throw null; }
                public bool IsOptional { get => throw null; set => throw null; }
                public const string RefStructs = default;
                public const string RequiredMembers = default;
            }

            public class CompilerGeneratedAttribute : System.Attribute
            {
                public CompilerGeneratedAttribute() => throw null;
            }

            public class CompilerGlobalScopeAttribute : System.Attribute
            {
                public CompilerGlobalScopeAttribute() => throw null;
            }

            public class ConditionalWeakTable<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable where TKey : class where TValue : class
            {
                public delegate TValue CreateValueCallback(TKey key);


                public void Add(TKey key, TValue value) => throw null;
                public void AddOrUpdate(TKey key, TValue value) => throw null;
                public void Clear() => throw null;
                public ConditionalWeakTable() => throw null;
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>.GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public TValue GetOrCreateValue(TKey key) => throw null;
                public TValue GetValue(TKey key, System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue>.CreateValueCallback createValueCallback) => throw null;
                public bool Remove(TKey key) => throw null;
                public bool TryAdd(TKey key, TValue value) => throw null;
                public bool TryGetValue(TKey key, out TValue value) => throw null;
            }

            public struct ConfiguredAsyncDisposable
            {
                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable DisposeAsync() => throw null;
            }

            public struct ConfiguredCancelableAsyncEnumerable<T>
            {
                public struct Enumerator
                {
                    public T Current { get => throw null; }
                    public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable DisposeAsync() => throw null;
                    // Stub generator skipped constructor 
                    public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<bool> MoveNextAsync() => throw null;
                }


                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T>.Enumerator GetAsyncEnumerator() => throw null;
                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation(System.Threading.CancellationToken cancellationToken) => throw null;
            }

            public struct ConfiguredTaskAwaitable
            {
                public struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    // Stub generator skipped constructor 
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }


                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter() => throw null;
            }

            public struct ConfiguredTaskAwaitable<TResult>
            {
                public struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    // Stub generator skipped constructor 
                    public TResult GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }


                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult>.ConfiguredTaskAwaiter GetAwaiter() => throw null;
            }

            public struct ConfiguredValueTaskAwaitable
            {
                public struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    // Stub generator skipped constructor 
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }


                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter GetAwaiter() => throw null;
            }

            public struct ConfiguredValueTaskAwaitable<TResult>
            {
                public struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    // Stub generator skipped constructor 
                    public TResult GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }


                // Stub generator skipped constructor 
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult>.ConfiguredValueTaskAwaiter GetAwaiter() => throw null;
            }

            public abstract class CustomConstantAttribute : System.Attribute
            {
                protected CustomConstantAttribute() => throw null;
                public abstract object Value { get; }
            }

            public class DateTimeConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                public DateTimeConstantAttribute(System.Int64 ticks) => throw null;
                public override object Value { get => throw null; }
            }

            public class DecimalConstantAttribute : System.Attribute
            {
                public DecimalConstantAttribute(System.Byte scale, System.Byte sign, int hi, int mid, int low) => throw null;
                public DecimalConstantAttribute(System.Byte scale, System.Byte sign, System.UInt32 hi, System.UInt32 mid, System.UInt32 low) => throw null;
                public System.Decimal Value { get => throw null; }
            }

            public class DefaultDependencyAttribute : System.Attribute
            {
                public DefaultDependencyAttribute(System.Runtime.CompilerServices.LoadHint loadHintArgument) => throw null;
                public System.Runtime.CompilerServices.LoadHint LoadHint { get => throw null; }
            }

            public struct DefaultInterpolatedStringHandler
            {
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                // Stub generator skipped constructor 
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount) => throw null;
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, System.IFormatProvider provider) => throw null;
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, System.IFormatProvider provider, System.Span<System.Char> initialBuffer) => throw null;
                public override string ToString() => throw null;
                public string ToStringAndClear() => throw null;
            }

            public class DependencyAttribute : System.Attribute
            {
                public DependencyAttribute(string dependentAssemblyArgument, System.Runtime.CompilerServices.LoadHint loadHintArgument) => throw null;
                public string DependentAssembly { get => throw null; }
                public System.Runtime.CompilerServices.LoadHint LoadHint { get => throw null; }
            }

            public class DisablePrivateReflectionAttribute : System.Attribute
            {
                public DisablePrivateReflectionAttribute() => throw null;
            }

            public class DisableRuntimeMarshallingAttribute : System.Attribute
            {
                public DisableRuntimeMarshallingAttribute() => throw null;
            }

            public class DiscardableAttribute : System.Attribute
            {
                public DiscardableAttribute() => throw null;
            }

            public class EnumeratorCancellationAttribute : System.Attribute
            {
                public EnumeratorCancellationAttribute() => throw null;
            }

            public class ExtensionAttribute : System.Attribute
            {
                public ExtensionAttribute() => throw null;
            }

            public class FixedAddressValueTypeAttribute : System.Attribute
            {
                public FixedAddressValueTypeAttribute() => throw null;
            }

            public class FixedBufferAttribute : System.Attribute
            {
                public System.Type ElementType { get => throw null; }
                public FixedBufferAttribute(System.Type elementType, int length) => throw null;
                public int Length { get => throw null; }
            }

            public static class FormattableStringFactory
            {
                public static System.FormattableString Create(string format, params object[] arguments) => throw null;
            }

            public interface IAsyncStateMachine
            {
                void MoveNext();
                void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            public interface ICriticalNotifyCompletion : System.Runtime.CompilerServices.INotifyCompletion
            {
                void UnsafeOnCompleted(System.Action continuation);
            }

            public interface INotifyCompletion
            {
                void OnCompleted(System.Action continuation);
            }

            public interface IStrongBox
            {
                object Value { get; set; }
            }

            public interface ITuple
            {
                object this[int index] { get; }
                int Length { get; }
            }

            public class IndexerNameAttribute : System.Attribute
            {
                public IndexerNameAttribute(string indexerName) => throw null;
            }

            public class InternalsVisibleToAttribute : System.Attribute
            {
                public bool AllInternalsVisible { get => throw null; set => throw null; }
                public string AssemblyName { get => throw null; }
                public InternalsVisibleToAttribute(string assemblyName) => throw null;
            }

            public class InterpolatedStringHandlerArgumentAttribute : System.Attribute
            {
                public string[] Arguments { get => throw null; }
                public InterpolatedStringHandlerArgumentAttribute(params string[] arguments) => throw null;
                public InterpolatedStringHandlerArgumentAttribute(string argument) => throw null;
            }

            public class InterpolatedStringHandlerAttribute : System.Attribute
            {
                public InterpolatedStringHandlerAttribute() => throw null;
            }

            public class IsByRefLikeAttribute : System.Attribute
            {
                public IsByRefLikeAttribute() => throw null;
            }

            public static class IsConst
            {
            }

            public static class IsExternalInit
            {
            }

            public partial class IsReadOnlyAttribute : System.Attribute
            {
                public IsReadOnlyAttribute() => throw null;
            }

            public static class IsVolatile
            {
            }

            public class IteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public IteratorStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }

            public enum LoadHint : int
            {
                Always = 1,
                Default = 0,
                Sometimes = 2,
            }

            public enum MethodCodeType : int
            {
                IL = 0,
                Native = 1,
                OPTIL = 2,
                Runtime = 3,
            }

            public class MethodImplAttribute : System.Attribute
            {
                public System.Runtime.CompilerServices.MethodCodeType MethodCodeType;
                public MethodImplAttribute() => throw null;
                public MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions methodImplOptions) => throw null;
                public MethodImplAttribute(System.Int16 value) => throw null;
                public System.Runtime.CompilerServices.MethodImplOptions Value { get => throw null; }
            }

            [System.Flags]
            public enum MethodImplOptions : int
            {
                AggressiveInlining = 256,
                AggressiveOptimization = 512,
                ForwardRef = 16,
                InternalCall = 4096,
                NoInlining = 8,
                NoOptimization = 64,
                PreserveSig = 128,
                Synchronized = 32,
                Unmanaged = 4,
            }

            public class ModuleInitializerAttribute : System.Attribute
            {
                public ModuleInitializerAttribute() => throw null;
            }

            public struct PoolingAsyncValueTaskMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder Create() => throw null;
                // Stub generator skipped constructor 
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask Task { get => throw null; }
            }

            public struct PoolingAsyncValueTaskMethodBuilder<TResult>
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder<TResult> Create() => throw null;
                // Stub generator skipped constructor 
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask<TResult> Task { get => throw null; }
            }

            public class PreserveBaseOverridesAttribute : System.Attribute
            {
                public PreserveBaseOverridesAttribute() => throw null;
            }

            public class ReferenceAssemblyAttribute : System.Attribute
            {
                public string Description { get => throw null; }
                public ReferenceAssemblyAttribute() => throw null;
                public ReferenceAssemblyAttribute(string description) => throw null;
            }

            public class RequiredMemberAttribute : System.Attribute
            {
                public RequiredMemberAttribute() => throw null;
            }

            public class RuntimeCompatibilityAttribute : System.Attribute
            {
                public RuntimeCompatibilityAttribute() => throw null;
                public bool WrapNonExceptionThrows { get => throw null; set => throw null; }
            }

            public static class RuntimeFeature
            {
                public const string ByRefFields = default;
                public const string CovariantReturnsOfClasses = default;
                public const string DefaultImplementationsOfInterfaces = default;
                public static bool IsDynamicCodeCompiled { get => throw null; }
                public static bool IsDynamicCodeSupported { get => throw null; }
                public static bool IsSupported(string feature) => throw null;
                public const string NumericIntPtr = default;
                public const string PortablePdb = default;
                public const string UnmanagedSignatureCallingConvention = default;
                public const string VirtualStaticsInInterfaces = default;
            }

            public static class RuntimeHelpers
            {
                public delegate void CleanupCode(object userData, bool exceptionThrown);


                public delegate void TryCode(object userData);


                public static System.IntPtr AllocateTypeAssociatedMemory(System.Type type, int size) => throw null;
                public static System.ReadOnlySpan<T> CreateSpan<T>(System.RuntimeFieldHandle fldHandle) => throw null;
                public static void EnsureSufficientExecutionStack() => throw null;
                public static bool Equals(object o1, object o2) => throw null;
                public static void ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData) => throw null;
                public static int GetHashCode(object o) => throw null;
                public static object GetObjectValue(object obj) => throw null;
                public static T[] GetSubArray<T>(T[] array, System.Range range) => throw null;
                public static object GetUninitializedObject(System.Type type) => throw null;
                public static void InitializeArray(System.Array array, System.RuntimeFieldHandle fldHandle) => throw null;
                public static bool IsReferenceOrContainsReferences<T>() => throw null;
                public static int OffsetToStringData { get => throw null; }
                public static void PrepareConstrainedRegions() => throw null;
                public static void PrepareConstrainedRegionsNoOP() => throw null;
                public static void PrepareContractedDelegate(System.Delegate d) => throw null;
                public static void PrepareDelegate(System.Delegate d) => throw null;
                public static void PrepareMethod(System.RuntimeMethodHandle method) => throw null;
                public static void PrepareMethod(System.RuntimeMethodHandle method, System.RuntimeTypeHandle[] instantiation) => throw null;
                public static void ProbeForSufficientStack() => throw null;
                public static void RunClassConstructor(System.RuntimeTypeHandle type) => throw null;
                public static void RunModuleConstructor(System.ModuleHandle module) => throw null;
                public static bool TryEnsureSufficientExecutionStack() => throw null;
            }

            public class RuntimeWrappedException : System.Exception
            {
                public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public RuntimeWrappedException(object thrownObject) => throw null;
                public object WrappedException { get => throw null; }
            }

            public class SkipLocalsInitAttribute : System.Attribute
            {
                public SkipLocalsInitAttribute() => throw null;
            }

            public class SpecialNameAttribute : System.Attribute
            {
                public SpecialNameAttribute() => throw null;
            }

            public class StateMachineAttribute : System.Attribute
            {
                public StateMachineAttribute(System.Type stateMachineType) => throw null;
                public System.Type StateMachineType { get => throw null; }
            }

            public class StringFreezingAttribute : System.Attribute
            {
                public StringFreezingAttribute() => throw null;
            }

            public class StrongBox<T> : System.Runtime.CompilerServices.IStrongBox
            {
                public StrongBox() => throw null;
                public StrongBox(T value) => throw null;
                public T Value;
                object System.Runtime.CompilerServices.IStrongBox.Value { get => throw null; set => throw null; }
            }

            public class SuppressIldasmAttribute : System.Attribute
            {
                public SuppressIldasmAttribute() => throw null;
            }

            public class SwitchExpressionException : System.InvalidOperationException
            {
                public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public override string Message { get => throw null; }
                public SwitchExpressionException() => throw null;
                public SwitchExpressionException(System.Exception innerException) => throw null;
                public SwitchExpressionException(object unmatchedValue) => throw null;
                public SwitchExpressionException(string message) => throw null;
                public SwitchExpressionException(string message, System.Exception innerException) => throw null;
                public object UnmatchedValue { get => throw null; }
            }

            public struct TaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public void GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                // Stub generator skipped constructor 
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }

            public struct TaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public TResult GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                // Stub generator skipped constructor 
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }

            public class TupleElementNamesAttribute : System.Attribute
            {
                public System.Collections.Generic.IList<string> TransformNames { get => throw null; }
                public TupleElementNamesAttribute(string[] transformNames) => throw null;
            }

            public class TypeForwardedFromAttribute : System.Attribute
            {
                public string AssemblyFullName { get => throw null; }
                public TypeForwardedFromAttribute(string assemblyFullName) => throw null;
            }

            public class TypeForwardedToAttribute : System.Attribute
            {
                public System.Type Destination { get => throw null; }
                public TypeForwardedToAttribute(System.Type destination) => throw null;
            }

            public static class Unsafe
            {
                unsafe public static void* Add<T>(void* source, int elementOffset) => throw null;
                public static T Add<T>(ref T source, System.IntPtr elementOffset) => throw null;
                public static T Add<T>(ref T source, System.UIntPtr elementOffset) => throw null;
                public static T Add<T>(ref T source, int elementOffset) => throw null;
                public static T AddByteOffset<T>(ref T source, System.IntPtr byteOffset) => throw null;
                public static T AddByteOffset<T>(ref T source, System.UIntPtr byteOffset) => throw null;
                public static bool AreSame<T>(ref T left, ref T right) => throw null;
                public static T As<T>(object o) where T : class => throw null;
                public static TTo As<TFrom, TTo>(ref TFrom source) => throw null;
                unsafe public static void* AsPointer<T>(ref T value) => throw null;
                public static T AsRef<T>(T source) => throw null;
                unsafe public static T AsRef<T>(void* source) => throw null;
                public static System.IntPtr ByteOffset<T>(ref T origin, ref T target) => throw null;
                unsafe public static void Copy<T>(void* destination, ref T source) => throw null;
                unsafe public static void Copy<T>(ref T destination, void* source) => throw null;
                unsafe public static void CopyBlock(void* destination, void* source, System.UInt32 byteCount) => throw null;
                public static void CopyBlock(ref System.Byte destination, ref System.Byte source, System.UInt32 byteCount) => throw null;
                unsafe public static void CopyBlockUnaligned(void* destination, void* source, System.UInt32 byteCount) => throw null;
                public static void CopyBlockUnaligned(ref System.Byte destination, ref System.Byte source, System.UInt32 byteCount) => throw null;
                unsafe public static void InitBlock(void* startAddress, System.Byte value, System.UInt32 byteCount) => throw null;
                public static void InitBlock(ref System.Byte startAddress, System.Byte value, System.UInt32 byteCount) => throw null;
                unsafe public static void InitBlockUnaligned(void* startAddress, System.Byte value, System.UInt32 byteCount) => throw null;
                public static void InitBlockUnaligned(ref System.Byte startAddress, System.Byte value, System.UInt32 byteCount) => throw null;
                public static bool IsAddressGreaterThan<T>(ref T left, ref T right) => throw null;
                public static bool IsAddressLessThan<T>(ref T left, ref T right) => throw null;
                public static bool IsNullRef<T>(ref T source) => throw null;
                public static T NullRef<T>() => throw null;
                unsafe public static T Read<T>(void* source) => throw null;
                unsafe public static T ReadUnaligned<T>(void* source) => throw null;
                public static T ReadUnaligned<T>(ref System.Byte source) => throw null;
                public static int SizeOf<T>() => throw null;
                public static void SkipInit<T>(out T value) => throw null;
                unsafe public static void* Subtract<T>(void* source, int elementOffset) => throw null;
                public static T Subtract<T>(ref T source, System.IntPtr elementOffset) => throw null;
                public static T Subtract<T>(ref T source, System.UIntPtr elementOffset) => throw null;
                public static T Subtract<T>(ref T source, int elementOffset) => throw null;
                public static T SubtractByteOffset<T>(ref T source, System.IntPtr byteOffset) => throw null;
                public static T SubtractByteOffset<T>(ref T source, System.UIntPtr byteOffset) => throw null;
                public static T Unbox<T>(object box) where T : struct => throw null;
                unsafe public static void Write<T>(void* destination, T value) => throw null;
                unsafe public static void WriteUnaligned<T>(void* destination, T value) => throw null;
                public static void WriteUnaligned<T>(ref System.Byte destination, T value) => throw null;
            }

            public class UnsafeValueTypeAttribute : System.Attribute
            {
                public UnsafeValueTypeAttribute() => throw null;
            }

            public struct ValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public void GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
                // Stub generator skipped constructor 
            }

            public struct ValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public TResult GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
                // Stub generator skipped constructor 
            }

            public struct YieldAwaitable
            {
                public struct YieldAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                    // Stub generator skipped constructor 
                }


                public System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter() => throw null;
                // Stub generator skipped constructor 
            }

        }
        namespace ConstrainedExecution
        {
            public enum Cer : int
            {
                MayFail = 1,
                None = 0,
                Success = 2,
            }

            public enum Consistency : int
            {
                MayCorruptAppDomain = 1,
                MayCorruptInstance = 2,
                MayCorruptProcess = 0,
                WillNotCorruptState = 3,
            }

            public abstract class CriticalFinalizerObject
            {
                protected CriticalFinalizerObject() => throw null;
                // ERR: Stub generator didn't handle member: ~CriticalFinalizerObject
            }

            public class PrePrepareMethodAttribute : System.Attribute
            {
                public PrePrepareMethodAttribute() => throw null;
            }

            public class ReliabilityContractAttribute : System.Attribute
            {
                public System.Runtime.ConstrainedExecution.Cer Cer { get => throw null; }
                public System.Runtime.ConstrainedExecution.Consistency ConsistencyGuarantee { get => throw null; }
                public ReliabilityContractAttribute(System.Runtime.ConstrainedExecution.Consistency consistencyGuarantee, System.Runtime.ConstrainedExecution.Cer cer) => throw null;
            }

        }
        namespace ExceptionServices
        {
            public class ExceptionDispatchInfo
            {
                public static System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(System.Exception source) => throw null;
                public static System.Exception SetCurrentStackTrace(System.Exception source) => throw null;
                public static System.Exception SetRemoteStackTrace(System.Exception source, string stackTrace) => throw null;
                public System.Exception SourceException { get => throw null; }
                public void Throw() => throw null;
                public static void Throw(System.Exception source) => throw null;
            }

            public class FirstChanceExceptionEventArgs : System.EventArgs
            {
                public System.Exception Exception { get => throw null; }
                public FirstChanceExceptionEventArgs(System.Exception exception) => throw null;
            }

            public class HandleProcessCorruptedStateExceptionsAttribute : System.Attribute
            {
                public HandleProcessCorruptedStateExceptionsAttribute() => throw null;
            }

        }
        namespace InteropServices
        {
            public enum Architecture : int
            {
                Arm = 2,
                Arm64 = 3,
                Armv6 = 7,
                LoongArch64 = 6,
                Ppc64le = 8,
                S390x = 5,
                Wasm = 4,
                X64 = 1,
                X86 = 0,
            }

            public enum CharSet : int
            {
                Ansi = 2,
                Auto = 4,
                None = 1,
                Unicode = 3,
            }

            public class ComVisibleAttribute : System.Attribute
            {
                public ComVisibleAttribute(bool visibility) => throw null;
                public bool Value { get => throw null; }
            }

            public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                public void Close() => throw null;
                protected CriticalHandle(System.IntPtr invalidHandleValue) => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public bool IsClosed { get => throw null; }
                public abstract bool IsInvalid { get; }
                protected abstract bool ReleaseHandle();
                protected void SetHandle(System.IntPtr handle) => throw null;
                public void SetHandleAsInvalid() => throw null;
                protected System.IntPtr handle;
                // ERR: Stub generator didn't handle member: ~CriticalHandle
            }

            public class ExternalException : System.SystemException
            {
                public virtual int ErrorCode { get => throw null; }
                public ExternalException() => throw null;
                protected ExternalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public ExternalException(string message) => throw null;
                public ExternalException(string message, System.Exception inner) => throw null;
                public ExternalException(string message, int errorCode) => throw null;
                public override string ToString() => throw null;
            }

            public class FieldOffsetAttribute : System.Attribute
            {
                public FieldOffsetAttribute(int offset) => throw null;
                public int Value { get => throw null; }
            }

            public struct GCHandle : System.IEquatable<System.Runtime.InteropServices.GCHandle>
            {
                public static bool operator !=(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b) => throw null;
                public static bool operator ==(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b) => throw null;
                public System.IntPtr AddrOfPinnedObject() => throw null;
                public static System.Runtime.InteropServices.GCHandle Alloc(object value) => throw null;
                public static System.Runtime.InteropServices.GCHandle Alloc(object value, System.Runtime.InteropServices.GCHandleType type) => throw null;
                public bool Equals(System.Runtime.InteropServices.GCHandle other) => throw null;
                public override bool Equals(object o) => throw null;
                public void Free() => throw null;
                public static System.Runtime.InteropServices.GCHandle FromIntPtr(System.IntPtr value) => throw null;
                // Stub generator skipped constructor 
                public override int GetHashCode() => throw null;
                public bool IsAllocated { get => throw null; }
                public object Target { get => throw null; set => throw null; }
                public static System.IntPtr ToIntPtr(System.Runtime.InteropServices.GCHandle value) => throw null;
                public static explicit operator System.IntPtr(System.Runtime.InteropServices.GCHandle value) => throw null;
                public static explicit operator System.Runtime.InteropServices.GCHandle(System.IntPtr value) => throw null;
            }

            public enum GCHandleType : int
            {
                Normal = 2,
                Pinned = 3,
                Weak = 0,
                WeakTrackResurrection = 1,
            }

            public class InAttribute : System.Attribute
            {
                public InAttribute() => throw null;
            }

            public enum LayoutKind : int
            {
                Auto = 3,
                Explicit = 2,
                Sequential = 0,
            }

            public struct OSPlatform : System.IEquatable<System.Runtime.InteropServices.OSPlatform>
            {
                public static bool operator !=(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right) => throw null;
                public static bool operator ==(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right) => throw null;
                public static System.Runtime.InteropServices.OSPlatform Create(string osPlatform) => throw null;
                public bool Equals(System.Runtime.InteropServices.OSPlatform other) => throw null;
                public override bool Equals(object obj) => throw null;
                public static System.Runtime.InteropServices.OSPlatform FreeBSD { get => throw null; }
                public override int GetHashCode() => throw null;
                public static System.Runtime.InteropServices.OSPlatform Linux { get => throw null; }
                // Stub generator skipped constructor 
                public static System.Runtime.InteropServices.OSPlatform OSX { get => throw null; }
                public override string ToString() => throw null;
                public static System.Runtime.InteropServices.OSPlatform Windows { get => throw null; }
            }

            public class OutAttribute : System.Attribute
            {
                public OutAttribute() => throw null;
            }

            public static class RuntimeInformation
            {
                public static string FrameworkDescription { get => throw null; }
                public static bool IsOSPlatform(System.Runtime.InteropServices.OSPlatform osPlatform) => throw null;
                public static System.Runtime.InteropServices.Architecture OSArchitecture { get => throw null; }
                public static string OSDescription { get => throw null; }
                public static System.Runtime.InteropServices.Architecture ProcessArchitecture { get => throw null; }
                public static string RuntimeIdentifier { get => throw null; }
            }

            public abstract class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                unsafe public void AcquirePointer(ref System.Byte* pointer) => throw null;
                public System.UInt64 ByteLength { get => throw null; }
                public void Initialize(System.UInt32 numElements, System.UInt32 sizeOfEachElement) => throw null;
                public void Initialize(System.UInt64 numBytes) => throw null;
                public void Initialize<T>(System.UInt32 numElements) where T : struct => throw null;
                public T Read<T>(System.UInt64 byteOffset) where T : struct => throw null;
                public void ReadArray<T>(System.UInt64 byteOffset, T[] array, int index, int count) where T : struct => throw null;
                public void ReadSpan<T>(System.UInt64 byteOffset, System.Span<T> buffer) where T : struct => throw null;
                public void ReleasePointer() => throw null;
                protected SafeBuffer(bool ownsHandle) : base(default(bool)) => throw null;
                public void Write<T>(System.UInt64 byteOffset, T value) where T : struct => throw null;
                public void WriteArray<T>(System.UInt64 byteOffset, T[] array, int index, int count) where T : struct => throw null;
                public void WriteSpan<T>(System.UInt64 byteOffset, System.ReadOnlySpan<T> data) where T : struct => throw null;
            }

            public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                public void Close() => throw null;
                public void DangerousAddRef(ref bool success) => throw null;
                public System.IntPtr DangerousGetHandle() => throw null;
                public void DangerousRelease() => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public bool IsClosed { get => throw null; }
                public abstract bool IsInvalid { get; }
                protected abstract bool ReleaseHandle();
                protected SafeHandle(System.IntPtr invalidHandleValue, bool ownsHandle) => throw null;
                protected void SetHandle(System.IntPtr handle) => throw null;
                public void SetHandleAsInvalid() => throw null;
                protected System.IntPtr handle;
                // ERR: Stub generator didn't handle member: ~SafeHandle
            }

            public class StructLayoutAttribute : System.Attribute
            {
                public System.Runtime.InteropServices.CharSet CharSet;
                public int Pack;
                public int Size;
                public StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind layoutKind) => throw null;
                public StructLayoutAttribute(System.Int16 layoutKind) => throw null;
                public System.Runtime.InteropServices.LayoutKind Value { get => throw null; }
            }

            public class SuppressGCTransitionAttribute : System.Attribute
            {
                public SuppressGCTransitionAttribute() => throw null;
            }

            public enum UnmanagedType : int
            {
                AnsiBStr = 35,
                AsAny = 40,
                BStr = 19,
                Bool = 2,
                ByValArray = 30,
                ByValTStr = 23,
                Currency = 15,
                CustomMarshaler = 44,
                Error = 45,
                FunctionPtr = 38,
                HString = 47,
                I1 = 3,
                I2 = 5,
                I4 = 7,
                I8 = 9,
                IDispatch = 26,
                IInspectable = 46,
                IUnknown = 25,
                Interface = 28,
                LPArray = 42,
                LPStr = 20,
                LPStruct = 43,
                LPTStr = 22,
                LPUTF8Str = 48,
                LPWStr = 21,
                R4 = 11,
                R8 = 12,
                SafeArray = 29,
                Struct = 27,
                SysInt = 31,
                SysUInt = 32,
                TBStr = 36,
                U1 = 4,
                U2 = 6,
                U4 = 8,
                U8 = 10,
                VBByRefStr = 34,
                VariantBool = 37,
            }

            namespace Marshalling
            {
                public class ContiguousCollectionMarshallerAttribute : System.Attribute
                {
                    public ContiguousCollectionMarshallerAttribute() => throw null;
                }

                public class CustomMarshallerAttribute : System.Attribute
                {
                    public struct GenericPlaceholder
                    {
                        // Stub generator skipped constructor 
                    }


                    public CustomMarshallerAttribute(System.Type managedType, System.Runtime.InteropServices.Marshalling.MarshalMode marshalMode, System.Type marshallerType) => throw null;
                    public System.Type ManagedType { get => throw null; }
                    public System.Runtime.InteropServices.Marshalling.MarshalMode MarshalMode { get => throw null; }
                    public System.Type MarshallerType { get => throw null; }
                }

                public enum MarshalMode : int
                {
                    Default = 0,
                    ElementIn = 7,
                    ElementOut = 9,
                    ElementRef = 8,
                    ManagedToUnmanagedIn = 1,
                    ManagedToUnmanagedOut = 3,
                    ManagedToUnmanagedRef = 2,
                    UnmanagedToManagedIn = 4,
                    UnmanagedToManagedOut = 6,
                    UnmanagedToManagedRef = 5,
                }

                public class NativeMarshallingAttribute : System.Attribute
                {
                    public NativeMarshallingAttribute(System.Type nativeType) => throw null;
                    public System.Type NativeType { get => throw null; }
                }

                public static class ReadOnlySpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : unmanaged
                {
                    public struct ManagedToUnmanagedIn
                    {
                        public static int BufferSize { get => throw null; }
                        public void Free() => throw null;
                        public void FromManaged(System.ReadOnlySpan<T> managed, System.Span<TUnmanagedElement> buffer) => throw null;
                        public System.ReadOnlySpan<T> GetManagedValuesSource() => throw null;
                        public TUnmanagedElement GetPinnableReference() => throw null;
                        public static T GetPinnableReference(System.ReadOnlySpan<T> managed) => throw null;
                        public System.Span<TUnmanagedElement> GetUnmanagedValuesDestination() => throw null;
                        // Stub generator skipped constructor 
                        unsafe public TUnmanagedElement* ToUnmanaged() => throw null;
                    }


                    public static class UnmanagedToManagedOut
                    {
                        unsafe public static TUnmanagedElement* AllocateContainerForUnmanagedElements(System.ReadOnlySpan<T> managed, out int numElements) => throw null;
                        public static System.ReadOnlySpan<T> GetManagedValuesSource(System.ReadOnlySpan<T> managed) => throw null;
                        unsafe public static System.Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    }


                }

                public static class SpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : unmanaged
                {
                    public struct ManagedToUnmanagedIn
                    {
                        public static int BufferSize { get => throw null; }
                        public void Free() => throw null;
                        public void FromManaged(System.Span<T> managed, System.Span<TUnmanagedElement> buffer) => throw null;
                        public System.ReadOnlySpan<T> GetManagedValuesSource() => throw null;
                        public TUnmanagedElement GetPinnableReference() => throw null;
                        public static T GetPinnableReference(System.Span<T> managed) => throw null;
                        public System.Span<TUnmanagedElement> GetUnmanagedValuesDestination() => throw null;
                        // Stub generator skipped constructor 
                        unsafe public TUnmanagedElement* ToUnmanaged() => throw null;
                    }


                    unsafe public static System.Span<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    unsafe public static TUnmanagedElement* AllocateContainerForUnmanagedElements(System.Span<T> managed, out int numElements) => throw null;
                    unsafe public static void Free(TUnmanagedElement* unmanaged) => throw null;
                    public static System.Span<T> GetManagedValuesDestination(System.Span<T> managed) => throw null;
                    public static System.ReadOnlySpan<T> GetManagedValuesSource(System.Span<T> managed) => throw null;
                    unsafe public static System.Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    unsafe public static System.ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements) => throw null;
                }

            }
        }
        namespace Remoting
        {
            public class ObjectHandle : System.MarshalByRefObject
            {
                public ObjectHandle(object o) => throw null;
                public object Unwrap() => throw null;
            }

        }
        namespace Serialization
        {
            public interface IDeserializationCallback
            {
                void OnDeserialization(object sender);
            }

            public interface IFormatterConverter
            {
                object Convert(object value, System.Type type);
                object Convert(object value, System.TypeCode typeCode);
                bool ToBoolean(object value);
                System.Byte ToByte(object value);
                System.Char ToChar(object value);
                System.DateTime ToDateTime(object value);
                System.Decimal ToDecimal(object value);
                double ToDouble(object value);
                System.Int16 ToInt16(object value);
                int ToInt32(object value);
                System.Int64 ToInt64(object value);
                System.SByte ToSByte(object value);
                float ToSingle(object value);
                string ToString(object value);
                System.UInt16 ToUInt16(object value);
                System.UInt32 ToUInt32(object value);
                System.UInt64 ToUInt64(object value);
            }

            public interface IObjectReference
            {
                object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            }

            public interface ISafeSerializationData
            {
                void CompleteDeserialization(object deserialized);
            }

            public interface ISerializable
            {
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            public class OnDeserializedAttribute : System.Attribute
            {
                public OnDeserializedAttribute() => throw null;
            }

            public class OnDeserializingAttribute : System.Attribute
            {
                public OnDeserializingAttribute() => throw null;
            }

            public class OnSerializedAttribute : System.Attribute
            {
                public OnSerializedAttribute() => throw null;
            }

            public class OnSerializingAttribute : System.Attribute
            {
                public OnSerializingAttribute() => throw null;
            }

            public class OptionalFieldAttribute : System.Attribute
            {
                public OptionalFieldAttribute() => throw null;
                public int VersionAdded { get => throw null; set => throw null; }
            }

            public class SafeSerializationEventArgs : System.EventArgs
            {
                public void AddSerializedState(System.Runtime.Serialization.ISafeSerializationData serializedState) => throw null;
                public System.Runtime.Serialization.StreamingContext StreamingContext { get => throw null; }
            }

            public struct SerializationEntry
            {
                public string Name { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                // Stub generator skipped constructor 
                public object Value { get => throw null; }
            }

            public class SerializationException : System.SystemException
            {
                public SerializationException() => throw null;
                protected SerializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public SerializationException(string message) => throw null;
                public SerializationException(string message, System.Exception innerException) => throw null;
            }

            public class SerializationInfo
            {
                public void AddValue(string name, System.DateTime value) => throw null;
                public void AddValue(string name, bool value) => throw null;
                public void AddValue(string name, System.Byte value) => throw null;
                public void AddValue(string name, System.Char value) => throw null;
                public void AddValue(string name, System.Decimal value) => throw null;
                public void AddValue(string name, double value) => throw null;
                public void AddValue(string name, float value) => throw null;
                public void AddValue(string name, int value) => throw null;
                public void AddValue(string name, System.Int64 value) => throw null;
                public void AddValue(string name, object value) => throw null;
                public void AddValue(string name, object value, System.Type type) => throw null;
                public void AddValue(string name, System.SByte value) => throw null;
                public void AddValue(string name, System.Int16 value) => throw null;
                public void AddValue(string name, System.UInt32 value) => throw null;
                public void AddValue(string name, System.UInt64 value) => throw null;
                public void AddValue(string name, System.UInt16 value) => throw null;
                public string AssemblyName { get => throw null; set => throw null; }
                public string FullTypeName { get => throw null; set => throw null; }
                public bool GetBoolean(string name) => throw null;
                public System.Byte GetByte(string name) => throw null;
                public System.Char GetChar(string name) => throw null;
                public System.DateTime GetDateTime(string name) => throw null;
                public System.Decimal GetDecimal(string name) => throw null;
                public double GetDouble(string name) => throw null;
                public System.Runtime.Serialization.SerializationInfoEnumerator GetEnumerator() => throw null;
                public System.Int16 GetInt16(string name) => throw null;
                public int GetInt32(string name) => throw null;
                public System.Int64 GetInt64(string name) => throw null;
                public System.SByte GetSByte(string name) => throw null;
                public float GetSingle(string name) => throw null;
                public string GetString(string name) => throw null;
                public System.UInt16 GetUInt16(string name) => throw null;
                public System.UInt32 GetUInt32(string name) => throw null;
                public System.UInt64 GetUInt64(string name) => throw null;
                public object GetValue(string name, System.Type type) => throw null;
                public bool IsAssemblyNameSetExplicit { get => throw null; }
                public bool IsFullTypeNameSetExplicit { get => throw null; }
                public int MemberCount { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                public SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter) => throw null;
                public SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter, bool requireSameTokenInPartialTrust) => throw null;
                public void SetType(System.Type type) => throw null;
            }

            public class SerializationInfoEnumerator : System.Collections.IEnumerator
            {
                public System.Runtime.Serialization.SerializationEntry Current { get => throw null; }
                object System.Collections.IEnumerator.Current { get => throw null; }
                public bool MoveNext() => throw null;
                public string Name { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                public void Reset() => throw null;
                public object Value { get => throw null; }
            }

            public struct StreamingContext
            {
                public object Context { get => throw null; }
                public override bool Equals(object obj) => throw null;
                public override int GetHashCode() => throw null;
                public System.Runtime.Serialization.StreamingContextStates State { get => throw null; }
                // Stub generator skipped constructor 
                public StreamingContext(System.Runtime.Serialization.StreamingContextStates state) => throw null;
                public StreamingContext(System.Runtime.Serialization.StreamingContextStates state, object additional) => throw null;
            }

            [System.Flags]
            public enum StreamingContextStates : int
            {
                All = 255,
                Clone = 64,
                CrossAppDomain = 128,
                CrossMachine = 2,
                CrossProcess = 1,
                File = 4,
                Other = 32,
                Persistence = 8,
                Remoting = 16,
            }

        }
        namespace Versioning
        {
            public class ComponentGuaranteesAttribute : System.Attribute
            {
                public ComponentGuaranteesAttribute(System.Runtime.Versioning.ComponentGuaranteesOptions guarantees) => throw null;
                public System.Runtime.Versioning.ComponentGuaranteesOptions Guarantees { get => throw null; }
            }

            [System.Flags]
            public enum ComponentGuaranteesOptions : int
            {
                Exchange = 1,
                None = 0,
                SideBySide = 4,
                Stable = 2,
            }

            public class FrameworkName : System.IEquatable<System.Runtime.Versioning.FrameworkName>
            {
                public static bool operator !=(System.Runtime.Versioning.FrameworkName left, System.Runtime.Versioning.FrameworkName right) => throw null;
                public static bool operator ==(System.Runtime.Versioning.FrameworkName left, System.Runtime.Versioning.FrameworkName right) => throw null;
                public bool Equals(System.Runtime.Versioning.FrameworkName other) => throw null;
                public override bool Equals(object obj) => throw null;
                public FrameworkName(string frameworkName) => throw null;
                public FrameworkName(string identifier, System.Version version) => throw null;
                public FrameworkName(string identifier, System.Version version, string profile) => throw null;
                public string FullName { get => throw null; }
                public override int GetHashCode() => throw null;
                public string Identifier { get => throw null; }
                public string Profile { get => throw null; }
                public override string ToString() => throw null;
                public System.Version Version { get => throw null; }
            }

            public abstract class OSPlatformAttribute : System.Attribute
            {
                protected private OSPlatformAttribute(string platformName) => throw null;
                public string PlatformName { get => throw null; }
            }

            public class ObsoletedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public string Message { get => throw null; }
                public ObsoletedOSPlatformAttribute(string platformName) : base(default(string)) => throw null;
                public ObsoletedOSPlatformAttribute(string platformName, string message) : base(default(string)) => throw null;
                public string Url { get => throw null; set => throw null; }
            }

            public class RequiresPreviewFeaturesAttribute : System.Attribute
            {
                public string Message { get => throw null; }
                public RequiresPreviewFeaturesAttribute() => throw null;
                public RequiresPreviewFeaturesAttribute(string message) => throw null;
                public string Url { get => throw null; set => throw null; }
            }

            public class ResourceConsumptionAttribute : System.Attribute
            {
                public System.Runtime.Versioning.ResourceScope ConsumptionScope { get => throw null; }
                public ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope) => throw null;
                public ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope, System.Runtime.Versioning.ResourceScope consumptionScope) => throw null;
                public System.Runtime.Versioning.ResourceScope ResourceScope { get => throw null; }
            }

            public class ResourceExposureAttribute : System.Attribute
            {
                public ResourceExposureAttribute(System.Runtime.Versioning.ResourceScope exposureLevel) => throw null;
                public System.Runtime.Versioning.ResourceScope ResourceExposureLevel { get => throw null; }
            }

            [System.Flags]
            public enum ResourceScope : int
            {
                AppDomain = 4,
                Assembly = 32,
                Library = 8,
                Machine = 1,
                None = 0,
                Private = 16,
                Process = 2,
            }

            public class SupportedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public SupportedOSPlatformAttribute(string platformName) : base(default(string)) => throw null;
            }

            public class SupportedOSPlatformGuardAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public SupportedOSPlatformGuardAttribute(string platformName) : base(default(string)) => throw null;
            }

            public class TargetFrameworkAttribute : System.Attribute
            {
                public string FrameworkDisplayName { get => throw null; set => throw null; }
                public string FrameworkName { get => throw null; }
                public TargetFrameworkAttribute(string frameworkName) => throw null;
            }

            public class TargetPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public TargetPlatformAttribute(string platformName) : base(default(string)) => throw null;
            }

            public class UnsupportedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public string Message { get => throw null; }
                public UnsupportedOSPlatformAttribute(string platformName) : base(default(string)) => throw null;
                public UnsupportedOSPlatformAttribute(string platformName, string message) : base(default(string)) => throw null;
            }

            public class UnsupportedOSPlatformGuardAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public UnsupportedOSPlatformGuardAttribute(string platformName) : base(default(string)) => throw null;
            }

            public static class VersioningHelper
            {
                public static string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to) => throw null;
                public static string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to, System.Type type) => throw null;
            }

        }
    }
    namespace Security
    {
        public class AllowPartiallyTrustedCallersAttribute : System.Attribute
        {
            public AllowPartiallyTrustedCallersAttribute() => throw null;
            public System.Security.PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get => throw null; set => throw null; }
        }

        public interface IPermission : System.Security.ISecurityEncodable
        {
            System.Security.IPermission Copy();
            void Demand();
            System.Security.IPermission Intersect(System.Security.IPermission target);
            bool IsSubsetOf(System.Security.IPermission target);
            System.Security.IPermission Union(System.Security.IPermission target);
        }

        public interface ISecurityEncodable
        {
            void FromXml(System.Security.SecurityElement e);
            System.Security.SecurityElement ToXml();
        }

        public interface IStackWalk
        {
            void Assert();
            void Demand();
            void Deny();
            void PermitOnly();
        }

        public enum PartialTrustVisibilityLevel : int
        {
            NotVisibleByDefault = 1,
            VisibleToAllHosts = 0,
        }

        public class PermissionSet : System.Collections.ICollection, System.Collections.IEnumerable, System.Runtime.Serialization.IDeserializationCallback, System.Security.ISecurityEncodable, System.Security.IStackWalk
        {
            public System.Security.IPermission AddPermission(System.Security.IPermission perm) => throw null;
            protected virtual System.Security.IPermission AddPermissionImpl(System.Security.IPermission perm) => throw null;
            public void Assert() => throw null;
            public bool ContainsNonCodeAccessPermissions() => throw null;
            public static System.Byte[] ConvertPermissionSet(string inFormat, System.Byte[] inData, string outFormat) => throw null;
            public virtual System.Security.PermissionSet Copy() => throw null;
            public virtual void CopyTo(System.Array array, int index) => throw null;
            public virtual int Count { get => throw null; }
            public void Demand() => throw null;
            public void Deny() => throw null;
            public override bool Equals(object o) => throw null;
            public virtual void FromXml(System.Security.SecurityElement et) => throw null;
            public System.Collections.IEnumerator GetEnumerator() => throw null;
            protected virtual System.Collections.IEnumerator GetEnumeratorImpl() => throw null;
            public override int GetHashCode() => throw null;
            public System.Security.IPermission GetPermission(System.Type permClass) => throw null;
            protected virtual System.Security.IPermission GetPermissionImpl(System.Type permClass) => throw null;
            public System.Security.PermissionSet Intersect(System.Security.PermissionSet other) => throw null;
            public bool IsEmpty() => throw null;
            public virtual bool IsReadOnly { get => throw null; }
            public bool IsSubsetOf(System.Security.PermissionSet target) => throw null;
            public virtual bool IsSynchronized { get => throw null; }
            public bool IsUnrestricted() => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public PermissionSet(System.Security.PermissionSet permSet) => throw null;
            public PermissionSet(System.Security.Permissions.PermissionState state) => throw null;
            public void PermitOnly() => throw null;
            public System.Security.IPermission RemovePermission(System.Type permClass) => throw null;
            protected virtual System.Security.IPermission RemovePermissionImpl(System.Type permClass) => throw null;
            public static void RevertAssert() => throw null;
            public System.Security.IPermission SetPermission(System.Security.IPermission perm) => throw null;
            protected virtual System.Security.IPermission SetPermissionImpl(System.Security.IPermission perm) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public override string ToString() => throw null;
            public virtual System.Security.SecurityElement ToXml() => throw null;
            public System.Security.PermissionSet Union(System.Security.PermissionSet other) => throw null;
        }

        public class SecurityCriticalAttribute : System.Attribute
        {
            public System.Security.SecurityCriticalScope Scope { get => throw null; }
            public SecurityCriticalAttribute() => throw null;
            public SecurityCriticalAttribute(System.Security.SecurityCriticalScope scope) => throw null;
        }

        public enum SecurityCriticalScope : int
        {
            Everything = 1,
            Explicit = 0,
        }

        public class SecurityElement
        {
            public void AddAttribute(string name, string value) => throw null;
            public void AddChild(System.Security.SecurityElement child) => throw null;
            public string Attribute(string name) => throw null;
            public System.Collections.Hashtable Attributes { get => throw null; set => throw null; }
            public System.Collections.ArrayList Children { get => throw null; set => throw null; }
            public System.Security.SecurityElement Copy() => throw null;
            public bool Equal(System.Security.SecurityElement other) => throw null;
            public static string Escape(string str) => throw null;
            public static System.Security.SecurityElement FromString(string xml) => throw null;
            public static bool IsValidAttributeName(string name) => throw null;
            public static bool IsValidAttributeValue(string value) => throw null;
            public static bool IsValidTag(string tag) => throw null;
            public static bool IsValidText(string text) => throw null;
            public System.Security.SecurityElement SearchForChildByTag(string tag) => throw null;
            public string SearchForTextOfTag(string tag) => throw null;
            public SecurityElement(string tag) => throw null;
            public SecurityElement(string tag, string text) => throw null;
            public string Tag { get => throw null; set => throw null; }
            public string Text { get => throw null; set => throw null; }
            public override string ToString() => throw null;
        }

        public class SecurityException : System.SystemException
        {
            public object Demanded { get => throw null; set => throw null; }
            public object DenySetInstance { get => throw null; set => throw null; }
            public System.Reflection.AssemblyName FailedAssemblyInfo { get => throw null; set => throw null; }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public string GrantedSet { get => throw null; set => throw null; }
            public System.Reflection.MethodInfo Method { get => throw null; set => throw null; }
            public string PermissionState { get => throw null; set => throw null; }
            public System.Type PermissionType { get => throw null; set => throw null; }
            public object PermitOnlySetInstance { get => throw null; set => throw null; }
            public string RefusedSet { get => throw null; set => throw null; }
            public SecurityException() => throw null;
            protected SecurityException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public SecurityException(string message) => throw null;
            public SecurityException(string message, System.Exception inner) => throw null;
            public SecurityException(string message, System.Type type) => throw null;
            public SecurityException(string message, System.Type type, string state) => throw null;
            public override string ToString() => throw null;
            public string Url { get => throw null; set => throw null; }
        }

        public enum SecurityRuleSet : byte
        {
            Level1 = 1,
            Level2 = 2,
            None = 0,
        }

        public class SecurityRulesAttribute : System.Attribute
        {
            public System.Security.SecurityRuleSet RuleSet { get => throw null; }
            public SecurityRulesAttribute(System.Security.SecurityRuleSet ruleSet) => throw null;
            public bool SkipVerificationInFullTrust { get => throw null; set => throw null; }
        }

        public class SecuritySafeCriticalAttribute : System.Attribute
        {
            public SecuritySafeCriticalAttribute() => throw null;
        }

        public class SecurityTransparentAttribute : System.Attribute
        {
            public SecurityTransparentAttribute() => throw null;
        }

        public class SecurityTreatAsSafeAttribute : System.Attribute
        {
            public SecurityTreatAsSafeAttribute() => throw null;
        }

        public class SuppressUnmanagedCodeSecurityAttribute : System.Attribute
        {
            public SuppressUnmanagedCodeSecurityAttribute() => throw null;
        }

        public class UnverifiableCodeAttribute : System.Attribute
        {
            public UnverifiableCodeAttribute() => throw null;
        }

        public class VerificationException : System.SystemException
        {
            public VerificationException() => throw null;
            protected VerificationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public VerificationException(string message) => throw null;
            public VerificationException(string message, System.Exception innerException) => throw null;
        }

        namespace Cryptography
        {
            public class CryptographicException : System.SystemException
            {
                public CryptographicException() => throw null;
                protected CryptographicException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public CryptographicException(int hr) => throw null;
                public CryptographicException(string message) => throw null;
                public CryptographicException(string message, System.Exception inner) => throw null;
                public CryptographicException(string format, string insert) => throw null;
            }

        }
        namespace Permissions
        {
            public abstract class CodeAccessSecurityAttribute : System.Security.Permissions.SecurityAttribute
            {
                protected CodeAccessSecurityAttribute(System.Security.Permissions.SecurityAction action) : base(default(System.Security.Permissions.SecurityAction)) => throw null;
            }

            public enum PermissionState : int
            {
                None = 0,
                Unrestricted = 1,
            }

            public enum SecurityAction : int
            {
                Assert = 3,
                Demand = 2,
                Deny = 4,
                InheritanceDemand = 7,
                LinkDemand = 6,
                PermitOnly = 5,
                RequestMinimum = 8,
                RequestOptional = 9,
                RequestRefuse = 10,
            }

            public abstract class SecurityAttribute : System.Attribute
            {
                public System.Security.Permissions.SecurityAction Action { get => throw null; set => throw null; }
                public abstract System.Security.IPermission CreatePermission();
                protected SecurityAttribute(System.Security.Permissions.SecurityAction action) => throw null;
                public bool Unrestricted { get => throw null; set => throw null; }
            }

            public class SecurityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                public bool Assertion { get => throw null; set => throw null; }
                public bool BindingRedirects { get => throw null; set => throw null; }
                public bool ControlAppDomain { get => throw null; set => throw null; }
                public bool ControlDomainPolicy { get => throw null; set => throw null; }
                public bool ControlEvidence { get => throw null; set => throw null; }
                public bool ControlPolicy { get => throw null; set => throw null; }
                public bool ControlPrincipal { get => throw null; set => throw null; }
                public bool ControlThread { get => throw null; set => throw null; }
                public override System.Security.IPermission CreatePermission() => throw null;
                public bool Execution { get => throw null; set => throw null; }
                public System.Security.Permissions.SecurityPermissionFlag Flags { get => throw null; set => throw null; }
                public bool Infrastructure { get => throw null; set => throw null; }
                public bool RemotingConfiguration { get => throw null; set => throw null; }
                public SecurityPermissionAttribute(System.Security.Permissions.SecurityAction action) : base(default(System.Security.Permissions.SecurityAction)) => throw null;
                public bool SerializationFormatter { get => throw null; set => throw null; }
                public bool SkipVerification { get => throw null; set => throw null; }
                public bool UnmanagedCode { get => throw null; set => throw null; }
            }

            [System.Flags]
            public enum SecurityPermissionFlag : int
            {
                AllFlags = 16383,
                Assertion = 1,
                BindingRedirects = 8192,
                ControlAppDomain = 1024,
                ControlDomainPolicy = 256,
                ControlEvidence = 32,
                ControlPolicy = 64,
                ControlPrincipal = 512,
                ControlThread = 16,
                Execution = 8,
                Infrastructure = 4096,
                NoFlags = 0,
                RemotingConfiguration = 2048,
                SerializationFormatter = 128,
                SkipVerification = 4,
                UnmanagedCode = 2,
            }

        }
        namespace Principal
        {
            public interface IIdentity
            {
                string AuthenticationType { get; }
                bool IsAuthenticated { get; }
                string Name { get; }
            }

            public interface IPrincipal
            {
                System.Security.Principal.IIdentity Identity { get; }
                bool IsInRole(string role);
            }

            public enum PrincipalPolicy : int
            {
                NoPrincipal = 1,
                UnauthenticatedPrincipal = 0,
                WindowsPrincipal = 2,
            }

            public enum TokenImpersonationLevel : int
            {
                Anonymous = 1,
                Delegation = 4,
                Identification = 2,
                Impersonation = 3,
                None = 0,
            }

        }
    }
    namespace Text
    {
        public abstract class Decoder
        {
            public virtual void Convert(System.Byte[] bytes, int byteIndex, int byteCount, System.Char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            public virtual void Convert(System.ReadOnlySpan<System.Byte> bytes, System.Span<System.Char> chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            unsafe public virtual void Convert(System.Byte* bytes, int byteCount, System.Char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            protected Decoder() => throw null;
            public System.Text.DecoderFallback Fallback { get => throw null; set => throw null; }
            public System.Text.DecoderFallbackBuffer FallbackBuffer { get => throw null; }
            public abstract int GetCharCount(System.Byte[] bytes, int index, int count);
            public virtual int GetCharCount(System.Byte[] bytes, int index, int count, bool flush) => throw null;
            public virtual int GetCharCount(System.ReadOnlySpan<System.Byte> bytes, bool flush) => throw null;
            unsafe public virtual int GetCharCount(System.Byte* bytes, int count, bool flush) => throw null;
            public abstract int GetChars(System.Byte[] bytes, int byteIndex, int byteCount, System.Char[] chars, int charIndex);
            public virtual int GetChars(System.Byte[] bytes, int byteIndex, int byteCount, System.Char[] chars, int charIndex, bool flush) => throw null;
            public virtual int GetChars(System.ReadOnlySpan<System.Byte> bytes, System.Span<System.Char> chars, bool flush) => throw null;
            unsafe public virtual int GetChars(System.Byte* bytes, int byteCount, System.Char* chars, int charCount, bool flush) => throw null;
            public virtual void Reset() => throw null;
        }

        public class DecoderExceptionFallback : System.Text.DecoderFallback
        {
            public override System.Text.DecoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public DecoderExceptionFallback() => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }

        public class DecoderExceptionFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            public DecoderExceptionFallbackBuffer() => throw null;
            public override bool Fallback(System.Byte[] bytesUnknown, int index) => throw null;
            public override System.Char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
        }

        public abstract class DecoderFallback
        {
            public abstract System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            protected DecoderFallback() => throw null;
            public static System.Text.DecoderFallback ExceptionFallback { get => throw null; }
            public abstract int MaxCharCount { get; }
            public static System.Text.DecoderFallback ReplacementFallback { get => throw null; }
        }

        public abstract class DecoderFallbackBuffer
        {
            protected DecoderFallbackBuffer() => throw null;
            public abstract bool Fallback(System.Byte[] bytesUnknown, int index);
            public abstract System.Char GetNextChar();
            public abstract bool MovePrevious();
            public abstract int Remaining { get; }
            public virtual void Reset() => throw null;
        }

        public class DecoderFallbackException : System.ArgumentException
        {
            public System.Byte[] BytesUnknown { get => throw null; }
            public DecoderFallbackException() => throw null;
            public DecoderFallbackException(string message) => throw null;
            public DecoderFallbackException(string message, System.Byte[] bytesUnknown, int index) => throw null;
            public DecoderFallbackException(string message, System.Exception innerException) => throw null;
            public int Index { get => throw null; }
        }

        public class DecoderReplacementFallback : System.Text.DecoderFallback
        {
            public override System.Text.DecoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public DecoderReplacementFallback() => throw null;
            public DecoderReplacementFallback(string replacement) => throw null;
            public string DefaultString { get => throw null; }
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }

        public class DecoderReplacementFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            public DecoderReplacementFallbackBuffer(System.Text.DecoderReplacementFallback fallback) => throw null;
            public override bool Fallback(System.Byte[] bytesUnknown, int index) => throw null;
            public override System.Char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
            public override void Reset() => throw null;
        }

        public abstract class Encoder
        {
            public virtual void Convert(System.Char[] chars, int charIndex, int charCount, System.Byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            public virtual void Convert(System.ReadOnlySpan<System.Char> chars, System.Span<System.Byte> bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            unsafe public virtual void Convert(System.Char* chars, int charCount, System.Byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            protected Encoder() => throw null;
            public System.Text.EncoderFallback Fallback { get => throw null; set => throw null; }
            public System.Text.EncoderFallbackBuffer FallbackBuffer { get => throw null; }
            public abstract int GetByteCount(System.Char[] chars, int index, int count, bool flush);
            public virtual int GetByteCount(System.ReadOnlySpan<System.Char> chars, bool flush) => throw null;
            unsafe public virtual int GetByteCount(System.Char* chars, int count, bool flush) => throw null;
            public abstract int GetBytes(System.Char[] chars, int charIndex, int charCount, System.Byte[] bytes, int byteIndex, bool flush);
            public virtual int GetBytes(System.ReadOnlySpan<System.Char> chars, System.Span<System.Byte> bytes, bool flush) => throw null;
            unsafe public virtual int GetBytes(System.Char* chars, int charCount, System.Byte* bytes, int byteCount, bool flush) => throw null;
            public virtual void Reset() => throw null;
        }

        public class EncoderExceptionFallback : System.Text.EncoderFallback
        {
            public override System.Text.EncoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public EncoderExceptionFallback() => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }

        public class EncoderExceptionFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            public EncoderExceptionFallbackBuffer() => throw null;
            public override bool Fallback(System.Char charUnknownHigh, System.Char charUnknownLow, int index) => throw null;
            public override bool Fallback(System.Char charUnknown, int index) => throw null;
            public override System.Char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
        }

        public abstract class EncoderFallback
        {
            public abstract System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            protected EncoderFallback() => throw null;
            public static System.Text.EncoderFallback ExceptionFallback { get => throw null; }
            public abstract int MaxCharCount { get; }
            public static System.Text.EncoderFallback ReplacementFallback { get => throw null; }
        }

        public abstract class EncoderFallbackBuffer
        {
            protected EncoderFallbackBuffer() => throw null;
            public abstract bool Fallback(System.Char charUnknownHigh, System.Char charUnknownLow, int index);
            public abstract bool Fallback(System.Char charUnknown, int index);
            public abstract System.Char GetNextChar();
            public abstract bool MovePrevious();
            public abstract int Remaining { get; }
            public virtual void Reset() => throw null;
        }

        public class EncoderFallbackException : System.ArgumentException
        {
            public System.Char CharUnknown { get => throw null; }
            public System.Char CharUnknownHigh { get => throw null; }
            public System.Char CharUnknownLow { get => throw null; }
            public EncoderFallbackException() => throw null;
            public EncoderFallbackException(string message) => throw null;
            public EncoderFallbackException(string message, System.Exception innerException) => throw null;
            public int Index { get => throw null; }
            public bool IsUnknownSurrogate() => throw null;
        }

        public class EncoderReplacementFallback : System.Text.EncoderFallback
        {
            public override System.Text.EncoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public string DefaultString { get => throw null; }
            public EncoderReplacementFallback() => throw null;
            public EncoderReplacementFallback(string replacement) => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }

        public class EncoderReplacementFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            public EncoderReplacementFallbackBuffer(System.Text.EncoderReplacementFallback fallback) => throw null;
            public override bool Fallback(System.Char charUnknownHigh, System.Char charUnknownLow, int index) => throw null;
            public override bool Fallback(System.Char charUnknown, int index) => throw null;
            public override System.Char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
            public override void Reset() => throw null;
        }

        public abstract class Encoding : System.ICloneable
        {
            public static System.Text.Encoding ASCII { get => throw null; }
            public static System.Text.Encoding BigEndianUnicode { get => throw null; }
            public virtual string BodyName { get => throw null; }
            public virtual object Clone() => throw null;
            public virtual int CodePage { get => throw null; }
            public static System.Byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, System.Byte[] bytes) => throw null;
            public static System.Byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, System.Byte[] bytes, int index, int count) => throw null;
            public static System.IO.Stream CreateTranscodingStream(System.IO.Stream innerStream, System.Text.Encoding innerStreamEncoding, System.Text.Encoding outerStreamEncoding, bool leaveOpen = default(bool)) => throw null;
            public System.Text.DecoderFallback DecoderFallback { get => throw null; set => throw null; }
            public static System.Text.Encoding Default { get => throw null; }
            public System.Text.EncoderFallback EncoderFallback { get => throw null; set => throw null; }
            protected Encoding() => throw null;
            protected Encoding(int codePage) => throw null;
            protected Encoding(int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public virtual string EncodingName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public virtual int GetByteCount(System.Char[] chars) => throw null;
            public abstract int GetByteCount(System.Char[] chars, int index, int count);
            public virtual int GetByteCount(System.ReadOnlySpan<System.Char> chars) => throw null;
            unsafe public virtual int GetByteCount(System.Char* chars, int count) => throw null;
            public virtual int GetByteCount(string s) => throw null;
            public int GetByteCount(string s, int index, int count) => throw null;
            public virtual System.Byte[] GetBytes(System.Char[] chars) => throw null;
            public virtual System.Byte[] GetBytes(System.Char[] chars, int index, int count) => throw null;
            public abstract int GetBytes(System.Char[] chars, int charIndex, int charCount, System.Byte[] bytes, int byteIndex);
            public virtual int GetBytes(System.ReadOnlySpan<System.Char> chars, System.Span<System.Byte> bytes) => throw null;
            unsafe public virtual int GetBytes(System.Char* chars, int charCount, System.Byte* bytes, int byteCount) => throw null;
            public virtual System.Byte[] GetBytes(string s) => throw null;
            public System.Byte[] GetBytes(string s, int index, int count) => throw null;
            public virtual int GetBytes(string s, int charIndex, int charCount, System.Byte[] bytes, int byteIndex) => throw null;
            public virtual int GetCharCount(System.Byte[] bytes) => throw null;
            public abstract int GetCharCount(System.Byte[] bytes, int index, int count);
            public virtual int GetCharCount(System.ReadOnlySpan<System.Byte> bytes) => throw null;
            unsafe public virtual int GetCharCount(System.Byte* bytes, int count) => throw null;
            public virtual System.Char[] GetChars(System.Byte[] bytes) => throw null;
            public virtual System.Char[] GetChars(System.Byte[] bytes, int index, int count) => throw null;
            public abstract int GetChars(System.Byte[] bytes, int byteIndex, int byteCount, System.Char[] chars, int charIndex);
            public virtual int GetChars(System.ReadOnlySpan<System.Byte> bytes, System.Span<System.Char> chars) => throw null;
            unsafe public virtual int GetChars(System.Byte* bytes, int byteCount, System.Char* chars, int charCount) => throw null;
            public virtual System.Text.Decoder GetDecoder() => throw null;
            public virtual System.Text.Encoder GetEncoder() => throw null;
            public static System.Text.Encoding GetEncoding(int codepage) => throw null;
            public static System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public static System.Text.Encoding GetEncoding(string name) => throw null;
            public static System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public static System.Text.EncodingInfo[] GetEncodings() => throw null;
            public override int GetHashCode() => throw null;
            public abstract int GetMaxByteCount(int charCount);
            public abstract int GetMaxCharCount(int byteCount);
            public virtual System.Byte[] GetPreamble() => throw null;
            public virtual string GetString(System.Byte[] bytes) => throw null;
            public virtual string GetString(System.Byte[] bytes, int index, int count) => throw null;
            public string GetString(System.ReadOnlySpan<System.Byte> bytes) => throw null;
            unsafe public string GetString(System.Byte* bytes, int byteCount) => throw null;
            public virtual string HeaderName { get => throw null; }
            public bool IsAlwaysNormalized() => throw null;
            public virtual bool IsAlwaysNormalized(System.Text.NormalizationForm form) => throw null;
            public virtual bool IsBrowserDisplay { get => throw null; }
            public virtual bool IsBrowserSave { get => throw null; }
            public virtual bool IsMailNewsDisplay { get => throw null; }
            public virtual bool IsMailNewsSave { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public virtual bool IsSingleByte { get => throw null; }
            public static System.Text.Encoding Latin1 { get => throw null; }
            public virtual System.ReadOnlySpan<System.Byte> Preamble { get => throw null; }
            public static void RegisterProvider(System.Text.EncodingProvider provider) => throw null;
            public static System.Text.Encoding UTF32 { get => throw null; }
            public static System.Text.Encoding UTF7 { get => throw null; }
            public static System.Text.Encoding UTF8 { get => throw null; }
            public static System.Text.Encoding Unicode { get => throw null; }
            public virtual string WebName { get => throw null; }
            public virtual int WindowsCodePage { get => throw null; }
        }

        public class EncodingInfo
        {
            public int CodePage { get => throw null; }
            public string DisplayName { get => throw null; }
            public EncodingInfo(System.Text.EncodingProvider provider, int codePage, string name, string displayName) => throw null;
            public override bool Equals(object value) => throw null;
            public System.Text.Encoding GetEncoding() => throw null;
            public override int GetHashCode() => throw null;
            public string Name { get => throw null; }
        }

        public abstract class EncodingProvider
        {
            public EncodingProvider() => throw null;
            public abstract System.Text.Encoding GetEncoding(int codepage);
            public virtual System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public abstract System.Text.Encoding GetEncoding(string name);
            public virtual System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Text.EncodingInfo> GetEncodings() => throw null;
        }

        public enum NormalizationForm : int
        {
            FormC = 1,
            FormD = 2,
            FormKC = 5,
            FormKD = 6,
        }

        public struct Rune : System.IComparable, System.IComparable<System.Text.Rune>, System.IEquatable<System.Text.Rune>, System.IFormattable, System.ISpanFormattable
        {
            public static bool operator !=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator <(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator <=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator ==(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator >(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator >=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public int CompareTo(System.Text.Rune other) => throw null;
            int System.IComparable.CompareTo(object obj) => throw null;
            public static System.Buffers.OperationStatus DecodeFromUtf16(System.ReadOnlySpan<System.Char> source, out System.Text.Rune result, out int charsConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<System.Byte> source, out System.Text.Rune result, out int bytesConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeLastFromUtf16(System.ReadOnlySpan<System.Char> source, out System.Text.Rune result, out int charsConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeLastFromUtf8(System.ReadOnlySpan<System.Byte> source, out System.Text.Rune value, out int bytesConsumed) => throw null;
            public int EncodeToUtf16(System.Span<System.Char> destination) => throw null;
            public int EncodeToUtf8(System.Span<System.Byte> destination) => throw null;
            public bool Equals(System.Text.Rune other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public static double GetNumericValue(System.Text.Rune value) => throw null;
            public static System.Text.Rune GetRuneAt(string input, int index) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(System.Text.Rune value) => throw null;
            public bool IsAscii { get => throw null; }
            public bool IsBmp { get => throw null; }
            public static bool IsControl(System.Text.Rune value) => throw null;
            public static bool IsDigit(System.Text.Rune value) => throw null;
            public static bool IsLetter(System.Text.Rune value) => throw null;
            public static bool IsLetterOrDigit(System.Text.Rune value) => throw null;
            public static bool IsLower(System.Text.Rune value) => throw null;
            public static bool IsNumber(System.Text.Rune value) => throw null;
            public static bool IsPunctuation(System.Text.Rune value) => throw null;
            public static bool IsSeparator(System.Text.Rune value) => throw null;
            public static bool IsSymbol(System.Text.Rune value) => throw null;
            public static bool IsUpper(System.Text.Rune value) => throw null;
            public static bool IsValid(int value) => throw null;
            public static bool IsValid(System.UInt32 value) => throw null;
            public static bool IsWhiteSpace(System.Text.Rune value) => throw null;
            public int Plane { get => throw null; }
            public static System.Text.Rune ReplacementChar { get => throw null; }
            // Stub generator skipped constructor 
            public Rune(System.Char ch) => throw null;
            public Rune(System.Char highSurrogate, System.Char lowSurrogate) => throw null;
            public Rune(int value) => throw null;
            public Rune(System.UInt32 value) => throw null;
            public static System.Text.Rune ToLower(System.Text.Rune value, System.Globalization.CultureInfo culture) => throw null;
            public static System.Text.Rune ToLowerInvariant(System.Text.Rune value) => throw null;
            public override string ToString() => throw null;
            string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
            public static System.Text.Rune ToUpper(System.Text.Rune value, System.Globalization.CultureInfo culture) => throw null;
            public static System.Text.Rune ToUpperInvariant(System.Text.Rune value) => throw null;
            public static bool TryCreate(System.Char highSurrogate, System.Char lowSurrogate, out System.Text.Rune result) => throw null;
            public static bool TryCreate(System.Char ch, out System.Text.Rune result) => throw null;
            public static bool TryCreate(int value, out System.Text.Rune result) => throw null;
            public static bool TryCreate(System.UInt32 value, out System.Text.Rune result) => throw null;
            public bool TryEncodeToUtf16(System.Span<System.Char> destination, out int charsWritten) => throw null;
            public bool TryEncodeToUtf8(System.Span<System.Byte> destination, out int bytesWritten) => throw null;
            bool System.ISpanFormattable.TryFormat(System.Span<System.Char> destination, out int charsWritten, System.ReadOnlySpan<System.Char> format, System.IFormatProvider provider) => throw null;
            public static bool TryGetRuneAt(string input, int index, out System.Text.Rune value) => throw null;
            public int Utf16SequenceLength { get => throw null; }
            public int Utf8SequenceLength { get => throw null; }
            public int Value { get => throw null; }
            public static explicit operator System.Text.Rune(System.Char ch) => throw null;
            public static explicit operator System.Text.Rune(int value) => throw null;
            public static explicit operator System.Text.Rune(System.UInt32 value) => throw null;
        }

        public class StringBuilder : System.Runtime.Serialization.ISerializable
        {
            public struct AppendInterpolatedStringHandler
            {
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<System.Char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                // Stub generator skipped constructor 
                public AppendInterpolatedStringHandler(int literalLength, int formattedCount, System.Text.StringBuilder stringBuilder) => throw null;
                public AppendInterpolatedStringHandler(int literalLength, int formattedCount, System.Text.StringBuilder stringBuilder, System.IFormatProvider provider) => throw null;
                public void AppendLiteral(string value) => throw null;
            }


            public struct ChunkEnumerator
            {
                // Stub generator skipped constructor 
                public System.ReadOnlyMemory<System.Char> Current { get => throw null; }
                public System.Text.StringBuilder.ChunkEnumerator GetEnumerator() => throw null;
                public bool MoveNext() => throw null;
            }


            public System.Text.StringBuilder Append(System.Char[] value) => throw null;
            public System.Text.StringBuilder Append(System.Char[] value, int startIndex, int charCount) => throw null;
            public System.Text.StringBuilder Append(System.IFormatProvider provider, ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder Append(System.ReadOnlyMemory<System.Char> value) => throw null;
            public System.Text.StringBuilder Append(System.ReadOnlySpan<System.Char> value) => throw null;
            public System.Text.StringBuilder Append(System.Text.StringBuilder value) => throw null;
            public System.Text.StringBuilder Append(System.Text.StringBuilder value, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Append(bool value) => throw null;
            public System.Text.StringBuilder Append(System.Byte value) => throw null;
            public System.Text.StringBuilder Append(System.Char value) => throw null;
            unsafe public System.Text.StringBuilder Append(System.Char* value, int valueCount) => throw null;
            public System.Text.StringBuilder Append(System.Char value, int repeatCount) => throw null;
            public System.Text.StringBuilder Append(System.Decimal value) => throw null;
            public System.Text.StringBuilder Append(double value) => throw null;
            public System.Text.StringBuilder Append(float value) => throw null;
            public System.Text.StringBuilder Append(int value) => throw null;
            public System.Text.StringBuilder Append(System.Int64 value) => throw null;
            public System.Text.StringBuilder Append(object value) => throw null;
            public System.Text.StringBuilder Append(ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder Append(System.SByte value) => throw null;
            public System.Text.StringBuilder Append(System.Int16 value) => throw null;
            public System.Text.StringBuilder Append(string value) => throw null;
            public System.Text.StringBuilder Append(string value, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Append(System.UInt32 value) => throw null;
            public System.Text.StringBuilder Append(System.UInt64 value) => throw null;
            public System.Text.StringBuilder Append(System.UInt16 value) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, params object[] args) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, params object[] args) => throw null;
            public System.Text.StringBuilder AppendJoin(System.Char separator, params object[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(System.Char separator, params string[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(string separator, params object[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(string separator, params string[] values) => throw null;
            public System.Text.StringBuilder AppendJoin<T>(System.Char separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
            public System.Text.StringBuilder AppendJoin<T>(string separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
            public System.Text.StringBuilder AppendLine() => throw null;
            public System.Text.StringBuilder AppendLine(System.IFormatProvider provider, ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder AppendLine(ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder AppendLine(string value) => throw null;
            public int Capacity { get => throw null; set => throw null; }
            [System.Runtime.CompilerServices.IndexerName("Chars")]
            public System.Char this[int index] { get => throw null; set => throw null; }
            public System.Text.StringBuilder Clear() => throw null;
            public void CopyTo(int sourceIndex, System.Char[] destination, int destinationIndex, int count) => throw null;
            public void CopyTo(int sourceIndex, System.Span<System.Char> destination, int count) => throw null;
            public int EnsureCapacity(int capacity) => throw null;
            public bool Equals(System.ReadOnlySpan<System.Char> span) => throw null;
            public bool Equals(System.Text.StringBuilder sb) => throw null;
            public System.Text.StringBuilder.ChunkEnumerator GetChunks() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Char[] value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Char[] value, int startIndex, int charCount) => throw null;
            public System.Text.StringBuilder Insert(int index, System.ReadOnlySpan<System.Char> value) => throw null;
            public System.Text.StringBuilder Insert(int index, bool value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Byte value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Char value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Decimal value) => throw null;
            public System.Text.StringBuilder Insert(int index, double value) => throw null;
            public System.Text.StringBuilder Insert(int index, float value) => throw null;
            public System.Text.StringBuilder Insert(int index, int value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Int64 value) => throw null;
            public System.Text.StringBuilder Insert(int index, object value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.SByte value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.Int16 value) => throw null;
            public System.Text.StringBuilder Insert(int index, string value) => throw null;
            public System.Text.StringBuilder Insert(int index, string value, int count) => throw null;
            public System.Text.StringBuilder Insert(int index, System.UInt32 value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.UInt64 value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.UInt16 value) => throw null;
            public int Length { get => throw null; set => throw null; }
            public int MaxCapacity { get => throw null; }
            public System.Text.StringBuilder Remove(int startIndex, int length) => throw null;
            public System.Text.StringBuilder Replace(System.Char oldChar, System.Char newChar) => throw null;
            public System.Text.StringBuilder Replace(System.Char oldChar, System.Char newChar, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Replace(string oldValue, string newValue) => throw null;
            public System.Text.StringBuilder Replace(string oldValue, string newValue, int startIndex, int count) => throw null;
            public StringBuilder() => throw null;
            public StringBuilder(int capacity) => throw null;
            public StringBuilder(int capacity, int maxCapacity) => throw null;
            public StringBuilder(string value) => throw null;
            public StringBuilder(string value, int capacity) => throw null;
            public StringBuilder(string value, int startIndex, int length, int capacity) => throw null;
            public override string ToString() => throw null;
            public string ToString(int startIndex, int length) => throw null;
        }

        public struct StringRuneEnumerator : System.Collections.Generic.IEnumerable<System.Text.Rune>, System.Collections.Generic.IEnumerator<System.Text.Rune>, System.Collections.IEnumerable, System.Collections.IEnumerator, System.IDisposable
        {
            public System.Text.Rune Current { get => throw null; }
            object System.Collections.IEnumerator.Current { get => throw null; }
            void System.IDisposable.Dispose() => throw null;
            public System.Text.StringRuneEnumerator GetEnumerator() => throw null;
            System.Collections.Generic.IEnumerator<System.Text.Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public bool MoveNext() => throw null;
            void System.Collections.IEnumerator.Reset() => throw null;
            // Stub generator skipped constructor 
        }

        namespace Unicode
        {
            public static class Utf8
            {
                public static System.Buffers.OperationStatus FromUtf16(System.ReadOnlySpan<System.Char> source, System.Span<System.Byte> destination, out int charsRead, out int bytesWritten, bool replaceInvalidSequences = default(bool), bool isFinalBlock = default(bool)) => throw null;
                public static System.Buffers.OperationStatus ToUtf16(System.ReadOnlySpan<System.Byte> source, System.Span<System.Char> destination, out int bytesRead, out int charsWritten, bool replaceInvalidSequences = default(bool), bool isFinalBlock = default(bool)) => throw null;
            }

        }
    }
    namespace Threading
    {
        public struct CancellationToken : System.IEquatable<System.Threading.CancellationToken>
        {
            public static bool operator !=(System.Threading.CancellationToken left, System.Threading.CancellationToken right) => throw null;
            public static bool operator ==(System.Threading.CancellationToken left, System.Threading.CancellationToken right) => throw null;
            public bool CanBeCanceled { get => throw null; }
            // Stub generator skipped constructor 
            public CancellationToken(bool canceled) => throw null;
            public bool Equals(System.Threading.CancellationToken other) => throw null;
            public override bool Equals(object other) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsCancellationRequested { get => throw null; }
            public static System.Threading.CancellationToken None { get => throw null; }
            public System.Threading.CancellationTokenRegistration Register(System.Action callback) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action callback, bool useSynchronizationContext) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object, System.Threading.CancellationToken> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state, bool useSynchronizationContext) => throw null;
            public void ThrowIfCancellationRequested() => throw null;
            public System.Threading.CancellationTokenRegistration UnsafeRegister(System.Action<object, System.Threading.CancellationToken> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration UnsafeRegister(System.Action<object> callback, object state) => throw null;
            public System.Threading.WaitHandle WaitHandle { get => throw null; }
        }

        public struct CancellationTokenRegistration : System.IAsyncDisposable, System.IDisposable, System.IEquatable<System.Threading.CancellationTokenRegistration>
        {
            public static bool operator !=(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right) => throw null;
            public static bool operator ==(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right) => throw null;
            // Stub generator skipped constructor 
            public void Dispose() => throw null;
            public System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public bool Equals(System.Threading.CancellationTokenRegistration other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public System.Threading.CancellationToken Token { get => throw null; }
            public bool Unregister() => throw null;
        }

        public class CancellationTokenSource : System.IDisposable
        {
            public void Cancel() => throw null;
            public void Cancel(bool throwOnFirstException) => throw null;
            public void CancelAfter(System.TimeSpan delay) => throw null;
            public void CancelAfter(int millisecondsDelay) => throw null;
            public CancellationTokenSource() => throw null;
            public CancellationTokenSource(System.TimeSpan delay) => throw null;
            public CancellationTokenSource(int millisecondsDelay) => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token) => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2) => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(params System.Threading.CancellationToken[] tokens) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public bool IsCancellationRequested { get => throw null; }
            public System.Threading.CancellationToken Token { get => throw null; }
            public bool TryReset() => throw null;
        }

        public enum LazyThreadSafetyMode : int
        {
            ExecutionAndPublication = 2,
            None = 0,
            PublicationOnly = 1,
        }

        public class PeriodicTimer : System.IDisposable
        {
            public void Dispose() => throw null;
            public PeriodicTimer(System.TimeSpan period) => throw null;
            public System.Threading.Tasks.ValueTask<bool> WaitForNextTickAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            // ERR: Stub generator didn't handle member: ~PeriodicTimer
        }

        public static class Timeout
        {
            public const int Infinite = default;
            public static System.TimeSpan InfiniteTimeSpan;
        }

        public class Timer : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
        {
            public static System.Int64 ActiveCount { get => throw null; }
            public bool Change(System.TimeSpan dueTime, System.TimeSpan period) => throw null;
            public bool Change(int dueTime, int period) => throw null;
            public bool Change(System.Int64 dueTime, System.Int64 period) => throw null;
            public bool Change(System.UInt32 dueTime, System.UInt32 period) => throw null;
            public void Dispose() => throw null;
            public bool Dispose(System.Threading.WaitHandle notifyObject) => throw null;
            public System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public Timer(System.Threading.TimerCallback callback) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, System.TimeSpan dueTime, System.TimeSpan period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, int dueTime, int period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, System.Int64 dueTime, System.Int64 period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, System.UInt32 dueTime, System.UInt32 period) => throw null;
        }

        public delegate void TimerCallback(object state);

        public abstract class WaitHandle : System.MarshalByRefObject, System.IDisposable
        {
            public virtual void Close() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool explicitDisposing) => throw null;
            public virtual System.IntPtr Handle { get => throw null; set => throw null; }
            protected static System.IntPtr InvalidHandle;
            public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get => throw null; set => throw null; }
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn) => throw null;
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, System.TimeSpan timeout, bool exitContext) => throw null;
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext) => throw null;
            protected WaitHandle() => throw null;
            public virtual bool WaitOne() => throw null;
            public virtual bool WaitOne(System.TimeSpan timeout) => throw null;
            public virtual bool WaitOne(System.TimeSpan timeout, bool exitContext) => throw null;
            public virtual bool WaitOne(int millisecondsTimeout) => throw null;
            public virtual bool WaitOne(int millisecondsTimeout, bool exitContext) => throw null;
            public const int WaitTimeout = default;
        }

        public static class WaitHandleExtensions
        {
            public static Microsoft.Win32.SafeHandles.SafeWaitHandle GetSafeWaitHandle(this System.Threading.WaitHandle waitHandle) => throw null;
            public static void SetSafeWaitHandle(this System.Threading.WaitHandle waitHandle, Microsoft.Win32.SafeHandles.SafeWaitHandle value) => throw null;
        }

        namespace Tasks
        {
            public class ConcurrentExclusiveSchedulerPair
            {
                public void Complete() => throw null;
                public System.Threading.Tasks.Task Completion { get => throw null; }
                public ConcurrentExclusiveSchedulerPair() => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler) => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel) => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask) => throw null;
                public System.Threading.Tasks.TaskScheduler ConcurrentScheduler { get => throw null; }
                public System.Threading.Tasks.TaskScheduler ExclusiveScheduler { get => throw null; }
            }

            public class Task : System.IAsyncResult, System.IDisposable
            {
                public object AsyncState { get => throw null; }
                System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get => throw null; }
                bool System.IAsyncResult.CompletedSynchronously { get => throw null; }
                public static System.Threading.Tasks.Task CompletedTask { get => throw null; }
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public static int? CurrentId { get => throw null; }
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay) => throw null;
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task Delay(int millisecondsDelay) => throw null;
                public static System.Threading.Tasks.Task Delay(int millisecondsDelay, System.Threading.CancellationToken cancellationToken) => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public System.AggregateException Exception { get => throw null; }
                public static System.Threading.Tasks.TaskFactory Factory { get => throw null; }
                public static System.Threading.Tasks.Task FromCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task FromException(System.Exception exception) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromException<TResult>(System.Exception exception) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromResult<TResult>(TResult result) => throw null;
                public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() => throw null;
                public int Id { get => throw null; }
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public static System.Threading.Tasks.Task Run(System.Action action) => throw null;
                public static System.Threading.Tasks.Task Run(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function) => throw null;
                public static System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public void RunSynchronously() => throw null;
                public void RunSynchronously(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public void Start() => throw null;
                public void Start(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.TaskStatus Status { get => throw null; }
                public Task(System.Action action) => throw null;
                public Task(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public Task(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action<object> action, object state) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public void Wait() => throw null;
                public void Wait(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool Wait(System.TimeSpan timeout) => throw null;
                public bool Wait(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public bool Wait(int millisecondsTimeout) => throw null;
                public bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static void WaitAll(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static void WaitAll(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static int WaitAny(params System.Threading.Tasks.Task[] tasks) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task WhenAll(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks) => throw null;
                public static System.Threading.Tasks.Task WhenAll(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks) => throw null;
                public static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(params System.Threading.Tasks.Task<TResult>[] tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Threading.Tasks.Task task1, System.Threading.Tasks.Task task2) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Threading.Tasks.Task<TResult> task1, System.Threading.Tasks.Task<TResult> task2) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(params System.Threading.Tasks.Task<TResult>[] tasks) => throw null;
                public static System.Runtime.CompilerServices.YieldAwaitable Yield() => throw null;
            }

            public class Task<TResult> : System.Threading.Tasks.Task
            {
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public static System.Threading.Tasks.TaskFactory<TResult> Factory { get => throw null; }
                public System.Runtime.CompilerServices.TaskAwaiter<TResult> GetAwaiter() => throw null;
                public TResult Result { get => throw null; }
                public Task(System.Func<TResult> function) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
            }

            public static class TaskAsyncEnumerableExtensions
            {
                public static System.Runtime.CompilerServices.ConfiguredAsyncDisposable ConfigureAwait(this System.IAsyncDisposable source, bool continueOnCapturedContext) => throw null;
                public static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, bool continueOnCapturedContext) => throw null;
                public static System.Collections.Generic.IEnumerable<T> ToBlockingEnumerable<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, System.Threading.CancellationToken cancellationToken) => throw null;
            }

            public class TaskCanceledException : System.OperationCanceledException
            {
                public System.Threading.Tasks.Task Task { get => throw null; }
                public TaskCanceledException() => throw null;
                protected TaskCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public TaskCanceledException(System.Threading.Tasks.Task task) => throw null;
                public TaskCanceledException(string message) => throw null;
                public TaskCanceledException(string message, System.Exception innerException) => throw null;
                public TaskCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token) => throw null;
            }

            public class TaskCompletionSource
            {
                public void SetCanceled() => throw null;
                public void SetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public void SetResult() => throw null;
                public System.Threading.Tasks.Task Task { get => throw null; }
                public TaskCompletionSource() => throw null;
                public TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskCompletionSource(object state) => throw null;
                public TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public bool TrySetCanceled() => throw null;
                public bool TrySetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool TrySetException(System.Exception exception) => throw null;
                public bool TrySetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public bool TrySetResult() => throw null;
            }

            public class TaskCompletionSource<TResult>
            {
                public void SetCanceled() => throw null;
                public void SetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public void SetResult(TResult result) => throw null;
                public System.Threading.Tasks.Task<TResult> Task { get => throw null; }
                public TaskCompletionSource() => throw null;
                public TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskCompletionSource(object state) => throw null;
                public TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public bool TrySetCanceled() => throw null;
                public bool TrySetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool TrySetException(System.Exception exception) => throw null;
                public bool TrySetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public bool TrySetResult(TResult result) => throw null;
            }

            [System.Flags]
            public enum TaskContinuationOptions : int
            {
                AttachedToParent = 4,
                DenyChildAttach = 8,
                ExecuteSynchronously = 524288,
                HideScheduler = 16,
                LazyCancellation = 32,
                LongRunning = 2,
                None = 0,
                NotOnCanceled = 262144,
                NotOnFaulted = 131072,
                NotOnRanToCompletion = 65536,
                OnlyOnCanceled = 196608,
                OnlyOnFaulted = 327680,
                OnlyOnRanToCompletion = 393216,
                PreferFairness = 1,
                RunContinuationsAsynchronously = 64,
            }

            [System.Flags]
            public enum TaskCreationOptions : int
            {
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                LongRunning = 2,
                None = 0,
                PreferFairness = 1,
                RunContinuationsAsynchronously = 64,
            }

            public static class TaskExtensions
            {
                public static System.Threading.Tasks.Task Unwrap(this System.Threading.Tasks.Task<System.Threading.Tasks.Task> task) => throw null;
                public static System.Threading.Tasks.Task<TResult> Unwrap<TResult>(this System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> task) => throw null;
            }

            public class TaskFactory
            {
                public System.Threading.CancellationToken CancellationToken { get => throw null; }
                public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get => throw null; }
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.TaskScheduler Scheduler { get => throw null; }
                public System.Threading.Tasks.Task StartNew(System.Action action) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskFactory() => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken) => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
            }

            public class TaskFactory<TResult>
            {
                public System.Threading.CancellationToken CancellationToken { get => throw null; }
                public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get => throw null; }
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.TaskScheduler Scheduler { get => throw null; }
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskFactory() => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken) => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
            }

            public abstract class TaskScheduler
            {
                public static System.Threading.Tasks.TaskScheduler Current { get => throw null; }
                public static System.Threading.Tasks.TaskScheduler Default { get => throw null; }
                public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() => throw null;
                protected abstract System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();
                public int Id { get => throw null; }
                public virtual int MaximumConcurrencyLevel { get => throw null; }
                protected internal abstract void QueueTask(System.Threading.Tasks.Task task);
                protected TaskScheduler() => throw null;
                protected internal virtual bool TryDequeue(System.Threading.Tasks.Task task) => throw null;
                protected bool TryExecuteTask(System.Threading.Tasks.Task task) => throw null;
                protected abstract bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                public static event System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> UnobservedTaskException;
            }

            public class TaskSchedulerException : System.Exception
            {
                public TaskSchedulerException() => throw null;
                public TaskSchedulerException(System.Exception innerException) => throw null;
                protected TaskSchedulerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public TaskSchedulerException(string message) => throw null;
                public TaskSchedulerException(string message, System.Exception innerException) => throw null;
            }

            public enum TaskStatus : int
            {
                Canceled = 6,
                Created = 0,
                Faulted = 7,
                RanToCompletion = 5,
                Running = 3,
                WaitingForActivation = 1,
                WaitingForChildrenToComplete = 4,
                WaitingToRun = 2,
            }

            public class UnobservedTaskExceptionEventArgs : System.EventArgs
            {
                public System.AggregateException Exception { get => throw null; }
                public bool Observed { get => throw null; }
                public void SetObserved() => throw null;
                public UnobservedTaskExceptionEventArgs(System.AggregateException exception) => throw null;
            }

            public struct ValueTask : System.IEquatable<System.Threading.Tasks.ValueTask>
            {
                public static bool operator !=(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right) => throw null;
                public static bool operator ==(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right) => throw null;
                public System.Threading.Tasks.Task AsTask() => throw null;
                public static System.Threading.Tasks.ValueTask CompletedTask { get => throw null; }
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public bool Equals(System.Threading.Tasks.ValueTask other) => throw null;
                public override bool Equals(object obj) => throw null;
                public static System.Threading.Tasks.ValueTask FromCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.ValueTask FromException(System.Exception exception) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromException<TResult>(System.Exception exception) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromResult<TResult>(TResult result) => throw null;
                public System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter() => throw null;
                public override int GetHashCode() => throw null;
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public System.Threading.Tasks.ValueTask Preserve() => throw null;
                // Stub generator skipped constructor 
                public ValueTask(System.Threading.Tasks.Sources.IValueTaskSource source, System.Int16 token) => throw null;
                public ValueTask(System.Threading.Tasks.Task task) => throw null;
            }

            public struct ValueTask<TResult> : System.IEquatable<System.Threading.Tasks.ValueTask<TResult>>
            {
                public static bool operator !=(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right) => throw null;
                public static bool operator ==(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right) => throw null;
                public System.Threading.Tasks.Task<TResult> AsTask() => throw null;
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public bool Equals(System.Threading.Tasks.ValueTask<TResult> other) => throw null;
                public override bool Equals(object obj) => throw null;
                public System.Runtime.CompilerServices.ValueTaskAwaiter<TResult> GetAwaiter() => throw null;
                public override int GetHashCode() => throw null;
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public System.Threading.Tasks.ValueTask<TResult> Preserve() => throw null;
                public TResult Result { get => throw null; }
                public override string ToString() => throw null;
                // Stub generator skipped constructor 
                public ValueTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, System.Int16 token) => throw null;
                public ValueTask(TResult result) => throw null;
                public ValueTask(System.Threading.Tasks.Task<TResult> task) => throw null;
            }

            namespace Sources
            {
                public interface IValueTaskSource
                {
                    void GetResult(System.Int16 token);
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(System.Int16 token);
                    void OnCompleted(System.Action<object> continuation, object state, System.Int16 token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                }

                public interface IValueTaskSource<TResult>
                {
                    TResult GetResult(System.Int16 token);
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(System.Int16 token);
                    void OnCompleted(System.Action<object> continuation, object state, System.Int16 token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                }

                public struct ManualResetValueTaskSourceCore<TResult>
                {
                    public TResult GetResult(System.Int16 token) => throw null;
                    public System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(System.Int16 token) => throw null;
                    // Stub generator skipped constructor 
                    public void OnCompleted(System.Action<object> continuation, object state, System.Int16 token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags) => throw null;
                    public void Reset() => throw null;
                    public bool RunContinuationsAsynchronously { get => throw null; set => throw null; }
                    public void SetException(System.Exception error) => throw null;
                    public void SetResult(TResult result) => throw null;
                    public System.Int16 Version { get => throw null; }
                }

                [System.Flags]
                public enum ValueTaskSourceOnCompletedFlags : int
                {
                    FlowExecutionContext = 2,
                    None = 0,
                    UseSchedulingContext = 1,
                }

                public enum ValueTaskSourceStatus : int
                {
                    Canceled = 3,
                    Faulted = 2,
                    Pending = 0,
                    Succeeded = 1,
                }

            }
        }
    }
}
