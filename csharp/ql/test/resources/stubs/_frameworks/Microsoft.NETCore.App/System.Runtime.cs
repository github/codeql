// This file contains auto-generated code.
// Generated from `System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`.
namespace Microsoft
{
    namespace Win32
    {
        namespace SafeHandles
        {
            public abstract class CriticalHandleMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                protected CriticalHandleMinusOneIsInvalid() : base(default(nint)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }
            public abstract class CriticalHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                protected CriticalHandleZeroOrMinusOneIsInvalid() : base(default(nint)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }
            public sealed class SafeFileHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                public SafeFileHandle() : base(default(bool)) => throw null;
                public SafeFileHandle(nint preexistingHandle, bool ownsHandle) : base(default(bool)) => throw null;
                public bool IsAsync { get => throw null; }
                public override bool IsInvalid { get => throw null; }
                protected override bool ReleaseHandle() => throw null;
            }
            public abstract class SafeHandleMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                protected SafeHandleMinusOneIsInvalid(bool ownsHandle) : base(default(nint), default(bool)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }
            public abstract class SafeHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle) : base(default(nint), default(bool)) => throw null;
                public override bool IsInvalid { get => throw null; }
            }
            public sealed class SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                public SafeWaitHandle() : base(default(bool)) => throw null;
                public SafeWaitHandle(nint existingHandle, bool ownsHandle) : base(default(bool)) => throw null;
                protected override bool ReleaseHandle() => throw null;
            }
        }
    }
}
namespace System
{
    public class AccessViolationException : System.SystemException
    {
        public AccessViolationException() => throw null;
        protected AccessViolationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AccessViolationException(string message) => throw null;
        public AccessViolationException(string message, System.Exception innerException) => throw null;
    }
    public delegate void Action();
    public delegate void Action<T>(T obj);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public delegate void Action<T1, T2>(T1 arg1, T2 arg2);
    public delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);
    public delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public delegate void Action<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public delegate void Action<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public static class Activator
    {
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public static object CreateInstance(System.Type type) => throw null;
        public static object CreateInstance(System.Type type, bool nonPublic) => throw null;
        public static object CreateInstance(System.Type type, params object[] args) => throw null;
        public static object CreateInstance(System.Type type, object[] args, object[] activationAttributes) => throw null;
        public static object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture) => throw null;
        public static object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static T CreateInstance<T>() => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
    }
    public class AggregateException : System.Exception
    {
        public AggregateException() => throw null;
        public AggregateException(System.Collections.Generic.IEnumerable<System.Exception> innerExceptions) => throw null;
        public AggregateException(params System.Exception[] innerExceptions) => throw null;
        protected AggregateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AggregateException(string message) => throw null;
        public AggregateException(string message, System.Collections.Generic.IEnumerable<System.Exception> innerExceptions) => throw null;
        public AggregateException(string message, System.Exception innerException) => throw null;
        public AggregateException(string message, params System.Exception[] innerExceptions) => throw null;
        public System.AggregateException Flatten() => throw null;
        public override System.Exception GetBaseException() => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public void Handle(System.Func<System.Exception, bool> predicate) => throw null;
        public System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> InnerExceptions { get => throw null; }
        public override string Message { get => throw null; }
        public override string ToString() => throw null;
    }
    public static class AppContext
    {
        public static string BaseDirectory { get => throw null; }
        public static object GetData(string name) => throw null;
        public static void SetData(string name, object data) => throw null;
        public static void SetSwitch(string switchName, bool isEnabled) => throw null;
        public static string TargetFrameworkName { get => throw null; }
        public static bool TryGetSwitch(string switchName, out bool isEnabled) => throw null;
    }
    public sealed class AppDomain : System.MarshalByRefObject
    {
        public void AppendPrivatePath(string path) => throw null;
        public string ApplyPolicy(string assemblyName) => throw null;
        public event System.AssemblyLoadEventHandler AssemblyLoad;
        public event System.ResolveEventHandler AssemblyResolve;
        public string BaseDirectory { get => throw null; }
        public void ClearPrivatePath() => throw null;
        public void ClearShadowCopyPath() => throw null;
        public static System.AppDomain CreateDomain(string friendlyName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) => throw null;
        public static System.AppDomain CurrentDomain { get => throw null; }
        public event System.EventHandler DomainUnload;
        public string DynamicDirectory { get => throw null; }
        public int ExecuteAssembly(string assemblyFile) => throw null;
        public int ExecuteAssembly(string assemblyFile, string[] args) => throw null;
        public int ExecuteAssembly(string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) => throw null;
        public int ExecuteAssemblyByName(System.Reflection.AssemblyName assemblyName, params string[] args) => throw null;
        public int ExecuteAssemblyByName(string assemblyName) => throw null;
        public int ExecuteAssemblyByName(string assemblyName, params string[] args) => throw null;
        public event System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
        public string FriendlyName { get => throw null; }
        public System.Reflection.Assembly[] GetAssemblies() => throw null;
        public static int GetCurrentThreadId() => throw null;
        public object GetData(string name) => throw null;
        public int Id { get => throw null; }
        public bool? IsCompatibilitySwitchSet(string value) => throw null;
        public bool IsDefaultAppDomain() => throw null;
        public bool IsFinalizingForUnload() => throw null;
        public bool IsFullyTrusted { get => throw null; }
        public bool IsHomogenous { get => throw null; }
        public System.Reflection.Assembly Load(byte[] rawAssembly) => throw null;
        public System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore) => throw null;
        public System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef) => throw null;
        public System.Reflection.Assembly Load(string assemblyString) => throw null;
        public static bool MonitoringIsEnabled { get => throw null; set { } }
        public long MonitoringSurvivedMemorySize { get => throw null; }
        public static long MonitoringSurvivedProcessMemorySize { get => throw null; }
        public long MonitoringTotalAllocatedMemorySize { get => throw null; }
        public System.TimeSpan MonitoringTotalProcessorTime { get => throw null; }
        public System.Security.PermissionSet PermissionSet { get => throw null; }
        public event System.EventHandler ProcessExit;
        public event System.ResolveEventHandler ReflectionOnlyAssemblyResolve;
        public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() => throw null;
        public string RelativeSearchPath { get => throw null; }
        public event System.ResolveEventHandler ResourceResolve;
        public void SetCachePath(string path) => throw null;
        public void SetData(string name, object data) => throw null;
        public void SetDynamicBase(string path) => throw null;
        public void SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy policy) => throw null;
        public void SetShadowCopyFiles() => throw null;
        public void SetShadowCopyPath(string path) => throw null;
        public void SetThreadPrincipal(System.Security.Principal.IPrincipal principal) => throw null;
        public System.AppDomainSetup SetupInformation { get => throw null; }
        public bool ShadowCopyFiles { get => throw null; }
        public override string ToString() => throw null;
        public event System.ResolveEventHandler TypeResolve;
        public event System.UnhandledExceptionEventHandler UnhandledException;
        public static void Unload(System.AppDomain domain) => throw null;
    }
    public sealed class AppDomainSetup
    {
        public string ApplicationBase { get => throw null; }
        public string TargetFrameworkName { get => throw null; }
    }
    public class AppDomainUnloadedException : System.SystemException
    {
        public AppDomainUnloadedException() => throw null;
        protected AppDomainUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public AppDomainUnloadedException(string message) => throw null;
        public AppDomainUnloadedException(string message, System.Exception innerException) => throw null;
    }
    public class ApplicationException : System.Exception
    {
        public ApplicationException() => throw null;
        protected ApplicationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ApplicationException(string message) => throw null;
        public ApplicationException(string message, System.Exception innerException) => throw null;
    }
    public sealed class ApplicationId
    {
        public System.ApplicationId Copy() => throw null;
        public ApplicationId(byte[] publicKeyToken, string name, System.Version version, string processorArchitecture, string culture) => throw null;
        public string Culture { get => throw null; }
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public string Name { get => throw null; }
        public string ProcessorArchitecture { get => throw null; }
        public byte[] PublicKeyToken { get => throw null; }
        public override string ToString() => throw null;
        public System.Version Version { get => throw null; }
    }
    public struct ArgIterator
    {
        public ArgIterator(System.RuntimeArgumentHandle arglist) => throw null;
        public unsafe ArgIterator(System.RuntimeArgumentHandle arglist, void* ptr) => throw null;
        public void End() => throw null;
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public System.TypedReference GetNextArg() => throw null;
        public System.TypedReference GetNextArg(System.RuntimeTypeHandle rth) => throw null;
        public System.RuntimeTypeHandle GetNextArgType() => throw null;
        public int GetRemainingCount() => throw null;
    }
    public class ArgumentException : System.SystemException
    {
        public ArgumentException() => throw null;
        protected ArgumentException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentException(string message) => throw null;
        public ArgumentException(string message, System.Exception innerException) => throw null;
        public ArgumentException(string message, string paramName) => throw null;
        public ArgumentException(string message, string paramName, System.Exception innerException) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public virtual string ParamName { get => throw null; }
        public static void ThrowIfNullOrEmpty(string argument, string paramName = default(string)) => throw null;
        public static void ThrowIfNullOrWhiteSpace(string argument, string paramName = default(string)) => throw null;
    }
    public class ArgumentNullException : System.ArgumentException
    {
        public ArgumentNullException() => throw null;
        protected ArgumentNullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentNullException(string paramName) => throw null;
        public ArgumentNullException(string message, System.Exception innerException) => throw null;
        public ArgumentNullException(string paramName, string message) => throw null;
        public static void ThrowIfNull(object argument, string paramName = default(string)) => throw null;
        public static unsafe void ThrowIfNull(void* argument, string paramName = default(string)) => throw null;
    }
    public class ArgumentOutOfRangeException : System.ArgumentException
    {
        public virtual object ActualValue { get => throw null; }
        public ArgumentOutOfRangeException() => throw null;
        protected ArgumentOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArgumentOutOfRangeException(string paramName) => throw null;
        public ArgumentOutOfRangeException(string message, System.Exception innerException) => throw null;
        public ArgumentOutOfRangeException(string paramName, object actualValue, string message) => throw null;
        public ArgumentOutOfRangeException(string paramName, string message) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public static void ThrowIfEqual<T>(T value, T other, string paramName = default(string)) where T : System.IEquatable<T> => throw null;
        public static void ThrowIfGreaterThan<T>(T value, T other, string paramName = default(string)) where T : System.IComparable<T> => throw null;
        public static void ThrowIfGreaterThanOrEqual<T>(T value, T other, string paramName = default(string)) where T : System.IComparable<T> => throw null;
        public static void ThrowIfLessThan<T>(T value, T other, string paramName = default(string)) where T : System.IComparable<T> => throw null;
        public static void ThrowIfLessThanOrEqual<T>(T value, T other, string paramName = default(string)) where T : System.IComparable<T> => throw null;
        public static void ThrowIfNegative<T>(T value, string paramName = default(string)) where T : System.Numerics.INumberBase<T> => throw null;
        public static void ThrowIfNegativeOrZero<T>(T value, string paramName = default(string)) where T : System.Numerics.INumberBase<T> => throw null;
        public static void ThrowIfNotEqual<T>(T value, T other, string paramName = default(string)) where T : System.IEquatable<T> => throw null;
        public static void ThrowIfZero<T>(T value, string paramName = default(string)) where T : System.Numerics.INumberBase<T> => throw null;
    }
    public class ArithmeticException : System.SystemException
    {
        public ArithmeticException() => throw null;
        protected ArithmeticException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArithmeticException(string message) => throw null;
        public ArithmeticException(string message, System.Exception innerException) => throw null;
    }
    public abstract class Array : System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable
    {
        int System.Collections.IList.Add(object value) => throw null;
        public static System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly<T>(T[] array) => throw null;
        public static int BinarySearch(System.Array array, int index, int length, object value) => throw null;
        public static int BinarySearch(System.Array array, int index, int length, object value, System.Collections.IComparer comparer) => throw null;
        public static int BinarySearch(System.Array array, object value) => throw null;
        public static int BinarySearch(System.Array array, object value, System.Collections.IComparer comparer) => throw null;
        public static int BinarySearch<T>(T[] array, int index, int length, T value) => throw null;
        public static int BinarySearch<T>(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static int BinarySearch<T>(T[] array, T value) => throw null;
        public static int BinarySearch<T>(T[] array, T value, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static void Clear(System.Array array) => throw null;
        public static void Clear(System.Array array, int index, int length) => throw null;
        void System.Collections.IList.Clear() => throw null;
        public object Clone() => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        public static void ConstrainedCopy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) => throw null;
        bool System.Collections.IList.Contains(object value) => throw null;
        public static TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, System.Converter<TInput, TOutput> converter) => throw null;
        public static void Copy(System.Array sourceArray, System.Array destinationArray, int length) => throw null;
        public static void Copy(System.Array sourceArray, System.Array destinationArray, long length) => throw null;
        public static void Copy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) => throw null;
        public static void Copy(System.Array sourceArray, long sourceIndex, System.Array destinationArray, long destinationIndex, long length) => throw null;
        public void CopyTo(System.Array array, int index) => throw null;
        public void CopyTo(System.Array array, long index) => throw null;
        int System.Collections.ICollection.Count { get => throw null; }
        public static System.Array CreateInstance(System.Type elementType, int length) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int length1, int length2) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int length1, int length2, int length3) => throw null;
        public static System.Array CreateInstance(System.Type elementType, params int[] lengths) => throw null;
        public static System.Array CreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds) => throw null;
        public static System.Array CreateInstance(System.Type elementType, params long[] lengths) => throw null;
        public static T[] Empty<T>() => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public static bool Exists<T>(T[] array, System.Predicate<T> match) => throw null;
        public static void Fill<T>(T[] array, T value) => throw null;
        public static void Fill<T>(T[] array, T value, int startIndex, int count) => throw null;
        public static T Find<T>(T[] array, System.Predicate<T> match) => throw null;
        public static T[] FindAll<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, int startIndex, System.Predicate<T> match) => throw null;
        public static int FindIndex<T>(T[] array, System.Predicate<T> match) => throw null;
        public static T FindLast<T>(T[] array, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, int startIndex, System.Predicate<T> match) => throw null;
        public static int FindLastIndex<T>(T[] array, System.Predicate<T> match) => throw null;
        public static void ForEach<T>(T[] array, System.Action<T> action) => throw null;
        public System.Collections.IEnumerator GetEnumerator() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        public int GetLength(int dimension) => throw null;
        public long GetLongLength(int dimension) => throw null;
        public int GetLowerBound(int dimension) => throw null;
        public int GetUpperBound(int dimension) => throw null;
        public object GetValue(int index) => throw null;
        public object GetValue(int index1, int index2) => throw null;
        public object GetValue(int index1, int index2, int index3) => throw null;
        public object GetValue(params int[] indices) => throw null;
        public object GetValue(long index) => throw null;
        public object GetValue(long index1, long index2) => throw null;
        public object GetValue(long index1, long index2, long index3) => throw null;
        public object GetValue(params long[] indices) => throw null;
        public static int IndexOf(System.Array array, object value) => throw null;
        public static int IndexOf(System.Array array, object value, int startIndex) => throw null;
        public static int IndexOf(System.Array array, object value, int startIndex, int count) => throw null;
        public static int IndexOf<T>(T[] array, T value) => throw null;
        public static int IndexOf<T>(T[] array, T value, int startIndex) => throw null;
        public static int IndexOf<T>(T[] array, T value, int startIndex, int count) => throw null;
        int System.Collections.IList.IndexOf(object value) => throw null;
        public void Initialize() => throw null;
        void System.Collections.IList.Insert(int index, object value) => throw null;
        public bool IsFixedSize { get => throw null; }
        public bool IsReadOnly { get => throw null; }
        public bool IsSynchronized { get => throw null; }
        object System.Collections.IList.this[int index] { get => throw null; set { } }
        public static int LastIndexOf(System.Array array, object value) => throw null;
        public static int LastIndexOf(System.Array array, object value, int startIndex) => throw null;
        public static int LastIndexOf(System.Array array, object value, int startIndex, int count) => throw null;
        public static int LastIndexOf<T>(T[] array, T value) => throw null;
        public static int LastIndexOf<T>(T[] array, T value, int startIndex) => throw null;
        public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count) => throw null;
        public int Length { get => throw null; }
        public long LongLength { get => throw null; }
        public static int MaxLength { get => throw null; }
        public int Rank { get => throw null; }
        void System.Collections.IList.Remove(object value) => throw null;
        void System.Collections.IList.RemoveAt(int index) => throw null;
        public static void Resize<T>(ref T[] array, int newSize) => throw null;
        public static void Reverse(System.Array array) => throw null;
        public static void Reverse(System.Array array, int index, int length) => throw null;
        public static void Reverse<T>(T[] array) => throw null;
        public static void Reverse<T>(T[] array, int index, int length) => throw null;
        public void SetValue(object value, int index) => throw null;
        public void SetValue(object value, int index1, int index2) => throw null;
        public void SetValue(object value, int index1, int index2, int index3) => throw null;
        public void SetValue(object value, params int[] indices) => throw null;
        public void SetValue(object value, long index) => throw null;
        public void SetValue(object value, long index1, long index2) => throw null;
        public void SetValue(object value, long index1, long index2, long index3) => throw null;
        public void SetValue(object value, params long[] indices) => throw null;
        public static void Sort(System.Array array) => throw null;
        public static void Sort(System.Array keys, System.Array items) => throw null;
        public static void Sort(System.Array keys, System.Array items, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array keys, System.Array items, int index, int length) => throw null;
        public static void Sort(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array array, System.Collections.IComparer comparer) => throw null;
        public static void Sort(System.Array array, int index, int length) => throw null;
        public static void Sort(System.Array array, int index, int length, System.Collections.IComparer comparer) => throw null;
        public static void Sort<T>(T[] array) => throw null;
        public static void Sort<T>(T[] array, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static void Sort<T>(T[] array, System.Comparison<T> comparison) => throw null;
        public static void Sort<T>(T[] array, int index, int length) => throw null;
        public static void Sort<T>(T[] array, int index, int length, System.Collections.Generic.IComparer<T> comparer) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, System.Collections.Generic.IComparer<TKey> comparer) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length) => throw null;
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer<TKey> comparer) => throw null;
        public object SyncRoot { get => throw null; }
        public static bool TrueForAll<T>(T[] array, System.Predicate<T> match) => throw null;
    }
    public struct ArraySegment<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>
    {
        void System.Collections.Generic.ICollection<T>.Add(T item) => throw null;
        public T[] Array { get => throw null; }
        void System.Collections.Generic.ICollection<T>.Clear() => throw null;
        bool System.Collections.Generic.ICollection<T>.Contains(T item) => throw null;
        public void CopyTo(System.ArraySegment<T> destination) => throw null;
        public void CopyTo(T[] destination) => throw null;
        public void CopyTo(T[] destination, int destinationIndex) => throw null;
        public int Count { get => throw null; }
        public ArraySegment(T[] array) => throw null;
        public ArraySegment(T[] array, int offset, int count) => throw null;
        public static System.ArraySegment<T> Empty { get => throw null; }
        public struct Enumerator : System.IDisposable, System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator
        {
            public T Current { get => throw null; }
            object System.Collections.IEnumerator.Current { get => throw null; }
            public void Dispose() => throw null;
            public bool MoveNext() => throw null;
            void System.Collections.IEnumerator.Reset() => throw null;
        }
        public bool Equals(System.ArraySegment<T> obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public System.ArraySegment<T>.Enumerator GetEnumerator() => throw null;
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator() => throw null;
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.Generic.IList<T>.IndexOf(T item) => throw null;
        void System.Collections.Generic.IList<T>.Insert(int index, T item) => throw null;
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
        T System.Collections.Generic.IList<T>.this[int index] { get => throw null; set { } }
        T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get => throw null; }
        public int Offset { get => throw null; }
        public static bool operator ==(System.ArraySegment<T> a, System.ArraySegment<T> b) => throw null;
        public static implicit operator System.ArraySegment<T>(T[] array) => throw null;
        public static bool operator !=(System.ArraySegment<T> a, System.ArraySegment<T> b) => throw null;
        bool System.Collections.Generic.ICollection<T>.Remove(T item) => throw null;
        void System.Collections.Generic.IList<T>.RemoveAt(int index) => throw null;
        public System.ArraySegment<T> Slice(int index) => throw null;
        public System.ArraySegment<T> Slice(int index, int count) => throw null;
        public T this[int index] { get => throw null; set { } }
        public T[] ToArray() => throw null;
    }
    public class ArrayTypeMismatchException : System.SystemException
    {
        public ArrayTypeMismatchException() => throw null;
        protected ArrayTypeMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ArrayTypeMismatchException(string message) => throw null;
        public ArrayTypeMismatchException(string message, System.Exception innerException) => throw null;
    }
    public class AssemblyLoadEventArgs : System.EventArgs
    {
        public AssemblyLoadEventArgs(System.Reflection.Assembly loadedAssembly) => throw null;
        public System.Reflection.Assembly LoadedAssembly { get => throw null; }
    }
    public delegate void AssemblyLoadEventHandler(object sender, System.AssemblyLoadEventArgs args);
    public delegate void AsyncCallback(System.IAsyncResult ar);
    [System.AttributeUsage((System.AttributeTargets)32767, Inherited = true, AllowMultiple = false)]
    public abstract class Attribute
    {
        protected Attribute() => throw null;
        public override bool Equals(object obj) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, bool inherit) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public override int GetHashCode() => throw null;
        public virtual bool IsDefaultAttribute() => throw null;
        public static bool IsDefined(System.Reflection.Assembly element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.Assembly element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.Module element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.Module element, System.Type attributeType, bool inherit) => throw null;
        public static bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
        public static bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        public virtual bool Match(object obj) => throw null;
        public virtual object TypeId { get => throw null; }
    }
    [System.Flags]
    public enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767,
    }
    [System.AttributeUsage((System.AttributeTargets)4, Inherited = true)]
    public sealed class AttributeUsageAttribute : System.Attribute
    {
        public bool AllowMultiple { get => throw null; set { } }
        public AttributeUsageAttribute(System.AttributeTargets validOn) => throw null;
        public bool Inherited { get => throw null; set { } }
        public System.AttributeTargets ValidOn { get => throw null; }
    }
    public class BadImageFormatException : System.SystemException
    {
        public BadImageFormatException() => throw null;
        protected BadImageFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public BadImageFormatException(string message) => throw null;
        public BadImageFormatException(string message, System.Exception inner) => throw null;
        public BadImageFormatException(string message, string fileName) => throw null;
        public BadImageFormatException(string message, string fileName, System.Exception inner) => throw null;
        public string FileName { get => throw null; }
        public string FusionLog { get => throw null; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public override string ToString() => throw null;
    }
    [System.Flags]
    public enum Base64FormattingOptions
    {
        None = 0,
        InsertLineBreaks = 1,
    }
    public static class BitConverter
    {
        public static long DoubleToInt64Bits(double value) => throw null;
        public static ulong DoubleToUInt64Bits(double value) => throw null;
        public static byte[] GetBytes(bool value) => throw null;
        public static byte[] GetBytes(char value) => throw null;
        public static byte[] GetBytes(double value) => throw null;
        public static byte[] GetBytes(System.Half value) => throw null;
        public static byte[] GetBytes(short value) => throw null;
        public static byte[] GetBytes(int value) => throw null;
        public static byte[] GetBytes(long value) => throw null;
        public static byte[] GetBytes(float value) => throw null;
        public static byte[] GetBytes(ushort value) => throw null;
        public static byte[] GetBytes(uint value) => throw null;
        public static byte[] GetBytes(ulong value) => throw null;
        public static short HalfToInt16Bits(System.Half value) => throw null;
        public static ushort HalfToUInt16Bits(System.Half value) => throw null;
        public static System.Half Int16BitsToHalf(short value) => throw null;
        public static float Int32BitsToSingle(int value) => throw null;
        public static double Int64BitsToDouble(long value) => throw null;
        public static readonly bool IsLittleEndian;
        public static int SingleToInt32Bits(float value) => throw null;
        public static uint SingleToUInt32Bits(float value) => throw null;
        public static bool ToBoolean(byte[] value, int startIndex) => throw null;
        public static bool ToBoolean(System.ReadOnlySpan<byte> value) => throw null;
        public static char ToChar(byte[] value, int startIndex) => throw null;
        public static char ToChar(System.ReadOnlySpan<byte> value) => throw null;
        public static double ToDouble(byte[] value, int startIndex) => throw null;
        public static double ToDouble(System.ReadOnlySpan<byte> value) => throw null;
        public static System.Half ToHalf(byte[] value, int startIndex) => throw null;
        public static System.Half ToHalf(System.ReadOnlySpan<byte> value) => throw null;
        public static short ToInt16(byte[] value, int startIndex) => throw null;
        public static short ToInt16(System.ReadOnlySpan<byte> value) => throw null;
        public static int ToInt32(byte[] value, int startIndex) => throw null;
        public static int ToInt32(System.ReadOnlySpan<byte> value) => throw null;
        public static long ToInt64(byte[] value, int startIndex) => throw null;
        public static long ToInt64(System.ReadOnlySpan<byte> value) => throw null;
        public static float ToSingle(byte[] value, int startIndex) => throw null;
        public static float ToSingle(System.ReadOnlySpan<byte> value) => throw null;
        public static string ToString(byte[] value) => throw null;
        public static string ToString(byte[] value, int startIndex) => throw null;
        public static string ToString(byte[] value, int startIndex, int length) => throw null;
        public static ushort ToUInt16(byte[] value, int startIndex) => throw null;
        public static ushort ToUInt16(System.ReadOnlySpan<byte> value) => throw null;
        public static uint ToUInt32(byte[] value, int startIndex) => throw null;
        public static uint ToUInt32(System.ReadOnlySpan<byte> value) => throw null;
        public static ulong ToUInt64(byte[] value, int startIndex) => throw null;
        public static ulong ToUInt64(System.ReadOnlySpan<byte> value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, bool value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, char value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, double value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, System.Half value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, short value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, int value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, long value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, float value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, ushort value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, uint value) => throw null;
        public static bool TryWriteBytes(System.Span<byte> destination, ulong value) => throw null;
        public static System.Half UInt16BitsToHalf(ushort value) => throw null;
        public static float UInt32BitsToSingle(uint value) => throw null;
        public static double UInt64BitsToDouble(ulong value) => throw null;
    }
    public struct Boolean : System.IComparable, System.IComparable<bool>, System.IConvertible, System.IEquatable<bool>, System.IParsable<bool>, System.ISpanParsable<bool>
    {
        public int CompareTo(bool value) => throw null;
        public int CompareTo(object obj) => throw null;
        public bool Equals(bool obj) => throw null;
        public override bool Equals(object obj) => throw null;
        public static readonly string FalseString;
        public override int GetHashCode() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static bool Parse(System.ReadOnlySpan<char> value) => throw null;
        public static bool Parse(string value) => throw null;
        static bool System.IParsable<bool>.Parse(string s, System.IFormatProvider provider) => throw null;
        static bool System.ISpanParsable<bool>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static readonly string TrueString;
        public bool TryFormat(System.Span<char> destination, out int charsWritten) => throw null;
        static bool System.IParsable<bool>.TryParse(string s, System.IFormatProvider provider, out bool result) => throw null;
        static bool System.ISpanParsable<bool>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out bool result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> value, out bool result) => throw null;
        public static bool TryParse(string value, out bool result) => throw null;
    }
    public static class Buffer
    {
        public static void BlockCopy(System.Array src, int srcOffset, System.Array dst, int dstOffset, int count) => throw null;
        public static int ByteLength(System.Array array) => throw null;
        public static byte GetByte(System.Array array, int index) => throw null;
        public static unsafe void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy) => throw null;
        public static unsafe void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy) => throw null;
        public static void SetByte(System.Array array, int index, byte value) => throw null;
    }
    namespace Buffers
    {
        public abstract class ArrayPool<T>
        {
            public static System.Buffers.ArrayPool<T> Create() => throw null;
            public static System.Buffers.ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket) => throw null;
            protected ArrayPool() => throw null;
            public abstract T[] Rent(int minimumLength);
            public abstract void Return(T[] array, bool clearArray = default(bool));
            public static System.Buffers.ArrayPool<T> Shared { get => throw null; }
        }
        public interface IMemoryOwner<T> : System.IDisposable
        {
            System.Memory<T> Memory { get; }
        }
        public interface IPinnable
        {
            System.Buffers.MemoryHandle Pin(int elementIndex);
            void Unpin();
        }
        public struct MemoryHandle : System.IDisposable
        {
            public unsafe MemoryHandle(void* pointer, System.Runtime.InteropServices.GCHandle handle = default(System.Runtime.InteropServices.GCHandle), System.Buffers.IPinnable pinnable = default(System.Buffers.IPinnable)) => throw null;
            public void Dispose() => throw null;
            public unsafe void* Pointer { get => throw null; }
        }
        public abstract class MemoryManager<T> : System.IDisposable, System.Buffers.IMemoryOwner<T>, System.Buffers.IPinnable
        {
            protected System.Memory<T> CreateMemory(int length) => throw null;
            protected System.Memory<T> CreateMemory(int start, int length) => throw null;
            protected MemoryManager() => throw null;
            protected abstract void Dispose(bool disposing);
            void System.IDisposable.Dispose() => throw null;
            public abstract System.Span<T> GetSpan();
            public virtual System.Memory<T> Memory { get => throw null; }
            public abstract System.Buffers.MemoryHandle Pin(int elementIndex = default(int));
            protected virtual bool TryGetArray(out System.ArraySegment<T> segment) => throw null;
            public abstract void Unpin();
        }
        public enum OperationStatus
        {
            Done = 0,
            DestinationTooSmall = 1,
            NeedMoreData = 2,
            InvalidData = 3,
        }
        public delegate void ReadOnlySpanAction<T, TArg>(System.ReadOnlySpan<T> span, TArg arg);
        public class SearchValues<T> where T : System.IEquatable<T>
        {
            public bool Contains(T value) => throw null;
        }
        public static class SearchValues
        {
            public static System.Buffers.SearchValues<byte> Create(System.ReadOnlySpan<byte> values) => throw null;
            public static System.Buffers.SearchValues<char> Create(System.ReadOnlySpan<char> values) => throw null;
        }
        public delegate void SpanAction<T, TArg>(System.Span<T> span, TArg arg);
        namespace Text
        {
            public static class Base64
            {
                public static System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<byte> utf8, System.Span<byte> bytes, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = default(bool)) => throw null;
                public static System.Buffers.OperationStatus DecodeFromUtf8InPlace(System.Span<byte> buffer, out int bytesWritten) => throw null;
                public static System.Buffers.OperationStatus EncodeToUtf8(System.ReadOnlySpan<byte> bytes, System.Span<byte> utf8, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = default(bool)) => throw null;
                public static System.Buffers.OperationStatus EncodeToUtf8InPlace(System.Span<byte> buffer, int dataLength, out int bytesWritten) => throw null;
                public static int GetMaxDecodedFromUtf8Length(int length) => throw null;
                public static int GetMaxEncodedToUtf8Length(int length) => throw null;
                public static bool IsValid(System.ReadOnlySpan<char> base64Text) => throw null;
                public static bool IsValid(System.ReadOnlySpan<char> base64Text, out int decodedLength) => throw null;
                public static bool IsValid(System.ReadOnlySpan<byte> base64TextUtf8) => throw null;
                public static bool IsValid(System.ReadOnlySpan<byte> base64TextUtf8, out int decodedLength) => throw null;
            }
        }
    }
    public struct Byte : System.Numerics.IAdditionOperators<byte, byte, byte>, System.Numerics.IAdditiveIdentity<byte, byte>, System.Numerics.IBinaryInteger<byte>, System.Numerics.IBinaryNumber<byte>, System.Numerics.IBitwiseOperators<byte, byte, byte>, System.IComparable, System.IComparable<byte>, System.Numerics.IComparisonOperators<byte, byte, bool>, System.IConvertible, System.Numerics.IDecrementOperators<byte>, System.Numerics.IDivisionOperators<byte, byte, byte>, System.Numerics.IEqualityOperators<byte, byte, bool>, System.IEquatable<byte>, System.IFormattable, System.Numerics.IIncrementOperators<byte>, System.Numerics.IMinMaxValue<byte>, System.Numerics.IModulusOperators<byte, byte, byte>, System.Numerics.IMultiplicativeIdentity<byte, byte>, System.Numerics.IMultiplyOperators<byte, byte, byte>, System.Numerics.INumber<byte>, System.Numerics.INumberBase<byte>, System.IParsable<byte>, System.Numerics.IShiftOperators<byte, int, byte>, System.ISpanFormattable, System.ISpanParsable<byte>, System.Numerics.ISubtractionOperators<byte, byte, byte>, System.Numerics.IUnaryNegationOperators<byte, byte>, System.Numerics.IUnaryPlusOperators<byte, byte>, System.Numerics.IUnsignedNumber<byte>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<byte>
    {
        static byte System.Numerics.INumberBase<byte>.Abs(byte value) => throw null;
        static byte System.Numerics.IAdditiveIdentity<byte, byte>.AdditiveIdentity { get => throw null; }
        static byte System.Numerics.IBinaryNumber<byte>.AllBitsSet { get => throw null; }
        static byte System.Numerics.INumber<byte>.Clamp(byte value, byte min, byte max) => throw null;
        public int CompareTo(byte value) => throw null;
        public int CompareTo(object value) => throw null;
        static byte System.Numerics.INumber<byte>.CopySign(byte value, byte sign) => throw null;
        static byte System.Numerics.INumberBase<byte>.CreateChecked<TOther>(TOther value) => throw null;
        static byte System.Numerics.INumberBase<byte>.CreateSaturating<TOther>(TOther value) => throw null;
        static byte System.Numerics.INumberBase<byte>.CreateTruncating<TOther>(TOther value) => throw null;
        static (byte Quotient, byte Remainder) System.Numerics.IBinaryInteger<byte>.DivRem(byte left, byte right) => throw null;
        public bool Equals(byte obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<byte>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<byte>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<byte>.IsCanonical(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsComplexNumber(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsEvenInteger(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsFinite(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsImaginaryNumber(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsInfinity(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsInteger(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsNaN(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsNegative(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsNegativeInfinity(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsNormal(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsOddInteger(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsPositive(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsPositiveInfinity(byte value) => throw null;
        static bool System.Numerics.IBinaryNumber<byte>.IsPow2(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsRealNumber(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsSubnormal(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.IsZero(byte value) => throw null;
        static byte System.Numerics.IBinaryInteger<byte>.LeadingZeroCount(byte value) => throw null;
        static byte System.Numerics.IBinaryNumber<byte>.Log2(byte value) => throw null;
        static byte System.Numerics.INumber<byte>.Max(byte x, byte y) => throw null;
        static byte System.Numerics.INumberBase<byte>.MaxMagnitude(byte x, byte y) => throw null;
        static byte System.Numerics.INumberBase<byte>.MaxMagnitudeNumber(byte x, byte y) => throw null;
        static byte System.Numerics.INumber<byte>.MaxNumber(byte x, byte y) => throw null;
        public const byte MaxValue = 255;
        static byte System.Numerics.IMinMaxValue<byte>.MaxValue { get => throw null; }
        static byte System.Numerics.INumber<byte>.Min(byte x, byte y) => throw null;
        static byte System.Numerics.INumberBase<byte>.MinMagnitude(byte x, byte y) => throw null;
        static byte System.Numerics.INumberBase<byte>.MinMagnitudeNumber(byte x, byte y) => throw null;
        static byte System.Numerics.INumber<byte>.MinNumber(byte x, byte y) => throw null;
        public const byte MinValue = 0;
        static byte System.Numerics.IMinMaxValue<byte>.MinValue { get => throw null; }
        static byte System.Numerics.IMultiplicativeIdentity<byte, byte>.MultiplicativeIdentity { get => throw null; }
        static byte System.Numerics.INumberBase<byte>.One { get => throw null; }
        static byte System.Numerics.IAdditionOperators<byte, byte, byte>.operator +(byte left, byte right) => throw null;
        static byte System.Numerics.IBitwiseOperators<byte, byte, byte>.operator &(byte left, byte right) => throw null;
        static byte System.Numerics.IBitwiseOperators<byte, byte, byte>.operator |(byte left, byte right) => throw null;
        static byte System.Numerics.IAdditionOperators<byte, byte, byte>.operator checked +(byte left, byte right) => throw null;
        static byte System.Numerics.IDecrementOperators<byte>.operator checked --(byte value) => throw null;
        static byte System.Numerics.IIncrementOperators<byte>.operator checked ++(byte value) => throw null;
        static byte System.Numerics.IMultiplyOperators<byte, byte, byte>.operator checked *(byte left, byte right) => throw null;
        static byte System.Numerics.ISubtractionOperators<byte, byte, byte>.operator checked -(byte left, byte right) => throw null;
        static byte System.Numerics.IUnaryNegationOperators<byte, byte>.operator checked -(byte value) => throw null;
        static byte System.Numerics.IDecrementOperators<byte>.operator --(byte value) => throw null;
        static byte System.Numerics.IDivisionOperators<byte, byte, byte>.operator /(byte left, byte right) => throw null;
        static bool System.Numerics.IEqualityOperators<byte, byte, bool>.operator ==(byte left, byte right) => throw null;
        static byte System.Numerics.IBitwiseOperators<byte, byte, byte>.operator ^(byte left, byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<byte, byte, bool>.operator >(byte left, byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<byte, byte, bool>.operator >=(byte left, byte right) => throw null;
        static byte System.Numerics.IIncrementOperators<byte>.operator ++(byte value) => throw null;
        static bool System.Numerics.IEqualityOperators<byte, byte, bool>.operator !=(byte left, byte right) => throw null;
        static byte System.Numerics.IShiftOperators<byte, int, byte>.operator <<(byte value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<byte, byte, bool>.operator <(byte left, byte right) => throw null;
        static bool System.Numerics.IComparisonOperators<byte, byte, bool>.operator <=(byte left, byte right) => throw null;
        static byte System.Numerics.IModulusOperators<byte, byte, byte>.operator %(byte left, byte right) => throw null;
        static byte System.Numerics.IMultiplyOperators<byte, byte, byte>.operator *(byte left, byte right) => throw null;
        static byte System.Numerics.IBitwiseOperators<byte, byte, byte>.operator ~(byte value) => throw null;
        static byte System.Numerics.IShiftOperators<byte, int, byte>.operator >>(byte value, int shiftAmount) => throw null;
        static byte System.Numerics.ISubtractionOperators<byte, byte, byte>.operator -(byte left, byte right) => throw null;
        static byte System.Numerics.IUnaryNegationOperators<byte, byte>.operator -(byte value) => throw null;
        static byte System.Numerics.IUnaryPlusOperators<byte, byte>.operator +(byte value) => throw null;
        static byte System.Numerics.IShiftOperators<byte, int, byte>.operator >>>(byte value, int shiftAmount) => throw null;
        static byte System.Numerics.INumberBase<byte>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static byte System.IUtf8SpanParsable<byte>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static byte System.Numerics.INumberBase<byte>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static byte System.ISpanParsable<byte>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static byte Parse(string s) => throw null;
        public static byte Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static byte System.Numerics.INumberBase<byte>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static byte System.IParsable<byte>.Parse(string s, System.IFormatProvider provider) => throw null;
        static byte System.Numerics.IBinaryInteger<byte>.PopCount(byte value) => throw null;
        static int System.Numerics.INumberBase<byte>.Radix { get => throw null; }
        static byte System.Numerics.IBinaryInteger<byte>.RotateLeft(byte value, int rotateAmount) => throw null;
        static byte System.Numerics.IBinaryInteger<byte>.RotateRight(byte value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<byte>.Sign(byte value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static byte System.Numerics.IBinaryInteger<byte>.TrailingZeroCount(byte value) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertFromChecked<TOther>(TOther value, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertFromSaturating<TOther>(TOther value, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertFromTruncating<TOther>(TOther value, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertToChecked<TOther>(byte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertToSaturating<TOther>(byte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryConvertToTruncating<TOther>(byte value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out byte result) => throw null;
        static bool System.IUtf8SpanParsable<byte>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out byte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out byte result) => throw null;
        static bool System.ISpanParsable<byte>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out byte result) => throw null;
        public static bool TryParse(string s, out byte result) => throw null;
        static bool System.Numerics.INumberBase<byte>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out byte result) => throw null;
        static bool System.IParsable<byte>.TryParse(string s, System.IFormatProvider provider, out byte result) => throw null;
        static bool System.Numerics.IBinaryInteger<byte>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out byte value) => throw null;
        static bool System.Numerics.IBinaryInteger<byte>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out byte value) => throw null;
        bool System.Numerics.IBinaryInteger<byte>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<byte>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static byte System.Numerics.INumberBase<byte>.Zero { get => throw null; }
    }
    public class CannotUnloadAppDomainException : System.SystemException
    {
        public CannotUnloadAppDomainException() => throw null;
        protected CannotUnloadAppDomainException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public CannotUnloadAppDomainException(string message) => throw null;
        public CannotUnloadAppDomainException(string message, System.Exception innerException) => throw null;
    }
    public struct Char : System.Numerics.IAdditionOperators<char, char, char>, System.Numerics.IAdditiveIdentity<char, char>, System.Numerics.IBinaryInteger<char>, System.Numerics.IBinaryNumber<char>, System.Numerics.IBitwiseOperators<char, char, char>, System.IComparable, System.IComparable<char>, System.Numerics.IComparisonOperators<char, char, bool>, System.IConvertible, System.Numerics.IDecrementOperators<char>, System.Numerics.IDivisionOperators<char, char, char>, System.Numerics.IEqualityOperators<char, char, bool>, System.IEquatable<char>, System.IFormattable, System.Numerics.IIncrementOperators<char>, System.Numerics.IMinMaxValue<char>, System.Numerics.IModulusOperators<char, char, char>, System.Numerics.IMultiplicativeIdentity<char, char>, System.Numerics.IMultiplyOperators<char, char, char>, System.Numerics.INumber<char>, System.Numerics.INumberBase<char>, System.IParsable<char>, System.Numerics.IShiftOperators<char, int, char>, System.ISpanFormattable, System.ISpanParsable<char>, System.Numerics.ISubtractionOperators<char, char, char>, System.Numerics.IUnaryNegationOperators<char, char>, System.Numerics.IUnaryPlusOperators<char, char>, System.Numerics.IUnsignedNumber<char>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<char>
    {
        static char System.Numerics.INumberBase<char>.Abs(char value) => throw null;
        static char System.Numerics.IAdditiveIdentity<char, char>.AdditiveIdentity { get => throw null; }
        static char System.Numerics.IBinaryNumber<char>.AllBitsSet { get => throw null; }
        public int CompareTo(char value) => throw null;
        public int CompareTo(object value) => throw null;
        public static string ConvertFromUtf32(int utf32) => throw null;
        public static int ConvertToUtf32(char highSurrogate, char lowSurrogate) => throw null;
        public static int ConvertToUtf32(string s, int index) => throw null;
        public bool Equals(char obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<char>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        public static double GetNumericValue(char c) => throw null;
        public static double GetNumericValue(string s, int index) => throw null;
        int System.Numerics.IBinaryInteger<char>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static System.Globalization.UnicodeCategory GetUnicodeCategory(char c) => throw null;
        public static System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index) => throw null;
        public static bool IsAscii(char c) => throw null;
        public static bool IsAsciiDigit(char c) => throw null;
        public static bool IsAsciiHexDigit(char c) => throw null;
        public static bool IsAsciiHexDigitLower(char c) => throw null;
        public static bool IsAsciiHexDigitUpper(char c) => throw null;
        public static bool IsAsciiLetter(char c) => throw null;
        public static bool IsAsciiLetterLower(char c) => throw null;
        public static bool IsAsciiLetterOrDigit(char c) => throw null;
        public static bool IsAsciiLetterUpper(char c) => throw null;
        public static bool IsBetween(char c, char minInclusive, char maxInclusive) => throw null;
        static bool System.Numerics.INumberBase<char>.IsCanonical(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsComplexNumber(char value) => throw null;
        public static bool IsControl(char c) => throw null;
        public static bool IsControl(string s, int index) => throw null;
        public static bool IsDigit(char c) => throw null;
        public static bool IsDigit(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsEvenInteger(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsFinite(char value) => throw null;
        public static bool IsHighSurrogate(char c) => throw null;
        public static bool IsHighSurrogate(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsImaginaryNumber(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsInfinity(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsInteger(char value) => throw null;
        public static bool IsLetter(char c) => throw null;
        public static bool IsLetter(string s, int index) => throw null;
        public static bool IsLetterOrDigit(char c) => throw null;
        public static bool IsLetterOrDigit(string s, int index) => throw null;
        public static bool IsLower(char c) => throw null;
        public static bool IsLower(string s, int index) => throw null;
        public static bool IsLowSurrogate(char c) => throw null;
        public static bool IsLowSurrogate(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsNaN(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsNegative(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsNegativeInfinity(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsNormal(char value) => throw null;
        public static bool IsNumber(char c) => throw null;
        public static bool IsNumber(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsOddInteger(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsPositive(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.IsPositiveInfinity(char value) => throw null;
        static bool System.Numerics.IBinaryNumber<char>.IsPow2(char value) => throw null;
        public static bool IsPunctuation(char c) => throw null;
        public static bool IsPunctuation(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsRealNumber(char value) => throw null;
        public static bool IsSeparator(char c) => throw null;
        public static bool IsSeparator(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsSubnormal(char value) => throw null;
        public static bool IsSurrogate(char c) => throw null;
        public static bool IsSurrogate(string s, int index) => throw null;
        public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate) => throw null;
        public static bool IsSurrogatePair(string s, int index) => throw null;
        public static bool IsSymbol(char c) => throw null;
        public static bool IsSymbol(string s, int index) => throw null;
        public static bool IsUpper(char c) => throw null;
        public static bool IsUpper(string s, int index) => throw null;
        public static bool IsWhiteSpace(char c) => throw null;
        public static bool IsWhiteSpace(string s, int index) => throw null;
        static bool System.Numerics.INumberBase<char>.IsZero(char value) => throw null;
        static char System.Numerics.IBinaryInteger<char>.LeadingZeroCount(char value) => throw null;
        static char System.Numerics.IBinaryNumber<char>.Log2(char value) => throw null;
        static char System.Numerics.INumberBase<char>.MaxMagnitude(char x, char y) => throw null;
        static char System.Numerics.INumberBase<char>.MaxMagnitudeNumber(char x, char y) => throw null;
        public const char MaxValue = default;
        static char System.Numerics.IMinMaxValue<char>.MaxValue { get => throw null; }
        static char System.Numerics.INumberBase<char>.MinMagnitude(char x, char y) => throw null;
        static char System.Numerics.INumberBase<char>.MinMagnitudeNumber(char x, char y) => throw null;
        public const char MinValue = default;
        static char System.Numerics.IMinMaxValue<char>.MinValue { get => throw null; }
        static char System.Numerics.IMultiplicativeIdentity<char, char>.MultiplicativeIdentity { get => throw null; }
        static char System.Numerics.INumberBase<char>.One { get => throw null; }
        static char System.Numerics.IAdditionOperators<char, char, char>.operator +(char left, char right) => throw null;
        static char System.Numerics.IBitwiseOperators<char, char, char>.operator &(char left, char right) => throw null;
        static char System.Numerics.IBitwiseOperators<char, char, char>.operator |(char left, char right) => throw null;
        static char System.Numerics.IAdditionOperators<char, char, char>.operator checked +(char left, char right) => throw null;
        static char System.Numerics.IDecrementOperators<char>.operator checked --(char value) => throw null;
        static char System.Numerics.IIncrementOperators<char>.operator checked ++(char value) => throw null;
        static char System.Numerics.IMultiplyOperators<char, char, char>.operator checked *(char left, char right) => throw null;
        static char System.Numerics.ISubtractionOperators<char, char, char>.operator checked -(char left, char right) => throw null;
        static char System.Numerics.IUnaryNegationOperators<char, char>.operator checked -(char value) => throw null;
        static char System.Numerics.IDecrementOperators<char>.operator --(char value) => throw null;
        static char System.Numerics.IDivisionOperators<char, char, char>.operator /(char left, char right) => throw null;
        static bool System.Numerics.IEqualityOperators<char, char, bool>.operator ==(char left, char right) => throw null;
        static char System.Numerics.IBitwiseOperators<char, char, char>.operator ^(char left, char right) => throw null;
        static bool System.Numerics.IComparisonOperators<char, char, bool>.operator >(char left, char right) => throw null;
        static bool System.Numerics.IComparisonOperators<char, char, bool>.operator >=(char left, char right) => throw null;
        static char System.Numerics.IIncrementOperators<char>.operator ++(char value) => throw null;
        static bool System.Numerics.IEqualityOperators<char, char, bool>.operator !=(char left, char right) => throw null;
        static char System.Numerics.IShiftOperators<char, int, char>.operator <<(char value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<char, char, bool>.operator <(char left, char right) => throw null;
        static bool System.Numerics.IComparisonOperators<char, char, bool>.operator <=(char left, char right) => throw null;
        static char System.Numerics.IModulusOperators<char, char, char>.operator %(char left, char right) => throw null;
        static char System.Numerics.IMultiplyOperators<char, char, char>.operator *(char left, char right) => throw null;
        static char System.Numerics.IBitwiseOperators<char, char, char>.operator ~(char value) => throw null;
        static char System.Numerics.IShiftOperators<char, int, char>.operator >>(char value, int shiftAmount) => throw null;
        static char System.Numerics.ISubtractionOperators<char, char, char>.operator -(char left, char right) => throw null;
        static char System.Numerics.IUnaryNegationOperators<char, char>.operator -(char value) => throw null;
        static char System.Numerics.IUnaryPlusOperators<char, char>.operator +(char value) => throw null;
        static char System.Numerics.IShiftOperators<char, int, char>.operator >>>(char value, int shiftAmount) => throw null;
        public static char Parse(string s) => throw null;
        static char System.IParsable<char>.Parse(string s, System.IFormatProvider provider) => throw null;
        static char System.ISpanParsable<char>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        static char System.Numerics.INumberBase<char>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static char System.Numerics.INumberBase<char>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static char System.Numerics.IBinaryInteger<char>.PopCount(char value) => throw null;
        static int System.Numerics.INumberBase<char>.Radix { get => throw null; }
        static char System.Numerics.IBinaryInteger<char>.RotateLeft(char value, int rotateAmount) => throw null;
        static char System.Numerics.IBinaryInteger<char>.RotateRight(char value, int rotateAmount) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static char ToLower(char c) => throw null;
        public static char ToLower(char c, System.Globalization.CultureInfo culture) => throw null;
        public static char ToLowerInvariant(char c) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public override string ToString() => throw null;
        public static string ToString(char c) => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static char ToUpper(char c) => throw null;
        public static char ToUpper(char c, System.Globalization.CultureInfo culture) => throw null;
        public static char ToUpperInvariant(char c) => throw null;
        static char System.Numerics.IBinaryInteger<char>.TrailingZeroCount(char value) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertFromChecked<TOther>(TOther value, out char result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertFromSaturating<TOther>(TOther value, out char result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertFromTruncating<TOther>(TOther value, out char result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertToChecked<TOther>(char value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertToSaturating<TOther>(char value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryConvertToTruncating<TOther>(char value, out TOther result) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        bool System.IUtf8SpanFormattable.TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        static bool System.IParsable<char>.TryParse(string s, System.IFormatProvider provider, out char result) => throw null;
        static bool System.ISpanParsable<char>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out char result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out char result) => throw null;
        static bool System.Numerics.INumberBase<char>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out char result) => throw null;
        public static bool TryParse(string s, out char result) => throw null;
        static bool System.Numerics.IBinaryInteger<char>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out char value) => throw null;
        static bool System.Numerics.IBinaryInteger<char>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out char value) => throw null;
        bool System.Numerics.IBinaryInteger<char>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<char>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static char System.Numerics.INumberBase<char>.Zero { get => throw null; }
    }
    public sealed class CharEnumerator : System.ICloneable, System.IDisposable, System.Collections.Generic.IEnumerator<char>, System.Collections.IEnumerator
    {
        public object Clone() => throw null;
        public char Current { get => throw null; }
        object System.Collections.IEnumerator.Current { get => throw null; }
        public void Dispose() => throw null;
        public bool MoveNext() => throw null;
        public void Reset() => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)32767, Inherited = true, AllowMultiple = false)]
    public sealed class CLSCompliantAttribute : System.Attribute
    {
        public CLSCompliantAttribute(bool isCompliant) => throw null;
        public bool IsCompliant { get => throw null; }
    }
    namespace CodeDom
    {
        namespace Compiler
        {
            [System.AttributeUsage((System.AttributeTargets)32767, Inherited = false, AllowMultiple = false)]
            public sealed class GeneratedCodeAttribute : System.Attribute
            {
                public GeneratedCodeAttribute(string tool, string version) => throw null;
                public string Tool { get => throw null; }
                public string Version { get => throw null; }
            }
            public class IndentedTextWriter : System.IO.TextWriter
            {
                public override void Close() => throw null;
                public IndentedTextWriter(System.IO.TextWriter writer) => throw null;
                public IndentedTextWriter(System.IO.TextWriter writer, string tabString) => throw null;
                public const string DefaultTabString = default;
                public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
                public override System.Text.Encoding Encoding { get => throw null; }
                public override void Flush() => throw null;
                public override System.Threading.Tasks.Task FlushAsync() => throw null;
                public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
                public int Indent { get => throw null; set { } }
                public System.IO.TextWriter InnerWriter { get => throw null; }
                public override string NewLine { get => throw null; set { } }
                protected virtual void OutputTabs() => throw null;
                protected virtual System.Threading.Tasks.Task OutputTabsAsync() => throw null;
                public override void Write(bool value) => throw null;
                public override void Write(char value) => throw null;
                public override void Write(char[] buffer) => throw null;
                public override void Write(char[] buffer, int index, int count) => throw null;
                public override void Write(double value) => throw null;
                public override void Write(int value) => throw null;
                public override void Write(long value) => throw null;
                public override void Write(object value) => throw null;
                public override void Write(float value) => throw null;
                public override void Write(string s) => throw null;
                public override void Write(string format, object arg0) => throw null;
                public override void Write(string format, object arg0, object arg1) => throw null;
                public override void Write(string format, params object[] arg) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(char value) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
                public override System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override void WriteLine() => throw null;
                public override void WriteLine(bool value) => throw null;
                public override void WriteLine(char value) => throw null;
                public override void WriteLine(char[] buffer) => throw null;
                public override void WriteLine(char[] buffer, int index, int count) => throw null;
                public override void WriteLine(double value) => throw null;
                public override void WriteLine(int value) => throw null;
                public override void WriteLine(long value) => throw null;
                public override void WriteLine(object value) => throw null;
                public override void WriteLine(float value) => throw null;
                public override void WriteLine(string s) => throw null;
                public override void WriteLine(string format, object arg0) => throw null;
                public override void WriteLine(string format, object arg0, object arg1) => throw null;
                public override void WriteLine(string format, params object[] arg) => throw null;
                public override void WriteLine(uint value) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync() => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(char value) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
                public override System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public void WriteLineNoTabs(string s) => throw null;
                public System.Threading.Tasks.Task WriteLineNoTabsAsync(string s) => throw null;
            }
        }
    }
    namespace Collections
    {
        public class ArrayList : System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
        {
            public static System.Collections.ArrayList Adapter(System.Collections.IList list) => throw null;
            public virtual int Add(object value) => throw null;
            public virtual void AddRange(System.Collections.ICollection c) => throw null;
            public virtual int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer) => throw null;
            public virtual int BinarySearch(object value) => throw null;
            public virtual int BinarySearch(object value, System.Collections.IComparer comparer) => throw null;
            public virtual int Capacity { get => throw null; set { } }
            public virtual void Clear() => throw null;
            public virtual object Clone() => throw null;
            public virtual bool Contains(object item) => throw null;
            public virtual void CopyTo(System.Array array) => throw null;
            public virtual void CopyTo(System.Array array, int arrayIndex) => throw null;
            public virtual void CopyTo(int index, System.Array array, int arrayIndex, int count) => throw null;
            public virtual int Count { get => throw null; }
            public ArrayList() => throw null;
            public ArrayList(System.Collections.ICollection c) => throw null;
            public ArrayList(int capacity) => throw null;
            public static System.Collections.ArrayList FixedSize(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList FixedSize(System.Collections.IList list) => throw null;
            public virtual System.Collections.IEnumerator GetEnumerator() => throw null;
            public virtual System.Collections.IEnumerator GetEnumerator(int index, int count) => throw null;
            public virtual System.Collections.ArrayList GetRange(int index, int count) => throw null;
            public virtual int IndexOf(object value) => throw null;
            public virtual int IndexOf(object value, int startIndex) => throw null;
            public virtual int IndexOf(object value, int startIndex, int count) => throw null;
            public virtual void Insert(int index, object value) => throw null;
            public virtual void InsertRange(int index, System.Collections.ICollection c) => throw null;
            public virtual bool IsFixedSize { get => throw null; }
            public virtual bool IsReadOnly { get => throw null; }
            public virtual bool IsSynchronized { get => throw null; }
            public virtual int LastIndexOf(object value) => throw null;
            public virtual int LastIndexOf(object value, int startIndex) => throw null;
            public virtual int LastIndexOf(object value, int startIndex, int count) => throw null;
            public static System.Collections.ArrayList ReadOnly(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList ReadOnly(System.Collections.IList list) => throw null;
            public virtual void Remove(object obj) => throw null;
            public virtual void RemoveAt(int index) => throw null;
            public virtual void RemoveRange(int index, int count) => throw null;
            public static System.Collections.ArrayList Repeat(object value, int count) => throw null;
            public virtual void Reverse() => throw null;
            public virtual void Reverse(int index, int count) => throw null;
            public virtual void SetRange(int index, System.Collections.ICollection c) => throw null;
            public virtual void Sort() => throw null;
            public virtual void Sort(System.Collections.IComparer comparer) => throw null;
            public virtual void Sort(int index, int count, System.Collections.IComparer comparer) => throw null;
            public static System.Collections.ArrayList Synchronized(System.Collections.ArrayList list) => throw null;
            public static System.Collections.IList Synchronized(System.Collections.IList list) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public virtual object this[int index] { get => throw null; set { } }
            public virtual object[] ToArray() => throw null;
            public virtual System.Array ToArray(System.Type type) => throw null;
            public virtual void TrimToSize() => throw null;
        }
        public sealed class Comparer : System.Collections.IComparer, System.Runtime.Serialization.ISerializable
        {
            public int Compare(object a, object b) => throw null;
            public Comparer(System.Globalization.CultureInfo culture) => throw null;
            public static readonly System.Collections.Comparer Default;
            public static readonly System.Collections.Comparer DefaultInvariant;
            public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        }
        public struct DictionaryEntry
        {
            public DictionaryEntry(object key, object value) => throw null;
            public void Deconstruct(out object key, out object value) => throw null;
            public object Key { get => throw null; set { } }
            public object Value { get => throw null; set { } }
        }
        namespace Generic
        {
            public interface IAsyncEnumerable<T>
            {
                System.Collections.Generic.IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
            }
            public interface IAsyncEnumerator<T> : System.IAsyncDisposable
            {
                T Current { get; }
                System.Threading.Tasks.ValueTask<bool> MoveNextAsync();
            }
            public interface ICollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                void Add(T item);
                void Clear();
                bool Contains(T item);
                void CopyTo(T[] array, int arrayIndex);
                int Count { get; }
                bool IsReadOnly { get; }
                bool Remove(T item);
            }
            public interface IComparer<T>
            {
                int Compare(T x, T y);
            }
            public interface IDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                void Add(TKey key, TValue value);
                bool ContainsKey(TKey key);
                System.Collections.Generic.ICollection<TKey> Keys { get; }
                bool Remove(TKey key);
                TValue this[TKey key] { get; set; }
                bool TryGetValue(TKey key, out TValue value);
                System.Collections.Generic.ICollection<TValue> Values { get; }
            }
            public interface IEnumerable<T> : System.Collections.IEnumerable
            {
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
            }
            public interface IEnumerator<T> : System.IDisposable, System.Collections.IEnumerator
            {
                T Current { get; }
            }
            public interface IEqualityComparer<T>
            {
                bool Equals(T x, T y);
                int GetHashCode(T obj);
            }
            public interface IList<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int IndexOf(T item);
                void Insert(int index, T item);
                void RemoveAt(int index);
                T this[int index] { get; set; }
            }
            public interface IReadOnlyCollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int Count { get; }
            }
            public interface IReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
            {
                bool ContainsKey(TKey key);
                System.Collections.Generic.IEnumerable<TKey> Keys { get; }
                TValue this[TKey key] { get; }
                bool TryGetValue(TKey key, out TValue value);
                System.Collections.Generic.IEnumerable<TValue> Values { get; }
            }
            public interface IReadOnlyList<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>
            {
                T this[int index] { get; }
            }
            public interface IReadOnlySet<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>
            {
                bool Contains(T item);
                bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
                bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
            }
            public interface ISet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                bool Add(T item);
                void ExceptWith(System.Collections.Generic.IEnumerable<T> other);
                void IntersectWith(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
                bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
                bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
                bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
                void SymmetricExceptWith(System.Collections.Generic.IEnumerable<T> other);
                void UnionWith(System.Collections.Generic.IEnumerable<T> other);
            }
            public class KeyNotFoundException : System.SystemException
            {
                public KeyNotFoundException() => throw null;
                protected KeyNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public KeyNotFoundException(string message) => throw null;
                public KeyNotFoundException(string message, System.Exception innerException) => throw null;
            }
            public static class KeyValuePair
            {
                public static System.Collections.Generic.KeyValuePair<TKey, TValue> Create<TKey, TValue>(TKey key, TValue value) => throw null;
            }
            public struct KeyValuePair<TKey, TValue>
            {
                public KeyValuePair(TKey key, TValue value) => throw null;
                public void Deconstruct(out TKey key, out TValue value) => throw null;
                public TKey Key { get => throw null; }
                public override string ToString() => throw null;
                public TValue Value { get => throw null; }
            }
        }
        public class Hashtable : System.ICloneable, System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Collections.IDictionary, System.Collections.IEnumerable, System.Runtime.Serialization.ISerializable
        {
            public virtual void Add(object key, object value) => throw null;
            public virtual void Clear() => throw null;
            public virtual object Clone() => throw null;
            protected System.Collections.IComparer comparer { get => throw null; set { } }
            public virtual bool Contains(object key) => throw null;
            public virtual bool ContainsKey(object key) => throw null;
            public virtual bool ContainsValue(object value) => throw null;
            public virtual void CopyTo(System.Array array, int arrayIndex) => throw null;
            public virtual int Count { get => throw null; }
            public Hashtable() => throw null;
            public Hashtable(System.Collections.IDictionary d) => throw null;
            public Hashtable(System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(int capacity) => throw null;
            public Hashtable(int capacity, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            public Hashtable(int capacity, float loadFactor) => throw null;
            public Hashtable(int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer) => throw null;
            public Hashtable(int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer) => throw null;
            protected Hashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            protected System.Collections.IEqualityComparer EqualityComparer { get => throw null; }
            public virtual System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            protected virtual int GetHash(object key) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            protected System.Collections.IHashCodeProvider hcp { get => throw null; set { } }
            public virtual bool IsFixedSize { get => throw null; }
            public virtual bool IsReadOnly { get => throw null; }
            public virtual bool IsSynchronized { get => throw null; }
            protected virtual bool KeyEquals(object item, object key) => throw null;
            public virtual System.Collections.ICollection Keys { get => throw null; }
            public virtual void OnDeserialization(object sender) => throw null;
            public virtual void Remove(object key) => throw null;
            public static System.Collections.Hashtable Synchronized(System.Collections.Hashtable table) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public virtual object this[object key] { get => throw null; set { } }
            public virtual System.Collections.ICollection Values { get => throw null; }
        }
        public interface ICollection : System.Collections.IEnumerable
        {
            void CopyTo(System.Array array, int index);
            int Count { get; }
            bool IsSynchronized { get; }
            object SyncRoot { get; }
        }
        public interface IComparer
        {
            int Compare(object x, object y);
        }
        public interface IDictionary : System.Collections.ICollection, System.Collections.IEnumerable
        {
            void Add(object key, object value);
            void Clear();
            bool Contains(object key);
            System.Collections.IDictionaryEnumerator GetEnumerator();
            bool IsFixedSize { get; }
            bool IsReadOnly { get; }
            System.Collections.ICollection Keys { get; }
            void Remove(object key);
            object this[object key] { get; set; }
            System.Collections.ICollection Values { get; }
        }
        public interface IDictionaryEnumerator : System.Collections.IEnumerator
        {
            System.Collections.DictionaryEntry Entry { get; }
            object Key { get; }
            object Value { get; }
        }
        public interface IEnumerable
        {
            System.Collections.IEnumerator GetEnumerator();
        }
        public interface IEnumerator
        {
            object Current { get; }
            bool MoveNext();
            void Reset();
        }
        public interface IEqualityComparer
        {
            bool Equals(object x, object y);
            int GetHashCode(object obj);
        }
        public interface IHashCodeProvider
        {
            int GetHashCode(object obj);
        }
        public interface IList : System.Collections.ICollection, System.Collections.IEnumerable
        {
            int Add(object value);
            void Clear();
            bool Contains(object value);
            int IndexOf(object value);
            void Insert(int index, object value);
            bool IsFixedSize { get; }
            bool IsReadOnly { get; }
            void Remove(object value);
            void RemoveAt(int index);
            object this[int index] { get; set; }
        }
        public interface IStructuralComparable
        {
            int CompareTo(object other, System.Collections.IComparer comparer);
        }
        public interface IStructuralEquatable
        {
            bool Equals(object other, System.Collections.IEqualityComparer comparer);
            int GetHashCode(System.Collections.IEqualityComparer comparer);
        }
        namespace ObjectModel
        {
            public class Collection<T> : System.Collections.Generic.ICollection<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IList<T>, System.Collections.IList, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>
            {
                public void Add(T item) => throw null;
                int System.Collections.IList.Add(object value) => throw null;
                public void Clear() => throw null;
                protected virtual void ClearItems() => throw null;
                public bool Contains(T item) => throw null;
                bool System.Collections.IList.Contains(object value) => throw null;
                public void CopyTo(T[] array, int index) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                public int Count { get => throw null; }
                public Collection() => throw null;
                public Collection(System.Collections.Generic.IList<T> list) => throw null;
                public System.Collections.Generic.IEnumerator<T> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public int IndexOf(T item) => throw null;
                int System.Collections.IList.IndexOf(object value) => throw null;
                public void Insert(int index, T item) => throw null;
                void System.Collections.IList.Insert(int index, object value) => throw null;
                protected virtual void InsertItem(int index, T item) => throw null;
                bool System.Collections.IList.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
                bool System.Collections.IList.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                object System.Collections.IList.this[int index] { get => throw null; set { } }
                protected System.Collections.Generic.IList<T> Items { get => throw null; }
                public bool Remove(T item) => throw null;
                void System.Collections.IList.Remove(object value) => throw null;
                public void RemoveAt(int index) => throw null;
                protected virtual void RemoveItem(int index) => throw null;
                protected virtual void SetItem(int index, T item) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
                public T this[int index] { get => throw null; set { } }
            }
            public class ReadOnlyCollection<T> : System.Collections.Generic.ICollection<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IList<T>, System.Collections.IList, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>
            {
                void System.Collections.Generic.ICollection<T>.Add(T value) => throw null;
                int System.Collections.IList.Add(object value) => throw null;
                void System.Collections.Generic.ICollection<T>.Clear() => throw null;
                void System.Collections.IList.Clear() => throw null;
                public bool Contains(T value) => throw null;
                bool System.Collections.IList.Contains(object value) => throw null;
                public void CopyTo(T[] array, int index) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                public int Count { get => throw null; }
                public ReadOnlyCollection(System.Collections.Generic.IList<T> list) => throw null;
                public static System.Collections.ObjectModel.ReadOnlyCollection<T> Empty { get => throw null; }
                public System.Collections.Generic.IEnumerator<T> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public int IndexOf(T value) => throw null;
                int System.Collections.IList.IndexOf(object value) => throw null;
                void System.Collections.Generic.IList<T>.Insert(int index, T value) => throw null;
                void System.Collections.IList.Insert(int index, object value) => throw null;
                bool System.Collections.IList.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<T>.IsReadOnly { get => throw null; }
                bool System.Collections.IList.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                T System.Collections.Generic.IList<T>.this[int index] { get => throw null; set { } }
                object System.Collections.IList.this[int index] { get => throw null; set { } }
                protected System.Collections.Generic.IList<T> Items { get => throw null; }
                bool System.Collections.Generic.ICollection<T>.Remove(T value) => throw null;
                void System.Collections.IList.Remove(object value) => throw null;
                void System.Collections.Generic.IList<T>.RemoveAt(int index) => throw null;
                void System.Collections.IList.RemoveAt(int index) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
                public T this[int index] { get => throw null; }
            }
            public class ReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.ICollection, System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.IDictionary, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>
            {
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                void System.Collections.Generic.IDictionary<TKey, TValue>.Add(TKey key, TValue value) => throw null;
                void System.Collections.IDictionary.Add(object key, object value) => throw null;
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Clear() => throw null;
                void System.Collections.IDictionary.Clear() => throw null;
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                bool System.Collections.IDictionary.Contains(object key) => throw null;
                public bool ContainsKey(TKey key) => throw null;
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) => throw null;
                void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                public int Count { get => throw null; }
                public ReadOnlyDictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary) => throw null;
                protected System.Collections.Generic.IDictionary<TKey, TValue> Dictionary { get => throw null; }
                public static System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue> Empty { get => throw null; }
                public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() => throw null;
                System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                bool System.Collections.IDictionary.IsFixedSize { get => throw null; }
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.IsReadOnly { get => throw null; }
                bool System.Collections.IDictionary.IsReadOnly { get => throw null; }
                bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                TValue System.Collections.Generic.IDictionary<TKey, TValue>.this[TKey key] { get => throw null; set { } }
                object System.Collections.IDictionary.this[object key] { get => throw null; set { } }
                public sealed class KeyCollection : System.Collections.Generic.ICollection<TKey>, System.Collections.ICollection, System.Collections.Generic.IEnumerable<TKey>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<TKey>
                {
                    void System.Collections.Generic.ICollection<TKey>.Add(TKey item) => throw null;
                    void System.Collections.Generic.ICollection<TKey>.Clear() => throw null;
                    public bool Contains(TKey item) => throw null;
                    public void CopyTo(TKey[] array, int arrayIndex) => throw null;
                    void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                    public int Count { get => throw null; }
                    public System.Collections.Generic.IEnumerator<TKey> GetEnumerator() => throw null;
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                    bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get => throw null; }
                    bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                    bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item) => throw null;
                    object System.Collections.ICollection.SyncRoot { get => throw null; }
                }
                public System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.KeyCollection Keys { get => throw null; }
                System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey, TValue>.Keys { get => throw null; }
                System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Keys { get => throw null; }
                System.Collections.ICollection System.Collections.IDictionary.Keys { get => throw null; }
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item) => throw null;
                bool System.Collections.Generic.IDictionary<TKey, TValue>.Remove(TKey key) => throw null;
                void System.Collections.IDictionary.Remove(object key) => throw null;
                object System.Collections.ICollection.SyncRoot { get => throw null; }
                public TValue this[TKey key] { get => throw null; }
                public bool TryGetValue(TKey key, out TValue value) => throw null;
                public sealed class ValueCollection : System.Collections.Generic.ICollection<TValue>, System.Collections.ICollection, System.Collections.Generic.IEnumerable<TValue>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<TValue>
                {
                    void System.Collections.Generic.ICollection<TValue>.Add(TValue item) => throw null;
                    void System.Collections.Generic.ICollection<TValue>.Clear() => throw null;
                    bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item) => throw null;
                    public void CopyTo(TValue[] array, int arrayIndex) => throw null;
                    void System.Collections.ICollection.CopyTo(System.Array array, int index) => throw null;
                    public int Count { get => throw null; }
                    public System.Collections.Generic.IEnumerator<TValue> GetEnumerator() => throw null;
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                    bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get => throw null; }
                    bool System.Collections.ICollection.IsSynchronized { get => throw null; }
                    bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item) => throw null;
                    object System.Collections.ICollection.SyncRoot { get => throw null; }
                }
                System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey, TValue>.Values { get => throw null; }
                System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Values { get => throw null; }
                System.Collections.ICollection System.Collections.IDictionary.Values { get => throw null; }
                public System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.ValueCollection Values { get => throw null; }
            }
        }
    }
    public delegate int Comparison<T>(T x, T y);
    namespace ComponentModel
    {
        [System.AttributeUsage((System.AttributeTargets)32767)]
        public class DefaultValueAttribute : System.Attribute
        {
            public DefaultValueAttribute(bool value) => throw null;
            public DefaultValueAttribute(byte value) => throw null;
            public DefaultValueAttribute(char value) => throw null;
            public DefaultValueAttribute(double value) => throw null;
            public DefaultValueAttribute(short value) => throw null;
            public DefaultValueAttribute(int value) => throw null;
            public DefaultValueAttribute(long value) => throw null;
            public DefaultValueAttribute(object value) => throw null;
            public DefaultValueAttribute(sbyte value) => throw null;
            public DefaultValueAttribute(float value) => throw null;
            public DefaultValueAttribute(string value) => throw null;
            public DefaultValueAttribute(System.Type type, string value) => throw null;
            public DefaultValueAttribute(ushort value) => throw null;
            public DefaultValueAttribute(uint value) => throw null;
            public DefaultValueAttribute(ulong value) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            protected void SetValue(object value) => throw null;
            public virtual object Value { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)6140)]
        public sealed class EditorBrowsableAttribute : System.Attribute
        {
            public EditorBrowsableAttribute() => throw null;
            public EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState state) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public System.ComponentModel.EditorBrowsableState State { get => throw null; }
        }
        public enum EditorBrowsableState
        {
            Always = 0,
            Never = 1,
            Advanced = 2,
        }
    }
    namespace Configuration
    {
        namespace Assemblies
        {
            public enum AssemblyHashAlgorithm
            {
                None = 0,
                MD5 = 32771,
                SHA1 = 32772,
                SHA256 = 32780,
                SHA384 = 32781,
                SHA512 = 32782,
            }
            public enum AssemblyVersionCompatibility
            {
                SameMachine = 1,
                SameProcess = 2,
                SameDomain = 3,
            }
        }
    }
    public abstract class ContextBoundObject : System.MarshalByRefObject
    {
        protected ContextBoundObject() => throw null;
    }
    public class ContextMarshalException : System.SystemException
    {
        public ContextMarshalException() => throw null;
        protected ContextMarshalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ContextMarshalException(string message) => throw null;
        public ContextMarshalException(string message, System.Exception inner) => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
    public class ContextStaticAttribute : System.Attribute
    {
        public ContextStaticAttribute() => throw null;
    }
    public static class Convert
    {
        public static object ChangeType(object value, System.Type conversionType) => throw null;
        public static object ChangeType(object value, System.Type conversionType, System.IFormatProvider provider) => throw null;
        public static object ChangeType(object value, System.TypeCode typeCode) => throw null;
        public static object ChangeType(object value, System.TypeCode typeCode, System.IFormatProvider provider) => throw null;
        public static readonly object DBNull;
        public static byte[] FromBase64CharArray(char[] inArray, int offset, int length) => throw null;
        public static byte[] FromBase64String(string s) => throw null;
        public static byte[] FromHexString(System.ReadOnlySpan<char> chars) => throw null;
        public static byte[] FromHexString(string s) => throw null;
        public static System.TypeCode GetTypeCode(object value) => throw null;
        public static bool IsDBNull(object value) => throw null;
        public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut) => throw null;
        public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(byte[] inArray) => throw null;
        public static string ToBase64String(byte[] inArray, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(byte[] inArray, int offset, int length) => throw null;
        public static string ToBase64String(byte[] inArray, int offset, int length, System.Base64FormattingOptions options) => throw null;
        public static string ToBase64String(System.ReadOnlySpan<byte> bytes, System.Base64FormattingOptions options = default(System.Base64FormattingOptions)) => throw null;
        public static bool ToBoolean(bool value) => throw null;
        public static bool ToBoolean(byte value) => throw null;
        public static bool ToBoolean(char value) => throw null;
        public static bool ToBoolean(System.DateTime value) => throw null;
        public static bool ToBoolean(decimal value) => throw null;
        public static bool ToBoolean(double value) => throw null;
        public static bool ToBoolean(short value) => throw null;
        public static bool ToBoolean(int value) => throw null;
        public static bool ToBoolean(long value) => throw null;
        public static bool ToBoolean(object value) => throw null;
        public static bool ToBoolean(object value, System.IFormatProvider provider) => throw null;
        public static bool ToBoolean(sbyte value) => throw null;
        public static bool ToBoolean(float value) => throw null;
        public static bool ToBoolean(string value) => throw null;
        public static bool ToBoolean(string value, System.IFormatProvider provider) => throw null;
        public static bool ToBoolean(ushort value) => throw null;
        public static bool ToBoolean(uint value) => throw null;
        public static bool ToBoolean(ulong value) => throw null;
        public static byte ToByte(bool value) => throw null;
        public static byte ToByte(byte value) => throw null;
        public static byte ToByte(char value) => throw null;
        public static byte ToByte(System.DateTime value) => throw null;
        public static byte ToByte(decimal value) => throw null;
        public static byte ToByte(double value) => throw null;
        public static byte ToByte(short value) => throw null;
        public static byte ToByte(int value) => throw null;
        public static byte ToByte(long value) => throw null;
        public static byte ToByte(object value) => throw null;
        public static byte ToByte(object value, System.IFormatProvider provider) => throw null;
        public static byte ToByte(sbyte value) => throw null;
        public static byte ToByte(float value) => throw null;
        public static byte ToByte(string value) => throw null;
        public static byte ToByte(string value, System.IFormatProvider provider) => throw null;
        public static byte ToByte(string value, int fromBase) => throw null;
        public static byte ToByte(ushort value) => throw null;
        public static byte ToByte(uint value) => throw null;
        public static byte ToByte(ulong value) => throw null;
        public static char ToChar(bool value) => throw null;
        public static char ToChar(byte value) => throw null;
        public static char ToChar(char value) => throw null;
        public static char ToChar(System.DateTime value) => throw null;
        public static char ToChar(decimal value) => throw null;
        public static char ToChar(double value) => throw null;
        public static char ToChar(short value) => throw null;
        public static char ToChar(int value) => throw null;
        public static char ToChar(long value) => throw null;
        public static char ToChar(object value) => throw null;
        public static char ToChar(object value, System.IFormatProvider provider) => throw null;
        public static char ToChar(sbyte value) => throw null;
        public static char ToChar(float value) => throw null;
        public static char ToChar(string value) => throw null;
        public static char ToChar(string value, System.IFormatProvider provider) => throw null;
        public static char ToChar(ushort value) => throw null;
        public static char ToChar(uint value) => throw null;
        public static char ToChar(ulong value) => throw null;
        public static System.DateTime ToDateTime(bool value) => throw null;
        public static System.DateTime ToDateTime(byte value) => throw null;
        public static System.DateTime ToDateTime(char value) => throw null;
        public static System.DateTime ToDateTime(System.DateTime value) => throw null;
        public static System.DateTime ToDateTime(decimal value) => throw null;
        public static System.DateTime ToDateTime(double value) => throw null;
        public static System.DateTime ToDateTime(short value) => throw null;
        public static System.DateTime ToDateTime(int value) => throw null;
        public static System.DateTime ToDateTime(long value) => throw null;
        public static System.DateTime ToDateTime(object value) => throw null;
        public static System.DateTime ToDateTime(object value, System.IFormatProvider provider) => throw null;
        public static System.DateTime ToDateTime(sbyte value) => throw null;
        public static System.DateTime ToDateTime(float value) => throw null;
        public static System.DateTime ToDateTime(string value) => throw null;
        public static System.DateTime ToDateTime(string value, System.IFormatProvider provider) => throw null;
        public static System.DateTime ToDateTime(ushort value) => throw null;
        public static System.DateTime ToDateTime(uint value) => throw null;
        public static System.DateTime ToDateTime(ulong value) => throw null;
        public static decimal ToDecimal(bool value) => throw null;
        public static decimal ToDecimal(byte value) => throw null;
        public static decimal ToDecimal(char value) => throw null;
        public static decimal ToDecimal(System.DateTime value) => throw null;
        public static decimal ToDecimal(decimal value) => throw null;
        public static decimal ToDecimal(double value) => throw null;
        public static decimal ToDecimal(short value) => throw null;
        public static decimal ToDecimal(int value) => throw null;
        public static decimal ToDecimal(long value) => throw null;
        public static decimal ToDecimal(object value) => throw null;
        public static decimal ToDecimal(object value, System.IFormatProvider provider) => throw null;
        public static decimal ToDecimal(sbyte value) => throw null;
        public static decimal ToDecimal(float value) => throw null;
        public static decimal ToDecimal(string value) => throw null;
        public static decimal ToDecimal(string value, System.IFormatProvider provider) => throw null;
        public static decimal ToDecimal(ushort value) => throw null;
        public static decimal ToDecimal(uint value) => throw null;
        public static decimal ToDecimal(ulong value) => throw null;
        public static double ToDouble(bool value) => throw null;
        public static double ToDouble(byte value) => throw null;
        public static double ToDouble(char value) => throw null;
        public static double ToDouble(System.DateTime value) => throw null;
        public static double ToDouble(decimal value) => throw null;
        public static double ToDouble(double value) => throw null;
        public static double ToDouble(short value) => throw null;
        public static double ToDouble(int value) => throw null;
        public static double ToDouble(long value) => throw null;
        public static double ToDouble(object value) => throw null;
        public static double ToDouble(object value, System.IFormatProvider provider) => throw null;
        public static double ToDouble(sbyte value) => throw null;
        public static double ToDouble(float value) => throw null;
        public static double ToDouble(string value) => throw null;
        public static double ToDouble(string value, System.IFormatProvider provider) => throw null;
        public static double ToDouble(ushort value) => throw null;
        public static double ToDouble(uint value) => throw null;
        public static double ToDouble(ulong value) => throw null;
        public static string ToHexString(byte[] inArray) => throw null;
        public static string ToHexString(byte[] inArray, int offset, int length) => throw null;
        public static string ToHexString(System.ReadOnlySpan<byte> bytes) => throw null;
        public static short ToInt16(bool value) => throw null;
        public static short ToInt16(byte value) => throw null;
        public static short ToInt16(char value) => throw null;
        public static short ToInt16(System.DateTime value) => throw null;
        public static short ToInt16(decimal value) => throw null;
        public static short ToInt16(double value) => throw null;
        public static short ToInt16(short value) => throw null;
        public static short ToInt16(int value) => throw null;
        public static short ToInt16(long value) => throw null;
        public static short ToInt16(object value) => throw null;
        public static short ToInt16(object value, System.IFormatProvider provider) => throw null;
        public static short ToInt16(sbyte value) => throw null;
        public static short ToInt16(float value) => throw null;
        public static short ToInt16(string value) => throw null;
        public static short ToInt16(string value, System.IFormatProvider provider) => throw null;
        public static short ToInt16(string value, int fromBase) => throw null;
        public static short ToInt16(ushort value) => throw null;
        public static short ToInt16(uint value) => throw null;
        public static short ToInt16(ulong value) => throw null;
        public static int ToInt32(bool value) => throw null;
        public static int ToInt32(byte value) => throw null;
        public static int ToInt32(char value) => throw null;
        public static int ToInt32(System.DateTime value) => throw null;
        public static int ToInt32(decimal value) => throw null;
        public static int ToInt32(double value) => throw null;
        public static int ToInt32(short value) => throw null;
        public static int ToInt32(int value) => throw null;
        public static int ToInt32(long value) => throw null;
        public static int ToInt32(object value) => throw null;
        public static int ToInt32(object value, System.IFormatProvider provider) => throw null;
        public static int ToInt32(sbyte value) => throw null;
        public static int ToInt32(float value) => throw null;
        public static int ToInt32(string value) => throw null;
        public static int ToInt32(string value, System.IFormatProvider provider) => throw null;
        public static int ToInt32(string value, int fromBase) => throw null;
        public static int ToInt32(ushort value) => throw null;
        public static int ToInt32(uint value) => throw null;
        public static int ToInt32(ulong value) => throw null;
        public static long ToInt64(bool value) => throw null;
        public static long ToInt64(byte value) => throw null;
        public static long ToInt64(char value) => throw null;
        public static long ToInt64(System.DateTime value) => throw null;
        public static long ToInt64(decimal value) => throw null;
        public static long ToInt64(double value) => throw null;
        public static long ToInt64(short value) => throw null;
        public static long ToInt64(int value) => throw null;
        public static long ToInt64(long value) => throw null;
        public static long ToInt64(object value) => throw null;
        public static long ToInt64(object value, System.IFormatProvider provider) => throw null;
        public static long ToInt64(sbyte value) => throw null;
        public static long ToInt64(float value) => throw null;
        public static long ToInt64(string value) => throw null;
        public static long ToInt64(string value, System.IFormatProvider provider) => throw null;
        public static long ToInt64(string value, int fromBase) => throw null;
        public static long ToInt64(ushort value) => throw null;
        public static long ToInt64(uint value) => throw null;
        public static long ToInt64(ulong value) => throw null;
        public static sbyte ToSByte(bool value) => throw null;
        public static sbyte ToSByte(byte value) => throw null;
        public static sbyte ToSByte(char value) => throw null;
        public static sbyte ToSByte(System.DateTime value) => throw null;
        public static sbyte ToSByte(decimal value) => throw null;
        public static sbyte ToSByte(double value) => throw null;
        public static sbyte ToSByte(short value) => throw null;
        public static sbyte ToSByte(int value) => throw null;
        public static sbyte ToSByte(long value) => throw null;
        public static sbyte ToSByte(object value) => throw null;
        public static sbyte ToSByte(object value, System.IFormatProvider provider) => throw null;
        public static sbyte ToSByte(sbyte value) => throw null;
        public static sbyte ToSByte(float value) => throw null;
        public static sbyte ToSByte(string value) => throw null;
        public static sbyte ToSByte(string value, System.IFormatProvider provider) => throw null;
        public static sbyte ToSByte(string value, int fromBase) => throw null;
        public static sbyte ToSByte(ushort value) => throw null;
        public static sbyte ToSByte(uint value) => throw null;
        public static sbyte ToSByte(ulong value) => throw null;
        public static float ToSingle(bool value) => throw null;
        public static float ToSingle(byte value) => throw null;
        public static float ToSingle(char value) => throw null;
        public static float ToSingle(System.DateTime value) => throw null;
        public static float ToSingle(decimal value) => throw null;
        public static float ToSingle(double value) => throw null;
        public static float ToSingle(short value) => throw null;
        public static float ToSingle(int value) => throw null;
        public static float ToSingle(long value) => throw null;
        public static float ToSingle(object value) => throw null;
        public static float ToSingle(object value, System.IFormatProvider provider) => throw null;
        public static float ToSingle(sbyte value) => throw null;
        public static float ToSingle(float value) => throw null;
        public static float ToSingle(string value) => throw null;
        public static float ToSingle(string value, System.IFormatProvider provider) => throw null;
        public static float ToSingle(ushort value) => throw null;
        public static float ToSingle(uint value) => throw null;
        public static float ToSingle(ulong value) => throw null;
        public static string ToString(bool value) => throw null;
        public static string ToString(bool value, System.IFormatProvider provider) => throw null;
        public static string ToString(byte value) => throw null;
        public static string ToString(byte value, System.IFormatProvider provider) => throw null;
        public static string ToString(byte value, int toBase) => throw null;
        public static string ToString(char value) => throw null;
        public static string ToString(char value, System.IFormatProvider provider) => throw null;
        public static string ToString(System.DateTime value) => throw null;
        public static string ToString(System.DateTime value, System.IFormatProvider provider) => throw null;
        public static string ToString(decimal value) => throw null;
        public static string ToString(decimal value, System.IFormatProvider provider) => throw null;
        public static string ToString(double value) => throw null;
        public static string ToString(double value, System.IFormatProvider provider) => throw null;
        public static string ToString(short value) => throw null;
        public static string ToString(short value, System.IFormatProvider provider) => throw null;
        public static string ToString(short value, int toBase) => throw null;
        public static string ToString(int value) => throw null;
        public static string ToString(int value, System.IFormatProvider provider) => throw null;
        public static string ToString(int value, int toBase) => throw null;
        public static string ToString(long value) => throw null;
        public static string ToString(long value, System.IFormatProvider provider) => throw null;
        public static string ToString(long value, int toBase) => throw null;
        public static string ToString(object value) => throw null;
        public static string ToString(object value, System.IFormatProvider provider) => throw null;
        public static string ToString(sbyte value) => throw null;
        public static string ToString(sbyte value, System.IFormatProvider provider) => throw null;
        public static string ToString(float value) => throw null;
        public static string ToString(float value, System.IFormatProvider provider) => throw null;
        public static string ToString(string value) => throw null;
        public static string ToString(string value, System.IFormatProvider provider) => throw null;
        public static string ToString(ushort value) => throw null;
        public static string ToString(ushort value, System.IFormatProvider provider) => throw null;
        public static string ToString(uint value) => throw null;
        public static string ToString(uint value, System.IFormatProvider provider) => throw null;
        public static string ToString(ulong value) => throw null;
        public static string ToString(ulong value, System.IFormatProvider provider) => throw null;
        public static ushort ToUInt16(bool value) => throw null;
        public static ushort ToUInt16(byte value) => throw null;
        public static ushort ToUInt16(char value) => throw null;
        public static ushort ToUInt16(System.DateTime value) => throw null;
        public static ushort ToUInt16(decimal value) => throw null;
        public static ushort ToUInt16(double value) => throw null;
        public static ushort ToUInt16(short value) => throw null;
        public static ushort ToUInt16(int value) => throw null;
        public static ushort ToUInt16(long value) => throw null;
        public static ushort ToUInt16(object value) => throw null;
        public static ushort ToUInt16(object value, System.IFormatProvider provider) => throw null;
        public static ushort ToUInt16(sbyte value) => throw null;
        public static ushort ToUInt16(float value) => throw null;
        public static ushort ToUInt16(string value) => throw null;
        public static ushort ToUInt16(string value, System.IFormatProvider provider) => throw null;
        public static ushort ToUInt16(string value, int fromBase) => throw null;
        public static ushort ToUInt16(ushort value) => throw null;
        public static ushort ToUInt16(uint value) => throw null;
        public static ushort ToUInt16(ulong value) => throw null;
        public static uint ToUInt32(bool value) => throw null;
        public static uint ToUInt32(byte value) => throw null;
        public static uint ToUInt32(char value) => throw null;
        public static uint ToUInt32(System.DateTime value) => throw null;
        public static uint ToUInt32(decimal value) => throw null;
        public static uint ToUInt32(double value) => throw null;
        public static uint ToUInt32(short value) => throw null;
        public static uint ToUInt32(int value) => throw null;
        public static uint ToUInt32(long value) => throw null;
        public static uint ToUInt32(object value) => throw null;
        public static uint ToUInt32(object value, System.IFormatProvider provider) => throw null;
        public static uint ToUInt32(sbyte value) => throw null;
        public static uint ToUInt32(float value) => throw null;
        public static uint ToUInt32(string value) => throw null;
        public static uint ToUInt32(string value, System.IFormatProvider provider) => throw null;
        public static uint ToUInt32(string value, int fromBase) => throw null;
        public static uint ToUInt32(ushort value) => throw null;
        public static uint ToUInt32(uint value) => throw null;
        public static uint ToUInt32(ulong value) => throw null;
        public static ulong ToUInt64(bool value) => throw null;
        public static ulong ToUInt64(byte value) => throw null;
        public static ulong ToUInt64(char value) => throw null;
        public static ulong ToUInt64(System.DateTime value) => throw null;
        public static ulong ToUInt64(decimal value) => throw null;
        public static ulong ToUInt64(double value) => throw null;
        public static ulong ToUInt64(short value) => throw null;
        public static ulong ToUInt64(int value) => throw null;
        public static ulong ToUInt64(long value) => throw null;
        public static ulong ToUInt64(object value) => throw null;
        public static ulong ToUInt64(object value, System.IFormatProvider provider) => throw null;
        public static ulong ToUInt64(sbyte value) => throw null;
        public static ulong ToUInt64(float value) => throw null;
        public static ulong ToUInt64(string value) => throw null;
        public static ulong ToUInt64(string value, System.IFormatProvider provider) => throw null;
        public static ulong ToUInt64(string value, int fromBase) => throw null;
        public static ulong ToUInt64(ushort value) => throw null;
        public static ulong ToUInt64(uint value) => throw null;
        public static ulong ToUInt64(ulong value) => throw null;
        public static bool TryFromBase64Chars(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, out int bytesWritten) => throw null;
        public static bool TryFromBase64String(string s, System.Span<byte> bytes, out int bytesWritten) => throw null;
        public static bool TryToBase64Chars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, out int charsWritten, System.Base64FormattingOptions options = default(System.Base64FormattingOptions)) => throw null;
    }
    public delegate TOutput Converter<TInput, TOutput>(TInput input);
    public struct DateOnly : System.IComparable, System.IComparable<System.DateOnly>, System.IEquatable<System.DateOnly>, System.IFormattable, System.IParsable<System.DateOnly>, System.ISpanFormattable, System.ISpanParsable<System.DateOnly>, System.IUtf8SpanFormattable
    {
        public System.DateOnly AddDays(int value) => throw null;
        public System.DateOnly AddMonths(int value) => throw null;
        public System.DateOnly AddYears(int value) => throw null;
        public int CompareTo(System.DateOnly value) => throw null;
        public int CompareTo(object value) => throw null;
        public DateOnly(int year, int month, int day) => throw null;
        public DateOnly(int year, int month, int day, System.Globalization.Calendar calendar) => throw null;
        public int Day { get => throw null; }
        public int DayNumber { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public void Deconstruct(out int year, out int month, out int day) => throw null;
        public bool Equals(System.DateOnly value) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.DateOnly FromDateTime(System.DateTime dateTime) => throw null;
        public static System.DateOnly FromDayNumber(int dayNumber) => throw null;
        public override int GetHashCode() => throw null;
        public static System.DateOnly MaxValue { get => throw null; }
        public static System.DateOnly MinValue { get => throw null; }
        public int Month { get => throw null; }
        public static bool operator ==(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator >(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator >=(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator !=(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator <(System.DateOnly left, System.DateOnly right) => throw null;
        public static bool operator <=(System.DateOnly left, System.DateOnly right) => throw null;
        static System.DateOnly System.ISpanParsable<System.DateOnly>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.DateOnly Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly Parse(string s) => throw null;
        static System.DateOnly System.IParsable<System.DateOnly>.Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.DateOnly Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<char> s, string[] formats) => throw null;
        public static System.DateOnly ParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(string s, string format) => throw null;
        public static System.DateOnly ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateOnly ParseExact(string s, string[] formats) => throw null;
        public static System.DateOnly ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public System.DateTime ToDateTime(System.TimeOnly time) => throw null;
        public System.DateTime ToDateTime(System.TimeOnly time, System.DateTimeKind kind) => throw null;
        public string ToLongDateString() => throw null;
        public string ToShortDateString() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.DateOnly result) => throw null;
        static bool System.ISpanParsable<System.DateOnly>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.DateOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParse(string s, out System.DateOnly result) => throw null;
        static bool System.IParsable<System.DateOnly>.TryParse(string s, System.IFormatProvider provider, out System.DateOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, out System.DateOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string format, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, out System.DateOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateOnly result) => throw null;
        public int Year { get => throw null; }
    }
    public struct DateTime : System.IComparable, System.IComparable<System.DateTime>, System.IConvertible, System.IEquatable<System.DateTime>, System.IFormattable, System.IParsable<System.DateTime>, System.Runtime.Serialization.ISerializable, System.ISpanFormattable, System.ISpanParsable<System.DateTime>, System.IUtf8SpanFormattable
    {
        public System.DateTime Add(System.TimeSpan value) => throw null;
        public System.DateTime AddDays(double value) => throw null;
        public System.DateTime AddHours(double value) => throw null;
        public System.DateTime AddMicroseconds(double value) => throw null;
        public System.DateTime AddMilliseconds(double value) => throw null;
        public System.DateTime AddMinutes(double value) => throw null;
        public System.DateTime AddMonths(int months) => throw null;
        public System.DateTime AddSeconds(double value) => throw null;
        public System.DateTime AddTicks(long value) => throw null;
        public System.DateTime AddYears(int value) => throw null;
        public static int Compare(System.DateTime t1, System.DateTime t2) => throw null;
        public int CompareTo(System.DateTime value) => throw null;
        public int CompareTo(object value) => throw null;
        public DateTime(int year, int month, int day) => throw null;
        public DateTime(int year, int month, int day, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.DateTimeKind kind) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar) => throw null;
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar, System.DateTimeKind kind) => throw null;
        public DateTime(long ticks) => throw null;
        public DateTime(long ticks, System.DateTimeKind kind) => throw null;
        public DateTime(System.DateOnly date, System.TimeOnly time) => throw null;
        public DateTime(System.DateOnly date, System.TimeOnly time, System.DateTimeKind kind) => throw null;
        public System.DateTime Date { get => throw null; }
        public int Day { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public static int DaysInMonth(int year, int month) => throw null;
        public void Deconstruct(out System.DateOnly date, out System.TimeOnly time) => throw null;
        public void Deconstruct(out int year, out int month, out int day) => throw null;
        public bool Equals(System.DateTime value) => throw null;
        public static bool Equals(System.DateTime t1, System.DateTime t2) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.DateTime FromBinary(long dateData) => throw null;
        public static System.DateTime FromFileTime(long fileTime) => throw null;
        public static System.DateTime FromFileTimeUtc(long fileTime) => throw null;
        public static System.DateTime FromOADate(double d) => throw null;
        public string[] GetDateTimeFormats() => throw null;
        public string[] GetDateTimeFormats(char format) => throw null;
        public string[] GetDateTimeFormats(char format, System.IFormatProvider provider) => throw null;
        public string[] GetDateTimeFormats(System.IFormatProvider provider) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public int Hour { get => throw null; }
        public bool IsDaylightSavingTime() => throw null;
        public static bool IsLeapYear(int year) => throw null;
        public System.DateTimeKind Kind { get => throw null; }
        public static readonly System.DateTime MaxValue;
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public int Minute { get => throw null; }
        public static readonly System.DateTime MinValue;
        public int Month { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static System.DateTime Now { get => throw null; }
        public static System.DateTime operator +(System.DateTime d, System.TimeSpan t) => throw null;
        public static bool operator ==(System.DateTime d1, System.DateTime d2) => throw null;
        public static bool operator >(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator >=(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator !=(System.DateTime d1, System.DateTime d2) => throw null;
        public static bool operator <(System.DateTime t1, System.DateTime t2) => throw null;
        public static bool operator <=(System.DateTime t1, System.DateTime t2) => throw null;
        public static System.TimeSpan operator -(System.DateTime d1, System.DateTime d2) => throw null;
        public static System.DateTime operator -(System.DateTime d, System.TimeSpan t) => throw null;
        static System.DateTime System.ISpanParsable<System.DateTime>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.DateTime Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime Parse(string s) => throw null;
        static System.DateTime System.IParsable<System.DateTime>.Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.DateTime Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime ParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider) => throw null;
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) => throw null;
        public static System.DateTime ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) => throw null;
        public int Second { get => throw null; }
        public static System.DateTime SpecifyKind(System.DateTime value, System.DateTimeKind kind) => throw null;
        public System.TimeSpan Subtract(System.DateTime value) => throw null;
        public System.DateTime Subtract(System.TimeSpan value) => throw null;
        public long Ticks { get => throw null; }
        public System.TimeSpan TimeOfDay { get => throw null; }
        public long ToBinary() => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        public static System.DateTime Today { get => throw null; }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        public long ToFileTime() => throw null;
        public long ToFileTimeUtc() => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public System.DateTime ToLocalTime() => throw null;
        public string ToLongDateString() => throw null;
        public string ToLongTimeString() => throw null;
        public double ToOADate() => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        public string ToShortDateString() => throw null;
        public string ToShortTimeString() => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public System.DateTime ToUniversalTime() => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.DateTime result) => throw null;
        static bool System.ISpanParsable<System.DateTime>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.DateTime result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, out System.DateTime result) => throw null;
        public static bool TryParse(string s, out System.DateTime result) => throw null;
        static bool System.IParsable<System.DateTime>.TryParse(string s, System.IFormatProvider provider, out System.DateTime result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, out System.DateTime result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) => throw null;
        public static readonly System.DateTime UnixEpoch;
        public static System.DateTime UtcNow { get => throw null; }
        public int Year { get => throw null; }
    }
    public enum DateTimeKind
    {
        Unspecified = 0,
        Utc = 1,
        Local = 2,
    }
    public struct DateTimeOffset : System.IComparable, System.IComparable<System.DateTimeOffset>, System.Runtime.Serialization.IDeserializationCallback, System.IEquatable<System.DateTimeOffset>, System.IFormattable, System.IParsable<System.DateTimeOffset>, System.Runtime.Serialization.ISerializable, System.ISpanFormattable, System.ISpanParsable<System.DateTimeOffset>, System.IUtf8SpanFormattable
    {
        public System.DateTimeOffset Add(System.TimeSpan timeSpan) => throw null;
        public System.DateTimeOffset AddDays(double days) => throw null;
        public System.DateTimeOffset AddHours(double hours) => throw null;
        public System.DateTimeOffset AddMicroseconds(double microseconds) => throw null;
        public System.DateTimeOffset AddMilliseconds(double milliseconds) => throw null;
        public System.DateTimeOffset AddMinutes(double minutes) => throw null;
        public System.DateTimeOffset AddMonths(int months) => throw null;
        public System.DateTimeOffset AddSeconds(double seconds) => throw null;
        public System.DateTimeOffset AddTicks(long ticks) => throw null;
        public System.DateTimeOffset AddYears(int years) => throw null;
        public static int Compare(System.DateTimeOffset first, System.DateTimeOffset second) => throw null;
        public int CompareTo(System.DateTimeOffset other) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public DateTimeOffset(System.DateTime dateTime) => throw null;
        public DateTimeOffset(System.DateTime dateTime, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.Globalization.Calendar calendar, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.TimeSpan offset) => throw null;
        public DateTimeOffset(System.DateOnly date, System.TimeOnly time, System.TimeSpan offset) => throw null;
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, System.TimeSpan offset) => throw null;
        public DateTimeOffset(long ticks, System.TimeSpan offset) => throw null;
        public System.DateTime Date { get => throw null; }
        public System.DateTime DateTime { get => throw null; }
        public int Day { get => throw null; }
        public System.DayOfWeek DayOfWeek { get => throw null; }
        public int DayOfYear { get => throw null; }
        public void Deconstruct(out System.DateOnly date, out System.TimeOnly time, out System.TimeSpan offset) => throw null;
        public bool Equals(System.DateTimeOffset other) => throw null;
        public static bool Equals(System.DateTimeOffset first, System.DateTimeOffset second) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool EqualsExact(System.DateTimeOffset other) => throw null;
        public static System.DateTimeOffset FromFileTime(long fileTime) => throw null;
        public static System.DateTimeOffset FromUnixTimeMilliseconds(long milliseconds) => throw null;
        public static System.DateTimeOffset FromUnixTimeSeconds(long seconds) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public int Hour { get => throw null; }
        public System.DateTime LocalDateTime { get => throw null; }
        public static readonly System.DateTimeOffset MaxValue;
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public int Minute { get => throw null; }
        public static readonly System.DateTimeOffset MinValue;
        public int Month { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static System.DateTimeOffset Now { get => throw null; }
        public System.TimeSpan Offset { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public static System.DateTimeOffset operator +(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) => throw null;
        public static bool operator ==(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator >(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator >=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static implicit operator System.DateTimeOffset(System.DateTime dateTime) => throw null;
        public static bool operator !=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator <(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static bool operator <=(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static System.TimeSpan operator -(System.DateTimeOffset left, System.DateTimeOffset right) => throw null;
        public static System.DateTimeOffset operator -(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) => throw null;
        static System.DateTimeOffset System.ISpanParsable<System.DateTimeOffset>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.DateTimeOffset Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider = default(System.IFormatProvider), System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset Parse(string input) => throw null;
        static System.DateTimeOffset System.IParsable<System.DateTimeOffset>.Parse(string input, System.IFormatProvider formatProvider) => throw null;
        public static System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTimeOffset ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset ParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public static System.DateTimeOffset ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) => throw null;
        public int Second { get => throw null; }
        public System.TimeSpan Subtract(System.DateTimeOffset value) => throw null;
        public System.DateTimeOffset Subtract(System.TimeSpan value) => throw null;
        public long Ticks { get => throw null; }
        public System.TimeSpan TimeOfDay { get => throw null; }
        public long ToFileTime() => throw null;
        public System.DateTimeOffset ToLocalTime() => throw null;
        public System.DateTimeOffset ToOffset(System.TimeSpan offset) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider formatProvider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public int TotalOffsetMinutes { get => throw null; }
        public System.DateTimeOffset ToUniversalTime() => throw null;
        public long ToUnixTimeMilliseconds() => throw null;
        public long ToUnixTimeSeconds() => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> input, out System.DateTimeOffset result) => throw null;
        static bool System.ISpanParsable<System.DateTimeOffset>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(string input, out System.DateTimeOffset result) => throw null;
        static bool System.IParsable<System.DateTimeOffset>.TryParse(string s, System.IFormatProvider provider, out System.DateTimeOffset result) => throw null;
        public static bool TryParse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) => throw null;
        public static readonly System.DateTimeOffset UnixEpoch;
        public System.DateTime UtcDateTime { get => throw null; }
        public static System.DateTimeOffset UtcNow { get => throw null; }
        public long UtcTicks { get => throw null; }
        public int Year { get => throw null; }
    }
    public enum DayOfWeek
    {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }
    public sealed class DBNull : System.IConvertible, System.Runtime.Serialization.ISerializable
    {
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static readonly System.DBNull Value;
    }
    public struct Decimal : System.Numerics.IAdditionOperators<decimal, decimal, decimal>, System.Numerics.IAdditiveIdentity<decimal, decimal>, System.IComparable, System.IComparable<decimal>, System.Numerics.IComparisonOperators<decimal, decimal, bool>, System.IConvertible, System.Numerics.IDecrementOperators<decimal>, System.Runtime.Serialization.IDeserializationCallback, System.Numerics.IDivisionOperators<decimal, decimal, decimal>, System.Numerics.IEqualityOperators<decimal, decimal, bool>, System.IEquatable<decimal>, System.Numerics.IFloatingPoint<decimal>, System.Numerics.IFloatingPointConstants<decimal>, System.IFormattable, System.Numerics.IIncrementOperators<decimal>, System.Numerics.IMinMaxValue<decimal>, System.Numerics.IModulusOperators<decimal, decimal, decimal>, System.Numerics.IMultiplicativeIdentity<decimal, decimal>, System.Numerics.IMultiplyOperators<decimal, decimal, decimal>, System.Numerics.INumber<decimal>, System.Numerics.INumberBase<decimal>, System.IParsable<decimal>, System.Runtime.Serialization.ISerializable, System.Numerics.ISignedNumber<decimal>, System.ISpanFormattable, System.ISpanParsable<decimal>, System.Numerics.ISubtractionOperators<decimal, decimal, decimal>, System.Numerics.IUnaryNegationOperators<decimal, decimal>, System.Numerics.IUnaryPlusOperators<decimal, decimal>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<decimal>
    {
        static decimal System.Numerics.INumberBase<decimal>.Abs(decimal value) => throw null;
        public static decimal Add(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IAdditiveIdentity<decimal, decimal>.AdditiveIdentity { get => throw null; }
        static decimal System.Numerics.IFloatingPoint<decimal>.Ceiling(decimal d) => throw null;
        static decimal System.Numerics.INumber<decimal>.Clamp(decimal value, decimal min, decimal max) => throw null;
        public static int Compare(decimal d1, decimal d2) => throw null;
        public int CompareTo(decimal value) => throw null;
        public int CompareTo(object value) => throw null;
        static decimal System.Numerics.INumber<decimal>.CopySign(decimal value, decimal sign) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.CreateChecked<TOther>(TOther value) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.CreateSaturating<TOther>(TOther value) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.CreateTruncating<TOther>(TOther value) => throw null;
        public Decimal(double value) => throw null;
        public Decimal(int value) => throw null;
        public Decimal(int lo, int mid, int hi, bool isNegative, byte scale) => throw null;
        public Decimal(int[] bits) => throw null;
        public Decimal(long value) => throw null;
        public Decimal(System.ReadOnlySpan<int> bits) => throw null;
        public Decimal(float value) => throw null;
        public Decimal(uint value) => throw null;
        public Decimal(ulong value) => throw null;
        public static decimal Divide(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IFloatingPointConstants<decimal>.E { get => throw null; }
        public bool Equals(decimal value) => throw null;
        public static bool Equals(decimal d1, decimal d2) => throw null;
        public override bool Equals(object value) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Floor(decimal d) => throw null;
        public static decimal FromOACurrency(long cy) => throw null;
        public static int[] GetBits(decimal d) => throw null;
        public static int GetBits(decimal d, System.Span<int> destination) => throw null;
        int System.Numerics.IFloatingPoint<decimal>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<decimal>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IFloatingPoint<decimal>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<decimal>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsCanonical(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsComplexNumber(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsEvenInteger(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsFinite(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsImaginaryNumber(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsInfinity(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsInteger(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsNaN(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsNegative(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsNegativeInfinity(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsNormal(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsOddInteger(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsPositive(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsPositiveInfinity(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsRealNumber(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsSubnormal(decimal value) => throw null;
        static bool System.Numerics.INumberBase<decimal>.IsZero(decimal value) => throw null;
        static decimal System.Numerics.INumber<decimal>.Max(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.MaxMagnitude(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.MaxMagnitudeNumber(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumber<decimal>.MaxNumber(decimal x, decimal y) => throw null;
        public const decimal MaxValue = default;
        static decimal System.Numerics.IMinMaxValue<decimal>.MaxValue { get => throw null; }
        static decimal System.Numerics.INumber<decimal>.Min(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.MinMagnitude(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.MinMagnitudeNumber(decimal x, decimal y) => throw null;
        static decimal System.Numerics.INumber<decimal>.MinNumber(decimal x, decimal y) => throw null;
        public const decimal MinusOne = default;
        public const decimal MinValue = default;
        static decimal System.Numerics.IMinMaxValue<decimal>.MinValue { get => throw null; }
        static decimal System.Numerics.IMultiplicativeIdentity<decimal, decimal>.MultiplicativeIdentity { get => throw null; }
        public static decimal Multiply(decimal d1, decimal d2) => throw null;
        public static decimal Negate(decimal d) => throw null;
        static decimal System.Numerics.ISignedNumber<decimal>.NegativeOne { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public const decimal One = default;
        static decimal System.Numerics.INumberBase<decimal>.One { get => throw null; }
        static decimal System.Numerics.IAdditionOperators<decimal, decimal, decimal>.operator +(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IDecrementOperators<decimal>.operator --(decimal d) => throw null;
        static decimal System.Numerics.IDivisionOperators<decimal, decimal, decimal>.operator /(decimal d1, decimal d2) => throw null;
        static bool System.Numerics.IEqualityOperators<decimal, decimal, bool>.operator ==(decimal d1, decimal d2) => throw null;
        public static explicit operator byte(decimal value) => throw null;
        public static explicit operator char(decimal value) => throw null;
        public static explicit operator double(decimal value) => throw null;
        public static explicit operator short(decimal value) => throw null;
        public static explicit operator int(decimal value) => throw null;
        public static explicit operator long(decimal value) => throw null;
        public static explicit operator sbyte(decimal value) => throw null;
        public static explicit operator float(decimal value) => throw null;
        public static explicit operator ushort(decimal value) => throw null;
        public static explicit operator uint(decimal value) => throw null;
        public static explicit operator ulong(decimal value) => throw null;
        public static explicit operator decimal(double value) => throw null;
        public static explicit operator decimal(float value) => throw null;
        static bool System.Numerics.IComparisonOperators<decimal, decimal, bool>.operator >(decimal d1, decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<decimal, decimal, bool>.operator >=(decimal d1, decimal d2) => throw null;
        public static implicit operator decimal(byte value) => throw null;
        public static implicit operator decimal(char value) => throw null;
        public static implicit operator decimal(short value) => throw null;
        public static implicit operator decimal(int value) => throw null;
        public static implicit operator decimal(long value) => throw null;
        public static implicit operator decimal(sbyte value) => throw null;
        public static implicit operator decimal(ushort value) => throw null;
        public static implicit operator decimal(uint value) => throw null;
        public static implicit operator decimal(ulong value) => throw null;
        static decimal System.Numerics.IIncrementOperators<decimal>.operator ++(decimal d) => throw null;
        static bool System.Numerics.IEqualityOperators<decimal, decimal, bool>.operator !=(decimal d1, decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<decimal, decimal, bool>.operator <(decimal d1, decimal d2) => throw null;
        static bool System.Numerics.IComparisonOperators<decimal, decimal, bool>.operator <=(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IModulusOperators<decimal, decimal, decimal>.operator %(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IMultiplyOperators<decimal, decimal, decimal>.operator *(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.ISubtractionOperators<decimal, decimal, decimal>.operator -(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IUnaryNegationOperators<decimal, decimal>.operator -(decimal d) => throw null;
        static decimal System.Numerics.IUnaryPlusOperators<decimal, decimal>.operator +(decimal d) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static decimal System.IUtf8SpanParsable<decimal>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static decimal System.ISpanParsable<decimal>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static decimal Parse(string s) => throw null;
        public static decimal Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static decimal System.Numerics.INumberBase<decimal>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static decimal System.IParsable<decimal>.Parse(string s, System.IFormatProvider provider) => throw null;
        static decimal System.Numerics.IFloatingPointConstants<decimal>.Pi { get => throw null; }
        static int System.Numerics.INumberBase<decimal>.Radix { get => throw null; }
        public static decimal Remainder(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Round(decimal d) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Round(decimal d, int decimals) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Round(decimal d, int decimals, System.MidpointRounding mode) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Round(decimal d, System.MidpointRounding mode) => throw null;
        public byte Scale { get => throw null; }
        static int System.Numerics.INumber<decimal>.Sign(decimal d) => throw null;
        public static decimal Subtract(decimal d1, decimal d2) => throw null;
        static decimal System.Numerics.IFloatingPointConstants<decimal>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        public static byte ToByte(decimal value) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        public static double ToDouble(decimal d) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        public static short ToInt16(decimal value) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        public static int ToInt32(decimal d) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static long ToInt64(decimal d) => throw null;
        public static long ToOACurrency(decimal value) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        public static sbyte ToSByte(decimal value) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public static float ToSingle(decimal d) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        public static ushort ToUInt16(decimal value) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        public static uint ToUInt32(decimal d) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static ulong ToUInt64(decimal d) => throw null;
        static decimal System.Numerics.IFloatingPoint<decimal>.Truncate(decimal d) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertFromChecked<TOther>(TOther value, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertFromSaturating<TOther>(TOther value, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertFromTruncating<TOther>(TOther value, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertToChecked<TOther>(decimal value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertToSaturating<TOther>(decimal value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryConvertToTruncating<TOther>(decimal value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryGetBits(decimal d, System.Span<int> destination, out int valuesWritten) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out decimal result) => throw null;
        static bool System.IUtf8SpanParsable<decimal>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out decimal result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out decimal result) => throw null;
        static bool System.ISpanParsable<decimal>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out decimal result) => throw null;
        public static bool TryParse(string s, out decimal result) => throw null;
        static bool System.Numerics.INumberBase<decimal>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out decimal result) => throw null;
        static bool System.IParsable<decimal>.TryParse(string s, System.IFormatProvider provider, out decimal result) => throw null;
        bool System.Numerics.IFloatingPoint<decimal>.TryWriteExponentBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<decimal>.TryWriteExponentLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<decimal>.TryWriteSignificandBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<decimal>.TryWriteSignificandLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        public const decimal Zero = default;
        static decimal System.Numerics.INumberBase<decimal>.Zero { get => throw null; }
    }
    public abstract class Delegate : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        public virtual object Clone() => throw null;
        public static System.Delegate Combine(System.Delegate a, System.Delegate b) => throw null;
        public static System.Delegate Combine(params System.Delegate[] delegates) => throw null;
        protected virtual System.Delegate CombineImpl(System.Delegate d) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase) => throw null;
        public static System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) => throw null;
        protected Delegate(object target, string method) => throw null;
        protected Delegate(System.Type target, string method) => throw null;
        public object DynamicInvoke(params object[] args) => throw null;
        protected virtual object DynamicInvokeImpl(object[] args) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public virtual System.Delegate[] GetInvocationList() => throw null;
        protected virtual System.Reflection.MethodInfo GetMethodImpl() => throw null;
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.Reflection.MethodInfo Method { get => throw null; }
        public static bool operator ==(System.Delegate d1, System.Delegate d2) => throw null;
        public static bool operator !=(System.Delegate d1, System.Delegate d2) => throw null;
        public static System.Delegate Remove(System.Delegate source, System.Delegate value) => throw null;
        public static System.Delegate RemoveAll(System.Delegate source, System.Delegate value) => throw null;
        protected virtual System.Delegate RemoveImpl(System.Delegate d) => throw null;
        public object Target { get => throw null; }
    }
    namespace Diagnostics
    {
        namespace CodeAnalysis
        {
            [System.AttributeUsage((System.AttributeTargets)2432, Inherited = false)]
            public sealed class AllowNullAttribute : System.Attribute
            {
                public AllowNullAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class ConstantExpectedAttribute : System.Attribute
            {
                public ConstantExpectedAttribute() => throw null;
                public object Max { get => throw null; set { } }
                public object Min { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)2432, Inherited = false)]
            public sealed class DisallowNullAttribute : System.Attribute
            {
                public DisallowNullAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class DoesNotReturnAttribute : System.Attribute
            {
                public DoesNotReturnAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class DoesNotReturnIfAttribute : System.Attribute
            {
                public DoesNotReturnIfAttribute(bool parameterValue) => throw null;
                public bool ParameterValue { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)28108, Inherited = false)]
            public sealed class DynamicallyAccessedMembersAttribute : System.Attribute
            {
                public DynamicallyAccessedMembersAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes) => throw null;
                public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes MemberTypes { get => throw null; }
            }
            [System.Flags]
            public enum DynamicallyAccessedMemberTypes
            {
                All = -1,
                None = 0,
                PublicParameterlessConstructor = 1,
                PublicConstructors = 3,
                NonPublicConstructors = 4,
                PublicMethods = 8,
                NonPublicMethods = 16,
                PublicFields = 32,
                NonPublicFields = 64,
                PublicNestedTypes = 128,
                NonPublicNestedTypes = 256,
                PublicProperties = 512,
                NonPublicProperties = 1024,
                PublicEvents = 2048,
                NonPublicEvents = 4096,
                Interfaces = 8192,
            }
            [System.AttributeUsage((System.AttributeTargets)352, AllowMultiple = true, Inherited = false)]
            public sealed class DynamicDependencyAttribute : System.Attribute
            {
                public string AssemblyName { get => throw null; }
                public string Condition { get => throw null; set { } }
                public DynamicDependencyAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName) => throw null;
                public DynamicDependencyAttribute(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes memberTypes, System.Type type) => throw null;
                public DynamicDependencyAttribute(string memberSignature) => throw null;
                public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName) => throw null;
                public DynamicDependencyAttribute(string memberSignature, System.Type type) => throw null;
                public string MemberSignature { get => throw null; }
                public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes MemberTypes { get => throw null; }
                public System.Type Type { get => throw null; }
                public string TypeName { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)749, Inherited = false, AllowMultiple = false)]
            public sealed class ExcludeFromCodeCoverageAttribute : System.Attribute
            {
                public ExcludeFromCodeCoverageAttribute() => throw null;
                public string Justification { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)6143, Inherited = false)]
            public sealed class ExperimentalAttribute : System.Attribute
            {
                public ExperimentalAttribute(string diagnosticId) => throw null;
                public string DiagnosticId { get => throw null; }
                public string UrlFormat { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)10624, Inherited = false)]
            public sealed class MaybeNullAttribute : System.Attribute
            {
                public MaybeNullAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class MaybeNullWhenAttribute : System.Attribute
            {
                public MaybeNullWhenAttribute(bool returnValue) => throw null;
                public bool ReturnValue { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)192, Inherited = false, AllowMultiple = true)]
            public sealed class MemberNotNullAttribute : System.Attribute
            {
                public MemberNotNullAttribute(string member) => throw null;
                public MemberNotNullAttribute(params string[] members) => throw null;
                public string[] Members { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)192, Inherited = false, AllowMultiple = true)]
            public sealed class MemberNotNullWhenAttribute : System.Attribute
            {
                public MemberNotNullWhenAttribute(bool returnValue, string member) => throw null;
                public MemberNotNullWhenAttribute(bool returnValue, params string[] members) => throw null;
                public string[] Members { get => throw null; }
                public bool ReturnValue { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)10624, Inherited = false)]
            public sealed class NotNullAttribute : System.Attribute
            {
                public NotNullAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)10368, AllowMultiple = true, Inherited = false)]
            public sealed class NotNullIfNotNullAttribute : System.Attribute
            {
                public NotNullIfNotNullAttribute(string parameterName) => throw null;
                public string ParameterName { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class NotNullWhenAttribute : System.Attribute
            {
                public NotNullWhenAttribute(bool returnValue) => throw null;
                public bool ReturnValue { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)736, Inherited = false, AllowMultiple = false)]
            public sealed class RequiresAssemblyFilesAttribute : System.Attribute
            {
                public RequiresAssemblyFilesAttribute() => throw null;
                public RequiresAssemblyFilesAttribute(string message) => throw null;
                public string Message { get => throw null; }
                public string Url { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)100, Inherited = false)]
            public sealed class RequiresDynamicCodeAttribute : System.Attribute
            {
                public RequiresDynamicCodeAttribute(string message) => throw null;
                public string Message { get => throw null; }
                public string Url { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)100, Inherited = false)]
            public sealed class RequiresUnreferencedCodeAttribute : System.Attribute
            {
                public RequiresUnreferencedCodeAttribute(string message) => throw null;
                public string Message { get => throw null; }
                public string Url { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)32, AllowMultiple = false, Inherited = false)]
            public sealed class SetsRequiredMembersAttribute : System.Attribute
            {
                public SetsRequiredMembersAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2432, AllowMultiple = false, Inherited = false)]
            public sealed class StringSyntaxAttribute : System.Attribute
            {
                public object[] Arguments { get => throw null; }
                public const string CompositeFormat = default;
                public StringSyntaxAttribute(string syntax) => throw null;
                public StringSyntaxAttribute(string syntax, params object[] arguments) => throw null;
                public const string DateOnlyFormat = default;
                public const string DateTimeFormat = default;
                public const string EnumFormat = default;
                public const string GuidFormat = default;
                public const string Json = default;
                public const string NumericFormat = default;
                public const string Regex = default;
                public string Syntax { get => throw null; }
                public const string TimeOnlyFormat = default;
                public const string TimeSpanFormat = default;
                public const string Uri = default;
                public const string Xml = default;
            }
            [System.AttributeUsage((System.AttributeTargets)32767, Inherited = false, AllowMultiple = true)]
            public sealed class SuppressMessageAttribute : System.Attribute
            {
                public string Category { get => throw null; }
                public string CheckId { get => throw null; }
                public SuppressMessageAttribute(string category, string checkId) => throw null;
                public string Justification { get => throw null; set { } }
                public string MessageId { get => throw null; set { } }
                public string Scope { get => throw null; set { } }
                public string Target { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)32767, Inherited = false, AllowMultiple = true)]
            public sealed class UnconditionalSuppressMessageAttribute : System.Attribute
            {
                public string Category { get => throw null; }
                public string CheckId { get => throw null; }
                public UnconditionalSuppressMessageAttribute(string category, string checkId) => throw null;
                public string Justification { get => throw null; set { } }
                public string MessageId { get => throw null; set { } }
                public string Scope { get => throw null; set { } }
                public string Target { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)2240, AllowMultiple = false, Inherited = false)]
            public sealed class UnscopedRefAttribute : System.Attribute
            {
                public UnscopedRefAttribute() => throw null;
            }
        }
        [System.AttributeUsage((System.AttributeTargets)68, AllowMultiple = true)]
        public sealed class ConditionalAttribute : System.Attribute
        {
            public string ConditionString { get => throw null; }
            public ConditionalAttribute(string conditionString) => throw null;
        }
        public static class Debug
        {
            public static void Assert(bool condition) => throw null;
            public static void Assert(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.AssertInterpolatedStringHandler message) => throw null;
            public static void Assert(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.AssertInterpolatedStringHandler message, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.AssertInterpolatedStringHandler detailMessage) => throw null;
            public static void Assert(bool condition, string message) => throw null;
            public static void Assert(bool condition, string message, string detailMessage) => throw null;
            public static void Assert(bool condition, string message, string detailMessageFormat, params object[] args) => throw null;
            [System.Runtime.CompilerServices.InterpolatedStringHandler]
            public struct AssertInterpolatedStringHandler
            {
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                public AssertInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool shouldAppend) => throw null;
            }
            public static bool AutoFlush { get => throw null; set { } }
            public static void Close() => throw null;
            public static void Fail(string message) => throw null;
            public static void Fail(string message, string detailMessage) => throw null;
            public static void Flush() => throw null;
            public static void Indent() => throw null;
            public static int IndentLevel { get => throw null; set { } }
            public static int IndentSize { get => throw null; set { } }
            public static void Print(string message) => throw null;
            public static void Print(string format, params object[] args) => throw null;
            public static void Unindent() => throw null;
            public static void Write(object value) => throw null;
            public static void Write(object value, string category) => throw null;
            public static void Write(string message) => throw null;
            public static void Write(string message, string category) => throw null;
            public static void WriteIf(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message) => throw null;
            public static void WriteIf(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message, string category) => throw null;
            public static void WriteIf(bool condition, object value) => throw null;
            public static void WriteIf(bool condition, object value, string category) => throw null;
            public static void WriteIf(bool condition, string message) => throw null;
            public static void WriteIf(bool condition, string message, string category) => throw null;
            [System.Runtime.CompilerServices.InterpolatedStringHandler]
            public struct WriteIfInterpolatedStringHandler
            {
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool shouldAppend) => throw null;
            }
            public static void WriteLine(object value) => throw null;
            public static void WriteLine(object value, string category) => throw null;
            public static void WriteLine(string message) => throw null;
            public static void WriteLine(string format, params object[] args) => throw null;
            public static void WriteLine(string message, string category) => throw null;
            public static void WriteLineIf(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message) => throw null;
            public static void WriteLineIf(bool condition, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("condition")] ref System.Diagnostics.Debug.WriteIfInterpolatedStringHandler message, string category) => throw null;
            public static void WriteLineIf(bool condition, object value) => throw null;
            public static void WriteLineIf(bool condition, object value, string category) => throw null;
            public static void WriteLineIf(bool condition, string message) => throw null;
            public static void WriteLineIf(bool condition, string message, string category) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)3, AllowMultiple = false)]
        public sealed class DebuggableAttribute : System.Attribute
        {
            public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled) => throw null;
            public DebuggableAttribute(System.Diagnostics.DebuggableAttribute.DebuggingModes modes) => throw null;
            public System.Diagnostics.DebuggableAttribute.DebuggingModes DebuggingFlags { get => throw null; }
            [System.Flags]
            public enum DebuggingModes
            {
                None = 0,
                Default = 1,
                IgnoreSymbolStoreSequencePoints = 2,
                EnableEditAndContinue = 4,
                DisableOptimizations = 256,
            }
            public bool IsJITOptimizerDisabled { get => throw null; }
            public bool IsJITTrackingEnabled { get => throw null; }
        }
        public static class Debugger
        {
            public static void Break() => throw null;
            public static readonly string DefaultCategory;
            public static bool IsAttached { get => throw null; }
            public static bool IsLogging() => throw null;
            public static bool Launch() => throw null;
            public static void Log(int level, string category, string message) => throw null;
            public static void NotifyOfCrossThreadDependency() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)384, AllowMultiple = false)]
        public sealed class DebuggerBrowsableAttribute : System.Attribute
        {
            public DebuggerBrowsableAttribute(System.Diagnostics.DebuggerBrowsableState state) => throw null;
            public System.Diagnostics.DebuggerBrowsableState State { get => throw null; }
        }
        public enum DebuggerBrowsableState
        {
            Never = 0,
            Collapsed = 2,
            RootHidden = 3,
        }
        [System.AttributeUsage((System.AttributeTargets)4509, AllowMultiple = true)]
        public sealed class DebuggerDisplayAttribute : System.Attribute
        {
            public DebuggerDisplayAttribute(string value) => throw null;
            public string Name { get => throw null; set { } }
            public System.Type Target { get => throw null; set { } }
            public string TargetTypeName { get => throw null; set { } }
            public string Type { get => throw null; set { } }
            public string Value { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)224, Inherited = false)]
        public sealed class DebuggerHiddenAttribute : System.Attribute
        {
            public DebuggerHiddenAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)236, Inherited = false)]
        public sealed class DebuggerNonUserCodeAttribute : System.Attribute
        {
            public DebuggerNonUserCodeAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)96, Inherited = false)]
        public sealed class DebuggerStepperBoundaryAttribute : System.Attribute
        {
            public DebuggerStepperBoundaryAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)108, Inherited = false)]
        public sealed class DebuggerStepThroughAttribute : System.Attribute
        {
            public DebuggerStepThroughAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)13, AllowMultiple = true)]
        public sealed class DebuggerTypeProxyAttribute : System.Attribute
        {
            public DebuggerTypeProxyAttribute(string typeName) => throw null;
            public DebuggerTypeProxyAttribute(System.Type type) => throw null;
            public string ProxyTypeName { get => throw null; }
            public System.Type Target { get => throw null; set { } }
            public string TargetTypeName { get => throw null; set { } }
        }
        [System.AttributeUsage((System.AttributeTargets)13, AllowMultiple = true)]
        public sealed class DebuggerVisualizerAttribute : System.Attribute
        {
            public DebuggerVisualizerAttribute(string visualizerTypeName) => throw null;
            public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName) => throw null;
            public DebuggerVisualizerAttribute(string visualizerTypeName, System.Type visualizerObjectSource) => throw null;
            public DebuggerVisualizerAttribute(System.Type visualizer) => throw null;
            public DebuggerVisualizerAttribute(System.Type visualizer, string visualizerObjectSourceTypeName) => throw null;
            public DebuggerVisualizerAttribute(System.Type visualizer, System.Type visualizerObjectSource) => throw null;
            public string Description { get => throw null; set { } }
            public System.Type Target { get => throw null; set { } }
            public string TargetTypeName { get => throw null; set { } }
            public string VisualizerObjectSourceTypeName { get => throw null; }
            public string VisualizerTypeName { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)108, Inherited = false)]
        public sealed class StackTraceHiddenAttribute : System.Attribute
        {
            public StackTraceHiddenAttribute() => throw null;
        }
        public class Stopwatch
        {
            public Stopwatch() => throw null;
            public System.TimeSpan Elapsed { get => throw null; }
            public long ElapsedMilliseconds { get => throw null; }
            public long ElapsedTicks { get => throw null; }
            public static readonly long Frequency;
            public static System.TimeSpan GetElapsedTime(long startingTimestamp) => throw null;
            public static System.TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp) => throw null;
            public static long GetTimestamp() => throw null;
            public static readonly bool IsHighResolution;
            public bool IsRunning { get => throw null; }
            public void Reset() => throw null;
            public void Restart() => throw null;
            public void Start() => throw null;
            public static System.Diagnostics.Stopwatch StartNew() => throw null;
            public void Stop() => throw null;
            public override string ToString() => throw null;
        }
        public sealed class UnreachableException : System.Exception
        {
            public UnreachableException() => throw null;
            public UnreachableException(string message) => throw null;
            public UnreachableException(string message, System.Exception innerException) => throw null;
        }
    }
    public class DivideByZeroException : System.ArithmeticException
    {
        public DivideByZeroException() => throw null;
        protected DivideByZeroException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public DivideByZeroException(string message) => throw null;
        public DivideByZeroException(string message, System.Exception innerException) => throw null;
    }
    public struct Double : System.Numerics.IAdditionOperators<double, double, double>, System.Numerics.IAdditiveIdentity<double, double>, System.Numerics.IBinaryFloatingPointIeee754<double>, System.Numerics.IBinaryNumber<double>, System.Numerics.IBitwiseOperators<double, double, double>, System.IComparable, System.IComparable<double>, System.Numerics.IComparisonOperators<double, double, bool>, System.IConvertible, System.Numerics.IDecrementOperators<double>, System.Numerics.IDivisionOperators<double, double, double>, System.Numerics.IEqualityOperators<double, double, bool>, System.IEquatable<double>, System.Numerics.IExponentialFunctions<double>, System.Numerics.IFloatingPoint<double>, System.Numerics.IFloatingPointConstants<double>, System.Numerics.IFloatingPointIeee754<double>, System.IFormattable, System.Numerics.IHyperbolicFunctions<double>, System.Numerics.IIncrementOperators<double>, System.Numerics.ILogarithmicFunctions<double>, System.Numerics.IMinMaxValue<double>, System.Numerics.IModulusOperators<double, double, double>, System.Numerics.IMultiplicativeIdentity<double, double>, System.Numerics.IMultiplyOperators<double, double, double>, System.Numerics.INumber<double>, System.Numerics.INumberBase<double>, System.IParsable<double>, System.Numerics.IPowerFunctions<double>, System.Numerics.IRootFunctions<double>, System.Numerics.ISignedNumber<double>, System.ISpanFormattable, System.ISpanParsable<double>, System.Numerics.ISubtractionOperators<double, double, double>, System.Numerics.ITrigonometricFunctions<double>, System.Numerics.IUnaryNegationOperators<double, double>, System.Numerics.IUnaryPlusOperators<double, double>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<double>
    {
        static double System.Numerics.INumberBase<double>.Abs(double value) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.Acos(double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Acosh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.AcosPi(double x) => throw null;
        static double System.Numerics.IAdditiveIdentity<double, double>.AdditiveIdentity { get => throw null; }
        static double System.Numerics.IBinaryNumber<double>.AllBitsSet { get => throw null; }
        static double System.Numerics.ITrigonometricFunctions<double>.Asin(double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Asinh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.AsinPi(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.Atan(double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.Atan2(double y, double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.Atan2Pi(double y, double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Atanh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.AtanPi(double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.BitDecrement(double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.BitIncrement(double x) => throw null;
        static double System.Numerics.IRootFunctions<double>.Cbrt(double x) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Ceiling(double x) => throw null;
        static double System.Numerics.INumber<double>.Clamp(double value, double min, double max) => throw null;
        public int CompareTo(double value) => throw null;
        public int CompareTo(object value) => throw null;
        static double System.Numerics.INumber<double>.CopySign(double value, double sign) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.Cos(double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Cosh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.CosPi(double x) => throw null;
        static double System.Numerics.INumberBase<double>.CreateChecked<TOther>(TOther value) => throw null;
        static double System.Numerics.INumberBase<double>.CreateSaturating<TOther>(TOther value) => throw null;
        static double System.Numerics.INumberBase<double>.CreateTruncating<TOther>(TOther value) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.DegreesToRadians(double degrees) => throw null;
        public const double E = default;
        static double System.Numerics.IFloatingPointConstants<double>.E { get => throw null; }
        public const double Epsilon = default;
        static double System.Numerics.IFloatingPointIeee754<double>.Epsilon { get => throw null; }
        public bool Equals(double obj) => throw null;
        public override bool Equals(object obj) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.Exp(double x) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.Exp10(double x) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.Exp10M1(double x) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.Exp2(double x) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.Exp2M1(double x) => throw null;
        static double System.Numerics.IExponentialFunctions<double>.ExpM1(double x) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Floor(double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.FusedMultiplyAdd(double left, double right, double addend) => throw null;
        int System.Numerics.IFloatingPoint<double>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<double>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static double System.Numerics.IRootFunctions<double>.Hypot(double x, double y) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.Ieee754Remainder(double left, double right) => throw null;
        static int System.Numerics.IFloatingPointIeee754<double>.ILogB(double x) => throw null;
        static bool System.Numerics.INumberBase<double>.IsCanonical(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsComplexNumber(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsEvenInteger(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsFinite(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsImaginaryNumber(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsInfinity(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsInteger(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsNaN(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsNegative(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsNegativeInfinity(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsNormal(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsOddInteger(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsPositive(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsPositiveInfinity(double d) => throw null;
        static bool System.Numerics.IBinaryNumber<double>.IsPow2(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsRealNumber(double value) => throw null;
        static bool System.Numerics.INumberBase<double>.IsSubnormal(double d) => throw null;
        static bool System.Numerics.INumberBase<double>.IsZero(double value) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.Lerp(double value1, double value2, double amount) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log(double x) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log(double x, double newBase) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log10(double x) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log10P1(double x) => throw null;
        static double System.Numerics.IBinaryNumber<double>.Log2(double value) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log2(double value) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.Log2P1(double x) => throw null;
        static double System.Numerics.ILogarithmicFunctions<double>.LogP1(double x) => throw null;
        static double System.Numerics.INumber<double>.Max(double x, double y) => throw null;
        static double System.Numerics.INumberBase<double>.MaxMagnitude(double x, double y) => throw null;
        static double System.Numerics.INumberBase<double>.MaxMagnitudeNumber(double x, double y) => throw null;
        static double System.Numerics.INumber<double>.MaxNumber(double x, double y) => throw null;
        public const double MaxValue = default;
        static double System.Numerics.IMinMaxValue<double>.MaxValue { get => throw null; }
        static double System.Numerics.INumber<double>.Min(double x, double y) => throw null;
        static double System.Numerics.INumberBase<double>.MinMagnitude(double x, double y) => throw null;
        static double System.Numerics.INumberBase<double>.MinMagnitudeNumber(double x, double y) => throw null;
        static double System.Numerics.INumber<double>.MinNumber(double x, double y) => throw null;
        public const double MinValue = default;
        static double System.Numerics.IMinMaxValue<double>.MinValue { get => throw null; }
        static double System.Numerics.IMultiplicativeIdentity<double, double>.MultiplicativeIdentity { get => throw null; }
        public const double NaN = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NaN { get => throw null; }
        public const double NegativeInfinity = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NegativeInfinity { get => throw null; }
        static double System.Numerics.ISignedNumber<double>.NegativeOne { get => throw null; }
        public const double NegativeZero = default;
        static double System.Numerics.IFloatingPointIeee754<double>.NegativeZero { get => throw null; }
        static double System.Numerics.INumberBase<double>.One { get => throw null; }
        static double System.Numerics.IAdditionOperators<double, double, double>.operator +(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator &(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator |(double left, double right) => throw null;
        static double System.Numerics.IDecrementOperators<double>.operator --(double value) => throw null;
        static double System.Numerics.IDivisionOperators<double, double, double>.operator /(double left, double right) => throw null;
        static bool System.Numerics.IEqualityOperators<double, double, bool>.operator ==(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator ^(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator >(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator >=(double left, double right) => throw null;
        static double System.Numerics.IIncrementOperators<double>.operator ++(double value) => throw null;
        static bool System.Numerics.IEqualityOperators<double, double, bool>.operator !=(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator <(double left, double right) => throw null;
        static bool System.Numerics.IComparisonOperators<double, double, bool>.operator <=(double left, double right) => throw null;
        static double System.Numerics.IModulusOperators<double, double, double>.operator %(double left, double right) => throw null;
        static double System.Numerics.IMultiplyOperators<double, double, double>.operator *(double left, double right) => throw null;
        static double System.Numerics.IBitwiseOperators<double, double, double>.operator ~(double value) => throw null;
        static double System.Numerics.ISubtractionOperators<double, double, double>.operator -(double left, double right) => throw null;
        static double System.Numerics.IUnaryNegationOperators<double, double>.operator -(double value) => throw null;
        static double System.Numerics.IUnaryPlusOperators<double, double>.operator +(double value) => throw null;
        static double System.Numerics.INumberBase<double>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static double System.IUtf8SpanParsable<double>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static double System.Numerics.INumberBase<double>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static double System.ISpanParsable<double>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static double Parse(string s) => throw null;
        public static double Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static double System.Numerics.INumberBase<double>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static double System.IParsable<double>.Parse(string s, System.IFormatProvider provider) => throw null;
        public const double Pi = default;
        static double System.Numerics.IFloatingPointConstants<double>.Pi { get => throw null; }
        public const double PositiveInfinity = default;
        static double System.Numerics.IFloatingPointIeee754<double>.PositiveInfinity { get => throw null; }
        static double System.Numerics.IPowerFunctions<double>.Pow(double x, double y) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.RadiansToDegrees(double radians) => throw null;
        static int System.Numerics.INumberBase<double>.Radix { get => throw null; }
        static double System.Numerics.IFloatingPointIeee754<double>.ReciprocalEstimate(double x) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.ReciprocalSqrtEstimate(double x) => throw null;
        static double System.Numerics.IRootFunctions<double>.RootN(double x, int n) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Round(double x) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Round(double x, int digits) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Round(double x, int digits, System.MidpointRounding mode) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Round(double x, System.MidpointRounding mode) => throw null;
        static double System.Numerics.IFloatingPointIeee754<double>.ScaleB(double x, int n) => throw null;
        static int System.Numerics.INumber<double>.Sign(double value) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.Sin(double x) => throw null;
        static (double Sin, double Cos) System.Numerics.ITrigonometricFunctions<double>.SinCos(double x) => throw null;
        static (double SinPi, double CosPi) System.Numerics.ITrigonometricFunctions<double>.SinCosPi(double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Sinh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.SinPi(double x) => throw null;
        static double System.Numerics.IRootFunctions<double>.Sqrt(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.Tan(double x) => throw null;
        static double System.Numerics.IHyperbolicFunctions<double>.Tanh(double x) => throw null;
        static double System.Numerics.ITrigonometricFunctions<double>.TanPi(double x) => throw null;
        public const double Tau = default;
        static double System.Numerics.IFloatingPointConstants<double>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static double System.Numerics.IFloatingPoint<double>.Truncate(double x) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromChecked<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromSaturating<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertFromTruncating<TOther>(TOther value, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToChecked<TOther>(double value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToSaturating<TOther>(double value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryConvertToTruncating<TOther>(double value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) => throw null;
        static bool System.IUtf8SpanParsable<double>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) => throw null;
        static bool System.ISpanParsable<double>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out double result) => throw null;
        public static bool TryParse(string s, out double result) => throw null;
        static bool System.Numerics.INumberBase<double>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) => throw null;
        static bool System.IParsable<double>.TryParse(string s, System.IFormatProvider provider, out double result) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteExponentBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteExponentLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteSignificandBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<double>.TryWriteSignificandLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static double System.Numerics.INumberBase<double>.Zero { get => throw null; }
    }
    public class DuplicateWaitObjectException : System.ArgumentException
    {
        public DuplicateWaitObjectException() => throw null;
        protected DuplicateWaitObjectException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public DuplicateWaitObjectException(string parameterName) => throw null;
        public DuplicateWaitObjectException(string message, System.Exception innerException) => throw null;
        public DuplicateWaitObjectException(string parameterName, string message) => throw null;
    }
    public class EntryPointNotFoundException : System.TypeLoadException
    {
        public EntryPointNotFoundException() => throw null;
        protected EntryPointNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public EntryPointNotFoundException(string message) => throw null;
        public EntryPointNotFoundException(string message, System.Exception inner) => throw null;
    }
    public abstract class Enum : System.IComparable, System.IConvertible, System.IFormattable, System.ISpanFormattable
    {
        public int CompareTo(object target) => throw null;
        protected Enum() => throw null;
        public override bool Equals(object obj) => throw null;
        public static string Format(System.Type enumType, object value, string format) => throw null;
        public override int GetHashCode() => throw null;
        public static string GetName(System.Type enumType, object value) => throw null;
        public static string GetName<TEnum>(TEnum value) where TEnum : System.Enum => throw null;
        public static string[] GetNames(System.Type enumType) => throw null;
        public static string[] GetNames<TEnum>() where TEnum : System.Enum => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public static System.Type GetUnderlyingType(System.Type enumType) => throw null;
        public static System.Array GetValues(System.Type enumType) => throw null;
        public static TEnum[] GetValues<TEnum>() where TEnum : System.Enum => throw null;
        public static System.Array GetValuesAsUnderlyingType(System.Type enumType) => throw null;
        public static System.Array GetValuesAsUnderlyingType<TEnum>() where TEnum : System.Enum => throw null;
        public bool HasFlag(System.Enum flag) => throw null;
        public static bool IsDefined(System.Type enumType, object value) => throw null;
        public static bool IsDefined<TEnum>(TEnum value) where TEnum : System.Enum => throw null;
        public static object Parse(System.Type enumType, System.ReadOnlySpan<char> value) => throw null;
        public static object Parse(System.Type enumType, System.ReadOnlySpan<char> value, bool ignoreCase) => throw null;
        public static object Parse(System.Type enumType, string value) => throw null;
        public static object Parse(System.Type enumType, string value, bool ignoreCase) => throw null;
        public static TEnum Parse<TEnum>(System.ReadOnlySpan<char> value) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(System.ReadOnlySpan<char> value, bool ignoreCase) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(string value) where TEnum : struct => throw null;
        public static TEnum Parse<TEnum>(string value, bool ignoreCase) where TEnum : struct => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public static object ToObject(System.Type enumType, byte value) => throw null;
        public static object ToObject(System.Type enumType, short value) => throw null;
        public static object ToObject(System.Type enumType, int value) => throw null;
        public static object ToObject(System.Type enumType, long value) => throw null;
        public static object ToObject(System.Type enumType, object value) => throw null;
        public static object ToObject(System.Type enumType, sbyte value) => throw null;
        public static object ToObject(System.Type enumType, ushort value) => throw null;
        public static object ToObject(System.Type enumType, uint value) => throw null;
        public static object ToObject(System.Type enumType, ulong value) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public static bool TryFormat<TEnum>(TEnum value, System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>)) where TEnum : struct => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        public static bool TryParse(System.Type enumType, System.ReadOnlySpan<char> value, bool ignoreCase, out object result) => throw null;
        public static bool TryParse(System.Type enumType, System.ReadOnlySpan<char> value, out object result) => throw null;
        public static bool TryParse(System.Type enumType, string value, bool ignoreCase, out object result) => throw null;
        public static bool TryParse(System.Type enumType, string value, out object result) => throw null;
        public static bool TryParse<TEnum>(System.ReadOnlySpan<char> value, bool ignoreCase, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(System.ReadOnlySpan<char> value, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct => throw null;
        public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct => throw null;
    }
    public static class Environment
    {
        public static string CommandLine { get => throw null; }
        public static string CurrentDirectory { get => throw null; set { } }
        public static int CurrentManagedThreadId { get => throw null; }
        public static void Exit(int exitCode) => throw null;
        public static int ExitCode { get => throw null; set { } }
        public static string ExpandEnvironmentVariables(string name) => throw null;
        public static void FailFast(string message) => throw null;
        public static void FailFast(string message, System.Exception exception) => throw null;
        public static string[] GetCommandLineArgs() => throw null;
        public static string GetEnvironmentVariable(string variable) => throw null;
        public static string GetEnvironmentVariable(string variable, System.EnvironmentVariableTarget target) => throw null;
        public static System.Collections.IDictionary GetEnvironmentVariables() => throw null;
        public static System.Collections.IDictionary GetEnvironmentVariables(System.EnvironmentVariableTarget target) => throw null;
        public static string GetFolderPath(System.Environment.SpecialFolder folder) => throw null;
        public static string GetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option) => throw null;
        public static string[] GetLogicalDrives() => throw null;
        public static bool HasShutdownStarted { get => throw null; }
        public static bool Is64BitOperatingSystem { get => throw null; }
        public static bool Is64BitProcess { get => throw null; }
        public static bool IsPrivilegedProcess { get => throw null; }
        public static string MachineName { get => throw null; }
        public static string NewLine { get => throw null; }
        public static System.OperatingSystem OSVersion { get => throw null; }
        public static int ProcessId { get => throw null; }
        public static int ProcessorCount { get => throw null; }
        public static string ProcessPath { get => throw null; }
        public static void SetEnvironmentVariable(string variable, string value) => throw null;
        public static void SetEnvironmentVariable(string variable, string value, System.EnvironmentVariableTarget target) => throw null;
        public enum SpecialFolder
        {
            Desktop = 0,
            Programs = 2,
            MyDocuments = 5,
            Personal = 5,
            Favorites = 6,
            Startup = 7,
            Recent = 8,
            SendTo = 9,
            StartMenu = 11,
            MyMusic = 13,
            MyVideos = 14,
            DesktopDirectory = 16,
            MyComputer = 17,
            NetworkShortcuts = 19,
            Fonts = 20,
            Templates = 21,
            CommonStartMenu = 22,
            CommonPrograms = 23,
            CommonStartup = 24,
            CommonDesktopDirectory = 25,
            ApplicationData = 26,
            PrinterShortcuts = 27,
            LocalApplicationData = 28,
            InternetCache = 32,
            Cookies = 33,
            History = 34,
            CommonApplicationData = 35,
            Windows = 36,
            System = 37,
            ProgramFiles = 38,
            MyPictures = 39,
            UserProfile = 40,
            SystemX86 = 41,
            ProgramFilesX86 = 42,
            CommonProgramFiles = 43,
            CommonProgramFilesX86 = 44,
            CommonTemplates = 45,
            CommonDocuments = 46,
            CommonAdminTools = 47,
            AdminTools = 48,
            CommonMusic = 53,
            CommonPictures = 54,
            CommonVideos = 55,
            Resources = 56,
            LocalizedResources = 57,
            CommonOemLinks = 58,
            CDBurning = 59,
        }
        public enum SpecialFolderOption
        {
            None = 0,
            DoNotVerify = 16384,
            Create = 32768,
        }
        public static string StackTrace { get => throw null; }
        public static string SystemDirectory { get => throw null; }
        public static int SystemPageSize { get => throw null; }
        public static int TickCount { get => throw null; }
        public static long TickCount64 { get => throw null; }
        public static string UserDomainName { get => throw null; }
        public static bool UserInteractive { get => throw null; }
        public static string UserName { get => throw null; }
        public static System.Version Version { get => throw null; }
        public static long WorkingSet { get => throw null; }
    }
    public enum EnvironmentVariableTarget
    {
        Process = 0,
        User = 1,
        Machine = 2,
    }
    public class EventArgs
    {
        public EventArgs() => throw null;
        public static readonly System.EventArgs Empty;
    }
    public delegate void EventHandler(object sender, System.EventArgs e);
    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);
    public class Exception : System.Runtime.Serialization.ISerializable
    {
        public Exception() => throw null;
        protected Exception(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public Exception(string message) => throw null;
        public Exception(string message, System.Exception innerException) => throw null;
        public virtual System.Collections.IDictionary Data { get => throw null; }
        public virtual System.Exception GetBaseException() => throw null;
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public System.Type GetType() => throw null;
        public virtual string HelpLink { get => throw null; set { } }
        public int HResult { get => throw null; set { } }
        public System.Exception InnerException { get => throw null; }
        public virtual string Message { get => throw null; }
        protected event System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> SerializeObjectState;
        public virtual string Source { get => throw null; set { } }
        public virtual string StackTrace { get => throw null; }
        public System.Reflection.MethodBase TargetSite { get => throw null; }
        public override string ToString() => throw null;
    }
    public sealed class ExecutionEngineException : System.SystemException
    {
        public ExecutionEngineException() => throw null;
        public ExecutionEngineException(string message) => throw null;
        public ExecutionEngineException(string message, System.Exception innerException) => throw null;
    }
    public class FieldAccessException : System.MemberAccessException
    {
        public FieldAccessException() => throw null;
        protected FieldAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public FieldAccessException(string message) => throw null;
        public FieldAccessException(string message, System.Exception inner) => throw null;
    }
    public class FileStyleUriParser : System.UriParser
    {
        public FileStyleUriParser() => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)16, Inherited = false)]
    public class FlagsAttribute : System.Attribute
    {
        public FlagsAttribute() => throw null;
    }
    public class FormatException : System.SystemException
    {
        public FormatException() => throw null;
        protected FormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public FormatException(string message) => throw null;
        public FormatException(string message, System.Exception innerException) => throw null;
    }
    public abstract class FormattableString : System.IFormattable
    {
        public abstract int ArgumentCount { get; }
        protected FormattableString() => throw null;
        public static string CurrentCulture(System.FormattableString formattable) => throw null;
        public abstract string Format { get; }
        public abstract object GetArgument(int index);
        public abstract object[] GetArguments();
        public static string Invariant(System.FormattableString formattable) => throw null;
        string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider) => throw null;
        public override string ToString() => throw null;
        public abstract string ToString(System.IFormatProvider formatProvider);
    }
    public class FtpStyleUriParser : System.UriParser
    {
        public FtpStyleUriParser() => throw null;
    }
    public delegate TResult Func<TResult>();
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public delegate TResult Func<T, TResult>(T arg);
    public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
    public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);
    public delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public static class GC
    {
        public static void AddMemoryPressure(long bytesAllocated) => throw null;
        public static T[] AllocateArray<T>(int length, bool pinned = default(bool)) => throw null;
        public static T[] AllocateUninitializedArray<T>(int length, bool pinned = default(bool)) => throw null;
        public static void CancelFullGCNotification() => throw null;
        public static void Collect() => throw null;
        public static void Collect(int generation) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode, bool blocking) => throw null;
        public static void Collect(int generation, System.GCCollectionMode mode, bool blocking, bool compacting) => throw null;
        public static int CollectionCount(int generation) => throw null;
        public static void EndNoGCRegion() => throw null;
        public static long GetAllocatedBytesForCurrentThread() => throw null;
        public static System.Collections.Generic.IReadOnlyDictionary<string, object> GetConfigurationVariables() => throw null;
        public static System.GCMemoryInfo GetGCMemoryInfo() => throw null;
        public static System.GCMemoryInfo GetGCMemoryInfo(System.GCKind kind) => throw null;
        public static int GetGeneration(object obj) => throw null;
        public static int GetGeneration(System.WeakReference wo) => throw null;
        public static long GetTotalAllocatedBytes(bool precise = default(bool)) => throw null;
        public static long GetTotalMemory(bool forceFullCollection) => throw null;
        public static System.TimeSpan GetTotalPauseDuration() => throw null;
        public static void KeepAlive(object obj) => throw null;
        public static int MaxGeneration { get => throw null; }
        public static void RefreshMemoryLimit() => throw null;
        public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold) => throw null;
        public static void RegisterNoGCRegionCallback(long totalSize, System.Action callback) => throw null;
        public static void RemoveMemoryPressure(long bytesAllocated) => throw null;
        public static void ReRegisterForFinalize(object obj) => throw null;
        public static void SuppressFinalize(object obj) => throw null;
        public static bool TryStartNoGCRegion(long totalSize) => throw null;
        public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC) => throw null;
        public static bool TryStartNoGCRegion(long totalSize, long lohSize) => throw null;
        public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC) => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach() => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCApproach(System.TimeSpan timeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete() => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout) => throw null;
        public static System.GCNotificationStatus WaitForFullGCComplete(System.TimeSpan timeout) => throw null;
        public static void WaitForPendingFinalizers() => throw null;
    }
    public enum GCCollectionMode
    {
        Default = 0,
        Forced = 1,
        Optimized = 2,
        Aggressive = 3,
    }
    public struct GCGenerationInfo
    {
        public long FragmentationAfterBytes { get => throw null; }
        public long FragmentationBeforeBytes { get => throw null; }
        public long SizeAfterBytes { get => throw null; }
        public long SizeBeforeBytes { get => throw null; }
    }
    public enum GCKind
    {
        Any = 0,
        Ephemeral = 1,
        FullBlocking = 2,
        Background = 3,
    }
    public struct GCMemoryInfo
    {
        public bool Compacted { get => throw null; }
        public bool Concurrent { get => throw null; }
        public long FinalizationPendingCount { get => throw null; }
        public long FragmentedBytes { get => throw null; }
        public int Generation { get => throw null; }
        public System.ReadOnlySpan<System.GCGenerationInfo> GenerationInfo { get => throw null; }
        public long HeapSizeBytes { get => throw null; }
        public long HighMemoryLoadThresholdBytes { get => throw null; }
        public long Index { get => throw null; }
        public long MemoryLoadBytes { get => throw null; }
        public System.ReadOnlySpan<System.TimeSpan> PauseDurations { get => throw null; }
        public double PauseTimePercentage { get => throw null; }
        public long PinnedObjectsCount { get => throw null; }
        public long PromotedBytes { get => throw null; }
        public long TotalAvailableMemoryBytes { get => throw null; }
        public long TotalCommittedBytes { get => throw null; }
    }
    public enum GCNotificationStatus
    {
        Succeeded = 0,
        Failed = 1,
        Canceled = 2,
        Timeout = 3,
        NotApplicable = 4,
    }
    public class GenericUriParser : System.UriParser
    {
        public GenericUriParser(System.GenericUriParserOptions options) => throw null;
    }
    [System.Flags]
    public enum GenericUriParserOptions
    {
        Default = 0,
        GenericAuthority = 1,
        AllowEmptyAuthority = 2,
        NoUserInfo = 4,
        NoPort = 8,
        NoQuery = 16,
        NoFragment = 32,
        DontConvertPathBackslashes = 64,
        DontCompressPath = 128,
        DontUnescapePathDotsAndSlashes = 256,
        Idn = 512,
        IriParsing = 1024,
    }
    namespace Globalization
    {
        public abstract class Calendar : System.ICloneable
        {
            public virtual System.DateTime AddDays(System.DateTime time, int days) => throw null;
            public virtual System.DateTime AddHours(System.DateTime time, int hours) => throw null;
            public virtual System.DateTime AddMilliseconds(System.DateTime time, double milliseconds) => throw null;
            public virtual System.DateTime AddMinutes(System.DateTime time, int minutes) => throw null;
            public abstract System.DateTime AddMonths(System.DateTime time, int months);
            public virtual System.DateTime AddSeconds(System.DateTime time, int seconds) => throw null;
            public virtual System.DateTime AddWeeks(System.DateTime time, int weeks) => throw null;
            public abstract System.DateTime AddYears(System.DateTime time, int years);
            public virtual System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public virtual object Clone() => throw null;
            protected Calendar() => throw null;
            public const int CurrentEra = 0;
            protected virtual int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public abstract int[] Eras { get; }
            public abstract int GetDayOfMonth(System.DateTime time);
            public abstract System.DayOfWeek GetDayOfWeek(System.DateTime time);
            public abstract int GetDayOfYear(System.DateTime time);
            public virtual int GetDaysInMonth(int year, int month) => throw null;
            public abstract int GetDaysInMonth(int year, int month, int era);
            public virtual int GetDaysInYear(int year) => throw null;
            public abstract int GetDaysInYear(int year, int era);
            public abstract int GetEra(System.DateTime time);
            public virtual int GetHour(System.DateTime time) => throw null;
            public virtual int GetLeapMonth(int year) => throw null;
            public virtual int GetLeapMonth(int year, int era) => throw null;
            public virtual double GetMilliseconds(System.DateTime time) => throw null;
            public virtual int GetMinute(System.DateTime time) => throw null;
            public abstract int GetMonth(System.DateTime time);
            public virtual int GetMonthsInYear(int year) => throw null;
            public abstract int GetMonthsInYear(int year, int era);
            public virtual int GetSecond(System.DateTime time) => throw null;
            public virtual int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public abstract int GetYear(System.DateTime time);
            public virtual bool IsLeapDay(int year, int month, int day) => throw null;
            public abstract bool IsLeapDay(int year, int month, int day, int era);
            public virtual bool IsLeapMonth(int year, int month) => throw null;
            public abstract bool IsLeapMonth(int year, int month, int era);
            public virtual bool IsLeapYear(int year) => throw null;
            public abstract bool IsLeapYear(int year, int era);
            public bool IsReadOnly { get => throw null; }
            public virtual System.DateTime MaxSupportedDateTime { get => throw null; }
            public virtual System.DateTime MinSupportedDateTime { get => throw null; }
            public static System.Globalization.Calendar ReadOnly(System.Globalization.Calendar calendar) => throw null;
            public virtual System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) => throw null;
            public abstract System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            public virtual int ToFourDigitYear(int year) => throw null;
            public virtual int TwoDigitYearMax { get => throw null; set { } }
        }
        public enum CalendarAlgorithmType
        {
            Unknown = 0,
            SolarCalendar = 1,
            LunarCalendar = 2,
            LunisolarCalendar = 3,
        }
        public enum CalendarWeekRule
        {
            FirstDay = 0,
            FirstFullWeek = 1,
            FirstFourDayWeek = 2,
        }
        public static class CharUnicodeInfo
        {
            public static int GetDecimalDigitValue(char ch) => throw null;
            public static int GetDecimalDigitValue(string s, int index) => throw null;
            public static int GetDigitValue(char ch) => throw null;
            public static int GetDigitValue(string s, int index) => throw null;
            public static double GetNumericValue(char ch) => throw null;
            public static double GetNumericValue(string s, int index) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(char ch) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(int codePoint) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index) => throw null;
        }
        public class ChineseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            public const int ChineseEra = 1;
            public ChineseLunisolarCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }
        public sealed class CompareInfo : System.Runtime.Serialization.IDeserializationCallback
        {
            public int Compare(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2) => throw null;
            public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options) => throw null;
            public int Compare(string string1, int offset1, string string2, int offset2) => throw null;
            public int Compare(string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options) => throw null;
            public int Compare(string string1, string string2) => throw null;
            public int Compare(string string1, string string2, System.Globalization.CompareOptions options) => throw null;
            public override bool Equals(object value) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(int culture) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(int culture, System.Reflection.Assembly assembly) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(string name) => throw null;
            public static System.Globalization.CompareInfo GetCompareInfo(string name, System.Reflection.Assembly assembly) => throw null;
            public override int GetHashCode() => throw null;
            public int GetHashCode(System.ReadOnlySpan<char> source, System.Globalization.CompareOptions options) => throw null;
            public int GetHashCode(string source, System.Globalization.CompareOptions options) => throw null;
            public int GetSortKey(System.ReadOnlySpan<char> source, System.Span<byte> destination, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public System.Globalization.SortKey GetSortKey(string source) => throw null;
            public System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options) => throw null;
            public int GetSortKeyLength(System.ReadOnlySpan<char> source, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public int IndexOf(System.ReadOnlySpan<char> source, System.Text.Rune value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int IndexOf(string source, char value) => throw null;
            public int IndexOf(string source, char value, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, char value, int startIndex) => throw null;
            public int IndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, char value, int startIndex, int count) => throw null;
            public int IndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value) => throw null;
            public int IndexOf(string source, string value, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value, int startIndex) => throw null;
            public int IndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int IndexOf(string source, string value, int startIndex, int count) => throw null;
            public int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public bool IsPrefix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public bool IsPrefix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public bool IsPrefix(string source, string prefix) => throw null;
            public bool IsPrefix(string source, string prefix, System.Globalization.CompareOptions options) => throw null;
            public static bool IsSortable(char ch) => throw null;
            public static bool IsSortable(System.ReadOnlySpan<char> text) => throw null;
            public static bool IsSortable(string text) => throw null;
            public static bool IsSortable(System.Text.Rune value) => throw null;
            public bool IsSuffix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public bool IsSuffix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public bool IsSuffix(string source, string suffix) => throw null;
            public bool IsSuffix(string source, string suffix, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int LastIndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options, out int matchLength) => throw null;
            public int LastIndexOf(System.ReadOnlySpan<char> source, System.Text.Rune value, System.Globalization.CompareOptions options = default(System.Globalization.CompareOptions)) => throw null;
            public int LastIndexOf(string source, char value) => throw null;
            public int LastIndexOf(string source, char value, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, char value, int startIndex) => throw null;
            public int LastIndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, char value, int startIndex, int count) => throw null;
            public int LastIndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value) => throw null;
            public int LastIndexOf(string source, string value, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value, int startIndex) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, int count) => throw null;
            public int LastIndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options) => throw null;
            public int LCID { get => throw null; }
            public string Name { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public override string ToString() => throw null;
            public System.Globalization.SortVersion Version { get => throw null; }
        }
        [System.Flags]
        public enum CompareOptions
        {
            None = 0,
            IgnoreCase = 1,
            IgnoreNonSpace = 2,
            IgnoreSymbols = 4,
            IgnoreKanaType = 8,
            IgnoreWidth = 16,
            OrdinalIgnoreCase = 268435456,
            StringSort = 536870912,
            Ordinal = 1073741824,
        }
        public class CultureInfo : System.ICloneable, System.IFormatProvider
        {
            public virtual System.Globalization.Calendar Calendar { get => throw null; }
            public void ClearCachedData() => throw null;
            public virtual object Clone() => throw null;
            public virtual System.Globalization.CompareInfo CompareInfo { get => throw null; }
            public static System.Globalization.CultureInfo CreateSpecificCulture(string name) => throw null;
            public CultureInfo(int culture) => throw null;
            public CultureInfo(int culture, bool useUserOverride) => throw null;
            public CultureInfo(string name) => throw null;
            public CultureInfo(string name, bool useUserOverride) => throw null;
            public System.Globalization.CultureTypes CultureTypes { get => throw null; }
            public static System.Globalization.CultureInfo CurrentCulture { get => throw null; set { } }
            public static System.Globalization.CultureInfo CurrentUICulture { get => throw null; set { } }
            public virtual System.Globalization.DateTimeFormatInfo DateTimeFormat { get => throw null; set { } }
            public static System.Globalization.CultureInfo DefaultThreadCurrentCulture { get => throw null; set { } }
            public static System.Globalization.CultureInfo DefaultThreadCurrentUICulture { get => throw null; set { } }
            public virtual string DisplayName { get => throw null; }
            public virtual string EnglishName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public System.Globalization.CultureInfo GetConsoleFallbackUICulture() => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(int culture) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name, bool predefinedOnly) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfo(string name, string altName) => throw null;
            public static System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag(string name) => throw null;
            public static System.Globalization.CultureInfo[] GetCultures(System.Globalization.CultureTypes types) => throw null;
            public virtual object GetFormat(System.Type formatType) => throw null;
            public override int GetHashCode() => throw null;
            public string IetfLanguageTag { get => throw null; }
            public static System.Globalization.CultureInfo InstalledUICulture { get => throw null; }
            public static System.Globalization.CultureInfo InvariantCulture { get => throw null; }
            public virtual bool IsNeutralCulture { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public virtual int KeyboardLayoutId { get => throw null; }
            public virtual int LCID { get => throw null; }
            public virtual string Name { get => throw null; }
            public virtual string NativeName { get => throw null; }
            public virtual System.Globalization.NumberFormatInfo NumberFormat { get => throw null; set { } }
            public virtual System.Globalization.Calendar[] OptionalCalendars { get => throw null; }
            public virtual System.Globalization.CultureInfo Parent { get => throw null; }
            public static System.Globalization.CultureInfo ReadOnly(System.Globalization.CultureInfo ci) => throw null;
            public virtual System.Globalization.TextInfo TextInfo { get => throw null; }
            public virtual string ThreeLetterISOLanguageName { get => throw null; }
            public virtual string ThreeLetterWindowsLanguageName { get => throw null; }
            public override string ToString() => throw null;
            public virtual string TwoLetterISOLanguageName { get => throw null; }
            public bool UseUserOverride { get => throw null; }
        }
        public class CultureNotFoundException : System.ArgumentException
        {
            public CultureNotFoundException() => throw null;
            protected CultureNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public CultureNotFoundException(string message) => throw null;
            public CultureNotFoundException(string message, System.Exception innerException) => throw null;
            public CultureNotFoundException(string message, int invalidCultureId, System.Exception innerException) => throw null;
            public CultureNotFoundException(string paramName, int invalidCultureId, string message) => throw null;
            public CultureNotFoundException(string paramName, string message) => throw null;
            public CultureNotFoundException(string message, string invalidCultureName, System.Exception innerException) => throw null;
            public CultureNotFoundException(string paramName, string invalidCultureName, string message) => throw null;
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual int? InvalidCultureId { get => throw null; }
            public virtual string InvalidCultureName { get => throw null; }
            public override string Message { get => throw null; }
        }
        [System.Flags]
        public enum CultureTypes
        {
            NeutralCultures = 1,
            SpecificCultures = 2,
            InstalledWin32Cultures = 4,
            AllCultures = 7,
            UserCustomCulture = 8,
            ReplacementCultures = 16,
            WindowsOnlyCultures = 32,
            FrameworkCultures = 64,
        }
        public sealed class DateTimeFormatInfo : System.ICloneable, System.IFormatProvider
        {
            public string[] AbbreviatedDayNames { get => throw null; set { } }
            public string[] AbbreviatedMonthGenitiveNames { get => throw null; set { } }
            public string[] AbbreviatedMonthNames { get => throw null; set { } }
            public string AMDesignator { get => throw null; set { } }
            public System.Globalization.Calendar Calendar { get => throw null; set { } }
            public System.Globalization.CalendarWeekRule CalendarWeekRule { get => throw null; set { } }
            public object Clone() => throw null;
            public DateTimeFormatInfo() => throw null;
            public static System.Globalization.DateTimeFormatInfo CurrentInfo { get => throw null; }
            public string DateSeparator { get => throw null; set { } }
            public string[] DayNames { get => throw null; set { } }
            public System.DayOfWeek FirstDayOfWeek { get => throw null; set { } }
            public string FullDateTimePattern { get => throw null; set { } }
            public string GetAbbreviatedDayName(System.DayOfWeek dayofweek) => throw null;
            public string GetAbbreviatedEraName(int era) => throw null;
            public string GetAbbreviatedMonthName(int month) => throw null;
            public string[] GetAllDateTimePatterns() => throw null;
            public string[] GetAllDateTimePatterns(char format) => throw null;
            public string GetDayName(System.DayOfWeek dayofweek) => throw null;
            public int GetEra(string eraName) => throw null;
            public string GetEraName(int era) => throw null;
            public object GetFormat(System.Type formatType) => throw null;
            public static System.Globalization.DateTimeFormatInfo GetInstance(System.IFormatProvider provider) => throw null;
            public string GetMonthName(int month) => throw null;
            public string GetShortestDayName(System.DayOfWeek dayOfWeek) => throw null;
            public static System.Globalization.DateTimeFormatInfo InvariantInfo { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public string LongDatePattern { get => throw null; set { } }
            public string LongTimePattern { get => throw null; set { } }
            public string MonthDayPattern { get => throw null; set { } }
            public string[] MonthGenitiveNames { get => throw null; set { } }
            public string[] MonthNames { get => throw null; set { } }
            public string NativeCalendarName { get => throw null; }
            public string PMDesignator { get => throw null; set { } }
            public static System.Globalization.DateTimeFormatInfo ReadOnly(System.Globalization.DateTimeFormatInfo dtfi) => throw null;
            public string RFC1123Pattern { get => throw null; }
            public void SetAllDateTimePatterns(string[] patterns, char format) => throw null;
            public string ShortDatePattern { get => throw null; set { } }
            public string[] ShortestDayNames { get => throw null; set { } }
            public string ShortTimePattern { get => throw null; set { } }
            public string SortableDateTimePattern { get => throw null; }
            public string TimeSeparator { get => throw null; set { } }
            public string UniversalSortableDateTimePattern { get => throw null; }
            public string YearMonthPattern { get => throw null; set { } }
        }
        [System.Flags]
        public enum DateTimeStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowInnerWhite = 4,
            AllowWhiteSpaces = 7,
            NoCurrentDateDefault = 8,
            AdjustToUniversal = 16,
            AssumeLocal = 32,
            AssumeUniversal = 64,
            RoundtripKind = 128,
        }
        public class DaylightTime
        {
            public DaylightTime(System.DateTime start, System.DateTime end, System.TimeSpan delta) => throw null;
            public System.TimeSpan Delta { get => throw null; }
            public System.DateTime End { get => throw null; }
            public System.DateTime Start { get => throw null; }
        }
        public enum DigitShapes
        {
            Context = 0,
            None = 1,
            NativeNational = 2,
        }
        public abstract class EastAsianLunisolarCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public int GetCelestialStem(int sexagenaryYear) => throw null;
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public virtual int GetSexagenaryYear(System.DateTime time) => throw null;
            public int GetTerrestrialBranch(int sexagenaryYear) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public static partial class GlobalizationExtensions
        {
            public static System.StringComparer GetStringComparer(this System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options) => throw null;
        }
        public class GregorianCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public const int ADEra = 1;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public virtual System.Globalization.GregorianCalendarTypes CalendarType { get => throw null; set { } }
            public GregorianCalendar() => throw null;
            public GregorianCalendar(System.Globalization.GregorianCalendarTypes type) => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public enum GregorianCalendarTypes
        {
            Localized = 1,
            USEnglish = 2,
            MiddleEastFrench = 9,
            Arabic = 10,
            TransliteratedEnglish = 11,
            TransliteratedFrench = 12,
        }
        public class HebrewCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public HebrewCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public static readonly int HebrewEra;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class HijriCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public HijriCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public int HijriAdjustment { get => throw null; set { } }
            public static readonly int HijriEra;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public sealed class IdnMapping
        {
            public bool AllowUnassigned { get => throw null; set { } }
            public IdnMapping() => throw null;
            public override bool Equals(object obj) => throw null;
            public string GetAscii(string unicode) => throw null;
            public string GetAscii(string unicode, int index) => throw null;
            public string GetAscii(string unicode, int index, int count) => throw null;
            public override int GetHashCode() => throw null;
            public string GetUnicode(string ascii) => throw null;
            public string GetUnicode(string ascii, int index) => throw null;
            public string GetUnicode(string ascii, int index, int count) => throw null;
            public bool UseStd3AsciiRules { get => throw null; set { } }
        }
        public static class ISOWeek
        {
            public static int GetWeekOfYear(System.DateTime date) => throw null;
            public static int GetWeeksInYear(int year) => throw null;
            public static int GetYear(System.DateTime date) => throw null;
            public static System.DateTime GetYearEnd(int year) => throw null;
            public static System.DateTime GetYearStart(int year) => throw null;
            public static System.DateTime ToDateTime(int year, int week, System.DayOfWeek dayOfWeek) => throw null;
        }
        public class JapaneseCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public JapaneseCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class JapaneseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            public JapaneseLunisolarCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public const int JapaneseEra = 1;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }
        public class JulianCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public JulianCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public static readonly int JulianEra;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class KoreanCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public KoreanCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public const int KoreanEra = 1;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class KoreanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            public KoreanLunisolarCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public const int GregorianEra = 1;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }
        public sealed class NumberFormatInfo : System.ICloneable, System.IFormatProvider
        {
            public object Clone() => throw null;
            public NumberFormatInfo() => throw null;
            public int CurrencyDecimalDigits { get => throw null; set { } }
            public string CurrencyDecimalSeparator { get => throw null; set { } }
            public string CurrencyGroupSeparator { get => throw null; set { } }
            public int[] CurrencyGroupSizes { get => throw null; set { } }
            public int CurrencyNegativePattern { get => throw null; set { } }
            public int CurrencyPositivePattern { get => throw null; set { } }
            public string CurrencySymbol { get => throw null; set { } }
            public static System.Globalization.NumberFormatInfo CurrentInfo { get => throw null; }
            public System.Globalization.DigitShapes DigitSubstitution { get => throw null; set { } }
            public object GetFormat(System.Type formatType) => throw null;
            public static System.Globalization.NumberFormatInfo GetInstance(System.IFormatProvider formatProvider) => throw null;
            public static System.Globalization.NumberFormatInfo InvariantInfo { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public string NaNSymbol { get => throw null; set { } }
            public string[] NativeDigits { get => throw null; set { } }
            public string NegativeInfinitySymbol { get => throw null; set { } }
            public string NegativeSign { get => throw null; set { } }
            public int NumberDecimalDigits { get => throw null; set { } }
            public string NumberDecimalSeparator { get => throw null; set { } }
            public string NumberGroupSeparator { get => throw null; set { } }
            public int[] NumberGroupSizes { get => throw null; set { } }
            public int NumberNegativePattern { get => throw null; set { } }
            public int PercentDecimalDigits { get => throw null; set { } }
            public string PercentDecimalSeparator { get => throw null; set { } }
            public string PercentGroupSeparator { get => throw null; set { } }
            public int[] PercentGroupSizes { get => throw null; set { } }
            public int PercentNegativePattern { get => throw null; set { } }
            public int PercentPositivePattern { get => throw null; set { } }
            public string PercentSymbol { get => throw null; set { } }
            public string PerMilleSymbol { get => throw null; set { } }
            public string PositiveInfinitySymbol { get => throw null; set { } }
            public string PositiveSign { get => throw null; set { } }
            public static System.Globalization.NumberFormatInfo ReadOnly(System.Globalization.NumberFormatInfo nfi) => throw null;
        }
        [System.Flags]
        public enum NumberStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowLeadingSign = 4,
            Integer = 7,
            AllowTrailingSign = 8,
            AllowParentheses = 16,
            AllowDecimalPoint = 32,
            AllowThousands = 64,
            Number = 111,
            AllowExponent = 128,
            Float = 167,
            AllowCurrencySymbol = 256,
            Currency = 383,
            Any = 511,
            AllowHexSpecifier = 512,
            HexNumber = 515,
            AllowBinarySpecifier = 1024,
            BinaryNumber = 1027,
        }
        public class PersianCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public PersianCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public static readonly int PersianEra;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class RegionInfo
        {
            public RegionInfo(int culture) => throw null;
            public RegionInfo(string name) => throw null;
            public virtual string CurrencyEnglishName { get => throw null; }
            public virtual string CurrencyNativeName { get => throw null; }
            public virtual string CurrencySymbol { get => throw null; }
            public static System.Globalization.RegionInfo CurrentRegion { get => throw null; }
            public virtual string DisplayName { get => throw null; }
            public virtual string EnglishName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public virtual int GeoId { get => throw null; }
            public override int GetHashCode() => throw null;
            public virtual bool IsMetric { get => throw null; }
            public virtual string ISOCurrencySymbol { get => throw null; }
            public virtual string Name { get => throw null; }
            public virtual string NativeName { get => throw null; }
            public virtual string ThreeLetterISORegionName { get => throw null; }
            public virtual string ThreeLetterWindowsRegionName { get => throw null; }
            public override string ToString() => throw null;
            public virtual string TwoLetterISORegionName { get => throw null; }
        }
        public sealed class SortKey
        {
            public static int Compare(System.Globalization.SortKey sortkey1, System.Globalization.SortKey sortkey2) => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public byte[] KeyData { get => throw null; }
            public string OriginalString { get => throw null; }
            public override string ToString() => throw null;
        }
        public sealed class SortVersion : System.IEquatable<System.Globalization.SortVersion>
        {
            public SortVersion(int fullVersion, System.Guid sortId) => throw null;
            public bool Equals(System.Globalization.SortVersion other) => throw null;
            public override bool Equals(object obj) => throw null;
            public int FullVersion { get => throw null; }
            public override int GetHashCode() => throw null;
            public static bool operator ==(System.Globalization.SortVersion left, System.Globalization.SortVersion right) => throw null;
            public static bool operator !=(System.Globalization.SortVersion left, System.Globalization.SortVersion right) => throw null;
            public System.Guid SortId { get => throw null; }
        }
        public class StringInfo
        {
            public StringInfo() => throw null;
            public StringInfo(string value) => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public static string GetNextTextElement(string str) => throw null;
            public static string GetNextTextElement(string str, int index) => throw null;
            public static int GetNextTextElementLength(System.ReadOnlySpan<char> str) => throw null;
            public static int GetNextTextElementLength(string str) => throw null;
            public static int GetNextTextElementLength(string str, int index) => throw null;
            public static System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str) => throw null;
            public static System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str, int index) => throw null;
            public int LengthInTextElements { get => throw null; }
            public static int[] ParseCombiningCharacters(string str) => throw null;
            public string String { get => throw null; set { } }
            public string SubstringByTextElements(int startingTextElement) => throw null;
            public string SubstringByTextElements(int startingTextElement, int lengthInTextElements) => throw null;
        }
        public class TaiwanCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public TaiwanCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        public class TaiwanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            public TaiwanLunisolarCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetEra(System.DateTime time) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
        }
        public class TextElementEnumerator : System.Collections.IEnumerator
        {
            public object Current { get => throw null; }
            public int ElementIndex { get => throw null; }
            public string GetTextElement() => throw null;
            public bool MoveNext() => throw null;
            public void Reset() => throw null;
        }
        public sealed class TextInfo : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback
        {
            public int ANSICodePage { get => throw null; }
            public object Clone() => throw null;
            public string CultureName { get => throw null; }
            public int EBCDICCodePage { get => throw null; }
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsReadOnly { get => throw null; }
            public bool IsRightToLeft { get => throw null; }
            public int LCID { get => throw null; }
            public string ListSeparator { get => throw null; set { } }
            public int MacCodePage { get => throw null; }
            public int OEMCodePage { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public static System.Globalization.TextInfo ReadOnly(System.Globalization.TextInfo textInfo) => throw null;
            public char ToLower(char c) => throw null;
            public string ToLower(string str) => throw null;
            public override string ToString() => throw null;
            public string ToTitleCase(string str) => throw null;
            public char ToUpper(char c) => throw null;
            public string ToUpper(string str) => throw null;
        }
        public class ThaiBuddhistCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public ThaiBuddhistCalendar() => throw null;
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public const int ThaiBuddhistEra = 1;
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
        }
        [System.Flags]
        public enum TimeSpanStyles
        {
            None = 0,
            AssumeNegative = 1,
        }
        public class UmAlQuraCalendar : System.Globalization.Calendar
        {
            public override System.DateTime AddMonths(System.DateTime time, int months) => throw null;
            public override System.DateTime AddYears(System.DateTime time, int years) => throw null;
            public override System.Globalization.CalendarAlgorithmType AlgorithmType { get => throw null; }
            public UmAlQuraCalendar() => throw null;
            protected override int DaysInYearBeforeMinSupportedYear { get => throw null; }
            public override int[] Eras { get => throw null; }
            public override int GetDayOfMonth(System.DateTime time) => throw null;
            public override System.DayOfWeek GetDayOfWeek(System.DateTime time) => throw null;
            public override int GetDayOfYear(System.DateTime time) => throw null;
            public override int GetDaysInMonth(int year, int month, int era) => throw null;
            public override int GetDaysInYear(int year, int era) => throw null;
            public override int GetEra(System.DateTime time) => throw null;
            public override int GetLeapMonth(int year, int era) => throw null;
            public override int GetMonth(System.DateTime time) => throw null;
            public override int GetMonthsInYear(int year, int era) => throw null;
            public override int GetYear(System.DateTime time) => throw null;
            public override bool IsLeapDay(int year, int month, int day, int era) => throw null;
            public override bool IsLeapMonth(int year, int month, int era) => throw null;
            public override bool IsLeapYear(int year, int era) => throw null;
            public override System.DateTime MaxSupportedDateTime { get => throw null; }
            public override System.DateTime MinSupportedDateTime { get => throw null; }
            public override System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) => throw null;
            public override int ToFourDigitYear(int year) => throw null;
            public override int TwoDigitYearMax { get => throw null; set { } }
            public const int UmAlQuraEra = 1;
        }
        public enum UnicodeCategory
        {
            UppercaseLetter = 0,
            LowercaseLetter = 1,
            TitlecaseLetter = 2,
            ModifierLetter = 3,
            OtherLetter = 4,
            NonSpacingMark = 5,
            SpacingCombiningMark = 6,
            EnclosingMark = 7,
            DecimalDigitNumber = 8,
            LetterNumber = 9,
            OtherNumber = 10,
            SpaceSeparator = 11,
            LineSeparator = 12,
            ParagraphSeparator = 13,
            Control = 14,
            Format = 15,
            Surrogate = 16,
            PrivateUse = 17,
            ConnectorPunctuation = 18,
            DashPunctuation = 19,
            OpenPunctuation = 20,
            ClosePunctuation = 21,
            InitialQuotePunctuation = 22,
            FinalQuotePunctuation = 23,
            OtherPunctuation = 24,
            MathSymbol = 25,
            CurrencySymbol = 26,
            ModifierSymbol = 27,
            OtherSymbol = 28,
            OtherNotAssigned = 29,
        }
    }
    public class GopherStyleUriParser : System.UriParser
    {
        public GopherStyleUriParser() => throw null;
    }
    public struct Guid : System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.IFormattable, System.IParsable<System.Guid>, System.ISpanFormattable, System.ISpanParsable<System.Guid>, System.IUtf8SpanFormattable
    {
        public int CompareTo(System.Guid value) => throw null;
        public int CompareTo(object value) => throw null;
        public Guid(byte[] b) => throw null;
        public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k) => throw null;
        public Guid(int a, short b, short c, byte[] d) => throw null;
        public Guid(System.ReadOnlySpan<byte> b) => throw null;
        public Guid(System.ReadOnlySpan<byte> b, bool bigEndian) => throw null;
        public Guid(string g) => throw null;
        public Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k) => throw null;
        public static readonly System.Guid Empty;
        public bool Equals(System.Guid g) => throw null;
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public static System.Guid NewGuid() => throw null;
        public static bool operator ==(System.Guid a, System.Guid b) => throw null;
        public static bool operator >(System.Guid left, System.Guid right) => throw null;
        public static bool operator >=(System.Guid left, System.Guid right) => throw null;
        public static bool operator !=(System.Guid a, System.Guid b) => throw null;
        public static bool operator <(System.Guid left, System.Guid right) => throw null;
        public static bool operator <=(System.Guid left, System.Guid right) => throw null;
        public static System.Guid Parse(System.ReadOnlySpan<char> input) => throw null;
        static System.Guid System.ISpanParsable<System.Guid>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.Guid Parse(string input) => throw null;
        static System.Guid System.IParsable<System.Guid>.Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.Guid ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format) => throw null;
        public static System.Guid ParseExact(string input, string format) => throw null;
        public byte[] ToByteArray() => throw null;
        public byte[] ToByteArray(bool bigEndian) => throw null;
        public override string ToString() => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        bool System.IUtf8SpanFormattable.TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> input, out System.Guid result) => throw null;
        static bool System.ISpanParsable<System.Guid>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.Guid result) => throw null;
        public static bool TryParse(string input, out System.Guid result) => throw null;
        static bool System.IParsable<System.Guid>.TryParse(string s, System.IFormatProvider provider, out System.Guid result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, out System.Guid result) => throw null;
        public static bool TryParseExact(string input, string format, out System.Guid result) => throw null;
        public bool TryWriteBytes(System.Span<byte> destination) => throw null;
        public bool TryWriteBytes(System.Span<byte> destination, bool bigEndian, out int bytesWritten) => throw null;
    }
    public struct Half : System.Numerics.IAdditionOperators<System.Half, System.Half, System.Half>, System.Numerics.IAdditiveIdentity<System.Half, System.Half>, System.Numerics.IBinaryFloatingPointIeee754<System.Half>, System.Numerics.IBinaryNumber<System.Half>, System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>, System.IComparable, System.IComparable<System.Half>, System.Numerics.IComparisonOperators<System.Half, System.Half, bool>, System.Numerics.IDecrementOperators<System.Half>, System.Numerics.IDivisionOperators<System.Half, System.Half, System.Half>, System.Numerics.IEqualityOperators<System.Half, System.Half, bool>, System.IEquatable<System.Half>, System.Numerics.IExponentialFunctions<System.Half>, System.Numerics.IFloatingPoint<System.Half>, System.Numerics.IFloatingPointConstants<System.Half>, System.Numerics.IFloatingPointIeee754<System.Half>, System.IFormattable, System.Numerics.IHyperbolicFunctions<System.Half>, System.Numerics.IIncrementOperators<System.Half>, System.Numerics.ILogarithmicFunctions<System.Half>, System.Numerics.IMinMaxValue<System.Half>, System.Numerics.IModulusOperators<System.Half, System.Half, System.Half>, System.Numerics.IMultiplicativeIdentity<System.Half, System.Half>, System.Numerics.IMultiplyOperators<System.Half, System.Half, System.Half>, System.Numerics.INumber<System.Half>, System.Numerics.INumberBase<System.Half>, System.IParsable<System.Half>, System.Numerics.IPowerFunctions<System.Half>, System.Numerics.IRootFunctions<System.Half>, System.Numerics.ISignedNumber<System.Half>, System.ISpanFormattable, System.ISpanParsable<System.Half>, System.Numerics.ISubtractionOperators<System.Half, System.Half, System.Half>, System.Numerics.ITrigonometricFunctions<System.Half>, System.Numerics.IUnaryNegationOperators<System.Half, System.Half>, System.Numerics.IUnaryPlusOperators<System.Half, System.Half>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Half>
    {
        static System.Half System.Numerics.INumberBase<System.Half>.Abs(System.Half value) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Acos(System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Acosh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.AcosPi(System.Half x) => throw null;
        static System.Half System.Numerics.IAdditiveIdentity<System.Half, System.Half>.AdditiveIdentity { get => throw null; }
        static System.Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get => throw null; }
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Asin(System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Asinh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.AsinPi(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Atan(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Atan2(System.Half y, System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Atan2Pi(System.Half y, System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Atanh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.AtanPi(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.BitDecrement(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.BitIncrement(System.Half x) => throw null;
        static System.Half System.Numerics.IRootFunctions<System.Half>.Cbrt(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Ceiling(System.Half x) => throw null;
        static System.Half System.Numerics.INumber<System.Half>.Clamp(System.Half value, System.Half min, System.Half max) => throw null;
        public int CompareTo(System.Half other) => throw null;
        public int CompareTo(object obj) => throw null;
        static System.Half System.Numerics.INumber<System.Half>.CopySign(System.Half value, System.Half sign) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Cos(System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Cosh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.CosPi(System.Half x) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.CreateTruncating<TOther>(TOther value) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.DegreesToRadians(System.Half degrees) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.E { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Epsilon { get => throw null; }
        public bool Equals(System.Half other) => throw null;
        public override bool Equals(object obj) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.Exp(System.Half x) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.Exp10(System.Half x) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.Exp10M1(System.Half x) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.Exp2(System.Half x) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.Exp2M1(System.Half x) => throw null;
        static System.Half System.Numerics.IExponentialFunctions<System.Half>.ExpM1(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Floor(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.FusedMultiplyAdd(System.Half left, System.Half right, System.Half addend) => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<System.Half>.GetSignificandByteCount() => throw null;
        static System.Half System.Numerics.IRootFunctions<System.Half>.Hypot(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Ieee754Remainder(System.Half left, System.Half right) => throw null;
        static int System.Numerics.IFloatingPointIeee754<System.Half>.ILogB(System.Half x) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsCanonical(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsComplexNumber(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsEvenInteger(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsFinite(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsImaginaryNumber(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsInfinity(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsInteger(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsNaN(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsNegative(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsNegativeInfinity(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsNormal(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsOddInteger(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsPositive(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsPositiveInfinity(System.Half value) => throw null;
        static bool System.Numerics.IBinaryNumber<System.Half>.IsPow2(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsRealNumber(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsSubnormal(System.Half value) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.IsZero(System.Half value) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.Lerp(System.Half value1, System.Half value2, System.Half amount) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log(System.Half x) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log(System.Half x, System.Half newBase) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log10(System.Half x) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log10P1(System.Half x) => throw null;
        static System.Half System.Numerics.IBinaryNumber<System.Half>.Log2(System.Half value) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log2(System.Half value) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.Log2P1(System.Half x) => throw null;
        static System.Half System.Numerics.ILogarithmicFunctions<System.Half>.LogP1(System.Half x) => throw null;
        static System.Half System.Numerics.INumber<System.Half>.Max(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.MaxMagnitude(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.MaxMagnitudeNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumber<System.Half>.MaxNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.IMinMaxValue<System.Half>.MaxValue { get => throw null; }
        static System.Half System.Numerics.INumber<System.Half>.Min(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.MinMagnitude(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.MinMagnitudeNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.INumber<System.Half>.MinNumber(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.IMinMaxValue<System.Half>.MinValue { get => throw null; }
        static System.Half System.Numerics.IMultiplicativeIdentity<System.Half, System.Half>.MultiplicativeIdentity { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NaN { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NegativeInfinity { get => throw null; }
        static System.Half System.Numerics.ISignedNumber<System.Half>.NegativeOne { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.NegativeZero { get => throw null; }
        static System.Half System.Numerics.INumberBase<System.Half>.One { get => throw null; }
        static System.Half System.Numerics.IAdditionOperators<System.Half, System.Half, System.Half>.operator +(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator &(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator |(System.Half left, System.Half right) => throw null;
        public static explicit operator checked byte(System.Half value) => throw null;
        public static explicit operator checked char(System.Half value) => throw null;
        public static explicit operator checked short(System.Half value) => throw null;
        public static explicit operator checked int(System.Half value) => throw null;
        public static explicit operator checked long(System.Half value) => throw null;
        public static explicit operator checked System.Int128(System.Half value) => throw null;
        public static explicit operator checked nint(System.Half value) => throw null;
        public static explicit operator checked sbyte(System.Half value) => throw null;
        public static explicit operator checked ushort(System.Half value) => throw null;
        public static explicit operator checked uint(System.Half value) => throw null;
        public static explicit operator checked ulong(System.Half value) => throw null;
        public static explicit operator checked System.UInt128(System.Half value) => throw null;
        public static explicit operator checked nuint(System.Half value) => throw null;
        static System.Half System.Numerics.IDecrementOperators<System.Half>.operator --(System.Half value) => throw null;
        static System.Half System.Numerics.IDivisionOperators<System.Half, System.Half, System.Half>.operator /(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Half, System.Half, bool>.operator ==(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator ^(System.Half left, System.Half right) => throw null;
        public static explicit operator System.Half(char value) => throw null;
        public static explicit operator System.Half(decimal value) => throw null;
        public static explicit operator System.Half(double value) => throw null;
        public static explicit operator byte(System.Half value) => throw null;
        public static explicit operator char(System.Half value) => throw null;
        public static explicit operator decimal(System.Half value) => throw null;
        public static explicit operator double(System.Half value) => throw null;
        public static explicit operator System.Int128(System.Half value) => throw null;
        public static explicit operator short(System.Half value) => throw null;
        public static explicit operator int(System.Half value) => throw null;
        public static explicit operator long(System.Half value) => throw null;
        public static explicit operator nint(System.Half value) => throw null;
        public static explicit operator sbyte(System.Half value) => throw null;
        public static explicit operator float(System.Half value) => throw null;
        public static explicit operator System.UInt128(System.Half value) => throw null;
        public static explicit operator ushort(System.Half value) => throw null;
        public static explicit operator uint(System.Half value) => throw null;
        public static explicit operator ulong(System.Half value) => throw null;
        public static explicit operator nuint(System.Half value) => throw null;
        public static explicit operator System.Half(short value) => throw null;
        public static explicit operator System.Half(int value) => throw null;
        public static explicit operator System.Half(long value) => throw null;
        public static explicit operator System.Half(nint value) => throw null;
        public static explicit operator System.Half(float value) => throw null;
        public static explicit operator System.Half(ushort value) => throw null;
        public static explicit operator System.Half(uint value) => throw null;
        public static explicit operator System.Half(ulong value) => throw null;
        public static explicit operator System.Half(nuint value) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator >(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator >=(System.Half left, System.Half right) => throw null;
        public static implicit operator System.Half(byte value) => throw null;
        public static implicit operator System.Half(sbyte value) => throw null;
        static System.Half System.Numerics.IIncrementOperators<System.Half>.operator ++(System.Half value) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Half, System.Half, bool>.operator !=(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator <(System.Half left, System.Half right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Half, System.Half, bool>.operator <=(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IModulusOperators<System.Half, System.Half, System.Half>.operator %(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IMultiplyOperators<System.Half, System.Half, System.Half>.operator *(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IBitwiseOperators<System.Half, System.Half, System.Half>.operator ~(System.Half value) => throw null;
        static System.Half System.Numerics.ISubtractionOperators<System.Half, System.Half, System.Half>.operator -(System.Half left, System.Half right) => throw null;
        static System.Half System.Numerics.IUnaryNegationOperators<System.Half, System.Half>.operator -(System.Half value) => throw null;
        static System.Half System.Numerics.IUnaryPlusOperators<System.Half, System.Half>.operator +(System.Half value) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Half System.IUtf8SpanParsable<System.Half>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Half System.ISpanParsable<System.Half>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.Half Parse(string s) => throw null;
        public static System.Half Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.Parse(string s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Half System.IParsable<System.Half>.Parse(string s, System.IFormatProvider provider) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.Pi { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.PositiveInfinity { get => throw null; }
        static System.Half System.Numerics.IPowerFunctions<System.Half>.Pow(System.Half x, System.Half y) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.RadiansToDegrees(System.Half radians) => throw null;
        static int System.Numerics.INumberBase<System.Half>.Radix { get => throw null; }
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.ReciprocalEstimate(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.ReciprocalSqrtEstimate(System.Half x) => throw null;
        static System.Half System.Numerics.IRootFunctions<System.Half>.RootN(System.Half x, int n) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Round(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Round(System.Half x, int digits) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Round(System.Half x, int digits, System.MidpointRounding mode) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Round(System.Half x, System.MidpointRounding mode) => throw null;
        static System.Half System.Numerics.IFloatingPointIeee754<System.Half>.ScaleB(System.Half x, int n) => throw null;
        static int System.Numerics.INumber<System.Half>.Sign(System.Half value) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Sin(System.Half x) => throw null;
        static (System.Half Sin, System.Half Cos) System.Numerics.ITrigonometricFunctions<System.Half>.SinCos(System.Half x) => throw null;
        static (System.Half SinPi, System.Half CosPi) System.Numerics.ITrigonometricFunctions<System.Half>.SinCosPi(System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Sinh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.SinPi(System.Half x) => throw null;
        static System.Half System.Numerics.IRootFunctions<System.Half>.Sqrt(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.Tan(System.Half x) => throw null;
        static System.Half System.Numerics.IHyperbolicFunctions<System.Half>.Tanh(System.Half x) => throw null;
        static System.Half System.Numerics.ITrigonometricFunctions<System.Half>.TanPi(System.Half x) => throw null;
        static System.Half System.Numerics.IFloatingPointConstants<System.Half>.Tau { get => throw null; }
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        static System.Half System.Numerics.IFloatingPoint<System.Half>.Truncate(System.Half x) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromChecked<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromSaturating<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertFromTruncating<TOther>(TOther value, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToChecked<TOther>(System.Half value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToSaturating<TOther>(System.Half value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryConvertToTruncating<TOther>(System.Half value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Half result) => throw null;
        static bool System.IUtf8SpanParsable<System.Half>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.Half result) => throw null;
        static bool System.ISpanParsable<System.Half>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.Half result) => throw null;
        static bool System.Numerics.INumberBase<System.Half>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Half result) => throw null;
        public static bool TryParse(string s, out System.Half result) => throw null;
        static bool System.IParsable<System.Half>.TryParse(string s, System.IFormatProvider provider, out System.Half result) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static System.Half System.Numerics.INumberBase<System.Half>.Zero { get => throw null; }
    }
    public struct HashCode
    {
        public void Add<T>(T value) => throw null;
        public void Add<T>(T value, System.Collections.Generic.IEqualityComparer<T> comparer) => throw null;
        public void AddBytes(System.ReadOnlySpan<byte> value) => throw null;
        public static int Combine<T1>(T1 value1) => throw null;
        public static int Combine<T1, T2>(T1 value1, T2 value2) => throw null;
        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3) => throw null;
        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4) => throw null;
        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7) => throw null;
        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public int ToHashCode() => throw null;
    }
    public class HttpStyleUriParser : System.UriParser
    {
        public HttpStyleUriParser() => throw null;
    }
    public interface IAsyncDisposable
    {
        System.Threading.Tasks.ValueTask DisposeAsync();
    }
    public interface IAsyncResult
    {
        object AsyncState { get; }
        System.Threading.WaitHandle AsyncWaitHandle { get; }
        bool CompletedSynchronously { get; }
        bool IsCompleted { get; }
    }
    public interface ICloneable
    {
        object Clone();
    }
    public interface IComparable
    {
        int CompareTo(object obj);
    }
    public interface IComparable<T>
    {
        int CompareTo(T other);
    }
    public interface IConvertible
    {
        System.TypeCode GetTypeCode();
        bool ToBoolean(System.IFormatProvider provider);
        byte ToByte(System.IFormatProvider provider);
        char ToChar(System.IFormatProvider provider);
        System.DateTime ToDateTime(System.IFormatProvider provider);
        decimal ToDecimal(System.IFormatProvider provider);
        double ToDouble(System.IFormatProvider provider);
        short ToInt16(System.IFormatProvider provider);
        int ToInt32(System.IFormatProvider provider);
        long ToInt64(System.IFormatProvider provider);
        sbyte ToSByte(System.IFormatProvider provider);
        float ToSingle(System.IFormatProvider provider);
        string ToString(System.IFormatProvider provider);
        object ToType(System.Type conversionType, System.IFormatProvider provider);
        ushort ToUInt16(System.IFormatProvider provider);
        uint ToUInt32(System.IFormatProvider provider);
        ulong ToUInt64(System.IFormatProvider provider);
    }
    public interface ICustomFormatter
    {
        string Format(string format, object arg, System.IFormatProvider formatProvider);
    }
    public interface IDisposable
    {
        void Dispose();
    }
    public interface IEquatable<T>
    {
        bool Equals(T other);
    }
    public interface IFormatProvider
    {
        object GetFormat(System.Type formatType);
    }
    public interface IFormattable
    {
        string ToString(string format, System.IFormatProvider formatProvider);
    }
    public struct Index : System.IEquatable<System.Index>
    {
        public Index(int value, bool fromEnd = default(bool)) => throw null;
        public static System.Index End { get => throw null; }
        public bool Equals(System.Index other) => throw null;
        public override bool Equals(object value) => throw null;
        public static System.Index FromEnd(int value) => throw null;
        public static System.Index FromStart(int value) => throw null;
        public override int GetHashCode() => throw null;
        public int GetOffset(int length) => throw null;
        public bool IsFromEnd { get => throw null; }
        public static implicit operator System.Index(int value) => throw null;
        public static System.Index Start { get => throw null; }
        public override string ToString() => throw null;
        public int Value { get => throw null; }
    }
    public sealed class IndexOutOfRangeException : System.SystemException
    {
        public IndexOutOfRangeException() => throw null;
        public IndexOutOfRangeException(string message) => throw null;
        public IndexOutOfRangeException(string message, System.Exception innerException) => throw null;
    }
    public sealed class InsufficientExecutionStackException : System.SystemException
    {
        public InsufficientExecutionStackException() => throw null;
        public InsufficientExecutionStackException(string message) => throw null;
        public InsufficientExecutionStackException(string message, System.Exception innerException) => throw null;
    }
    public sealed class InsufficientMemoryException : System.OutOfMemoryException
    {
        public InsufficientMemoryException() => throw null;
        public InsufficientMemoryException(string message) => throw null;
        public InsufficientMemoryException(string message, System.Exception innerException) => throw null;
    }
    public struct Int128 : System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IAdditiveIdentity<System.Int128, System.Int128>, System.Numerics.IBinaryInteger<System.Int128>, System.Numerics.IBinaryNumber<System.Int128>, System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>, System.IComparable, System.IComparable<System.Int128>, System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>, System.Numerics.IDecrementOperators<System.Int128>, System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>, System.IEquatable<System.Int128>, System.IFormattable, System.Numerics.IIncrementOperators<System.Int128>, System.Numerics.IMinMaxValue<System.Int128>, System.Numerics.IModulusOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IMultiplicativeIdentity<System.Int128, System.Int128>, System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.INumber<System.Int128>, System.Numerics.INumberBase<System.Int128>, System.IParsable<System.Int128>, System.Numerics.IShiftOperators<System.Int128, int, System.Int128>, System.Numerics.ISignedNumber<System.Int128>, System.ISpanFormattable, System.ISpanParsable<System.Int128>, System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>, System.Numerics.IUnaryPlusOperators<System.Int128, System.Int128>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Int128>
    {
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Abs(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IAdditiveIdentity<System.Int128, System.Int128>.AdditiveIdentity { get => throw null; }
        static System.Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get => throw null; }
        static System.Int128 System.Numerics.INumber<System.Int128>.Clamp(System.Int128 value, System.Int128 min, System.Int128 max) => throw null;
        public int CompareTo(System.Int128 value) => throw null;
        public int CompareTo(object value) => throw null;
        static System.Int128 System.Numerics.INumber<System.Int128>.CopySign(System.Int128 value, System.Int128 sign) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateChecked<TOther>(TOther value) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.CreateTruncating<TOther>(TOther value) => throw null;
        public Int128(ulong upper, ulong lower) => throw null;
        static (System.Int128 Quotient, System.Int128 Remainder) System.Numerics.IBinaryInteger<System.Int128>.DivRem(System.Int128 left, System.Int128 right) => throw null;
        public bool Equals(System.Int128 other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<System.Int128>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.Int128>.GetShortestBitLength() => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsCanonical(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsComplexNumber(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsEvenInteger(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsFinite(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsImaginaryNumber(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsInfinity(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsInteger(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsNaN(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsNegative(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsNegativeInfinity(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsNormal(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsOddInteger(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsPositive(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsPositiveInfinity(System.Int128 value) => throw null;
        static bool System.Numerics.IBinaryNumber<System.Int128>.IsPow2(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsRealNumber(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsSubnormal(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.IsZero(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IBinaryInteger<System.Int128>.LeadingZeroCount(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IBinaryNumber<System.Int128>.Log2(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.INumber<System.Int128>.Max(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.MaxMagnitude(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.MaxMagnitudeNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumber<System.Int128>.MaxNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.IMinMaxValue<System.Int128>.MaxValue { get => throw null; }
        static System.Int128 System.Numerics.INumber<System.Int128>.Min(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.MinMagnitude(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.MinMagnitudeNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.INumber<System.Int128>.MinNumber(System.Int128 x, System.Int128 y) => throw null;
        static System.Int128 System.Numerics.IMinMaxValue<System.Int128>.MinValue { get => throw null; }
        static System.Int128 System.Numerics.IMultiplicativeIdentity<System.Int128, System.Int128>.MultiplicativeIdentity { get => throw null; }
        static System.Int128 System.Numerics.ISignedNumber<System.Int128>.NegativeOne { get => throw null; }
        static System.Int128 System.Numerics.INumberBase<System.Int128>.One { get => throw null; }
        static System.Int128 System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>.operator +(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator &(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator |(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>.operator checked +(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IDecrementOperators<System.Int128>.operator checked --(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>.operator checked /(System.Int128 left, System.Int128 right) => throw null;
        public static explicit operator checked System.Int128(double value) => throw null;
        public static explicit operator checked byte(System.Int128 value) => throw null;
        public static explicit operator checked char(System.Int128 value) => throw null;
        public static explicit operator checked short(System.Int128 value) => throw null;
        public static explicit operator checked int(System.Int128 value) => throw null;
        public static explicit operator checked long(System.Int128 value) => throw null;
        public static explicit operator checked nint(System.Int128 value) => throw null;
        public static explicit operator checked sbyte(System.Int128 value) => throw null;
        public static explicit operator checked ushort(System.Int128 value) => throw null;
        public static explicit operator checked uint(System.Int128 value) => throw null;
        public static explicit operator checked ulong(System.Int128 value) => throw null;
        public static explicit operator checked System.UInt128(System.Int128 value) => throw null;
        public static explicit operator checked nuint(System.Int128 value) => throw null;
        public static explicit operator checked System.Int128(float value) => throw null;
        static System.Int128 System.Numerics.IIncrementOperators<System.Int128>.operator checked ++(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>.operator checked *(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>.operator checked -(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>.operator checked -(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IDecrementOperators<System.Int128>.operator --(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>.operator /(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>.operator ==(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator ^(System.Int128 left, System.Int128 right) => throw null;
        public static explicit operator System.Int128(decimal value) => throw null;
        public static explicit operator System.Int128(double value) => throw null;
        public static explicit operator byte(System.Int128 value) => throw null;
        public static explicit operator char(System.Int128 value) => throw null;
        public static explicit operator decimal(System.Int128 value) => throw null;
        public static explicit operator double(System.Int128 value) => throw null;
        public static explicit operator System.Half(System.Int128 value) => throw null;
        public static explicit operator short(System.Int128 value) => throw null;
        public static explicit operator int(System.Int128 value) => throw null;
        public static explicit operator long(System.Int128 value) => throw null;
        public static explicit operator nint(System.Int128 value) => throw null;
        public static explicit operator sbyte(System.Int128 value) => throw null;
        public static explicit operator float(System.Int128 value) => throw null;
        public static explicit operator System.UInt128(System.Int128 value) => throw null;
        public static explicit operator ushort(System.Int128 value) => throw null;
        public static explicit operator uint(System.Int128 value) => throw null;
        public static explicit operator ulong(System.Int128 value) => throw null;
        public static explicit operator nuint(System.Int128 value) => throw null;
        public static explicit operator System.Int128(float value) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator >(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator >=(System.Int128 left, System.Int128 right) => throw null;
        public static implicit operator System.Int128(byte value) => throw null;
        public static implicit operator System.Int128(char value) => throw null;
        public static implicit operator System.Int128(short value) => throw null;
        public static implicit operator System.Int128(int value) => throw null;
        public static implicit operator System.Int128(long value) => throw null;
        public static implicit operator System.Int128(nint value) => throw null;
        public static implicit operator System.Int128(sbyte value) => throw null;
        public static implicit operator System.Int128(ushort value) => throw null;
        public static implicit operator System.Int128(uint value) => throw null;
        public static implicit operator System.Int128(ulong value) => throw null;
        public static implicit operator System.Int128(nuint value) => throw null;
        static System.Int128 System.Numerics.IIncrementOperators<System.Int128>.operator ++(System.Int128 value) => throw null;
        static bool System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>.operator !=(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator <<(System.Int128 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator <(System.Int128 left, System.Int128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>.operator <=(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IModulusOperators<System.Int128, System.Int128, System.Int128>.operator %(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>.operator *(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>.operator ~(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator >>(System.Int128 value, int shiftAmount) => throw null;
        static System.Int128 System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>.operator -(System.Int128 left, System.Int128 right) => throw null;
        static System.Int128 System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>.operator -(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IUnaryPlusOperators<System.Int128, System.Int128>.operator +(System.Int128 value) => throw null;
        static System.Int128 System.Numerics.IShiftOperators<System.Int128, int, System.Int128>.operator >>>(System.Int128 value, int shiftAmount) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Int128 System.IUtf8SpanParsable<System.Int128>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.Int128 System.ISpanParsable<System.Int128>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.Int128 Parse(string s) => throw null;
        public static System.Int128 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static System.Int128 System.IParsable<System.Int128>.Parse(string s, System.IFormatProvider provider) => throw null;
        static System.Int128 System.Numerics.IBinaryInteger<System.Int128>.PopCount(System.Int128 value) => throw null;
        static int System.Numerics.INumberBase<System.Int128>.Radix { get => throw null; }
        static System.Int128 System.Numerics.IBinaryInteger<System.Int128>.RotateLeft(System.Int128 value, int rotateAmount) => throw null;
        static System.Int128 System.Numerics.IBinaryInteger<System.Int128>.RotateRight(System.Int128 value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<System.Int128>.Sign(System.Int128 value) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        static System.Int128 System.Numerics.IBinaryInteger<System.Int128>.TrailingZeroCount(System.Int128 value) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromChecked<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromSaturating<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertFromTruncating<TOther>(TOther value, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToChecked<TOther>(System.Int128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToSaturating<TOther>(System.Int128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryConvertToTruncating<TOther>(System.Int128 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int128 result) => throw null;
        static bool System.IUtf8SpanParsable<System.Int128>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int128 result) => throw null;
        static bool System.ISpanParsable<System.Int128>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.Int128 result) => throw null;
        static bool System.Numerics.INumberBase<System.Int128>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.Int128 result) => throw null;
        static bool System.IParsable<System.Int128>.TryParse(string s, System.IFormatProvider provider, out System.Int128 result) => throw null;
        public static bool TryParse(string s, out System.Int128 result) => throw null;
        static bool System.Numerics.IBinaryInteger<System.Int128>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out System.Int128 value) => throw null;
        static bool System.Numerics.IBinaryInteger<System.Int128>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out System.Int128 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static System.Int128 System.Numerics.INumberBase<System.Int128>.Zero { get => throw null; }
    }
    public struct Int16 : System.Numerics.IAdditionOperators<short, short, short>, System.Numerics.IAdditiveIdentity<short, short>, System.Numerics.IBinaryInteger<short>, System.Numerics.IBinaryNumber<short>, System.Numerics.IBitwiseOperators<short, short, short>, System.IComparable, System.IComparable<short>, System.Numerics.IComparisonOperators<short, short, bool>, System.IConvertible, System.Numerics.IDecrementOperators<short>, System.Numerics.IDivisionOperators<short, short, short>, System.Numerics.IEqualityOperators<short, short, bool>, System.IEquatable<short>, System.IFormattable, System.Numerics.IIncrementOperators<short>, System.Numerics.IMinMaxValue<short>, System.Numerics.IModulusOperators<short, short, short>, System.Numerics.IMultiplicativeIdentity<short, short>, System.Numerics.IMultiplyOperators<short, short, short>, System.Numerics.INumber<short>, System.Numerics.INumberBase<short>, System.IParsable<short>, System.Numerics.IShiftOperators<short, int, short>, System.Numerics.ISignedNumber<short>, System.ISpanFormattable, System.ISpanParsable<short>, System.Numerics.ISubtractionOperators<short, short, short>, System.Numerics.IUnaryNegationOperators<short, short>, System.Numerics.IUnaryPlusOperators<short, short>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<short>
    {
        static short System.Numerics.INumberBase<short>.Abs(short value) => throw null;
        static short System.Numerics.IAdditiveIdentity<short, short>.AdditiveIdentity { get => throw null; }
        static short System.Numerics.IBinaryNumber<short>.AllBitsSet { get => throw null; }
        static short System.Numerics.INumber<short>.Clamp(short value, short min, short max) => throw null;
        public int CompareTo(short value) => throw null;
        public int CompareTo(object value) => throw null;
        static short System.Numerics.INumber<short>.CopySign(short value, short sign) => throw null;
        static short System.Numerics.INumberBase<short>.CreateChecked<TOther>(TOther value) => throw null;
        static short System.Numerics.INumberBase<short>.CreateSaturating<TOther>(TOther value) => throw null;
        static short System.Numerics.INumberBase<short>.CreateTruncating<TOther>(TOther value) => throw null;
        static (short Quotient, short Remainder) System.Numerics.IBinaryInteger<short>.DivRem(short left, short right) => throw null;
        public bool Equals(short obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<short>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<short>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<short>.IsCanonical(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsComplexNumber(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsEvenInteger(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsFinite(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsImaginaryNumber(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsInfinity(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsInteger(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsNaN(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsNegative(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsNegativeInfinity(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsNormal(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsOddInteger(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsPositive(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsPositiveInfinity(short value) => throw null;
        static bool System.Numerics.IBinaryNumber<short>.IsPow2(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsRealNumber(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsSubnormal(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.IsZero(short value) => throw null;
        static short System.Numerics.IBinaryInteger<short>.LeadingZeroCount(short value) => throw null;
        static short System.Numerics.IBinaryNumber<short>.Log2(short value) => throw null;
        static short System.Numerics.INumber<short>.Max(short x, short y) => throw null;
        static short System.Numerics.INumberBase<short>.MaxMagnitude(short x, short y) => throw null;
        static short System.Numerics.INumberBase<short>.MaxMagnitudeNumber(short x, short y) => throw null;
        static short System.Numerics.INumber<short>.MaxNumber(short x, short y) => throw null;
        public const short MaxValue = 32767;
        static short System.Numerics.IMinMaxValue<short>.MaxValue { get => throw null; }
        static short System.Numerics.INumber<short>.Min(short x, short y) => throw null;
        static short System.Numerics.INumberBase<short>.MinMagnitude(short x, short y) => throw null;
        static short System.Numerics.INumberBase<short>.MinMagnitudeNumber(short x, short y) => throw null;
        static short System.Numerics.INumber<short>.MinNumber(short x, short y) => throw null;
        public const short MinValue = -32768;
        static short System.Numerics.IMinMaxValue<short>.MinValue { get => throw null; }
        static short System.Numerics.IMultiplicativeIdentity<short, short>.MultiplicativeIdentity { get => throw null; }
        static short System.Numerics.ISignedNumber<short>.NegativeOne { get => throw null; }
        static short System.Numerics.INumberBase<short>.One { get => throw null; }
        static short System.Numerics.IAdditionOperators<short, short, short>.operator +(short left, short right) => throw null;
        static short System.Numerics.IBitwiseOperators<short, short, short>.operator &(short left, short right) => throw null;
        static short System.Numerics.IBitwiseOperators<short, short, short>.operator |(short left, short right) => throw null;
        static short System.Numerics.IAdditionOperators<short, short, short>.operator checked +(short left, short right) => throw null;
        static short System.Numerics.IDecrementOperators<short>.operator checked --(short value) => throw null;
        static short System.Numerics.IIncrementOperators<short>.operator checked ++(short value) => throw null;
        static short System.Numerics.IMultiplyOperators<short, short, short>.operator checked *(short left, short right) => throw null;
        static short System.Numerics.ISubtractionOperators<short, short, short>.operator checked -(short left, short right) => throw null;
        static short System.Numerics.IUnaryNegationOperators<short, short>.operator checked -(short value) => throw null;
        static short System.Numerics.IDecrementOperators<short>.operator --(short value) => throw null;
        static short System.Numerics.IDivisionOperators<short, short, short>.operator /(short left, short right) => throw null;
        static bool System.Numerics.IEqualityOperators<short, short, bool>.operator ==(short left, short right) => throw null;
        static short System.Numerics.IBitwiseOperators<short, short, short>.operator ^(short left, short right) => throw null;
        static bool System.Numerics.IComparisonOperators<short, short, bool>.operator >(short left, short right) => throw null;
        static bool System.Numerics.IComparisonOperators<short, short, bool>.operator >=(short left, short right) => throw null;
        static short System.Numerics.IIncrementOperators<short>.operator ++(short value) => throw null;
        static bool System.Numerics.IEqualityOperators<short, short, bool>.operator !=(short left, short right) => throw null;
        static short System.Numerics.IShiftOperators<short, int, short>.operator <<(short value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<short, short, bool>.operator <(short left, short right) => throw null;
        static bool System.Numerics.IComparisonOperators<short, short, bool>.operator <=(short left, short right) => throw null;
        static short System.Numerics.IModulusOperators<short, short, short>.operator %(short left, short right) => throw null;
        static short System.Numerics.IMultiplyOperators<short, short, short>.operator *(short left, short right) => throw null;
        static short System.Numerics.IBitwiseOperators<short, short, short>.operator ~(short value) => throw null;
        static short System.Numerics.IShiftOperators<short, int, short>.operator >>(short value, int shiftAmount) => throw null;
        static short System.Numerics.ISubtractionOperators<short, short, short>.operator -(short left, short right) => throw null;
        static short System.Numerics.IUnaryNegationOperators<short, short>.operator -(short value) => throw null;
        static short System.Numerics.IUnaryPlusOperators<short, short>.operator +(short value) => throw null;
        static short System.Numerics.IShiftOperators<short, int, short>.operator >>>(short value, int shiftAmount) => throw null;
        static short System.Numerics.INumberBase<short>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static short System.IUtf8SpanParsable<short>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static short System.Numerics.INumberBase<short>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static short System.ISpanParsable<short>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static short Parse(string s) => throw null;
        public static short Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static short System.Numerics.INumberBase<short>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static short System.IParsable<short>.Parse(string s, System.IFormatProvider provider) => throw null;
        static short System.Numerics.IBinaryInteger<short>.PopCount(short value) => throw null;
        static int System.Numerics.INumberBase<short>.Radix { get => throw null; }
        static short System.Numerics.IBinaryInteger<short>.RotateLeft(short value, int rotateAmount) => throw null;
        static short System.Numerics.IBinaryInteger<short>.RotateRight(short value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<short>.Sign(short value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static short System.Numerics.IBinaryInteger<short>.TrailingZeroCount(short value) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertFromChecked<TOther>(TOther value, out short result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertFromSaturating<TOther>(TOther value, out short result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertFromTruncating<TOther>(TOther value, out short result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertToChecked<TOther>(short value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertToSaturating<TOther>(short value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryConvertToTruncating<TOther>(short value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<short>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out short result) => throw null;
        static bool System.IUtf8SpanParsable<short>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out short result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out short result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out short result) => throw null;
        static bool System.ISpanParsable<short>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out short result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out short result) => throw null;
        static bool System.Numerics.INumberBase<short>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out short result) => throw null;
        static bool System.IParsable<short>.TryParse(string s, System.IFormatProvider provider, out short result) => throw null;
        public static bool TryParse(string s, out short result) => throw null;
        static bool System.Numerics.IBinaryInteger<short>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out short value) => throw null;
        static bool System.Numerics.IBinaryInteger<short>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out short value) => throw null;
        bool System.Numerics.IBinaryInteger<short>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<short>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static short System.Numerics.INumberBase<short>.Zero { get => throw null; }
    }
    public struct Int32 : System.Numerics.IAdditionOperators<int, int, int>, System.Numerics.IAdditiveIdentity<int, int>, System.Numerics.IBinaryInteger<int>, System.Numerics.IBinaryNumber<int>, System.Numerics.IBitwiseOperators<int, int, int>, System.IComparable, System.IComparable<int>, System.Numerics.IComparisonOperators<int, int, bool>, System.IConvertible, System.Numerics.IDecrementOperators<int>, System.Numerics.IDivisionOperators<int, int, int>, System.Numerics.IEqualityOperators<int, int, bool>, System.IEquatable<int>, System.IFormattable, System.Numerics.IIncrementOperators<int>, System.Numerics.IMinMaxValue<int>, System.Numerics.IModulusOperators<int, int, int>, System.Numerics.IMultiplicativeIdentity<int, int>, System.Numerics.IMultiplyOperators<int, int, int>, System.Numerics.INumber<int>, System.Numerics.INumberBase<int>, System.IParsable<int>, System.Numerics.IShiftOperators<int, int, int>, System.Numerics.ISignedNumber<int>, System.ISpanFormattable, System.ISpanParsable<int>, System.Numerics.ISubtractionOperators<int, int, int>, System.Numerics.IUnaryNegationOperators<int, int>, System.Numerics.IUnaryPlusOperators<int, int>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<int>
    {
        static int System.Numerics.INumberBase<int>.Abs(int value) => throw null;
        public static int Abs(int value) => throw null;
        static int System.Numerics.IAdditiveIdentity<int, int>.AdditiveIdentity { get => throw null; }
        static int System.Numerics.IBinaryNumber<int>.AllBitsSet { get => throw null; }
        static int System.Numerics.INumber<int>.Clamp(int value, int min, int max) => throw null;
        public int CompareTo(int value) => throw null;
        public int CompareTo(object value) => throw null;
        static int System.Numerics.INumber<int>.CopySign(int value, int sign) => throw null;
        static int System.Numerics.INumberBase<int>.CreateChecked<TOther>(TOther value) => throw null;
        public static int CreateChecked<TOther>(TOther value) => throw null;
        static int System.Numerics.INumberBase<int>.CreateSaturating<TOther>(TOther value) => throw null;
        public static int CreateSaturating<TOther>(TOther value) => throw null;
        static int System.Numerics.INumberBase<int>.CreateTruncating<TOther>(TOther value) => throw null;
        public static int CreateTruncating<TOther>(TOther value) => throw null;
        static (int Quotient, int Remainder) System.Numerics.IBinaryInteger<int>.DivRem(int left, int right) => throw null;
        public bool Equals(int obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<int>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<int>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<int>.IsCanonical(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsComplexNumber(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsEvenInteger(int value) => throw null;
        public static bool IsEvenInteger(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsFinite(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsImaginaryNumber(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsInfinity(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsInteger(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsNaN(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsNegative(int value) => throw null;
        public static bool IsNegative(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsNegativeInfinity(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsNormal(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsOddInteger(int value) => throw null;
        public static bool IsOddInteger(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsPositive(int value) => throw null;
        public static bool IsPositive(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsPositiveInfinity(int value) => throw null;
        static bool System.Numerics.IBinaryNumber<int>.IsPow2(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsRealNumber(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsSubnormal(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.IsZero(int value) => throw null;
        static int System.Numerics.IBinaryInteger<int>.LeadingZeroCount(int value) => throw null;
        static int System.Numerics.IBinaryNumber<int>.Log2(int value) => throw null;
        static int System.Numerics.INumber<int>.Max(int x, int y) => throw null;
        static int System.Numerics.INumberBase<int>.MaxMagnitude(int x, int y) => throw null;
        public static int MaxMagnitude(int x, int y) => throw null;
        static int System.Numerics.INumberBase<int>.MaxMagnitudeNumber(int x, int y) => throw null;
        static int System.Numerics.INumber<int>.MaxNumber(int x, int y) => throw null;
        public const int MaxValue = 2147483647;
        static int System.Numerics.IMinMaxValue<int>.MaxValue { get => throw null; }
        static int System.Numerics.INumber<int>.Min(int x, int y) => throw null;
        static int System.Numerics.INumberBase<int>.MinMagnitude(int x, int y) => throw null;
        public static int MinMagnitude(int x, int y) => throw null;
        static int System.Numerics.INumberBase<int>.MinMagnitudeNumber(int x, int y) => throw null;
        static int System.Numerics.INumber<int>.MinNumber(int x, int y) => throw null;
        public const int MinValue = -2147483648;
        static int System.Numerics.IMinMaxValue<int>.MinValue { get => throw null; }
        static int System.Numerics.IMultiplicativeIdentity<int, int>.MultiplicativeIdentity { get => throw null; }
        static int System.Numerics.ISignedNumber<int>.NegativeOne { get => throw null; }
        static int System.Numerics.INumberBase<int>.One { get => throw null; }
        static int System.Numerics.IAdditionOperators<int, int, int>.operator +(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator &(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator |(int left, int right) => throw null;
        static int System.Numerics.IAdditionOperators<int, int, int>.operator checked +(int left, int right) => throw null;
        static int System.Numerics.IDecrementOperators<int>.operator checked --(int value) => throw null;
        static int System.Numerics.IIncrementOperators<int>.operator checked ++(int value) => throw null;
        static int System.Numerics.IMultiplyOperators<int, int, int>.operator checked *(int left, int right) => throw null;
        static int System.Numerics.ISubtractionOperators<int, int, int>.operator checked -(int left, int right) => throw null;
        static int System.Numerics.IUnaryNegationOperators<int, int>.operator checked -(int value) => throw null;
        static int System.Numerics.IDecrementOperators<int>.operator --(int value) => throw null;
        static int System.Numerics.IDivisionOperators<int, int, int>.operator /(int left, int right) => throw null;
        static bool System.Numerics.IEqualityOperators<int, int, bool>.operator ==(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator ^(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator >(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator >=(int left, int right) => throw null;
        static int System.Numerics.IIncrementOperators<int>.operator ++(int value) => throw null;
        static bool System.Numerics.IEqualityOperators<int, int, bool>.operator !=(int left, int right) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator <<(int value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator <(int left, int right) => throw null;
        static bool System.Numerics.IComparisonOperators<int, int, bool>.operator <=(int left, int right) => throw null;
        static int System.Numerics.IModulusOperators<int, int, int>.operator %(int left, int right) => throw null;
        static int System.Numerics.IMultiplyOperators<int, int, int>.operator *(int left, int right) => throw null;
        static int System.Numerics.IBitwiseOperators<int, int, int>.operator ~(int value) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator >>(int value, int shiftAmount) => throw null;
        static int System.Numerics.ISubtractionOperators<int, int, int>.operator -(int left, int right) => throw null;
        static int System.Numerics.IUnaryNegationOperators<int, int>.operator -(int value) => throw null;
        static int System.Numerics.IUnaryPlusOperators<int, int>.operator +(int value) => throw null;
        static int System.Numerics.IShiftOperators<int, int, int>.operator >>>(int value, int shiftAmount) => throw null;
        static int System.Numerics.INumberBase<int>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static int Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static int System.IUtf8SpanParsable<int>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static int System.Numerics.INumberBase<int>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static int Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static int System.ISpanParsable<int>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static int Parse(string s) => throw null;
        public static int Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static int System.Numerics.INumberBase<int>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        public static int Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static int System.IParsable<int>.Parse(string s, System.IFormatProvider provider) => throw null;
        static int System.Numerics.IBinaryInteger<int>.PopCount(int value) => throw null;
        static int System.Numerics.INumberBase<int>.Radix { get => throw null; }
        static int System.Numerics.IBinaryInteger<int>.RotateLeft(int value, int rotateAmount) => throw null;
        static int System.Numerics.IBinaryInteger<int>.RotateRight(int value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<int>.Sign(int value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static int System.Numerics.IBinaryInteger<int>.TrailingZeroCount(int value) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromChecked<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromSaturating<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertFromTruncating<TOther>(TOther value, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToChecked<TOther>(int value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToSaturating<TOther>(int value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryConvertToTruncating<TOther>(int value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<int>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        static bool System.IUtf8SpanParsable<int>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        static bool System.ISpanParsable<int>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out int result) => throw null;
        static bool System.Numerics.INumberBase<int>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) => throw null;
        static bool System.IParsable<int>.TryParse(string s, System.IFormatProvider provider, out int result) => throw null;
        public static bool TryParse(string s, out int result) => throw null;
        static bool System.Numerics.IBinaryInteger<int>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out int value) => throw null;
        static bool System.Numerics.IBinaryInteger<int>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out int value) => throw null;
        bool System.Numerics.IBinaryInteger<int>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<int>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static int System.Numerics.INumberBase<int>.Zero { get => throw null; }
    }
    public struct Int64 : System.Numerics.IAdditionOperators<long, long, long>, System.Numerics.IAdditiveIdentity<long, long>, System.Numerics.IBinaryInteger<long>, System.Numerics.IBinaryNumber<long>, System.Numerics.IBitwiseOperators<long, long, long>, System.IComparable, System.IComparable<long>, System.Numerics.IComparisonOperators<long, long, bool>, System.IConvertible, System.Numerics.IDecrementOperators<long>, System.Numerics.IDivisionOperators<long, long, long>, System.Numerics.IEqualityOperators<long, long, bool>, System.IEquatable<long>, System.IFormattable, System.Numerics.IIncrementOperators<long>, System.Numerics.IMinMaxValue<long>, System.Numerics.IModulusOperators<long, long, long>, System.Numerics.IMultiplicativeIdentity<long, long>, System.Numerics.IMultiplyOperators<long, long, long>, System.Numerics.INumber<long>, System.Numerics.INumberBase<long>, System.IParsable<long>, System.Numerics.IShiftOperators<long, int, long>, System.Numerics.ISignedNumber<long>, System.ISpanFormattable, System.ISpanParsable<long>, System.Numerics.ISubtractionOperators<long, long, long>, System.Numerics.IUnaryNegationOperators<long, long>, System.Numerics.IUnaryPlusOperators<long, long>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<long>
    {
        static long System.Numerics.INumberBase<long>.Abs(long value) => throw null;
        static long System.Numerics.IAdditiveIdentity<long, long>.AdditiveIdentity { get => throw null; }
        static long System.Numerics.IBinaryNumber<long>.AllBitsSet { get => throw null; }
        static long System.Numerics.INumber<long>.Clamp(long value, long min, long max) => throw null;
        public int CompareTo(long value) => throw null;
        public int CompareTo(object value) => throw null;
        static long System.Numerics.INumber<long>.CopySign(long value, long sign) => throw null;
        static long System.Numerics.INumberBase<long>.CreateChecked<TOther>(TOther value) => throw null;
        static long System.Numerics.INumberBase<long>.CreateSaturating<TOther>(TOther value) => throw null;
        static long System.Numerics.INumberBase<long>.CreateTruncating<TOther>(TOther value) => throw null;
        static (long Quotient, long Remainder) System.Numerics.IBinaryInteger<long>.DivRem(long left, long right) => throw null;
        public bool Equals(long obj) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<long>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<long>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<long>.IsCanonical(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsComplexNumber(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsEvenInteger(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsFinite(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsImaginaryNumber(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsInfinity(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsInteger(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsNaN(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsNegative(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsNegativeInfinity(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsNormal(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsOddInteger(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsPositive(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsPositiveInfinity(long value) => throw null;
        static bool System.Numerics.IBinaryNumber<long>.IsPow2(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsRealNumber(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsSubnormal(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.IsZero(long value) => throw null;
        static long System.Numerics.IBinaryInteger<long>.LeadingZeroCount(long value) => throw null;
        static long System.Numerics.IBinaryNumber<long>.Log2(long value) => throw null;
        static long System.Numerics.INumber<long>.Max(long x, long y) => throw null;
        static long System.Numerics.INumberBase<long>.MaxMagnitude(long x, long y) => throw null;
        static long System.Numerics.INumberBase<long>.MaxMagnitudeNumber(long x, long y) => throw null;
        static long System.Numerics.INumber<long>.MaxNumber(long x, long y) => throw null;
        public const long MaxValue = 9223372036854775807;
        static long System.Numerics.IMinMaxValue<long>.MaxValue { get => throw null; }
        static long System.Numerics.INumber<long>.Min(long x, long y) => throw null;
        static long System.Numerics.INumberBase<long>.MinMagnitude(long x, long y) => throw null;
        static long System.Numerics.INumberBase<long>.MinMagnitudeNumber(long x, long y) => throw null;
        static long System.Numerics.INumber<long>.MinNumber(long x, long y) => throw null;
        public const long MinValue = -9223372036854775808;
        static long System.Numerics.IMinMaxValue<long>.MinValue { get => throw null; }
        static long System.Numerics.IMultiplicativeIdentity<long, long>.MultiplicativeIdentity { get => throw null; }
        static long System.Numerics.ISignedNumber<long>.NegativeOne { get => throw null; }
        static long System.Numerics.INumberBase<long>.One { get => throw null; }
        static long System.Numerics.IAdditionOperators<long, long, long>.operator +(long left, long right) => throw null;
        static long System.Numerics.IBitwiseOperators<long, long, long>.operator &(long left, long right) => throw null;
        static long System.Numerics.IBitwiseOperators<long, long, long>.operator |(long left, long right) => throw null;
        static long System.Numerics.IAdditionOperators<long, long, long>.operator checked +(long left, long right) => throw null;
        static long System.Numerics.IDecrementOperators<long>.operator checked --(long value) => throw null;
        static long System.Numerics.IIncrementOperators<long>.operator checked ++(long value) => throw null;
        static long System.Numerics.IMultiplyOperators<long, long, long>.operator checked *(long left, long right) => throw null;
        static long System.Numerics.ISubtractionOperators<long, long, long>.operator checked -(long left, long right) => throw null;
        static long System.Numerics.IUnaryNegationOperators<long, long>.operator checked -(long value) => throw null;
        static long System.Numerics.IDecrementOperators<long>.operator --(long value) => throw null;
        static long System.Numerics.IDivisionOperators<long, long, long>.operator /(long left, long right) => throw null;
        static bool System.Numerics.IEqualityOperators<long, long, bool>.operator ==(long left, long right) => throw null;
        static long System.Numerics.IBitwiseOperators<long, long, long>.operator ^(long left, long right) => throw null;
        static bool System.Numerics.IComparisonOperators<long, long, bool>.operator >(long left, long right) => throw null;
        static bool System.Numerics.IComparisonOperators<long, long, bool>.operator >=(long left, long right) => throw null;
        static long System.Numerics.IIncrementOperators<long>.operator ++(long value) => throw null;
        static bool System.Numerics.IEqualityOperators<long, long, bool>.operator !=(long left, long right) => throw null;
        static long System.Numerics.IShiftOperators<long, int, long>.operator <<(long value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<long, long, bool>.operator <(long left, long right) => throw null;
        static bool System.Numerics.IComparisonOperators<long, long, bool>.operator <=(long left, long right) => throw null;
        static long System.Numerics.IModulusOperators<long, long, long>.operator %(long left, long right) => throw null;
        static long System.Numerics.IMultiplyOperators<long, long, long>.operator *(long left, long right) => throw null;
        static long System.Numerics.IBitwiseOperators<long, long, long>.operator ~(long value) => throw null;
        static long System.Numerics.IShiftOperators<long, int, long>.operator >>(long value, int shiftAmount) => throw null;
        static long System.Numerics.ISubtractionOperators<long, long, long>.operator -(long left, long right) => throw null;
        static long System.Numerics.IUnaryNegationOperators<long, long>.operator -(long value) => throw null;
        static long System.Numerics.IUnaryPlusOperators<long, long>.operator +(long value) => throw null;
        static long System.Numerics.IShiftOperators<long, int, long>.operator >>>(long value, int shiftAmount) => throw null;
        static long System.Numerics.INumberBase<long>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static long System.IUtf8SpanParsable<long>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static long System.Numerics.INumberBase<long>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static long System.ISpanParsable<long>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static long Parse(string s) => throw null;
        public static long Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static long System.Numerics.INumberBase<long>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static long System.IParsable<long>.Parse(string s, System.IFormatProvider provider) => throw null;
        static long System.Numerics.IBinaryInteger<long>.PopCount(long value) => throw null;
        static int System.Numerics.INumberBase<long>.Radix { get => throw null; }
        static long System.Numerics.IBinaryInteger<long>.RotateLeft(long value, int rotateAmount) => throw null;
        static long System.Numerics.IBinaryInteger<long>.RotateRight(long value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<long>.Sign(long value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static long System.Numerics.IBinaryInteger<long>.TrailingZeroCount(long value) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertFromChecked<TOther>(TOther value, out long result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertFromSaturating<TOther>(TOther value, out long result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertFromTruncating<TOther>(TOther value, out long result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertToChecked<TOther>(long value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertToSaturating<TOther>(long value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryConvertToTruncating<TOther>(long value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<long>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out long result) => throw null;
        static bool System.IUtf8SpanParsable<long>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out long result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out long result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out long result) => throw null;
        static bool System.ISpanParsable<long>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out long result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out long result) => throw null;
        static bool System.Numerics.INumberBase<long>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out long result) => throw null;
        static bool System.IParsable<long>.TryParse(string s, System.IFormatProvider provider, out long result) => throw null;
        public static bool TryParse(string s, out long result) => throw null;
        static bool System.Numerics.IBinaryInteger<long>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out long value) => throw null;
        static bool System.Numerics.IBinaryInteger<long>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out long value) => throw null;
        bool System.Numerics.IBinaryInteger<long>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<long>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static long System.Numerics.INumberBase<long>.Zero { get => throw null; }
    }
    public struct IntPtr : System.Numerics.IAdditionOperators<nint, nint, nint>, System.Numerics.IAdditiveIdentity<nint, nint>, System.Numerics.IBinaryInteger<nint>, System.Numerics.IBinaryNumber<nint>, System.Numerics.IBitwiseOperators<nint, nint, nint>, System.IComparable, System.IComparable<nint>, System.Numerics.IComparisonOperators<nint, nint, bool>, System.Numerics.IDecrementOperators<nint>, System.Numerics.IDivisionOperators<nint, nint, nint>, System.Numerics.IEqualityOperators<nint, nint, bool>, System.IEquatable<nint>, System.IFormattable, System.Numerics.IIncrementOperators<nint>, System.Numerics.IMinMaxValue<nint>, System.Numerics.IModulusOperators<nint, nint, nint>, System.Numerics.IMultiplicativeIdentity<nint, nint>, System.Numerics.IMultiplyOperators<nint, nint, nint>, System.Numerics.INumber<nint>, System.Numerics.INumberBase<nint>, System.IParsable<nint>, System.Runtime.Serialization.ISerializable, System.Numerics.IShiftOperators<nint, int, nint>, System.Numerics.ISignedNumber<nint>, System.ISpanFormattable, System.ISpanParsable<nint>, System.Numerics.ISubtractionOperators<nint, nint, nint>, System.Numerics.IUnaryNegationOperators<nint, nint>, System.Numerics.IUnaryPlusOperators<nint, nint>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<nint>
    {
        static nint System.Numerics.INumberBase<nint>.Abs(nint value) => throw null;
        public static nint Add(nint pointer, int offset) => throw null;
        static nint System.Numerics.IAdditiveIdentity<nint, nint>.AdditiveIdentity { get => throw null; }
        static nint System.Numerics.IBinaryNumber<nint>.AllBitsSet { get => throw null; }
        static nint System.Numerics.INumber<nint>.Clamp(nint value, nint min, nint max) => throw null;
        public int CompareTo(nint value) => throw null;
        public int CompareTo(object value) => throw null;
        static nint System.Numerics.INumber<nint>.CopySign(nint value, nint sign) => throw null;
        static nint System.Numerics.INumberBase<nint>.CreateChecked<TOther>(TOther value) => throw null;
        static nint System.Numerics.INumberBase<nint>.CreateSaturating<TOther>(TOther value) => throw null;
        static nint System.Numerics.INumberBase<nint>.CreateTruncating<TOther>(TOther value) => throw null;
        public IntPtr(int value) => throw null;
        public IntPtr(long value) => throw null;
        public unsafe IntPtr(void* value) => throw null;
        static (nint Quotient, nint Remainder) System.Numerics.IBinaryInteger<nint>.DivRem(nint left, nint right) => throw null;
        public bool Equals(nint other) => throw null;
        public override bool Equals(object obj) => throw null;
        int System.Numerics.IBinaryInteger<nint>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IBinaryInteger<nint>.GetShortestBitLength() => throw null;
        static bool System.Numerics.INumberBase<nint>.IsCanonical(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsComplexNumber(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsEvenInteger(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsFinite(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsImaginaryNumber(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsInfinity(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsInteger(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsNaN(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsNegative(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsNegativeInfinity(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsNormal(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsOddInteger(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsPositive(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsPositiveInfinity(nint value) => throw null;
        static bool System.Numerics.IBinaryNumber<nint>.IsPow2(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsRealNumber(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsSubnormal(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.IsZero(nint value) => throw null;
        static nint System.Numerics.IBinaryInteger<nint>.LeadingZeroCount(nint value) => throw null;
        static nint System.Numerics.IBinaryNumber<nint>.Log2(nint value) => throw null;
        static nint System.Numerics.INumber<nint>.Max(nint x, nint y) => throw null;
        static nint System.Numerics.INumberBase<nint>.MaxMagnitude(nint x, nint y) => throw null;
        static nint System.Numerics.INumberBase<nint>.MaxMagnitudeNumber(nint x, nint y) => throw null;
        static nint System.Numerics.INumber<nint>.MaxNumber(nint x, nint y) => throw null;
        public static nint MaxValue { get => throw null; }
        static nint System.Numerics.IMinMaxValue<nint>.MaxValue { get => throw null; }
        static nint System.Numerics.INumber<nint>.Min(nint x, nint y) => throw null;
        static nint System.Numerics.INumberBase<nint>.MinMagnitude(nint x, nint y) => throw null;
        static nint System.Numerics.INumberBase<nint>.MinMagnitudeNumber(nint x, nint y) => throw null;
        static nint System.Numerics.INumber<nint>.MinNumber(nint x, nint y) => throw null;
        public static nint MinValue { get => throw null; }
        static nint System.Numerics.IMinMaxValue<nint>.MinValue { get => throw null; }
        static nint System.Numerics.IMultiplicativeIdentity<nint, nint>.MultiplicativeIdentity { get => throw null; }
        static nint System.Numerics.ISignedNumber<nint>.NegativeOne { get => throw null; }
        static nint System.Numerics.INumberBase<nint>.One { get => throw null; }
        public static nint operator +(nint pointer, int offset) => throw null;
        static nint System.Numerics.IAdditionOperators<nint, nint, nint>.operator +(nint left, nint right) => throw null;
        static nint System.Numerics.IBitwiseOperators<nint, nint, nint>.operator &(nint left, nint right) => throw null;
        static nint System.Numerics.IBitwiseOperators<nint, nint, nint>.operator |(nint left, nint right) => throw null;
        static nint System.Numerics.IAdditionOperators<nint, nint, nint>.operator checked +(nint left, nint right) => throw null;
        static nint System.Numerics.IDecrementOperators<nint>.operator checked --(nint value) => throw null;
        static nint System.Numerics.IIncrementOperators<nint>.operator checked ++(nint value) => throw null;
        static nint System.Numerics.IMultiplyOperators<nint, nint, nint>.operator checked *(nint left, nint right) => throw null;
        static nint System.Numerics.ISubtractionOperators<nint, nint, nint>.operator checked -(nint left, nint right) => throw null;
        static nint System.Numerics.IUnaryNegationOperators<nint, nint>.operator checked -(nint value) => throw null;
        static nint System.Numerics.IDecrementOperators<nint>.operator --(nint value) => throw null;
        static nint System.Numerics.IDivisionOperators<nint, nint, nint>.operator /(nint left, nint right) => throw null;
        static bool System.Numerics.IEqualityOperators<nint, nint, bool>.operator ==(nint value1, nint value2) => throw null;
        static nint System.Numerics.IBitwiseOperators<nint, nint, nint>.operator ^(nint left, nint right) => throw null;
        public static explicit operator nint(int value) => throw null;
        public static explicit operator nint(long value) => throw null;
        public static explicit operator int(nint value) => throw null;
        public static explicit operator long(nint value) => throw null;
        public static unsafe explicit operator void*(nint value) => throw null;
        public static unsafe explicit operator nint(void* value) => throw null;
        static bool System.Numerics.IComparisonOperators<nint, nint, bool>.operator >(nint left, nint right) => throw null;
        static bool System.Numerics.IComparisonOperators<nint, nint, bool>.operator >=(nint left, nint right) => throw null;
        static nint System.Numerics.IIncrementOperators<nint>.operator ++(nint value) => throw null;
        static bool System.Numerics.IEqualityOperators<nint, nint, bool>.operator !=(nint value1, nint value2) => throw null;
        static nint System.Numerics.IShiftOperators<nint, int, nint>.operator <<(nint value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<nint, nint, bool>.operator <(nint left, nint right) => throw null;
        static bool System.Numerics.IComparisonOperators<nint, nint, bool>.operator <=(nint left, nint right) => throw null;
        static nint System.Numerics.IModulusOperators<nint, nint, nint>.operator %(nint left, nint right) => throw null;
        static nint System.Numerics.IMultiplyOperators<nint, nint, nint>.operator *(nint left, nint right) => throw null;
        static nint System.Numerics.IBitwiseOperators<nint, nint, nint>.operator ~(nint value) => throw null;
        static nint System.Numerics.IShiftOperators<nint, int, nint>.operator >>(nint value, int shiftAmount) => throw null;
        public static nint operator -(nint pointer, int offset) => throw null;
        static nint System.Numerics.ISubtractionOperators<nint, nint, nint>.operator -(nint left, nint right) => throw null;
        static nint System.Numerics.IUnaryNegationOperators<nint, nint>.operator -(nint value) => throw null;
        static nint System.Numerics.IUnaryPlusOperators<nint, nint>.operator +(nint value) => throw null;
        static nint System.Numerics.IShiftOperators<nint, int, nint>.operator >>>(nint value, int shiftAmount) => throw null;
        static nint System.Numerics.INumberBase<nint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static nint System.IUtf8SpanParsable<nint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static nint System.Numerics.INumberBase<nint>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static nint System.ISpanParsable<nint>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static nint Parse(string s) => throw null;
        public static nint Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static nint System.Numerics.INumberBase<nint>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static nint System.IParsable<nint>.Parse(string s, System.IFormatProvider provider) => throw null;
        static nint System.Numerics.IBinaryInteger<nint>.PopCount(nint value) => throw null;
        static int System.Numerics.INumberBase<nint>.Radix { get => throw null; }
        static nint System.Numerics.IBinaryInteger<nint>.RotateLeft(nint value, int rotateAmount) => throw null;
        static nint System.Numerics.IBinaryInteger<nint>.RotateRight(nint value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<nint>.Sign(nint value) => throw null;
        public static int Size { get => throw null; }
        public static nint Subtract(nint pointer, int offset) => throw null;
        public int ToInt32() => throw null;
        public long ToInt64() => throw null;
        public unsafe void* ToPointer() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        static nint System.Numerics.IBinaryInteger<nint>.TrailingZeroCount(nint value) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertFromChecked<TOther>(TOther value, out nint result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertFromSaturating<TOther>(TOther value, out nint result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertFromTruncating<TOther>(TOther value, out nint result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertToChecked<TOther>(nint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertToSaturating<TOther>(nint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryConvertToTruncating<TOther>(nint value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nint result) => throw null;
        static bool System.IUtf8SpanParsable<nint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out nint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out nint result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nint result) => throw null;
        static bool System.ISpanParsable<nint>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out nint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out nint result) => throw null;
        static bool System.Numerics.INumberBase<nint>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nint result) => throw null;
        static bool System.IParsable<nint>.TryParse(string s, System.IFormatProvider provider, out nint result) => throw null;
        public static bool TryParse(string s, out nint result) => throw null;
        static bool System.Numerics.IBinaryInteger<nint>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out nint value) => throw null;
        static bool System.Numerics.IBinaryInteger<nint>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out nint value) => throw null;
        bool System.Numerics.IBinaryInteger<nint>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<nint>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        public static readonly nint Zero;
        static nint System.Numerics.INumberBase<nint>.Zero { get => throw null; }
    }
    public class InvalidCastException : System.SystemException
    {
        public InvalidCastException() => throw null;
        protected InvalidCastException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidCastException(string message) => throw null;
        public InvalidCastException(string message, System.Exception innerException) => throw null;
        public InvalidCastException(string message, int errorCode) => throw null;
    }
    public class InvalidOperationException : System.SystemException
    {
        public InvalidOperationException() => throw null;
        protected InvalidOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidOperationException(string message) => throw null;
        public InvalidOperationException(string message, System.Exception innerException) => throw null;
    }
    public sealed class InvalidProgramException : System.SystemException
    {
        public InvalidProgramException() => throw null;
        public InvalidProgramException(string message) => throw null;
        public InvalidProgramException(string message, System.Exception inner) => throw null;
    }
    public class InvalidTimeZoneException : System.Exception
    {
        public InvalidTimeZoneException() => throw null;
        protected InvalidTimeZoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public InvalidTimeZoneException(string message) => throw null;
        public InvalidTimeZoneException(string message, System.Exception innerException) => throw null;
    }
    namespace IO
    {
        public class BinaryReader : System.IDisposable
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public virtual void Close() => throw null;
            public BinaryReader(System.IO.Stream input) => throw null;
            public BinaryReader(System.IO.Stream input, System.Text.Encoding encoding) => throw null;
            public BinaryReader(System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            protected virtual void FillBuffer(int numBytes) => throw null;
            public virtual int PeekChar() => throw null;
            public virtual int Read() => throw null;
            public virtual int Read(byte[] buffer, int index, int count) => throw null;
            public virtual int Read(char[] buffer, int index, int count) => throw null;
            public virtual int Read(System.Span<byte> buffer) => throw null;
            public virtual int Read(System.Span<char> buffer) => throw null;
            public int Read7BitEncodedInt() => throw null;
            public long Read7BitEncodedInt64() => throw null;
            public virtual bool ReadBoolean() => throw null;
            public virtual byte ReadByte() => throw null;
            public virtual byte[] ReadBytes(int count) => throw null;
            public virtual char ReadChar() => throw null;
            public virtual char[] ReadChars(int count) => throw null;
            public virtual decimal ReadDecimal() => throw null;
            public virtual double ReadDouble() => throw null;
            public virtual System.Half ReadHalf() => throw null;
            public virtual short ReadInt16() => throw null;
            public virtual int ReadInt32() => throw null;
            public virtual long ReadInt64() => throw null;
            public virtual sbyte ReadSByte() => throw null;
            public virtual float ReadSingle() => throw null;
            public virtual string ReadString() => throw null;
            public virtual ushort ReadUInt16() => throw null;
            public virtual uint ReadUInt32() => throw null;
            public virtual ulong ReadUInt64() => throw null;
        }
        public class BinaryWriter : System.IAsyncDisposable, System.IDisposable
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public virtual void Close() => throw null;
            protected BinaryWriter() => throw null;
            public BinaryWriter(System.IO.Stream output) => throw null;
            public BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding) => throw null;
            public BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding, bool leaveOpen) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public virtual void Flush() => throw null;
            public static readonly System.IO.BinaryWriter Null;
            protected System.IO.Stream OutStream;
            public virtual long Seek(int offset, System.IO.SeekOrigin origin) => throw null;
            public virtual void Write(bool value) => throw null;
            public virtual void Write(byte value) => throw null;
            public virtual void Write(byte[] buffer) => throw null;
            public virtual void Write(byte[] buffer, int index, int count) => throw null;
            public virtual void Write(char ch) => throw null;
            public virtual void Write(char[] chars) => throw null;
            public virtual void Write(char[] chars, int index, int count) => throw null;
            public virtual void Write(decimal value) => throw null;
            public virtual void Write(double value) => throw null;
            public virtual void Write(System.Half value) => throw null;
            public virtual void Write(short value) => throw null;
            public virtual void Write(int value) => throw null;
            public virtual void Write(long value) => throw null;
            public virtual void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public virtual void Write(System.ReadOnlySpan<char> chars) => throw null;
            public virtual void Write(sbyte value) => throw null;
            public virtual void Write(float value) => throw null;
            public virtual void Write(string value) => throw null;
            public virtual void Write(ushort value) => throw null;
            public virtual void Write(uint value) => throw null;
            public virtual void Write(ulong value) => throw null;
            public void Write7BitEncodedInt(int value) => throw null;
            public void Write7BitEncodedInt64(long value) => throw null;
        }
        public sealed class BufferedStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public int BufferSize { get => throw null; }
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public override void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            public BufferedStream(System.IO.Stream stream) => throw null;
            public BufferedStream(System.IO.Stream stream, int bufferSize) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override long Length { get => throw null; }
            public override long Position { get => throw null; set { } }
            public override int Read(byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<byte> destination) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override long Seek(long offset, System.IO.SeekOrigin origin) => throw null;
            public override void SetLength(long value) => throw null;
            public System.IO.Stream UnderlyingStream { get => throw null; }
            public override void Write(byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(byte value) => throw null;
        }
        public static class Directory
        {
            public static System.IO.DirectoryInfo CreateDirectory(string path) => throw null;
            public static System.IO.DirectoryInfo CreateDirectory(string path, System.IO.UnixFileMode unixCreateMode) => throw null;
            public static System.IO.FileSystemInfo CreateSymbolicLink(string path, string pathToTarget) => throw null;
            public static System.IO.DirectoryInfo CreateTempSubdirectory(string prefix = default(string)) => throw null;
            public static void Delete(string path) => throw null;
            public static void Delete(string path, bool recursive) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.DateTime GetCreationTime(string path) => throw null;
            public static System.DateTime GetCreationTimeUtc(string path) => throw null;
            public static string GetCurrentDirectory() => throw null;
            public static string[] GetDirectories(string path) => throw null;
            public static string[] GetDirectories(string path, string searchPattern) => throw null;
            public static string[] GetDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetDirectories(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static string GetDirectoryRoot(string path) => throw null;
            public static string[] GetFiles(string path) => throw null;
            public static string[] GetFiles(string path, string searchPattern) => throw null;
            public static string[] GetFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetFiles(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static string[] GetFileSystemEntries(string path) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public static string[] GetFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public static System.DateTime GetLastAccessTime(string path) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(string path) => throw null;
            public static System.DateTime GetLastWriteTime(string path) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(string path) => throw null;
            public static string[] GetLogicalDrives() => throw null;
            public static System.IO.DirectoryInfo GetParent(string path) => throw null;
            public static void Move(string sourceDirName, string destDirName) => throw null;
            public static System.IO.FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget) => throw null;
            public static void SetCreationTime(string path, System.DateTime creationTime) => throw null;
            public static void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc) => throw null;
            public static void SetCurrentDirectory(string path) => throw null;
            public static void SetLastAccessTime(string path, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastWriteTime(string path, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc) => throw null;
        }
        public sealed class DirectoryInfo : System.IO.FileSystemInfo
        {
            public void Create() => throw null;
            public System.IO.DirectoryInfo CreateSubdirectory(string path) => throw null;
            public DirectoryInfo(string path) => throw null;
            public override void Delete() => throw null;
            public void Delete(bool recursive) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos() => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public override bool Exists { get => throw null; }
            public System.IO.DirectoryInfo[] GetDirectories() => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern) => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.IO.FileInfo[] GetFiles() => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern) => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos() => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions) => throw null;
            public System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption) => throw null;
            public void MoveTo(string destDirName) => throw null;
            public override string Name { get => throw null; }
            public System.IO.DirectoryInfo Parent { get => throw null; }
            public System.IO.DirectoryInfo Root { get => throw null; }
            public override string ToString() => throw null;
        }
        public class DirectoryNotFoundException : System.IO.IOException
        {
            public DirectoryNotFoundException() => throw null;
            protected DirectoryNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public DirectoryNotFoundException(string message) => throw null;
            public DirectoryNotFoundException(string message, System.Exception innerException) => throw null;
        }
        public class EndOfStreamException : System.IO.IOException
        {
            public EndOfStreamException() => throw null;
            protected EndOfStreamException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public EndOfStreamException(string message) => throw null;
            public EndOfStreamException(string message, System.Exception innerException) => throw null;
        }
        namespace Enumeration
        {
            public struct FileSystemEntry
            {
                public System.IO.FileAttributes Attributes { get => throw null; }
                public System.DateTimeOffset CreationTimeUtc { get => throw null; }
                public System.ReadOnlySpan<char> Directory { get => throw null; }
                public System.ReadOnlySpan<char> FileName { get => throw null; }
                public bool IsDirectory { get => throw null; }
                public bool IsHidden { get => throw null; }
                public System.DateTimeOffset LastAccessTimeUtc { get => throw null; }
                public System.DateTimeOffset LastWriteTimeUtc { get => throw null; }
                public long Length { get => throw null; }
                public System.ReadOnlySpan<char> OriginalRootDirectory { get => throw null; }
                public System.ReadOnlySpan<char> RootDirectory { get => throw null; }
                public System.IO.FileSystemInfo ToFileSystemInfo() => throw null;
                public string ToFullPath() => throw null;
                public string ToSpecifiedFullPath() => throw null;
            }
            public class FileSystemEnumerable<TResult> : System.Collections.Generic.IEnumerable<TResult>, System.Collections.IEnumerable
            {
                public FileSystemEnumerable(string directory, System.IO.Enumeration.FileSystemEnumerable<TResult>.FindTransform transform, System.IO.EnumerationOptions options = default(System.IO.EnumerationOptions)) => throw null;
                public delegate bool FindPredicate(ref System.IO.Enumeration.FileSystemEntry entry);
                public delegate TResult FindTransform(ref System.IO.Enumeration.FileSystemEntry entry);
                public System.Collections.Generic.IEnumerator<TResult> GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public System.IO.Enumeration.FileSystemEnumerable<TResult>.FindPredicate ShouldIncludePredicate { get => throw null; set { } }
                public System.IO.Enumeration.FileSystemEnumerable<TResult>.FindPredicate ShouldRecursePredicate { get => throw null; set { } }
            }
            public abstract class FileSystemEnumerator<TResult> : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable, System.Collections.Generic.IEnumerator<TResult>, System.Collections.IEnumerator
            {
                protected virtual bool ContinueOnError(int error) => throw null;
                public FileSystemEnumerator(string directory, System.IO.EnumerationOptions options = default(System.IO.EnumerationOptions)) => throw null;
                public TResult Current { get => throw null; }
                object System.Collections.IEnumerator.Current { get => throw null; }
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public bool MoveNext() => throw null;
                protected virtual void OnDirectoryFinished(System.ReadOnlySpan<char> directory) => throw null;
                public void Reset() => throw null;
                protected virtual bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry) => throw null;
                protected virtual bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry) => throw null;
                protected abstract TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
            }
            public static class FileSystemName
            {
                public static bool MatchesSimpleExpression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase = default(bool)) => throw null;
                public static bool MatchesWin32Expression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase = default(bool)) => throw null;
                public static string TranslateWin32Expression(string expression) => throw null;
            }
        }
        public class EnumerationOptions
        {
            public System.IO.FileAttributes AttributesToSkip { get => throw null; set { } }
            public int BufferSize { get => throw null; set { } }
            public EnumerationOptions() => throw null;
            public bool IgnoreInaccessible { get => throw null; set { } }
            public System.IO.MatchCasing MatchCasing { get => throw null; set { } }
            public System.IO.MatchType MatchType { get => throw null; set { } }
            public int MaxRecursionDepth { get => throw null; set { } }
            public bool RecurseSubdirectories { get => throw null; set { } }
            public bool ReturnSpecialDirectories { get => throw null; set { } }
        }
        public static class File
        {
            public static void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents) => throw null;
            public static void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void AppendAllText(string path, string contents) => throw null;
            public static void AppendAllText(string path, string contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.IO.StreamWriter AppendText(string path) => throw null;
            public static void Copy(string sourceFileName, string destFileName) => throw null;
            public static void Copy(string sourceFileName, string destFileName, bool overwrite) => throw null;
            public static System.IO.FileStream Create(string path) => throw null;
            public static System.IO.FileStream Create(string path, int bufferSize) => throw null;
            public static System.IO.FileStream Create(string path, int bufferSize, System.IO.FileOptions options) => throw null;
            public static System.IO.FileSystemInfo CreateSymbolicLink(string path, string pathToTarget) => throw null;
            public static System.IO.StreamWriter CreateText(string path) => throw null;
            public static void Decrypt(string path) => throw null;
            public static void Delete(string path) => throw null;
            public static void Encrypt(string path) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.IO.FileAttributes GetAttributes(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.IO.FileAttributes GetAttributes(string path) => throw null;
            public static System.DateTime GetCreationTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetCreationTime(string path) => throw null;
            public static System.DateTime GetCreationTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetCreationTimeUtc(string path) => throw null;
            public static System.DateTime GetLastAccessTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastAccessTime(string path) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastAccessTimeUtc(string path) => throw null;
            public static System.DateTime GetLastWriteTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastWriteTime(string path) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.DateTime GetLastWriteTimeUtc(string path) => throw null;
            public static System.IO.UnixFileMode GetUnixFileMode(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle) => throw null;
            public static System.IO.UnixFileMode GetUnixFileMode(string path) => throw null;
            public static void Move(string sourceFileName, string destFileName) => throw null;
            public static void Move(string sourceFileName, string destFileName, bool overwrite) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public static System.IO.FileStream Open(string path, System.IO.FileStreamOptions options) => throw null;
            public static Microsoft.Win32.SafeHandles.SafeFileHandle OpenHandle(string path, System.IO.FileMode mode = default(System.IO.FileMode), System.IO.FileAccess access = default(System.IO.FileAccess), System.IO.FileShare share = default(System.IO.FileShare), System.IO.FileOptions options = default(System.IO.FileOptions), long preallocationSize = default(long)) => throw null;
            public static System.IO.FileStream OpenRead(string path) => throw null;
            public static System.IO.StreamReader OpenText(string path) => throw null;
            public static System.IO.FileStream OpenWrite(string path) => throw null;
            public static byte[] ReadAllBytes(string path) => throw null;
            public static System.Threading.Tasks.Task<byte[]> ReadAllBytesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static string[] ReadAllLines(string path) => throw null;
            public static string[] ReadAllLines(string path, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task<string[]> ReadAllLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task<string[]> ReadAllLinesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static string ReadAllText(string path) => throw null;
            public static string ReadAllText(string path, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Collections.Generic.IEnumerable<string> ReadLines(string path) => throw null;
            public static System.Collections.Generic.IEnumerable<string> ReadLines(string path, System.Text.Encoding encoding) => throw null;
            public static System.Collections.Generic.IAsyncEnumerable<string> ReadLinesAsync(string path, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Collections.Generic.IAsyncEnumerable<string> ReadLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) => throw null;
            public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) => throw null;
            public static System.IO.FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget) => throw null;
            public static void SetAttributes(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.IO.FileAttributes fileAttributes) => throw null;
            public static void SetAttributes(string path, System.IO.FileAttributes fileAttributes) => throw null;
            public static void SetCreationTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime creationTime) => throw null;
            public static void SetCreationTime(string path, System.DateTime creationTime) => throw null;
            public static void SetCreationTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime creationTimeUtc) => throw null;
            public static void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc) => throw null;
            public static void SetLastAccessTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTime(string path, System.DateTime lastAccessTime) => throw null;
            public static void SetLastAccessTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc) => throw null;
            public static void SetLastWriteTime(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTime(string path, System.DateTime lastWriteTime) => throw null;
            public static void SetLastWriteTimeUtc(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.DateTime lastWriteTimeUtc) => throw null;
            public static void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc) => throw null;
            public static void SetUnixFileMode(Microsoft.Win32.SafeHandles.SafeFileHandle fileHandle, System.IO.UnixFileMode mode) => throw null;
            public static void SetUnixFileMode(string path, System.IO.UnixFileMode mode) => throw null;
            public static void WriteAllBytes(string path, byte[] bytes) => throw null;
            public static System.Threading.Tasks.Task WriteAllBytesAsync(string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents) => throw null;
            public static void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding) => throw null;
            public static void WriteAllLines(string path, string[] contents) => throw null;
            public static void WriteAllLines(string path, string[] contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void WriteAllText(string path, string contents) => throw null;
            public static void WriteAllText(string path, string contents, System.Text.Encoding encoding) => throw null;
            public static System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }
        [System.Flags]
        public enum FileAccess
        {
            Read = 1,
            Write = 2,
            ReadWrite = 3,
        }
        [System.Flags]
        public enum FileAttributes
        {
            None = 0,
            ReadOnly = 1,
            Hidden = 2,
            System = 4,
            Directory = 16,
            Archive = 32,
            Device = 64,
            Normal = 128,
            Temporary = 256,
            SparseFile = 512,
            ReparsePoint = 1024,
            Compressed = 2048,
            Offline = 4096,
            NotContentIndexed = 8192,
            Encrypted = 16384,
            IntegrityStream = 32768,
            NoScrubData = 131072,
        }
        public sealed class FileInfo : System.IO.FileSystemInfo
        {
            public System.IO.StreamWriter AppendText() => throw null;
            public System.IO.FileInfo CopyTo(string destFileName) => throw null;
            public System.IO.FileInfo CopyTo(string destFileName, bool overwrite) => throw null;
            public System.IO.FileStream Create() => throw null;
            public System.IO.StreamWriter CreateText() => throw null;
            public FileInfo(string fileName) => throw null;
            public void Decrypt() => throw null;
            public override void Delete() => throw null;
            public System.IO.DirectoryInfo Directory { get => throw null; }
            public string DirectoryName { get => throw null; }
            public void Encrypt() => throw null;
            public override bool Exists { get => throw null; }
            public bool IsReadOnly { get => throw null; set { } }
            public long Length { get => throw null; }
            public void MoveTo(string destFileName) => throw null;
            public void MoveTo(string destFileName, bool overwrite) => throw null;
            public override string Name { get => throw null; }
            public System.IO.FileStream Open(System.IO.FileMode mode) => throw null;
            public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public System.IO.FileStream Open(System.IO.FileStreamOptions options) => throw null;
            public System.IO.FileStream OpenRead() => throw null;
            public System.IO.StreamReader OpenText() => throw null;
            public System.IO.FileStream OpenWrite() => throw null;
            public System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) => throw null;
            public System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) => throw null;
        }
        public class FileLoadException : System.IO.IOException
        {
            public FileLoadException() => throw null;
            protected FileLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public FileLoadException(string message) => throw null;
            public FileLoadException(string message, System.Exception inner) => throw null;
            public FileLoadException(string message, string fileName) => throw null;
            public FileLoadException(string message, string fileName, System.Exception inner) => throw null;
            public string FileName { get => throw null; }
            public string FusionLog { get => throw null; }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public override string Message { get => throw null; }
            public override string ToString() => throw null;
        }
        public enum FileMode
        {
            CreateNew = 1,
            Create = 2,
            Open = 3,
            OpenOrCreate = 4,
            Truncate = 5,
            Append = 6,
        }
        public class FileNotFoundException : System.IO.IOException
        {
            public FileNotFoundException() => throw null;
            protected FileNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public FileNotFoundException(string message) => throw null;
            public FileNotFoundException(string message, System.Exception innerException) => throw null;
            public FileNotFoundException(string message, string fileName) => throw null;
            public FileNotFoundException(string message, string fileName, System.Exception innerException) => throw null;
            public string FileName { get => throw null; }
            public string FusionLog { get => throw null; }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public override string Message { get => throw null; }
            public override string ToString() => throw null;
        }
        [System.Flags]
        public enum FileOptions
        {
            WriteThrough = -2147483648,
            None = 0,
            Encrypted = 16384,
            DeleteOnClose = 67108864,
            SequentialScan = 134217728,
            RandomAccess = 268435456,
            Asynchronous = 1073741824,
        }
        [System.Flags]
        public enum FileShare
        {
            None = 0,
            Read = 1,
            Write = 2,
            ReadWrite = 3,
            Delete = 4,
            Inheritable = 16,
        }
        public class FileStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize) => throw null;
            public FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync) => throw null;
            public FileStream(nint handle, System.IO.FileAccess access) => throw null;
            public FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle) => throw null;
            public FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize) => throw null;
            public FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync) => throw null;
            public FileStream(string path, System.IO.FileMode mode) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync) => throw null;
            public FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options) => throw null;
            public FileStream(string path, System.IO.FileStreamOptions options) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public override void Flush() => throw null;
            public virtual void Flush(bool flushToDisk) => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual nint Handle { get => throw null; }
            public virtual bool IsAsync { get => throw null; }
            public override long Length { get => throw null; }
            public virtual void Lock(long position, long length) => throw null;
            public virtual string Name { get => throw null; }
            public override long Position { get => throw null; set { } }
            public override int Read(byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get => throw null; }
            public override long Seek(long offset, System.IO.SeekOrigin origin) => throw null;
            public override void SetLength(long value) => throw null;
            public virtual void Unlock(long position, long length) => throw null;
            public override void Write(byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(byte value) => throw null;
        }
        public sealed class FileStreamOptions
        {
            public System.IO.FileAccess Access { get => throw null; set { } }
            public int BufferSize { get => throw null; set { } }
            public FileStreamOptions() => throw null;
            public System.IO.FileMode Mode { get => throw null; set { } }
            public System.IO.FileOptions Options { get => throw null; set { } }
            public long PreallocationSize { get => throw null; set { } }
            public System.IO.FileShare Share { get => throw null; set { } }
            public System.IO.UnixFileMode? UnixCreateMode { get => throw null; set { } }
        }
        public abstract class FileSystemInfo : System.MarshalByRefObject, System.Runtime.Serialization.ISerializable
        {
            public System.IO.FileAttributes Attributes { get => throw null; set { } }
            public void CreateAsSymbolicLink(string pathToTarget) => throw null;
            public System.DateTime CreationTime { get => throw null; set { } }
            public System.DateTime CreationTimeUtc { get => throw null; set { } }
            protected FileSystemInfo() => throw null;
            protected FileSystemInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public abstract void Delete();
            public abstract bool Exists { get; }
            public string Extension { get => throw null; }
            public virtual string FullName { get => throw null; }
            protected string FullPath;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.DateTime LastAccessTime { get => throw null; set { } }
            public System.DateTime LastAccessTimeUtc { get => throw null; set { } }
            public System.DateTime LastWriteTime { get => throw null; set { } }
            public System.DateTime LastWriteTimeUtc { get => throw null; set { } }
            public string LinkTarget { get => throw null; }
            public abstract string Name { get; }
            protected string OriginalPath;
            public void Refresh() => throw null;
            public System.IO.FileSystemInfo ResolveLinkTarget(bool returnFinalTarget) => throw null;
            public override string ToString() => throw null;
            public System.IO.UnixFileMode UnixFileMode { get => throw null; set { } }
        }
        public enum HandleInheritability
        {
            None = 0,
            Inheritable = 1,
        }
        public sealed class InvalidDataException : System.SystemException
        {
            public InvalidDataException() => throw null;
            public InvalidDataException(string message) => throw null;
            public InvalidDataException(string message, System.Exception innerException) => throw null;
        }
        public class IOException : System.SystemException
        {
            public IOException() => throw null;
            protected IOException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public IOException(string message) => throw null;
            public IOException(string message, System.Exception innerException) => throw null;
            public IOException(string message, int hresult) => throw null;
        }
        public enum MatchCasing
        {
            PlatformDefault = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
        }
        public enum MatchType
        {
            Simple = 0,
            Win32 = 1,
        }
        public class MemoryStream : System.IO.Stream
        {
            public override System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public virtual int Capacity { get => throw null; set { } }
            public override void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            public MemoryStream() => throw null;
            public MemoryStream(byte[] buffer) => throw null;
            public MemoryStream(byte[] buffer, bool writable) => throw null;
            public MemoryStream(byte[] buffer, int index, int count) => throw null;
            public MemoryStream(byte[] buffer, int index, int count, bool writable) => throw null;
            public MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible) => throw null;
            public MemoryStream(int capacity) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override int EndRead(System.IAsyncResult asyncResult) => throw null;
            public override void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual byte[] GetBuffer() => throw null;
            public override long Length { get => throw null; }
            public override long Position { get => throw null; set { } }
            public override int Read(byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override long Seek(long offset, System.IO.SeekOrigin loc) => throw null;
            public override void SetLength(long value) => throw null;
            public virtual byte[] ToArray() => throw null;
            public virtual bool TryGetBuffer(out System.ArraySegment<byte> buffer) => throw null;
            public override void Write(byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(byte value) => throw null;
            public virtual void WriteTo(System.IO.Stream stream) => throw null;
        }
        public static class Path
        {
            public static readonly char AltDirectorySeparatorChar;
            public static string ChangeExtension(string path, string extension) => throw null;
            public static string Combine(string path1, string path2) => throw null;
            public static string Combine(string path1, string path2, string path3) => throw null;
            public static string Combine(string path1, string path2, string path3, string path4) => throw null;
            public static string Combine(params string[] paths) => throw null;
            public static readonly char DirectorySeparatorChar;
            public static bool EndsInDirectorySeparator(System.ReadOnlySpan<char> path) => throw null;
            public static bool EndsInDirectorySeparator(string path) => throw null;
            public static bool Exists(string path) => throw null;
            public static System.ReadOnlySpan<char> GetDirectoryName(System.ReadOnlySpan<char> path) => throw null;
            public static string GetDirectoryName(string path) => throw null;
            public static System.ReadOnlySpan<char> GetExtension(System.ReadOnlySpan<char> path) => throw null;
            public static string GetExtension(string path) => throw null;
            public static System.ReadOnlySpan<char> GetFileName(System.ReadOnlySpan<char> path) => throw null;
            public static string GetFileName(string path) => throw null;
            public static System.ReadOnlySpan<char> GetFileNameWithoutExtension(System.ReadOnlySpan<char> path) => throw null;
            public static string GetFileNameWithoutExtension(string path) => throw null;
            public static string GetFullPath(string path) => throw null;
            public static string GetFullPath(string path, string basePath) => throw null;
            public static char[] GetInvalidFileNameChars() => throw null;
            public static char[] GetInvalidPathChars() => throw null;
            public static System.ReadOnlySpan<char> GetPathRoot(System.ReadOnlySpan<char> path) => throw null;
            public static string GetPathRoot(string path) => throw null;
            public static string GetRandomFileName() => throw null;
            public static string GetRelativePath(string relativeTo, string path) => throw null;
            public static string GetTempFileName() => throw null;
            public static string GetTempPath() => throw null;
            public static bool HasExtension(System.ReadOnlySpan<char> path) => throw null;
            public static bool HasExtension(string path) => throw null;
            public static readonly char[] InvalidPathChars;
            public static bool IsPathFullyQualified(System.ReadOnlySpan<char> path) => throw null;
            public static bool IsPathFullyQualified(string path) => throw null;
            public static bool IsPathRooted(System.ReadOnlySpan<char> path) => throw null;
            public static bool IsPathRooted(string path) => throw null;
            public static string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2) => throw null;
            public static string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3) => throw null;
            public static string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3, System.ReadOnlySpan<char> path4) => throw null;
            public static string Join(string path1, string path2) => throw null;
            public static string Join(string path1, string path2, string path3) => throw null;
            public static string Join(string path1, string path2, string path3, string path4) => throw null;
            public static string Join(params string[] paths) => throw null;
            public static readonly char PathSeparator;
            public static System.ReadOnlySpan<char> TrimEndingDirectorySeparator(System.ReadOnlySpan<char> path) => throw null;
            public static string TrimEndingDirectorySeparator(string path) => throw null;
            public static bool TryJoin(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3, System.Span<char> destination, out int charsWritten) => throw null;
            public static bool TryJoin(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.Span<char> destination, out int charsWritten) => throw null;
            public static readonly char VolumeSeparatorChar;
        }
        public class PathTooLongException : System.IO.IOException
        {
            public PathTooLongException() => throw null;
            protected PathTooLongException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public PathTooLongException(string message) => throw null;
            public PathTooLongException(string message, System.Exception innerException) => throw null;
        }
        public static class RandomAccess
        {
            public static void FlushToDisk(Microsoft.Win32.SafeHandles.SafeFileHandle handle) => throw null;
            public static long GetLength(Microsoft.Win32.SafeHandles.SafeFileHandle handle) => throw null;
            public static long Read(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.Memory<byte>> buffers, long fileOffset) => throw null;
            public static int Read(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Span<byte> buffer, long fileOffset) => throw null;
            public static System.Threading.Tasks.ValueTask<long> ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.Memory<byte>> buffers, long fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.ValueTask<int> ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Memory<byte> buffer, long fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static void SetLength(Microsoft.Win32.SafeHandles.SafeFileHandle handle, long length) => throw null;
            public static void Write(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.ReadOnlyMemory<byte>> buffers, long fileOffset) => throw null;
            public static void Write(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.ReadOnlySpan<byte> buffer, long fileOffset) => throw null;
            public static System.Threading.Tasks.ValueTask WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList<System.ReadOnlyMemory<byte>> buffers, long fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public static System.Threading.Tasks.ValueTask WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.ReadOnlyMemory<byte> buffer, long fileOffset, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }
        public enum SearchOption
        {
            TopDirectoryOnly = 0,
            AllDirectories = 1,
        }
        public enum SeekOrigin
        {
            Begin = 0,
            Current = 1,
            End = 2,
        }
        public abstract class Stream : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
        {
            public virtual System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public virtual System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) => throw null;
            public abstract bool CanRead { get; }
            public abstract bool CanSeek { get; }
            public virtual bool CanTimeout { get => throw null; }
            public abstract bool CanWrite { get; }
            public virtual void Close() => throw null;
            public void CopyTo(System.IO.Stream destination) => throw null;
            public virtual void CopyTo(System.IO.Stream destination, int bufferSize) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize) => throw null;
            public virtual System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) => throw null;
            public System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, System.Threading.CancellationToken cancellationToken) => throw null;
            protected virtual System.Threading.WaitHandle CreateWaitHandle() => throw null;
            protected Stream() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public virtual int EndRead(System.IAsyncResult asyncResult) => throw null;
            public virtual void EndWrite(System.IAsyncResult asyncResult) => throw null;
            public abstract void Flush();
            public System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public abstract long Length { get; }
            public static readonly System.IO.Stream Null;
            protected virtual void ObjectInvariant() => throw null;
            public abstract long Position { get; set; }
            public abstract int Read(byte[] buffer, int offset, int count);
            public virtual int Read(System.Span<byte> buffer) => throw null;
            public System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public int ReadAtLeast(System.Span<byte> buffer, int minimumBytes, bool throwOnEndOfStream = default(bool)) => throw null;
            public System.Threading.Tasks.ValueTask<int> ReadAtLeastAsync(System.Memory<byte> buffer, int minimumBytes, bool throwOnEndOfStream = default(bool), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadByte() => throw null;
            public void ReadExactly(byte[] buffer, int offset, int count) => throw null;
            public void ReadExactly(System.Span<byte> buffer) => throw null;
            public System.Threading.Tasks.ValueTask ReadExactlyAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public System.Threading.Tasks.ValueTask ReadExactlyAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadTimeout { get => throw null; set { } }
            public abstract long Seek(long offset, System.IO.SeekOrigin origin);
            public abstract void SetLength(long value);
            public static System.IO.Stream Synchronized(System.IO.Stream stream) => throw null;
            protected static void ValidateBufferArguments(byte[] buffer, int offset, int count) => throw null;
            protected static void ValidateCopyToArguments(System.IO.Stream destination, int bufferSize) => throw null;
            public abstract void Write(byte[] buffer, int offset, int count);
            public virtual void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual void WriteByte(byte value) => throw null;
            public virtual int WriteTimeout { get => throw null; set { } }
        }
        public class StreamReader : System.IO.TextReader
        {
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public override void Close() => throw null;
            public StreamReader(System.IO.Stream stream) => throw null;
            public StreamReader(System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize) => throw null;
            public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding = default(System.Text.Encoding), bool detectEncodingFromByteOrderMarks = default(bool), int bufferSize = default(int), bool leaveOpen = default(bool)) => throw null;
            public StreamReader(string path) => throw null;
            public StreamReader(string path, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(string path, System.IO.FileStreamOptions options) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize) => throw null;
            public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options) => throw null;
            public virtual System.Text.Encoding CurrentEncoding { get => throw null; }
            public void DiscardBufferedData() => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public bool EndOfStream { get => throw null; }
            public static readonly System.IO.StreamReader Null;
            public override int Peek() => throw null;
            public override int Read() => throw null;
            public override int Read(char[] buffer, int index, int count) => throw null;
            public override int Read(System.Span<char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadBlock(char[] buffer, int index, int count) => throw null;
            public override int ReadBlock(System.Span<char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override string ReadLine() => throw null;
            public override System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public override System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override string ReadToEnd() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
        }
        public class StreamWriter : System.IO.TextWriter
        {
            public virtual bool AutoFlush { get => throw null; set { } }
            public virtual System.IO.Stream BaseStream { get => throw null; }
            public override void Close() => throw null;
            public StreamWriter(System.IO.Stream stream) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize) => throw null;
            public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding = default(System.Text.Encoding), int bufferSize = default(int), bool leaveOpen = default(bool)) => throw null;
            public StreamWriter(string path) => throw null;
            public StreamWriter(string path, bool append) => throw null;
            public StreamWriter(string path, bool append, System.Text.Encoding encoding) => throw null;
            public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize) => throw null;
            public StreamWriter(string path, System.IO.FileStreamOptions options) => throw null;
            public StreamWriter(string path, System.Text.Encoding encoding, System.IO.FileStreamOptions options) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override System.Text.Encoding Encoding { get => throw null; }
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public static readonly System.IO.StreamWriter Null;
            public override void Write(char value) => throw null;
            public override void Write(char[] buffer) => throw null;
            public override void Write(char[] buffer, int index, int count) => throw null;
            public override void Write(System.ReadOnlySpan<char> buffer) => throw null;
            public override void Write(string value) => throw null;
            public override void Write(string format, object arg0) => throw null;
            public override void Write(string format, object arg0, object arg1) => throw null;
            public override void Write(string format, object arg0, object arg1, object arg2) => throw null;
            public override void Write(string format, params object[] arg) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(char value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public override void WriteLine(System.ReadOnlySpan<char> buffer) => throw null;
            public override void WriteLine(string value) => throw null;
            public override void WriteLine(string format, object arg0) => throw null;
            public override void WriteLine(string format, object arg0, object arg1) => throw null;
            public override void WriteLine(string format, object arg0, object arg1, object arg2) => throw null;
            public override void WriteLine(string format, params object[] arg) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync() => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(char value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
        }
        public class StringReader : System.IO.TextReader
        {
            public override void Close() => throw null;
            public StringReader(string s) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override int Peek() => throw null;
            public override int Read() => throw null;
            public override int Read(char[] buffer, int index, int count) => throw null;
            public override int Read(System.Span<char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadBlock(System.Span<char> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override string ReadLine() => throw null;
            public override System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public override System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public override string ReadToEnd() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public override System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
        }
        public class StringWriter : System.IO.TextWriter
        {
            public override void Close() => throw null;
            public StringWriter() => throw null;
            public StringWriter(System.IFormatProvider formatProvider) => throw null;
            public StringWriter(System.Text.StringBuilder sb) => throw null;
            public StringWriter(System.Text.StringBuilder sb, System.IFormatProvider formatProvider) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override System.Text.Encoding Encoding { get => throw null; }
            public override System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.Text.StringBuilder GetStringBuilder() => throw null;
            public override string ToString() => throw null;
            public override void Write(char value) => throw null;
            public override void Write(char[] buffer, int index, int count) => throw null;
            public override void Write(System.ReadOnlySpan<char> buffer) => throw null;
            public override void Write(string value) => throw null;
            public override void Write(System.Text.StringBuilder value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(char value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteLine(System.ReadOnlySpan<char> buffer) => throw null;
            public override void WriteLine(System.Text.StringBuilder value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(char value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
            public override System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }
        public abstract class TextReader : System.MarshalByRefObject, System.IDisposable
        {
            public virtual void Close() => throw null;
            protected TextReader() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public static readonly System.IO.TextReader Null;
            public virtual int Peek() => throw null;
            public virtual int Read() => throw null;
            public virtual int Read(char[] buffer, int index, int count) => throw null;
            public virtual int Read(System.Span<char> buffer) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual int ReadBlock(char[] buffer, int index, int count) => throw null;
            public virtual int ReadBlock(System.Span<char> buffer) => throw null;
            public virtual System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual string ReadLine() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadLineAsync() => throw null;
            public virtual System.Threading.Tasks.ValueTask<string> ReadLineAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual string ReadToEnd() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadToEndAsync() => throw null;
            public virtual System.Threading.Tasks.Task<string> ReadToEndAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public static System.IO.TextReader Synchronized(System.IO.TextReader reader) => throw null;
        }
        public abstract class TextWriter : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
        {
            public virtual void Close() => throw null;
            protected char[] CoreNewLine;
            protected TextWriter() => throw null;
            protected TextWriter(System.IFormatProvider formatProvider) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public abstract System.Text.Encoding Encoding { get; }
            public virtual void Flush() => throw null;
            public virtual System.Threading.Tasks.Task FlushAsync() => throw null;
            public virtual System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            public virtual System.IFormatProvider FormatProvider { get => throw null; }
            public virtual string NewLine { get => throw null; set { } }
            public static readonly System.IO.TextWriter Null;
            public static System.IO.TextWriter Synchronized(System.IO.TextWriter writer) => throw null;
            public virtual void Write(bool value) => throw null;
            public virtual void Write(char value) => throw null;
            public virtual void Write(char[] buffer) => throw null;
            public virtual void Write(char[] buffer, int index, int count) => throw null;
            public virtual void Write(decimal value) => throw null;
            public virtual void Write(double value) => throw null;
            public virtual void Write(int value) => throw null;
            public virtual void Write(long value) => throw null;
            public virtual void Write(object value) => throw null;
            public virtual void Write(System.ReadOnlySpan<char> buffer) => throw null;
            public virtual void Write(float value) => throw null;
            public virtual void Write(string value) => throw null;
            public virtual void Write(string format, object arg0) => throw null;
            public virtual void Write(string format, object arg0, object arg1) => throw null;
            public virtual void Write(string format, object arg0, object arg1, object arg2) => throw null;
            public virtual void Write(string format, params object[] arg) => throw null;
            public virtual void Write(System.Text.StringBuilder value) => throw null;
            public virtual void Write(uint value) => throw null;
            public virtual void Write(ulong value) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(char value) => throw null;
            public System.Threading.Tasks.Task WriteAsync(char[] buffer) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(string value) => throw null;
            public virtual System.Threading.Tasks.Task WriteAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual void WriteLine() => throw null;
            public virtual void WriteLine(bool value) => throw null;
            public virtual void WriteLine(char value) => throw null;
            public virtual void WriteLine(char[] buffer) => throw null;
            public virtual void WriteLine(char[] buffer, int index, int count) => throw null;
            public virtual void WriteLine(decimal value) => throw null;
            public virtual void WriteLine(double value) => throw null;
            public virtual void WriteLine(int value) => throw null;
            public virtual void WriteLine(long value) => throw null;
            public virtual void WriteLine(object value) => throw null;
            public virtual void WriteLine(System.ReadOnlySpan<char> buffer) => throw null;
            public virtual void WriteLine(float value) => throw null;
            public virtual void WriteLine(string value) => throw null;
            public virtual void WriteLine(string format, object arg0) => throw null;
            public virtual void WriteLine(string format, object arg0, object arg1) => throw null;
            public virtual void WriteLine(string format, object arg0, object arg1, object arg2) => throw null;
            public virtual void WriteLine(string format, params object[] arg) => throw null;
            public virtual void WriteLine(System.Text.StringBuilder value) => throw null;
            public virtual void WriteLine(uint value) => throw null;
            public virtual void WriteLine(ulong value) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync() => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(char value) => throw null;
            public System.Threading.Tasks.Task WriteLineAsync(char[] buffer) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(string value) => throw null;
            public virtual System.Threading.Tasks.Task WriteLineAsync(System.Text.StringBuilder value, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }
        [System.Flags]
        public enum UnixFileMode
        {
            None = 0,
            OtherExecute = 1,
            OtherWrite = 2,
            OtherRead = 4,
            GroupExecute = 8,
            GroupWrite = 16,
            GroupRead = 32,
            UserExecute = 64,
            UserWrite = 128,
            UserRead = 256,
            StickyBit = 512,
            SetGroup = 1024,
            SetUser = 2048,
        }
        public class UnmanagedMemoryStream : System.IO.Stream
        {
            public override bool CanRead { get => throw null; }
            public override bool CanSeek { get => throw null; }
            public override bool CanWrite { get => throw null; }
            public long Capacity { get => throw null; }
            protected UnmanagedMemoryStream() => throw null;
            public unsafe UnmanagedMemoryStream(byte* pointer, long length) => throw null;
            public unsafe UnmanagedMemoryStream(byte* pointer, long length, long capacity, System.IO.FileAccess access) => throw null;
            public UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length) => throw null;
            public UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access) => throw null;
            protected override void Dispose(bool disposing) => throw null;
            public override void Flush() => throw null;
            public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken) => throw null;
            protected unsafe void Initialize(byte* pointer, long length, long capacity, System.IO.FileAccess access) => throw null;
            protected void Initialize(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access) => throw null;
            public override long Length { get => throw null; }
            public override long Position { get => throw null; set { } }
            public unsafe byte* PositionPointer { get => throw null; set { } }
            public override int Read(byte[] buffer, int offset, int count) => throw null;
            public override int Read(System.Span<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override int ReadByte() => throw null;
            public override long Seek(long offset, System.IO.SeekOrigin loc) => throw null;
            public override void SetLength(long value) => throw null;
            public override void Write(byte[] buffer, int offset, int count) => throw null;
            public override void Write(System.ReadOnlySpan<byte> buffer) => throw null;
            public override System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) => throw null;
            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
            public override void WriteByte(byte value) => throw null;
        }
    }
    public interface IObservable<T>
    {
        System.IDisposable Subscribe(System.IObserver<T> observer);
    }
    public interface IObserver<T>
    {
        void OnCompleted();
        void OnError(System.Exception error);
        void OnNext(T value);
    }
    public interface IParsable<TSelf> where TSelf : System.IParsable<TSelf>
    {
        abstract static TSelf Parse(string s, System.IFormatProvider provider);
        abstract static bool TryParse(string s, System.IFormatProvider provider, out TSelf result);
    }
    public interface IProgress<T>
    {
        void Report(T value);
    }
    public interface ISpanFormattable : System.IFormattable
    {
        bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
    }
    public interface ISpanParsable<TSelf> : System.IParsable<TSelf> where TSelf : System.ISpanParsable<TSelf>
    {
        abstract static TSelf Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider);
        abstract static bool TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out TSelf result);
    }
    public interface IUtf8SpanFormattable
    {
        bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
    }
    public interface IUtf8SpanParsable<TSelf> where TSelf : System.IUtf8SpanParsable<TSelf>
    {
        abstract static TSelf Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider);
        abstract static bool TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out TSelf result);
    }
    public class Lazy<T>
    {
        public Lazy() => throw null;
        public Lazy(bool isThreadSafe) => throw null;
        public Lazy(System.Func<T> valueFactory) => throw null;
        public Lazy(System.Func<T> valueFactory, bool isThreadSafe) => throw null;
        public Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(T value) => throw null;
        public bool IsValueCreated { get => throw null; }
        public override string ToString() => throw null;
        public T Value { get => throw null; }
    }
    public class Lazy<T, TMetadata> : System.Lazy<T>
    {
        public Lazy(System.Func<T> valueFactory, TMetadata metadata) => throw null;
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, bool isThreadSafe) => throw null;
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public Lazy(TMetadata metadata) => throw null;
        public Lazy(TMetadata metadata, bool isThreadSafe) => throw null;
        public Lazy(TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) => throw null;
        public TMetadata Metadata { get => throw null; }
    }
    public class LdapStyleUriParser : System.UriParser
    {
        public LdapStyleUriParser() => throw null;
    }
    public enum LoaderOptimization
    {
        NotSpecified = 0,
        SingleDomain = 1,
        MultiDomain = 2,
        DomainMask = 3,
        MultiDomainHost = 3,
        DisallowBindings = 4,
    }
    [System.AttributeUsage((System.AttributeTargets)64)]
    public sealed class LoaderOptimizationAttribute : System.Attribute
    {
        public LoaderOptimizationAttribute(byte value) => throw null;
        public LoaderOptimizationAttribute(System.LoaderOptimization value) => throw null;
        public System.LoaderOptimization Value { get => throw null; }
    }
    public abstract class MarshalByRefObject
    {
        protected MarshalByRefObject() => throw null;
        public object GetLifetimeService() => throw null;
        public virtual object InitializeLifetimeService() => throw null;
        protected System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) => throw null;
    }
    public static class Math
    {
        public static decimal Abs(decimal value) => throw null;
        public static double Abs(double value) => throw null;
        public static short Abs(short value) => throw null;
        public static int Abs(int value) => throw null;
        public static long Abs(long value) => throw null;
        public static nint Abs(nint value) => throw null;
        public static sbyte Abs(sbyte value) => throw null;
        public static float Abs(float value) => throw null;
        public static double Acos(double d) => throw null;
        public static double Acosh(double d) => throw null;
        public static double Asin(double d) => throw null;
        public static double Asinh(double d) => throw null;
        public static double Atan(double d) => throw null;
        public static double Atan2(double y, double x) => throw null;
        public static double Atanh(double d) => throw null;
        public static long BigMul(int a, int b) => throw null;
        public static long BigMul(long a, long b, out long low) => throw null;
        public static ulong BigMul(ulong a, ulong b, out ulong low) => throw null;
        public static double BitDecrement(double x) => throw null;
        public static double BitIncrement(double x) => throw null;
        public static double Cbrt(double d) => throw null;
        public static decimal Ceiling(decimal d) => throw null;
        public static double Ceiling(double a) => throw null;
        public static byte Clamp(byte value, byte min, byte max) => throw null;
        public static decimal Clamp(decimal value, decimal min, decimal max) => throw null;
        public static double Clamp(double value, double min, double max) => throw null;
        public static short Clamp(short value, short min, short max) => throw null;
        public static int Clamp(int value, int min, int max) => throw null;
        public static long Clamp(long value, long min, long max) => throw null;
        public static nint Clamp(nint value, nint min, nint max) => throw null;
        public static sbyte Clamp(sbyte value, sbyte min, sbyte max) => throw null;
        public static float Clamp(float value, float min, float max) => throw null;
        public static ushort Clamp(ushort value, ushort min, ushort max) => throw null;
        public static uint Clamp(uint value, uint min, uint max) => throw null;
        public static ulong Clamp(ulong value, ulong min, ulong max) => throw null;
        public static nuint Clamp(nuint value, nuint min, nuint max) => throw null;
        public static double CopySign(double x, double y) => throw null;
        public static double Cos(double d) => throw null;
        public static double Cosh(double value) => throw null;
        public static int DivRem(int a, int b, out int result) => throw null;
        public static long DivRem(long a, long b, out long result) => throw null;
        public static (byte Quotient, byte Remainder) DivRem(byte left, byte right) => throw null;
        public static (short Quotient, short Remainder) DivRem(short left, short right) => throw null;
        public static (int Quotient, int Remainder) DivRem(int left, int right) => throw null;
        public static (long Quotient, long Remainder) DivRem(long left, long right) => throw null;
        public static (nint Quotient, nint Remainder) DivRem(nint left, nint right) => throw null;
        public static (sbyte Quotient, sbyte Remainder) DivRem(sbyte left, sbyte right) => throw null;
        public static (ushort Quotient, ushort Remainder) DivRem(ushort left, ushort right) => throw null;
        public static (uint Quotient, uint Remainder) DivRem(uint left, uint right) => throw null;
        public static (ulong Quotient, ulong Remainder) DivRem(ulong left, ulong right) => throw null;
        public static (nuint Quotient, nuint Remainder) DivRem(nuint left, nuint right) => throw null;
        public const double E = default;
        public static double Exp(double d) => throw null;
        public static decimal Floor(decimal d) => throw null;
        public static double Floor(double d) => throw null;
        public static double FusedMultiplyAdd(double x, double y, double z) => throw null;
        public static double IEEERemainder(double x, double y) => throw null;
        public static int ILogB(double x) => throw null;
        public static double Log(double d) => throw null;
        public static double Log(double a, double newBase) => throw null;
        public static double Log10(double d) => throw null;
        public static double Log2(double x) => throw null;
        public static byte Max(byte val1, byte val2) => throw null;
        public static decimal Max(decimal val1, decimal val2) => throw null;
        public static double Max(double val1, double val2) => throw null;
        public static short Max(short val1, short val2) => throw null;
        public static int Max(int val1, int val2) => throw null;
        public static long Max(long val1, long val2) => throw null;
        public static nint Max(nint val1, nint val2) => throw null;
        public static sbyte Max(sbyte val1, sbyte val2) => throw null;
        public static float Max(float val1, float val2) => throw null;
        public static ushort Max(ushort val1, ushort val2) => throw null;
        public static uint Max(uint val1, uint val2) => throw null;
        public static ulong Max(ulong val1, ulong val2) => throw null;
        public static nuint Max(nuint val1, nuint val2) => throw null;
        public static double MaxMagnitude(double x, double y) => throw null;
        public static byte Min(byte val1, byte val2) => throw null;
        public static decimal Min(decimal val1, decimal val2) => throw null;
        public static double Min(double val1, double val2) => throw null;
        public static short Min(short val1, short val2) => throw null;
        public static int Min(int val1, int val2) => throw null;
        public static long Min(long val1, long val2) => throw null;
        public static nint Min(nint val1, nint val2) => throw null;
        public static sbyte Min(sbyte val1, sbyte val2) => throw null;
        public static float Min(float val1, float val2) => throw null;
        public static ushort Min(ushort val1, ushort val2) => throw null;
        public static uint Min(uint val1, uint val2) => throw null;
        public static ulong Min(ulong val1, ulong val2) => throw null;
        public static nuint Min(nuint val1, nuint val2) => throw null;
        public static double MinMagnitude(double x, double y) => throw null;
        public const double PI = default;
        public static double Pow(double x, double y) => throw null;
        public static double ReciprocalEstimate(double d) => throw null;
        public static double ReciprocalSqrtEstimate(double d) => throw null;
        public static decimal Round(decimal d) => throw null;
        public static decimal Round(decimal d, int decimals) => throw null;
        public static decimal Round(decimal d, int decimals, System.MidpointRounding mode) => throw null;
        public static decimal Round(decimal d, System.MidpointRounding mode) => throw null;
        public static double Round(double a) => throw null;
        public static double Round(double value, int digits) => throw null;
        public static double Round(double value, int digits, System.MidpointRounding mode) => throw null;
        public static double Round(double value, System.MidpointRounding mode) => throw null;
        public static double ScaleB(double x, int n) => throw null;
        public static int Sign(decimal value) => throw null;
        public static int Sign(double value) => throw null;
        public static int Sign(short value) => throw null;
        public static int Sign(int value) => throw null;
        public static int Sign(long value) => throw null;
        public static int Sign(nint value) => throw null;
        public static int Sign(sbyte value) => throw null;
        public static int Sign(float value) => throw null;
        public static double Sin(double a) => throw null;
        public static (double Sin, double Cos) SinCos(double x) => throw null;
        public static double Sinh(double value) => throw null;
        public static double Sqrt(double d) => throw null;
        public static double Tan(double a) => throw null;
        public static double Tanh(double value) => throw null;
        public const double Tau = default;
        public static decimal Truncate(decimal d) => throw null;
        public static double Truncate(double d) => throw null;
    }
    public static class MathF
    {
        public static float Abs(float x) => throw null;
        public static float Acos(float x) => throw null;
        public static float Acosh(float x) => throw null;
        public static float Asin(float x) => throw null;
        public static float Asinh(float x) => throw null;
        public static float Atan(float x) => throw null;
        public static float Atan2(float y, float x) => throw null;
        public static float Atanh(float x) => throw null;
        public static float BitDecrement(float x) => throw null;
        public static float BitIncrement(float x) => throw null;
        public static float Cbrt(float x) => throw null;
        public static float Ceiling(float x) => throw null;
        public static float CopySign(float x, float y) => throw null;
        public static float Cos(float x) => throw null;
        public static float Cosh(float x) => throw null;
        public const float E = default;
        public static float Exp(float x) => throw null;
        public static float Floor(float x) => throw null;
        public static float FusedMultiplyAdd(float x, float y, float z) => throw null;
        public static float IEEERemainder(float x, float y) => throw null;
        public static int ILogB(float x) => throw null;
        public static float Log(float x) => throw null;
        public static float Log(float x, float y) => throw null;
        public static float Log10(float x) => throw null;
        public static float Log2(float x) => throw null;
        public static float Max(float x, float y) => throw null;
        public static float MaxMagnitude(float x, float y) => throw null;
        public static float Min(float x, float y) => throw null;
        public static float MinMagnitude(float x, float y) => throw null;
        public const float PI = default;
        public static float Pow(float x, float y) => throw null;
        public static float ReciprocalEstimate(float x) => throw null;
        public static float ReciprocalSqrtEstimate(float x) => throw null;
        public static float Round(float x) => throw null;
        public static float Round(float x, int digits) => throw null;
        public static float Round(float x, int digits, System.MidpointRounding mode) => throw null;
        public static float Round(float x, System.MidpointRounding mode) => throw null;
        public static float ScaleB(float x, int n) => throw null;
        public static int Sign(float x) => throw null;
        public static float Sin(float x) => throw null;
        public static (float Sin, float Cos) SinCos(float x) => throw null;
        public static float Sinh(float x) => throw null;
        public static float Sqrt(float x) => throw null;
        public static float Tan(float x) => throw null;
        public static float Tanh(float x) => throw null;
        public const float Tau = default;
        public static float Truncate(float x) => throw null;
    }
    public class MemberAccessException : System.SystemException
    {
        public MemberAccessException() => throw null;
        protected MemberAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MemberAccessException(string message) => throw null;
        public MemberAccessException(string message, System.Exception inner) => throw null;
    }
    public struct Memory<T> : System.IEquatable<System.Memory<T>>
    {
        public void CopyTo(System.Memory<T> destination) => throw null;
        public Memory(T[] array) => throw null;
        public Memory(T[] array, int start, int length) => throw null;
        public static System.Memory<T> Empty { get => throw null; }
        public bool Equals(System.Memory<T> other) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        public static implicit operator System.Memory<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlyMemory<T>(System.Memory<T> memory) => throw null;
        public static implicit operator System.Memory<T>(T[] array) => throw null;
        public System.Buffers.MemoryHandle Pin() => throw null;
        public System.Memory<T> Slice(int start) => throw null;
        public System.Memory<T> Slice(int start, int length) => throw null;
        public System.Span<T> Span { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Memory<T> destination) => throw null;
    }
    public class MethodAccessException : System.MemberAccessException
    {
        public MethodAccessException() => throw null;
        protected MethodAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MethodAccessException(string message) => throw null;
        public MethodAccessException(string message, System.Exception inner) => throw null;
    }
    public enum MidpointRounding
    {
        ToEven = 0,
        AwayFromZero = 1,
        ToZero = 2,
        ToNegativeInfinity = 3,
        ToPositiveInfinity = 4,
    }
    public class MissingFieldException : System.MissingMemberException
    {
        public MissingFieldException() => throw null;
        protected MissingFieldException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingFieldException(string message) => throw null;
        public MissingFieldException(string message, System.Exception inner) => throw null;
        public MissingFieldException(string className, string fieldName) => throw null;
        public override string Message { get => throw null; }
    }
    public class MissingMemberException : System.MemberAccessException
    {
        protected string ClassName;
        public MissingMemberException() => throw null;
        protected MissingMemberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingMemberException(string message) => throw null;
        public MissingMemberException(string message, System.Exception inner) => throw null;
        public MissingMemberException(string className, string memberName) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        protected string MemberName;
        public override string Message { get => throw null; }
        protected byte[] Signature;
    }
    public class MissingMethodException : System.MissingMemberException
    {
        public MissingMethodException() => throw null;
        protected MissingMethodException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public MissingMethodException(string message) => throw null;
        public MissingMethodException(string message, System.Exception inner) => throw null;
        public MissingMethodException(string className, string methodName) => throw null;
        public override string Message { get => throw null; }
    }
    public struct ModuleHandle : System.IEquatable<System.ModuleHandle>
    {
        public static readonly System.ModuleHandle EmptyHandle;
        public bool Equals(System.ModuleHandle handle) => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public System.RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken) => throw null;
        public System.RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken) => throw null;
        public System.RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken) => throw null;
        public int MDStreamVersion { get => throw null; }
        public static bool operator ==(System.ModuleHandle left, System.ModuleHandle right) => throw null;
        public static bool operator !=(System.ModuleHandle left, System.ModuleHandle right) => throw null;
        public System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken) => throw null;
        public System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
        public System.RuntimeMethodHandle ResolveMethodHandle(int methodToken) => throw null;
        public System.RuntimeMethodHandle ResolveMethodHandle(int methodToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
        public System.RuntimeTypeHandle ResolveTypeHandle(int typeToken) => throw null;
        public System.RuntimeTypeHandle ResolveTypeHandle(int typeToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext) => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)64)]
    public sealed class MTAThreadAttribute : System.Attribute
    {
        public MTAThreadAttribute() => throw null;
    }
    public abstract class MulticastDelegate : System.Delegate
    {
        protected override sealed System.Delegate CombineImpl(System.Delegate follow) => throw null;
        protected MulticastDelegate(object target, string method) : base(default(object), default(string)) => throw null;
        protected MulticastDelegate(System.Type target, string method) : base(default(object), default(string)) => throw null;
        public override sealed bool Equals(object obj) => throw null;
        public override sealed int GetHashCode() => throw null;
        public override sealed System.Delegate[] GetInvocationList() => throw null;
        protected override System.Reflection.MethodInfo GetMethodImpl() => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool operator ==(System.MulticastDelegate d1, System.MulticastDelegate d2) => throw null;
        public static bool operator !=(System.MulticastDelegate d1, System.MulticastDelegate d2) => throw null;
        protected override sealed System.Delegate RemoveImpl(System.Delegate value) => throw null;
    }
    public sealed class MulticastNotSupportedException : System.SystemException
    {
        public MulticastNotSupportedException() => throw null;
        public MulticastNotSupportedException(string message) => throw null;
        public MulticastNotSupportedException(string message, System.Exception inner) => throw null;
    }
    namespace Net
    {
        public static class WebUtility
        {
            public static string HtmlDecode(string value) => throw null;
            public static void HtmlDecode(string value, System.IO.TextWriter output) => throw null;
            public static string HtmlEncode(string value) => throw null;
            public static void HtmlEncode(string value, System.IO.TextWriter output) => throw null;
            public static string UrlDecode(string encodedValue) => throw null;
            public static byte[] UrlDecodeToBytes(byte[] encodedValue, int offset, int count) => throw null;
            public static string UrlEncode(string value) => throw null;
            public static byte[] UrlEncodeToBytes(byte[] value, int offset, int count) => throw null;
        }
    }
    public class NetPipeStyleUriParser : System.UriParser
    {
        public NetPipeStyleUriParser() => throw null;
    }
    public class NetTcpStyleUriParser : System.UriParser
    {
        public NetTcpStyleUriParser() => throw null;
    }
    public class NewsStyleUriParser : System.UriParser
    {
        public NewsStyleUriParser() => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
    public sealed class NonSerializedAttribute : System.Attribute
    {
        public NonSerializedAttribute() => throw null;
    }
    public class NotFiniteNumberException : System.ArithmeticException
    {
        public NotFiniteNumberException() => throw null;
        public NotFiniteNumberException(double offendingNumber) => throw null;
        protected NotFiniteNumberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotFiniteNumberException(string message) => throw null;
        public NotFiniteNumberException(string message, double offendingNumber) => throw null;
        public NotFiniteNumberException(string message, double offendingNumber, System.Exception innerException) => throw null;
        public NotFiniteNumberException(string message, System.Exception innerException) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public double OffendingNumber { get => throw null; }
    }
    public class NotImplementedException : System.SystemException
    {
        public NotImplementedException() => throw null;
        protected NotImplementedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotImplementedException(string message) => throw null;
        public NotImplementedException(string message, System.Exception inner) => throw null;
    }
    public class NotSupportedException : System.SystemException
    {
        public NotSupportedException() => throw null;
        protected NotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NotSupportedException(string message) => throw null;
        public NotSupportedException(string message, System.Exception innerException) => throw null;
    }
    public static class Nullable
    {
        public static int Compare<T>(T? n1, T? n2) where T : struct => throw null;
        public static bool Equals<T>(T? n1, T? n2) where T : struct => throw null;
        public static System.Type GetUnderlyingType(System.Type nullableType) => throw null;
        public static T GetValueRefOrDefaultRef<T>(ref readonly T? nullable) where T : struct => throw null;
    }
    public struct Nullable<T> where T : struct
    {
        public Nullable(T value) => throw null;
        public override bool Equals(object other) => throw null;
        public override int GetHashCode() => throw null;
        public T GetValueOrDefault() => throw null;
        public T GetValueOrDefault(T defaultValue) => throw null;
        public bool HasValue { get => throw null; }
        public static explicit operator T(T? value) => throw null;
        public static implicit operator T?(T value) => throw null;
        public override string ToString() => throw null;
        public T Value { get => throw null; }
    }
    public class NullReferenceException : System.SystemException
    {
        public NullReferenceException() => throw null;
        protected NullReferenceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public NullReferenceException(string message) => throw null;
        public NullReferenceException(string message, System.Exception innerException) => throw null;
    }
    namespace Numerics
    {
        public static class BitOperations
        {
            public static uint Crc32C(uint crc, byte data) => throw null;
            public static uint Crc32C(uint crc, ushort data) => throw null;
            public static uint Crc32C(uint crc, uint data) => throw null;
            public static uint Crc32C(uint crc, ulong data) => throw null;
            public static bool IsPow2(int value) => throw null;
            public static bool IsPow2(long value) => throw null;
            public static bool IsPow2(nint value) => throw null;
            public static bool IsPow2(uint value) => throw null;
            public static bool IsPow2(ulong value) => throw null;
            public static bool IsPow2(nuint value) => throw null;
            public static int LeadingZeroCount(uint value) => throw null;
            public static int LeadingZeroCount(ulong value) => throw null;
            public static int LeadingZeroCount(nuint value) => throw null;
            public static int Log2(uint value) => throw null;
            public static int Log2(ulong value) => throw null;
            public static int Log2(nuint value) => throw null;
            public static int PopCount(uint value) => throw null;
            public static int PopCount(ulong value) => throw null;
            public static int PopCount(nuint value) => throw null;
            public static uint RotateLeft(uint value, int offset) => throw null;
            public static ulong RotateLeft(ulong value, int offset) => throw null;
            public static nuint RotateLeft(nuint value, int offset) => throw null;
            public static uint RotateRight(uint value, int offset) => throw null;
            public static ulong RotateRight(ulong value, int offset) => throw null;
            public static nuint RotateRight(nuint value, int offset) => throw null;
            public static uint RoundUpToPowerOf2(uint value) => throw null;
            public static ulong RoundUpToPowerOf2(ulong value) => throw null;
            public static nuint RoundUpToPowerOf2(nuint value) => throw null;
            public static int TrailingZeroCount(int value) => throw null;
            public static int TrailingZeroCount(long value) => throw null;
            public static int TrailingZeroCount(nint value) => throw null;
            public static int TrailingZeroCount(uint value) => throw null;
            public static int TrailingZeroCount(ulong value) => throw null;
            public static int TrailingZeroCount(nuint value) => throw null;
        }
        public interface IAdditionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IAdditionOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator +(TSelf left, TOther right);
            static virtual TResult operator checked +(TSelf left, TOther right) => throw null;
        }
        public interface IAdditiveIdentity<TSelf, TResult> where TSelf : System.Numerics.IAdditiveIdentity<TSelf, TResult>
        {
            abstract static TResult AdditiveIdentity { get; }
        }
        public interface IBinaryFloatingPointIeee754<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBinaryNumber<TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IExponentialFunctions<TSelf>, System.Numerics.IFloatingPoint<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.Numerics.IFloatingPointIeee754<TSelf>, System.IFormattable, System.Numerics.IHyperbolicFunctions<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.ILogarithmicFunctions<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.Numerics.IPowerFunctions<TSelf>, System.Numerics.IRootFunctions<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.ITrigonometricFunctions<TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IBinaryFloatingPointIeee754<TSelf>
        {
        }
        public interface IBinaryInteger<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBinaryNumber<TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.Numerics.IShiftOperators<TSelf, int, TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IBinaryInteger<TSelf>
        {
            static virtual (TSelf Quotient, TSelf Remainder) DivRem(TSelf left, TSelf right) => throw null;
            int GetByteCount();
            int GetShortestBitLength();
            static virtual TSelf LeadingZeroCount(TSelf value) => throw null;
            abstract static TSelf PopCount(TSelf value);
            static virtual TSelf ReadBigEndian(byte[] source, bool isUnsigned) => throw null;
            static virtual TSelf ReadBigEndian(byte[] source, int startIndex, bool isUnsigned) => throw null;
            static virtual TSelf ReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(byte[] source, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(byte[] source, int startIndex, bool isUnsigned) => throw null;
            static virtual TSelf ReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned) => throw null;
            static virtual TSelf RotateLeft(TSelf value, int rotateAmount) => throw null;
            static virtual TSelf RotateRight(TSelf value, int rotateAmount) => throw null;
            abstract static TSelf TrailingZeroCount(TSelf value);
            abstract static bool TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value);
            abstract static bool TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value);
            bool TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten);
            bool TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten);
            virtual int WriteBigEndian(byte[] destination) => throw null;
            virtual int WriteBigEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteBigEndian(System.Span<byte> destination) => throw null;
            virtual int WriteLittleEndian(byte[] destination) => throw null;
            virtual int WriteLittleEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteLittleEndian(System.Span<byte> destination) => throw null;
        }
        public interface IBinaryNumber<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IBinaryNumber<TSelf>
        {
            static virtual TSelf AllBitsSet { get => throw null; }
            abstract static bool IsPow2(TSelf value);
            abstract static TSelf Log2(TSelf value);
        }
        public interface IBitwiseOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IBitwiseOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator &(TSelf left, TOther right);
            abstract static TResult operator |(TSelf left, TOther right);
            abstract static TResult operator ^(TSelf left, TOther right);
            abstract static TResult operator ~(TSelf value);
        }
        public interface IComparisonOperators<TSelf, TOther, TResult> : System.Numerics.IEqualityOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IComparisonOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator >(TSelf left, TOther right);
            abstract static TResult operator >=(TSelf left, TOther right);
            abstract static TResult operator <(TSelf left, TOther right);
            abstract static TResult operator <=(TSelf left, TOther right);
        }
        public interface IDecrementOperators<TSelf> where TSelf : System.Numerics.IDecrementOperators<TSelf>
        {
            static virtual TSelf operator checked --(TSelf value) => throw null;
            abstract static TSelf operator --(TSelf value);
        }
        public interface IDivisionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IDivisionOperators<TSelf, TOther, TResult>
        {
            static virtual TResult operator checked /(TSelf left, TOther right) => throw null;
            abstract static TResult operator /(TSelf left, TOther right);
        }
        public interface IEqualityOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IEqualityOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator ==(TSelf left, TOther right);
            abstract static TResult operator !=(TSelf left, TOther right);
        }
        public interface IExponentialFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IExponentialFunctions<TSelf>
        {
            abstract static TSelf Exp(TSelf x);
            abstract static TSelf Exp10(TSelf x);
            static virtual TSelf Exp10M1(TSelf x) => throw null;
            abstract static TSelf Exp2(TSelf x);
            static virtual TSelf Exp2M1(TSelf x) => throw null;
            static virtual TSelf ExpM1(TSelf x) => throw null;
        }
        public interface IFloatingPoint<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IFloatingPoint<TSelf>
        {
            static virtual TSelf Ceiling(TSelf x) => throw null;
            static virtual TSelf Floor(TSelf x) => throw null;
            int GetExponentByteCount();
            int GetExponentShortestBitLength();
            int GetSignificandBitLength();
            int GetSignificandByteCount();
            static virtual TSelf Round(TSelf x) => throw null;
            static virtual TSelf Round(TSelf x, int digits) => throw null;
            abstract static TSelf Round(TSelf x, int digits, System.MidpointRounding mode);
            static virtual TSelf Round(TSelf x, System.MidpointRounding mode) => throw null;
            static virtual TSelf Truncate(TSelf x) => throw null;
            bool TryWriteExponentBigEndian(System.Span<byte> destination, out int bytesWritten);
            bool TryWriteExponentLittleEndian(System.Span<byte> destination, out int bytesWritten);
            bool TryWriteSignificandBigEndian(System.Span<byte> destination, out int bytesWritten);
            bool TryWriteSignificandLittleEndian(System.Span<byte> destination, out int bytesWritten);
            virtual int WriteExponentBigEndian(byte[] destination) => throw null;
            virtual int WriteExponentBigEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteExponentBigEndian(System.Span<byte> destination) => throw null;
            virtual int WriteExponentLittleEndian(byte[] destination) => throw null;
            virtual int WriteExponentLittleEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteExponentLittleEndian(System.Span<byte> destination) => throw null;
            virtual int WriteSignificandBigEndian(byte[] destination) => throw null;
            virtual int WriteSignificandBigEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteSignificandBigEndian(System.Span<byte> destination) => throw null;
            virtual int WriteSignificandLittleEndian(byte[] destination) => throw null;
            virtual int WriteSignificandLittleEndian(byte[] destination, int startIndex) => throw null;
            virtual int WriteSignificandLittleEndian(System.Span<byte> destination) => throw null;
        }
        public interface IFloatingPointConstants<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IFloatingPointConstants<TSelf>
        {
            abstract static TSelf E { get; }
            abstract static TSelf Pi { get; }
            abstract static TSelf Tau { get; }
        }
        public interface IFloatingPointIeee754<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IExponentialFunctions<TSelf>, System.Numerics.IFloatingPoint<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IHyperbolicFunctions<TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.ILogarithmicFunctions<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.Numerics.IPowerFunctions<TSelf>, System.Numerics.IRootFunctions<TSelf>, System.Numerics.ISignedNumber<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.ITrigonometricFunctions<TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IFloatingPointIeee754<TSelf>
        {
            abstract static TSelf Atan2(TSelf y, TSelf x);
            abstract static TSelf Atan2Pi(TSelf y, TSelf x);
            abstract static TSelf BitDecrement(TSelf x);
            abstract static TSelf BitIncrement(TSelf x);
            abstract static TSelf Epsilon { get; }
            abstract static TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend);
            abstract static TSelf Ieee754Remainder(TSelf left, TSelf right);
            abstract static int ILogB(TSelf x);
            static virtual TSelf Lerp(TSelf value1, TSelf value2, TSelf amount) => throw null;
            abstract static TSelf NaN { get; }
            abstract static TSelf NegativeInfinity { get; }
            abstract static TSelf NegativeZero { get; }
            abstract static TSelf PositiveInfinity { get; }
            static virtual TSelf ReciprocalEstimate(TSelf x) => throw null;
            static virtual TSelf ReciprocalSqrtEstimate(TSelf x) => throw null;
            abstract static TSelf ScaleB(TSelf x, int n);
        }
        public interface IHyperbolicFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IHyperbolicFunctions<TSelf>
        {
            abstract static TSelf Acosh(TSelf x);
            abstract static TSelf Asinh(TSelf x);
            abstract static TSelf Atanh(TSelf x);
            abstract static TSelf Cosh(TSelf x);
            abstract static TSelf Sinh(TSelf x);
            abstract static TSelf Tanh(TSelf x);
        }
        public interface IIncrementOperators<TSelf> where TSelf : System.Numerics.IIncrementOperators<TSelf>
        {
            static virtual TSelf operator checked ++(TSelf value) => throw null;
            abstract static TSelf operator ++(TSelf value);
        }
        public interface ILogarithmicFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.ILogarithmicFunctions<TSelf>
        {
            abstract static TSelf Log(TSelf x);
            abstract static TSelf Log(TSelf x, TSelf newBase);
            abstract static TSelf Log10(TSelf x);
            static virtual TSelf Log10P1(TSelf x) => throw null;
            abstract static TSelf Log2(TSelf x);
            static virtual TSelf Log2P1(TSelf x) => throw null;
            static virtual TSelf LogP1(TSelf x) => throw null;
        }
        public interface IMinMaxValue<TSelf> where TSelf : System.Numerics.IMinMaxValue<TSelf>
        {
            abstract static TSelf MaxValue { get; }
            abstract static TSelf MinValue { get; }
        }
        public interface IModulusOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IModulusOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator %(TSelf left, TOther right);
        }
        public interface IMultiplicativeIdentity<TSelf, TResult> where TSelf : System.Numerics.IMultiplicativeIdentity<TSelf, TResult>
        {
            abstract static TResult MultiplicativeIdentity { get; }
        }
        public interface IMultiplyOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IMultiplyOperators<TSelf, TOther, TResult>
        {
            static virtual TResult operator checked *(TSelf left, TOther right) => throw null;
            abstract static TResult operator *(TSelf left, TOther right);
        }
        public interface INumber<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.IComparable, System.IComparable<TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.INumber<TSelf>
        {
            static virtual TSelf Clamp(TSelf value, TSelf min, TSelf max) => throw null;
            static virtual TSelf CopySign(TSelf value, TSelf sign) => throw null;
            static virtual TSelf Max(TSelf x, TSelf y) => throw null;
            static virtual TSelf MaxNumber(TSelf x, TSelf y) => throw null;
            static virtual TSelf Min(TSelf x, TSelf y) => throw null;
            static virtual TSelf MinNumber(TSelf x, TSelf y) => throw null;
            static virtual int Sign(TSelf value) => throw null;
        }
        public interface INumberBase<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.INumberBase<TSelf>
        {
            abstract static TSelf Abs(TSelf value);
            static virtual TSelf CreateChecked<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            static virtual TSelf CreateSaturating<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            static virtual TSelf CreateTruncating<TOther>(TOther value) where TOther : System.Numerics.INumberBase<TOther> => throw null;
            abstract static bool IsCanonical(TSelf value);
            abstract static bool IsComplexNumber(TSelf value);
            abstract static bool IsEvenInteger(TSelf value);
            abstract static bool IsFinite(TSelf value);
            abstract static bool IsImaginaryNumber(TSelf value);
            abstract static bool IsInfinity(TSelf value);
            abstract static bool IsInteger(TSelf value);
            abstract static bool IsNaN(TSelf value);
            abstract static bool IsNegative(TSelf value);
            abstract static bool IsNegativeInfinity(TSelf value);
            abstract static bool IsNormal(TSelf value);
            abstract static bool IsOddInteger(TSelf value);
            abstract static bool IsPositive(TSelf value);
            abstract static bool IsPositiveInfinity(TSelf value);
            abstract static bool IsRealNumber(TSelf value);
            abstract static bool IsSubnormal(TSelf value);
            abstract static bool IsZero(TSelf value);
            abstract static TSelf MaxMagnitude(TSelf x, TSelf y);
            abstract static TSelf MaxMagnitudeNumber(TSelf x, TSelf y);
            abstract static TSelf MinMagnitude(TSelf x, TSelf y);
            abstract static TSelf MinMagnitudeNumber(TSelf x, TSelf y);
            abstract static TSelf One { get; }
            static virtual TSelf Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
            abstract static TSelf Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
            abstract static TSelf Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
            static TSelf System.IUtf8SpanParsable<TSelf>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
            abstract static int Radix { get; }
            abstract static bool TryConvertFromChecked<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            abstract static bool TryConvertFromSaturating<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            abstract static bool TryConvertFromTruncating<TOther>(TOther value, out TSelf result) where TOther : System.Numerics.INumberBase<TOther>;
            abstract static bool TryConvertToChecked<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            abstract static bool TryConvertToSaturating<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            abstract static bool TryConvertToTruncating<TOther>(TSelf value, out TOther result) where TOther : System.Numerics.INumberBase<TOther>;
            bool System.IUtf8SpanFormattable.TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
            static bool System.IUtf8SpanParsable<TSelf>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out TSelf result) => throw null;
            static virtual bool TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out TSelf result) => throw null;
            abstract static bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out TSelf result);
            abstract static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out TSelf result);
            abstract static TSelf Zero { get; }
        }
        public interface IPowerFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IPowerFunctions<TSelf>
        {
            abstract static TSelf Pow(TSelf x, TSelf y);
        }
        public interface IRootFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IRootFunctions<TSelf>
        {
            abstract static TSelf Cbrt(TSelf x);
            abstract static TSelf Hypot(TSelf x, TSelf y);
            abstract static TSelf RootN(TSelf x, int n);
            abstract static TSelf Sqrt(TSelf x);
        }
        public interface IShiftOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.IShiftOperators<TSelf, TOther, TResult>
        {
            abstract static TResult operator <<(TSelf value, TOther shiftAmount);
            abstract static TResult operator >>(TSelf value, TOther shiftAmount);
            abstract static TResult operator >>>(TSelf value, TOther shiftAmount);
        }
        public interface ISignedNumber<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.ISignedNumber<TSelf>
        {
            abstract static TSelf NegativeOne { get; }
        }
        public interface ISubtractionOperators<TSelf, TOther, TResult> where TSelf : System.Numerics.ISubtractionOperators<TSelf, TOther, TResult>
        {
            static virtual TResult operator checked -(TSelf left, TOther right) => throw null;
            abstract static TResult operator -(TSelf left, TOther right);
        }
        public interface ITrigonometricFunctions<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.Numerics.IFloatingPointConstants<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.ITrigonometricFunctions<TSelf>
        {
            abstract static TSelf Acos(TSelf x);
            abstract static TSelf AcosPi(TSelf x);
            abstract static TSelf Asin(TSelf x);
            abstract static TSelf AsinPi(TSelf x);
            abstract static TSelf Atan(TSelf x);
            abstract static TSelf AtanPi(TSelf x);
            abstract static TSelf Cos(TSelf x);
            abstract static TSelf CosPi(TSelf x);
            static virtual TSelf DegreesToRadians(TSelf degrees) => throw null;
            static virtual TSelf RadiansToDegrees(TSelf radians) => throw null;
            abstract static TSelf Sin(TSelf x);
            abstract static (TSelf Sin, TSelf Cos) SinCos(TSelf x);
            abstract static (TSelf SinPi, TSelf CosPi) SinCosPi(TSelf x);
            abstract static TSelf SinPi(TSelf x);
            abstract static TSelf Tan(TSelf x);
            abstract static TSelf TanPi(TSelf x);
        }
        public interface IUnaryNegationOperators<TSelf, TResult> where TSelf : System.Numerics.IUnaryNegationOperators<TSelf, TResult>
        {
            static virtual TResult operator checked -(TSelf value) => throw null;
            abstract static TResult operator -(TSelf value);
        }
        public interface IUnaryPlusOperators<TSelf, TResult> where TSelf : System.Numerics.IUnaryPlusOperators<TSelf, TResult>
        {
            abstract static TResult operator +(TSelf value);
        }
        public interface IUnsignedNumber<TSelf> : System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.IEquatable<TSelf>, System.IFormattable, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf> where TSelf : System.Numerics.IUnsignedNumber<TSelf>
        {
        }
        public struct TotalOrderIeee754Comparer<T> : System.Collections.Generic.IComparer<T>, System.Collections.Generic.IEqualityComparer<T>, System.IEquatable<System.Numerics.TotalOrderIeee754Comparer<T>> where T : System.Numerics.IFloatingPointIeee754<T>
        {
            public int Compare(T x, T y) => throw null;
            public bool Equals(System.Numerics.TotalOrderIeee754Comparer<T> other) => throw null;
            public override bool Equals(object obj) => throw null;
            public bool Equals(T x, T y) => throw null;
            public override int GetHashCode() => throw null;
            public int GetHashCode(T obj) => throw null;
        }
    }
    public class Object
    {
        public Object() => throw null;
        public virtual bool Equals(object obj) => throw null;
        public static bool Equals(object objA, object objB) => throw null;
        public virtual int GetHashCode() => throw null;
        public System.Type GetType() => throw null;
        protected object MemberwiseClone() => throw null;
        public static bool ReferenceEquals(object objA, object objB) => throw null;
        public virtual string ToString() => throw null;
    }
    public class ObjectDisposedException : System.InvalidOperationException
    {
        protected ObjectDisposedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public ObjectDisposedException(string objectName) => throw null;
        public ObjectDisposedException(string message, System.Exception innerException) => throw null;
        public ObjectDisposedException(string objectName, string message) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public string ObjectName { get => throw null; }
        public static void ThrowIf(bool condition, object instance) => throw null;
        public static void ThrowIf(bool condition, System.Type type) => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)6140, Inherited = false)]
    public sealed class ObsoleteAttribute : System.Attribute
    {
        public ObsoleteAttribute() => throw null;
        public ObsoleteAttribute(string message) => throw null;
        public ObsoleteAttribute(string message, bool error) => throw null;
        public string DiagnosticId { get => throw null; set { } }
        public bool IsError { get => throw null; }
        public string Message { get => throw null; }
        public string UrlFormat { get => throw null; set { } }
    }
    public sealed class OperatingSystem : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        public object Clone() => throw null;
        public OperatingSystem(System.PlatformID platform, System.Version version) => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool IsAndroid() => throw null;
        public static bool IsAndroidVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsBrowser() => throw null;
        public static bool IsFreeBSD() => throw null;
        public static bool IsFreeBSDVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsIOS() => throw null;
        public static bool IsIOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsLinux() => throw null;
        public static bool IsMacCatalyst() => throw null;
        public static bool IsMacCatalystVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsMacOS() => throw null;
        public static bool IsMacOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsOSPlatform(string platform) => throw null;
        public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public static bool IsTvOS() => throw null;
        public static bool IsTvOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsWasi() => throw null;
        public static bool IsWatchOS() => throw null;
        public static bool IsWatchOSVersionAtLeast(int major, int minor = default(int), int build = default(int)) => throw null;
        public static bool IsWindows() => throw null;
        public static bool IsWindowsVersionAtLeast(int major, int minor = default(int), int build = default(int), int revision = default(int)) => throw null;
        public System.PlatformID Platform { get => throw null; }
        public string ServicePack { get => throw null; }
        public override string ToString() => throw null;
        public System.Version Version { get => throw null; }
        public string VersionString { get => throw null; }
    }
    public class OperationCanceledException : System.SystemException
    {
        public System.Threading.CancellationToken CancellationToken { get => throw null; }
        public OperationCanceledException() => throw null;
        protected OperationCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OperationCanceledException(string message) => throw null;
        public OperationCanceledException(string message, System.Exception innerException) => throw null;
        public OperationCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token) => throw null;
        public OperationCanceledException(string message, System.Threading.CancellationToken token) => throw null;
        public OperationCanceledException(System.Threading.CancellationToken token) => throw null;
    }
    public class OutOfMemoryException : System.SystemException
    {
        public OutOfMemoryException() => throw null;
        protected OutOfMemoryException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OutOfMemoryException(string message) => throw null;
        public OutOfMemoryException(string message, System.Exception innerException) => throw null;
    }
    public class OverflowException : System.ArithmeticException
    {
        public OverflowException() => throw null;
        protected OverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public OverflowException(string message) => throw null;
        public OverflowException(string message, System.Exception innerException) => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)2048, Inherited = true, AllowMultiple = false)]
    public sealed class ParamArrayAttribute : System.Attribute
    {
        public ParamArrayAttribute() => throw null;
    }
    public enum PlatformID
    {
        Win32S = 0,
        Win32Windows = 1,
        Win32NT = 2,
        WinCE = 3,
        Unix = 4,
        Xbox = 5,
        MacOSX = 6,
        Other = 7,
    }
    public class PlatformNotSupportedException : System.NotSupportedException
    {
        public PlatformNotSupportedException() => throw null;
        protected PlatformNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public PlatformNotSupportedException(string message) => throw null;
        public PlatformNotSupportedException(string message, System.Exception inner) => throw null;
    }
    public delegate bool Predicate<T>(T obj);
    public class Progress<T> : System.IProgress<T>
    {
        public Progress() => throw null;
        public Progress(System.Action<T> handler) => throw null;
        protected virtual void OnReport(T value) => throw null;
        public event System.EventHandler<T> ProgressChanged;
        void System.IProgress<T>.Report(T value) => throw null;
    }
    public class Random
    {
        public Random() => throw null;
        public Random(int Seed) => throw null;
        public T[] GetItems<T>(System.ReadOnlySpan<T> choices, int length) => throw null;
        public void GetItems<T>(System.ReadOnlySpan<T> choices, System.Span<T> destination) => throw null;
        public T[] GetItems<T>(T[] choices, int length) => throw null;
        public virtual int Next() => throw null;
        public virtual int Next(int maxValue) => throw null;
        public virtual int Next(int minValue, int maxValue) => throw null;
        public virtual void NextBytes(byte[] buffer) => throw null;
        public virtual void NextBytes(System.Span<byte> buffer) => throw null;
        public virtual double NextDouble() => throw null;
        public virtual long NextInt64() => throw null;
        public virtual long NextInt64(long maxValue) => throw null;
        public virtual long NextInt64(long minValue, long maxValue) => throw null;
        public virtual float NextSingle() => throw null;
        protected virtual double Sample() => throw null;
        public static System.Random Shared { get => throw null; }
        public void Shuffle<T>(System.Span<T> values) => throw null;
        public void Shuffle<T>(T[] values) => throw null;
    }
    public struct Range : System.IEquatable<System.Range>
    {
        public static System.Range All { get => throw null; }
        public Range(System.Index start, System.Index end) => throw null;
        public System.Index End { get => throw null; }
        public static System.Range EndAt(System.Index end) => throw null;
        public override bool Equals(object value) => throw null;
        public bool Equals(System.Range other) => throw null;
        public override int GetHashCode() => throw null;
        public (int Offset, int Length) GetOffsetAndLength(int length) => throw null;
        public System.Index Start { get => throw null; }
        public static System.Range StartAt(System.Index start) => throw null;
        public override string ToString() => throw null;
    }
    public class RankException : System.SystemException
    {
        public RankException() => throw null;
        protected RankException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public RankException(string message) => throw null;
        public RankException(string message, System.Exception innerException) => throw null;
    }
    public struct ReadOnlyMemory<T> : System.IEquatable<System.ReadOnlyMemory<T>>
    {
        public void CopyTo(System.Memory<T> destination) => throw null;
        public ReadOnlyMemory(T[] array) => throw null;
        public ReadOnlyMemory(T[] array, int start, int length) => throw null;
        public static System.ReadOnlyMemory<T> Empty { get => throw null; }
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.ReadOnlyMemory<T> other) => throw null;
        public override int GetHashCode() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        public static implicit operator System.ReadOnlyMemory<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlyMemory<T>(T[] array) => throw null;
        public System.Buffers.MemoryHandle Pin() => throw null;
        public System.ReadOnlyMemory<T> Slice(int start) => throw null;
        public System.ReadOnlyMemory<T> Slice(int start, int length) => throw null;
        public System.ReadOnlySpan<T> Span { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Memory<T> destination) => throw null;
    }
    public struct ReadOnlySpan<T>
    {
        public void CopyTo(System.Span<T> destination) => throw null;
        public unsafe ReadOnlySpan(void* pointer, int length) => throw null;
        public ReadOnlySpan(T[] array) => throw null;
        public ReadOnlySpan(T[] array, int start, int length) => throw null;
        public ReadOnlySpan(ref readonly T reference) => throw null;
        public static System.ReadOnlySpan<T> Empty { get => throw null; }
        public struct Enumerator
        {
            public T Current { get => throw null; }
            public bool MoveNext() => throw null;
        }
        public override bool Equals(object obj) => throw null;
        public System.ReadOnlySpan<T>.Enumerator GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public T GetPinnableReference() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        public static bool operator ==(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(T[] array) => throw null;
        public static bool operator !=(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right) => throw null;
        public System.ReadOnlySpan<T> Slice(int start) => throw null;
        public System.ReadOnlySpan<T> Slice(int start, int length) => throw null;
        public T this[int index] { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Span<T> destination) => throw null;
    }
    namespace Reflection
    {
        public sealed class AmbiguousMatchException : System.SystemException
        {
            public AmbiguousMatchException() => throw null;
            public AmbiguousMatchException(string message) => throw null;
            public AmbiguousMatchException(string message, System.Exception inner) => throw null;
        }
        public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable
        {
            public virtual string CodeBase { get => throw null; }
            public object CreateInstance(string typeName) => throw null;
            public object CreateInstance(string typeName, bool ignoreCase) => throw null;
            public virtual object CreateInstance(string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes) => throw null;
            public static string CreateQualifiedName(string assemblyName, string typeName) => throw null;
            protected Assembly() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> DefinedTypes { get => throw null; }
            public virtual System.Reflection.MethodInfo EntryPoint { get => throw null; }
            public override bool Equals(object o) => throw null;
            public virtual string EscapedCodeBase { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Type> ExportedTypes { get => throw null; }
            public virtual string FullName { get => throw null; }
            public static System.Reflection.Assembly GetAssembly(System.Type type) => throw null;
            public static System.Reflection.Assembly GetCallingAssembly() => throw null;
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public static System.Reflection.Assembly GetEntryAssembly() => throw null;
            public static System.Reflection.Assembly GetExecutingAssembly() => throw null;
            public virtual System.Type[] GetExportedTypes() => throw null;
            public virtual System.IO.FileStream GetFile(string name) => throw null;
            public virtual System.IO.FileStream[] GetFiles() => throw null;
            public virtual System.IO.FileStream[] GetFiles(bool getResourceModules) => throw null;
            public virtual System.Type[] GetForwardedTypes() => throw null;
            public override int GetHashCode() => throw null;
            public System.Reflection.Module[] GetLoadedModules() => throw null;
            public virtual System.Reflection.Module[] GetLoadedModules(bool getResourceModules) => throw null;
            public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) => throw null;
            public virtual string[] GetManifestResourceNames() => throw null;
            public virtual System.IO.Stream GetManifestResourceStream(string name) => throw null;
            public virtual System.IO.Stream GetManifestResourceStream(System.Type type, string name) => throw null;
            public virtual System.Reflection.Module GetModule(string name) => throw null;
            public System.Reflection.Module[] GetModules() => throw null;
            public virtual System.Reflection.Module[] GetModules(bool getResourceModules) => throw null;
            public virtual System.Reflection.AssemblyName GetName() => throw null;
            public virtual System.Reflection.AssemblyName GetName(bool copiedName) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies() => throw null;
            public virtual System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture) => throw null;
            public virtual System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version) => throw null;
            public virtual System.Type GetType(string name) => throw null;
            public virtual System.Type GetType(string name, bool throwOnError) => throw null;
            public virtual System.Type GetType(string name, bool throwOnError, bool ignoreCase) => throw null;
            public virtual System.Type[] GetTypes() => throw null;
            public virtual bool GlobalAssemblyCache { get => throw null; }
            public virtual long HostContext { get => throw null; }
            public virtual string ImageRuntimeVersion { get => throw null; }
            public virtual bool IsCollectible { get => throw null; }
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public virtual bool IsDynamic { get => throw null; }
            public bool IsFullyTrusted { get => throw null; }
            public static System.Reflection.Assembly Load(byte[] rawAssembly) => throw null;
            public static System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore) => throw null;
            public static System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef) => throw null;
            public static System.Reflection.Assembly Load(string assemblyString) => throw null;
            public static System.Reflection.Assembly LoadFile(string path) => throw null;
            public static System.Reflection.Assembly LoadFrom(string assemblyFile) => throw null;
            public static System.Reflection.Assembly LoadFrom(string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) => throw null;
            public System.Reflection.Module LoadModule(string moduleName, byte[] rawModule) => throw null;
            public virtual System.Reflection.Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore) => throw null;
            public static System.Reflection.Assembly LoadWithPartialName(string partialName) => throw null;
            public virtual string Location { get => throw null; }
            public virtual System.Reflection.Module ManifestModule { get => throw null; }
            public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.Module> Modules { get => throw null; }
            public static bool operator ==(System.Reflection.Assembly left, System.Reflection.Assembly right) => throw null;
            public static bool operator !=(System.Reflection.Assembly left, System.Reflection.Assembly right) => throw null;
            public virtual bool ReflectionOnly { get => throw null; }
            public static System.Reflection.Assembly ReflectionOnlyLoad(byte[] rawAssembly) => throw null;
            public static System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) => throw null;
            public static System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) => throw null;
            public virtual System.Security.SecurityRuleSet SecurityRuleSet { get => throw null; }
            public override string ToString() => throw null;
            public static System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyAlgorithmIdAttribute : System.Attribute
        {
            public uint AlgorithmId { get => throw null; }
            public AssemblyAlgorithmIdAttribute(System.Configuration.Assemblies.AssemblyHashAlgorithm algorithmId) => throw null;
            public AssemblyAlgorithmIdAttribute(uint algorithmId) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyCompanyAttribute : System.Attribute
        {
            public string Company { get => throw null; }
            public AssemblyCompanyAttribute(string company) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyConfigurationAttribute : System.Attribute
        {
            public string Configuration { get => throw null; }
            public AssemblyConfigurationAttribute(string configuration) => throw null;
        }
        public enum AssemblyContentType
        {
            Default = 0,
            WindowsRuntime = 1,
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyCopyrightAttribute : System.Attribute
        {
            public string Copyright { get => throw null; }
            public AssemblyCopyrightAttribute(string copyright) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyCultureAttribute : System.Attribute
        {
            public AssemblyCultureAttribute(string culture) => throw null;
            public string Culture { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyDefaultAliasAttribute : System.Attribute
        {
            public AssemblyDefaultAliasAttribute(string defaultAlias) => throw null;
            public string DefaultAlias { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyDelaySignAttribute : System.Attribute
        {
            public AssemblyDelaySignAttribute(bool delaySign) => throw null;
            public bool DelaySign { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyDescriptionAttribute : System.Attribute
        {
            public AssemblyDescriptionAttribute(string description) => throw null;
            public string Description { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyFileVersionAttribute : System.Attribute
        {
            public AssemblyFileVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyFlagsAttribute : System.Attribute
        {
            public int AssemblyFlags { get => throw null; }
            public AssemblyFlagsAttribute(int assemblyFlags) => throw null;
            public AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags assemblyFlags) => throw null;
            public AssemblyFlagsAttribute(uint flags) => throw null;
            public uint Flags { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyInformationalVersionAttribute : System.Attribute
        {
            public AssemblyInformationalVersionAttribute(string informationalVersion) => throw null;
            public string InformationalVersion { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyKeyFileAttribute : System.Attribute
        {
            public AssemblyKeyFileAttribute(string keyFile) => throw null;
            public string KeyFile { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyKeyNameAttribute : System.Attribute
        {
            public AssemblyKeyNameAttribute(string keyName) => throw null;
            public string KeyName { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = true, Inherited = false)]
        public sealed class AssemblyMetadataAttribute : System.Attribute
        {
            public AssemblyMetadataAttribute(string key, string value) => throw null;
            public string Key { get => throw null; }
            public string Value { get => throw null; }
        }
        public sealed class AssemblyName : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public object Clone() => throw null;
            public string CodeBase { get => throw null; set { } }
            public System.Reflection.AssemblyContentType ContentType { get => throw null; set { } }
            public AssemblyName() => throw null;
            public AssemblyName(string assemblyName) => throw null;
            public System.Globalization.CultureInfo CultureInfo { get => throw null; set { } }
            public string CultureName { get => throw null; set { } }
            public string EscapedCodeBase { get => throw null; }
            public System.Reflection.AssemblyNameFlags Flags { get => throw null; set { } }
            public string FullName { get => throw null; }
            public static System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) => throw null;
            public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public byte[] GetPublicKey() => throw null;
            public byte[] GetPublicKeyToken() => throw null;
            public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get => throw null; set { } }
            public System.Reflection.StrongNameKeyPair KeyPair { get => throw null; set { } }
            public string Name { get => throw null; set { } }
            public void OnDeserialization(object sender) => throw null;
            public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get => throw null; set { } }
            public static bool ReferenceMatchesDefinition(System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition) => throw null;
            public void SetPublicKey(byte[] publicKey) => throw null;
            public void SetPublicKeyToken(byte[] publicKeyToken) => throw null;
            public override string ToString() => throw null;
            public System.Version Version { get => throw null; set { } }
            public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get => throw null; set { } }
        }
        [System.Flags]
        public enum AssemblyNameFlags
        {
            None = 0,
            PublicKey = 1,
            Retargetable = 256,
            EnableJITcompileOptimizer = 16384,
            EnableJITcompileTracking = 32768,
        }
        public class AssemblyNameProxy : System.MarshalByRefObject
        {
            public AssemblyNameProxy() => throw null;
            public System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyProductAttribute : System.Attribute
        {
            public AssemblyProductAttribute(string product) => throw null;
            public string Product { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false, AllowMultiple = false)]
        public sealed class AssemblySignatureKeyAttribute : System.Attribute
        {
            public string Countersignature { get => throw null; }
            public AssemblySignatureKeyAttribute(string publicKey, string countersignature) => throw null;
            public string PublicKey { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyTitleAttribute : System.Attribute
        {
            public AssemblyTitleAttribute(string title) => throw null;
            public string Title { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyTrademarkAttribute : System.Attribute
        {
            public AssemblyTrademarkAttribute(string trademark) => throw null;
            public string Trademark { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyVersionAttribute : System.Attribute
        {
            public AssemblyVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }
        public abstract class Binder
        {
            public abstract System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);
            public abstract System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);
            public abstract object ChangeType(object value, System.Type type, System.Globalization.CultureInfo culture);
            protected Binder() => throw null;
            public abstract void ReorderArgumentArray(ref object[] args, object state);
            public abstract System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            public abstract System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
        }
        [System.Flags]
        public enum BindingFlags
        {
            Default = 0,
            IgnoreCase = 1,
            DeclaredOnly = 2,
            Instance = 4,
            Static = 8,
            Public = 16,
            NonPublic = 32,
            FlattenHierarchy = 64,
            InvokeMethod = 256,
            CreateInstance = 512,
            GetField = 1024,
            SetField = 2048,
            GetProperty = 4096,
            SetProperty = 8192,
            PutDispProperty = 16384,
            PutRefDispProperty = 32768,
            ExactBinding = 65536,
            SuppressChangeType = 131072,
            OptionalParamBinding = 262144,
            IgnoreReturn = 16777216,
            DoNotWrapExceptions = 33554432,
        }
        [System.Flags]
        public enum CallingConventions
        {
            Standard = 1,
            VarArgs = 2,
            Any = 3,
            HasThis = 32,
            ExplicitThis = 64,
        }
        public abstract class ConstructorInfo : System.Reflection.MethodBase
        {
            public static readonly string ConstructorName;
            protected ConstructorInfo() => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public object Invoke(object[] parameters) => throw null;
            public abstract object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static bool operator ==(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right) => throw null;
            public static bool operator !=(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right) => throw null;
            public static readonly string TypeConstructorName;
        }
        public sealed class ConstructorInvoker
        {
            public static System.Reflection.ConstructorInvoker Create(System.Reflection.ConstructorInfo constructor) => throw null;
            public object Invoke(System.Span<object> arguments) => throw null;
            public object Invoke() => throw null;
            public object Invoke(object arg1) => throw null;
            public object Invoke(object arg1, object arg2) => throw null;
            public object Invoke(object arg1, object arg2, object arg3) => throw null;
            public object Invoke(object arg1, object arg2, object arg3, object arg4) => throw null;
        }
        public class CustomAttributeData
        {
            public virtual System.Type AttributeType { get => throw null; }
            public virtual System.Reflection.ConstructorInfo Constructor { get => throw null; }
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ConstructorArguments { get => throw null; }
            protected CustomAttributeData() => throw null;
            public override bool Equals(object obj) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Assembly target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.MemberInfo target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Module target) => throw null;
            public static System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.ParameterInfo target) => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> NamedArguments { get => throw null; }
            public override string ToString() => throw null;
        }
        public static partial class CustomAttributeExtensions
        {
            public static System.Attribute GetCustomAttribute(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static System.Attribute GetCustomAttribute(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.Assembly element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.MemberInfo element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.MemberInfo element, bool inherit) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.Module element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.ParameterInfo element) where T : System.Attribute => throw null;
            public static T GetCustomAttribute<T>(this System.Reflection.ParameterInfo element, bool inherit) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Assembly element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Module element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.Assembly element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.MemberInfo element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.MemberInfo element, bool inherit) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.Module element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.ParameterInfo element) where T : System.Attribute => throw null;
            public static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(this System.Reflection.ParameterInfo element, bool inherit) where T : System.Attribute => throw null;
            public static bool IsDefined(this System.Reflection.Assembly element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.MemberInfo element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.MemberInfo element, System.Type attributeType, bool inherit) => throw null;
            public static bool IsDefined(this System.Reflection.Module element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.ParameterInfo element, System.Type attributeType) => throw null;
            public static bool IsDefined(this System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit) => throw null;
        }
        public class CustomAttributeFormatException : System.FormatException
        {
            public CustomAttributeFormatException() => throw null;
            protected CustomAttributeFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public CustomAttributeFormatException(string message) => throw null;
            public CustomAttributeFormatException(string message, System.Exception inner) => throw null;
        }
        public struct CustomAttributeNamedArgument : System.IEquatable<System.Reflection.CustomAttributeNamedArgument>
        {
            public CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, object value) => throw null;
            public CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, System.Reflection.CustomAttributeTypedArgument typedArgument) => throw null;
            public bool Equals(System.Reflection.CustomAttributeNamedArgument other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsField { get => throw null; }
            public System.Reflection.MemberInfo MemberInfo { get => throw null; }
            public string MemberName { get => throw null; }
            public static bool operator ==(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right) => throw null;
            public static bool operator !=(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right) => throw null;
            public override string ToString() => throw null;
            public System.Reflection.CustomAttributeTypedArgument TypedValue { get => throw null; }
        }
        public struct CustomAttributeTypedArgument : System.IEquatable<System.Reflection.CustomAttributeTypedArgument>
        {
            public System.Type ArgumentType { get => throw null; }
            public CustomAttributeTypedArgument(object value) => throw null;
            public CustomAttributeTypedArgument(System.Type argumentType, object value) => throw null;
            public override bool Equals(object obj) => throw null;
            public bool Equals(System.Reflection.CustomAttributeTypedArgument other) => throw null;
            public override int GetHashCode() => throw null;
            public static bool operator ==(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right) => throw null;
            public static bool operator !=(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right) => throw null;
            public override string ToString() => throw null;
            public object Value { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1036)]
        public sealed class DefaultMemberAttribute : System.Attribute
        {
            public DefaultMemberAttribute(string memberName) => throw null;
            public string MemberName { get => throw null; }
        }
        [System.Flags]
        public enum EventAttributes
        {
            None = 0,
            SpecialName = 512,
            ReservedMask = 1024,
            RTSpecialName = 1024,
        }
        public abstract class EventInfo : System.Reflection.MemberInfo
        {
            public virtual void AddEventHandler(object target, System.Delegate handler) => throw null;
            public virtual System.Reflection.MethodInfo AddMethod { get => throw null; }
            public abstract System.Reflection.EventAttributes Attributes { get; }
            protected EventInfo() => throw null;
            public override bool Equals(object obj) => throw null;
            public virtual System.Type EventHandlerType { get => throw null; }
            public System.Reflection.MethodInfo GetAddMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            public override int GetHashCode() => throw null;
            public System.Reflection.MethodInfo[] GetOtherMethods() => throw null;
            public virtual System.Reflection.MethodInfo[] GetOtherMethods(bool nonPublic) => throw null;
            public System.Reflection.MethodInfo GetRaiseMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            public System.Reflection.MethodInfo GetRemoveMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            public virtual bool IsMulticast { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static bool operator ==(System.Reflection.EventInfo left, System.Reflection.EventInfo right) => throw null;
            public static bool operator !=(System.Reflection.EventInfo left, System.Reflection.EventInfo right) => throw null;
            public virtual System.Reflection.MethodInfo RaiseMethod { get => throw null; }
            public virtual void RemoveEventHandler(object target, System.Delegate handler) => throw null;
            public virtual System.Reflection.MethodInfo RemoveMethod { get => throw null; }
        }
        public class ExceptionHandlingClause
        {
            public virtual System.Type CatchType { get => throw null; }
            protected ExceptionHandlingClause() => throw null;
            public virtual int FilterOffset { get => throw null; }
            public virtual System.Reflection.ExceptionHandlingClauseOptions Flags { get => throw null; }
            public virtual int HandlerLength { get => throw null; }
            public virtual int HandlerOffset { get => throw null; }
            public override string ToString() => throw null;
            public virtual int TryLength { get => throw null; }
            public virtual int TryOffset { get => throw null; }
        }
        [System.Flags]
        public enum ExceptionHandlingClauseOptions
        {
            Clause = 0,
            Filter = 1,
            Finally = 2,
            Fault = 4,
        }
        [System.Flags]
        public enum FieldAttributes
        {
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            FieldAccessMask = 7,
            Static = 16,
            InitOnly = 32,
            Literal = 64,
            NotSerialized = 128,
            HasFieldRVA = 256,
            SpecialName = 512,
            RTSpecialName = 1024,
            HasFieldMarshal = 4096,
            PinvokeImpl = 8192,
            HasDefault = 32768,
            ReservedMask = 38144,
        }
        public abstract class FieldInfo : System.Reflection.MemberInfo
        {
            public abstract System.Reflection.FieldAttributes Attributes { get; }
            protected FieldInfo() => throw null;
            public override bool Equals(object obj) => throw null;
            public abstract System.RuntimeFieldHandle FieldHandle { get; }
            public abstract System.Type FieldType { get; }
            public static System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle) => throw null;
            public static System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle, System.RuntimeTypeHandle declaringType) => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Type GetModifiedFieldType() => throw null;
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public virtual object GetRawConstantValue() => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public abstract object GetValue(object obj);
            public virtual object GetValueDirect(System.TypedReference obj) => throw null;
            public bool IsAssembly { get => throw null; }
            public bool IsFamily { get => throw null; }
            public bool IsFamilyAndAssembly { get => throw null; }
            public bool IsFamilyOrAssembly { get => throw null; }
            public bool IsInitOnly { get => throw null; }
            public bool IsLiteral { get => throw null; }
            public bool IsNotSerialized { get => throw null; }
            public bool IsPinvokeImpl { get => throw null; }
            public bool IsPrivate { get => throw null; }
            public bool IsPublic { get => throw null; }
            public virtual bool IsSecurityCritical { get => throw null; }
            public virtual bool IsSecuritySafeCritical { get => throw null; }
            public virtual bool IsSecurityTransparent { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public bool IsStatic { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static bool operator ==(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right) => throw null;
            public static bool operator !=(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right) => throw null;
            public void SetValue(object obj, object value) => throw null;
            public abstract void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            public virtual void SetValueDirect(System.TypedReference obj, object value) => throw null;
        }
        [System.Flags]
        public enum GenericParameterAttributes
        {
            None = 0,
            Covariant = 1,
            Contravariant = 2,
            VarianceMask = 3,
            ReferenceTypeConstraint = 4,
            NotNullableValueTypeConstraint = 8,
            DefaultConstructorConstraint = 16,
            SpecialConstraintMask = 28,
        }
        public interface ICustomAttributeProvider
        {
            object[] GetCustomAttributes(bool inherit);
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            bool IsDefined(System.Type attributeType, bool inherit);
        }
        public enum ImageFileMachine
        {
            I386 = 332,
            ARM = 452,
            IA64 = 512,
            AMD64 = 34404,
        }
        public struct InterfaceMapping
        {
            public System.Reflection.MethodInfo[] InterfaceMethods;
            public System.Type InterfaceType;
            public System.Reflection.MethodInfo[] TargetMethods;
            public System.Type TargetType;
        }
        public static partial class IntrospectionExtensions
        {
            public static System.Reflection.TypeInfo GetTypeInfo(this System.Type type) => throw null;
        }
        public class InvalidFilterCriteriaException : System.ApplicationException
        {
            public InvalidFilterCriteriaException() => throw null;
            protected InvalidFilterCriteriaException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public InvalidFilterCriteriaException(string message) => throw null;
            public InvalidFilterCriteriaException(string message, System.Exception inner) => throw null;
        }
        public interface IReflect
        {
            System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            System.Type UnderlyingSystemType { get; }
        }
        public interface IReflectableType
        {
            System.Reflection.TypeInfo GetTypeInfo();
        }
        public class LocalVariableInfo
        {
            protected LocalVariableInfo() => throw null;
            public virtual bool IsPinned { get => throw null; }
            public virtual int LocalIndex { get => throw null; }
            public virtual System.Type LocalType { get => throw null; }
            public override string ToString() => throw null;
        }
        public class ManifestResourceInfo
        {
            public ManifestResourceInfo(System.Reflection.Assembly containingAssembly, string containingFileName, System.Reflection.ResourceLocation resourceLocation) => throw null;
            public virtual string FileName { get => throw null; }
            public virtual System.Reflection.Assembly ReferencedAssembly { get => throw null; }
            public virtual System.Reflection.ResourceLocation ResourceLocation { get => throw null; }
        }
        public delegate bool MemberFilter(System.Reflection.MemberInfo m, object filterCriteria);
        public abstract class MemberInfo : System.Reflection.ICustomAttributeProvider
        {
            protected MemberInfo() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public abstract System.Type DeclaringType { get; }
            public override bool Equals(object obj) => throw null;
            public abstract object[] GetCustomAttributes(bool inherit);
            public abstract object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public override int GetHashCode() => throw null;
            public virtual bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other) => throw null;
            public virtual bool IsCollectible { get => throw null; }
            public abstract bool IsDefined(System.Type attributeType, bool inherit);
            public abstract System.Reflection.MemberTypes MemberType { get; }
            public virtual int MetadataToken { get => throw null; }
            public virtual System.Reflection.Module Module { get => throw null; }
            public abstract string Name { get; }
            public static bool operator ==(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right) => throw null;
            public static bool operator !=(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right) => throw null;
            public abstract System.Type ReflectedType { get; }
        }
        [System.Flags]
        public enum MemberTypes
        {
            Constructor = 1,
            Event = 2,
            Field = 4,
            Method = 8,
            Property = 16,
            TypeInfo = 32,
            Custom = 64,
            NestedType = 128,
            All = 191,
        }
        [System.Flags]
        public enum MethodAttributes
        {
            PrivateScope = 0,
            ReuseSlot = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            MemberAccessMask = 7,
            UnmanagedExport = 8,
            Static = 16,
            Final = 32,
            Virtual = 64,
            HideBySig = 128,
            NewSlot = 256,
            VtableLayoutMask = 256,
            CheckAccessOnOverride = 512,
            Abstract = 1024,
            SpecialName = 2048,
            RTSpecialName = 4096,
            PinvokeImpl = 8192,
            HasSecurity = 16384,
            RequireSecObject = 32768,
            ReservedMask = 53248,
        }
        public abstract class MethodBase : System.Reflection.MemberInfo
        {
            public abstract System.Reflection.MethodAttributes Attributes { get; }
            public virtual System.Reflection.CallingConventions CallingConvention { get => throw null; }
            public virtual bool ContainsGenericParameters { get => throw null; }
            protected MethodBase() => throw null;
            public override bool Equals(object obj) => throw null;
            public static System.Reflection.MethodBase GetCurrentMethod() => throw null;
            public virtual System.Type[] GetGenericArguments() => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Reflection.MethodBody GetMethodBody() => throw null;
            public static System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle) => throw null;
            public static System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle, System.RuntimeTypeHandle declaringType) => throw null;
            public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            public abstract System.Reflection.ParameterInfo[] GetParameters();
            public object Invoke(object obj, object[] parameters) => throw null;
            public abstract object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            public bool IsAbstract { get => throw null; }
            public bool IsAssembly { get => throw null; }
            public virtual bool IsConstructedGenericMethod { get => throw null; }
            public bool IsConstructor { get => throw null; }
            public bool IsFamily { get => throw null; }
            public bool IsFamilyAndAssembly { get => throw null; }
            public bool IsFamilyOrAssembly { get => throw null; }
            public bool IsFinal { get => throw null; }
            public virtual bool IsGenericMethod { get => throw null; }
            public virtual bool IsGenericMethodDefinition { get => throw null; }
            public bool IsHideBySig { get => throw null; }
            public bool IsPrivate { get => throw null; }
            public bool IsPublic { get => throw null; }
            public virtual bool IsSecurityCritical { get => throw null; }
            public virtual bool IsSecuritySafeCritical { get => throw null; }
            public virtual bool IsSecurityTransparent { get => throw null; }
            public bool IsSpecialName { get => throw null; }
            public bool IsStatic { get => throw null; }
            public bool IsVirtual { get => throw null; }
            public abstract System.RuntimeMethodHandle MethodHandle { get; }
            public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get => throw null; }
            public static bool operator ==(System.Reflection.MethodBase left, System.Reflection.MethodBase right) => throw null;
            public static bool operator !=(System.Reflection.MethodBase left, System.Reflection.MethodBase right) => throw null;
        }
        public class MethodBody
        {
            protected MethodBody() => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.ExceptionHandlingClause> ExceptionHandlingClauses { get => throw null; }
            public virtual byte[] GetILAsByteArray() => throw null;
            public virtual bool InitLocals { get => throw null; }
            public virtual int LocalSignatureMetadataToken { get => throw null; }
            public virtual System.Collections.Generic.IList<System.Reflection.LocalVariableInfo> LocalVariables { get => throw null; }
            public virtual int MaxStackSize { get => throw null; }
        }
        public enum MethodImplAttributes
        {
            IL = 0,
            Managed = 0,
            Native = 1,
            OPTIL = 2,
            CodeTypeMask = 3,
            Runtime = 3,
            ManagedMask = 4,
            Unmanaged = 4,
            NoInlining = 8,
            ForwardRef = 16,
            Synchronized = 32,
            NoOptimization = 64,
            PreserveSig = 128,
            AggressiveInlining = 256,
            AggressiveOptimization = 512,
            InternalCall = 4096,
            MaxMethodImplVal = 65535,
        }
        public abstract class MethodInfo : System.Reflection.MethodBase
        {
            public virtual System.Delegate CreateDelegate(System.Type delegateType) => throw null;
            public virtual System.Delegate CreateDelegate(System.Type delegateType, object target) => throw null;
            public T CreateDelegate<T>() where T : System.Delegate => throw null;
            public T CreateDelegate<T>(object target) where T : System.Delegate => throw null;
            protected MethodInfo() => throw null;
            public override bool Equals(object obj) => throw null;
            public abstract System.Reflection.MethodInfo GetBaseDefinition();
            public override System.Type[] GetGenericArguments() => throw null;
            public virtual System.Reflection.MethodInfo GetGenericMethodDefinition() => throw null;
            public override int GetHashCode() => throw null;
            public virtual System.Reflection.MethodInfo MakeGenericMethod(params System.Type[] typeArguments) => throw null;
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static bool operator ==(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right) => throw null;
            public static bool operator !=(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right) => throw null;
            public virtual System.Reflection.ParameterInfo ReturnParameter { get => throw null; }
            public virtual System.Type ReturnType { get => throw null; }
            public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
        }
        public sealed class MethodInvoker
        {
            public static System.Reflection.MethodInvoker Create(System.Reflection.MethodBase method) => throw null;
            public object Invoke(object obj, System.Span<object> arguments) => throw null;
            public object Invoke(object obj) => throw null;
            public object Invoke(object obj, object arg1) => throw null;
            public object Invoke(object obj, object arg1, object arg2) => throw null;
            public object Invoke(object obj, object arg1, object arg2, object arg3) => throw null;
            public object Invoke(object obj, object arg1, object arg2, object arg3, object arg4) => throw null;
        }
        public sealed class Missing : System.Runtime.Serialization.ISerializable
        {
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public static readonly System.Reflection.Missing Value;
        }
        public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable
        {
            public virtual System.Reflection.Assembly Assembly { get => throw null; }
            protected Module() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public override bool Equals(object o) => throw null;
            public static readonly System.Reflection.TypeFilter FilterTypeName;
            public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;
            public virtual System.Type[] FindTypes(System.Reflection.TypeFilter filter, object filterCriteria) => throw null;
            public virtual string FullyQualifiedName { get => throw null; }
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public System.Reflection.FieldInfo GetField(string name) => throw null;
            public virtual System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public System.Reflection.FieldInfo[] GetFields() => throw null;
            public virtual System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingFlags) => throw null;
            public override int GetHashCode() => throw null;
            public System.Reflection.MethodInfo GetMethod(string name) => throw null;
            public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types) => throw null;
            protected virtual System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public System.Reflection.MethodInfo[] GetMethods() => throw null;
            public virtual System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingFlags) => throw null;
            public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual void GetPEKind(out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine) => throw null;
            public virtual System.Type GetType(string className) => throw null;
            public virtual System.Type GetType(string className, bool ignoreCase) => throw null;
            public virtual System.Type GetType(string className, bool throwOnError, bool ignoreCase) => throw null;
            public virtual System.Type[] GetTypes() => throw null;
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public virtual bool IsResource() => throw null;
            public virtual int MDStreamVersion { get => throw null; }
            public virtual int MetadataToken { get => throw null; }
            public System.ModuleHandle ModuleHandle { get => throw null; }
            public virtual System.Guid ModuleVersionId { get => throw null; }
            public virtual string Name { get => throw null; }
            public static bool operator ==(System.Reflection.Module left, System.Reflection.Module right) => throw null;
            public static bool operator !=(System.Reflection.Module left, System.Reflection.Module right) => throw null;
            public System.Reflection.FieldInfo ResolveField(int metadataToken) => throw null;
            public virtual System.Reflection.FieldInfo ResolveField(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public System.Reflection.MemberInfo ResolveMember(int metadataToken) => throw null;
            public virtual System.Reflection.MemberInfo ResolveMember(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public System.Reflection.MethodBase ResolveMethod(int metadataToken) => throw null;
            public virtual System.Reflection.MethodBase ResolveMethod(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public virtual byte[] ResolveSignature(int metadataToken) => throw null;
            public virtual string ResolveString(int metadataToken) => throw null;
            public System.Type ResolveType(int metadataToken) => throw null;
            public virtual System.Type ResolveType(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments) => throw null;
            public virtual string ScopeName { get => throw null; }
            public override string ToString() => throw null;
        }
        public delegate System.Reflection.Module ModuleResolveEventHandler(object sender, System.ResolveEventArgs e);
        public sealed class NullabilityInfo
        {
            public System.Reflection.NullabilityInfo ElementType { get => throw null; }
            public System.Reflection.NullabilityInfo[] GenericTypeArguments { get => throw null; }
            public System.Reflection.NullabilityState ReadState { get => throw null; }
            public System.Type Type { get => throw null; }
            public System.Reflection.NullabilityState WriteState { get => throw null; }
        }
        public sealed class NullabilityInfoContext
        {
            public System.Reflection.NullabilityInfo Create(System.Reflection.EventInfo eventInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.FieldInfo fieldInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.ParameterInfo parameterInfo) => throw null;
            public System.Reflection.NullabilityInfo Create(System.Reflection.PropertyInfo propertyInfo) => throw null;
            public NullabilityInfoContext() => throw null;
        }
        public enum NullabilityState
        {
            Unknown = 0,
            NotNull = 1,
            Nullable = 2,
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
        public sealed class ObfuscateAssemblyAttribute : System.Attribute
        {
            public bool AssemblyIsPrivate { get => throw null; }
            public ObfuscateAssemblyAttribute(bool assemblyIsPrivate) => throw null;
            public bool StripAfterObfuscation { get => throw null; set { } }
        }
        [System.AttributeUsage((System.AttributeTargets)8157, AllowMultiple = true, Inherited = false)]
        public sealed class ObfuscationAttribute : System.Attribute
        {
            public bool ApplyToMembers { get => throw null; set { } }
            public ObfuscationAttribute() => throw null;
            public bool Exclude { get => throw null; set { } }
            public string Feature { get => throw null; set { } }
            public bool StripAfterObfuscation { get => throw null; set { } }
        }
        [System.Flags]
        public enum ParameterAttributes
        {
            None = 0,
            In = 1,
            Out = 2,
            Lcid = 4,
            Retval = 8,
            Optional = 16,
            HasDefault = 4096,
            HasFieldMarshal = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 61440,
        }
        public class ParameterInfo : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.IObjectReference
        {
            public virtual System.Reflection.ParameterAttributes Attributes { get => throw null; }
            protected System.Reflection.ParameterAttributes AttrsImpl;
            protected System.Type ClassImpl;
            protected ParameterInfo() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes { get => throw null; }
            public virtual object DefaultValue { get => throw null; }
            protected object DefaultValueImpl;
            public virtual object[] GetCustomAttributes(bool inherit) => throw null;
            public virtual object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public virtual System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData() => throw null;
            public virtual System.Type GetModifiedParameterType() => throw null;
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public object GetRealObject(System.Runtime.Serialization.StreamingContext context) => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public virtual bool HasDefaultValue { get => throw null; }
            public virtual bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public bool IsIn { get => throw null; }
            public bool IsLcid { get => throw null; }
            public bool IsOptional { get => throw null; }
            public bool IsOut { get => throw null; }
            public bool IsRetval { get => throw null; }
            public virtual System.Reflection.MemberInfo Member { get => throw null; }
            protected System.Reflection.MemberInfo MemberImpl;
            public virtual int MetadataToken { get => throw null; }
            public virtual string Name { get => throw null; }
            protected string NameImpl;
            public virtual System.Type ParameterType { get => throw null; }
            public virtual int Position { get => throw null; }
            protected int PositionImpl;
            public virtual object RawDefaultValue { get => throw null; }
            public override string ToString() => throw null;
        }
        public struct ParameterModifier
        {
            public ParameterModifier(int parameterCount) => throw null;
            public bool this[int index] { get => throw null; set { } }
        }
        public sealed class Pointer : System.Runtime.Serialization.ISerializable
        {
            public static unsafe object Box(void* ptr, System.Type type) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public static unsafe void* Unbox(object ptr) => throw null;
        }
        [System.Flags]
        public enum PortableExecutableKinds
        {
            NotAPortableExecutableImage = 0,
            ILOnly = 1,
            Required32Bit = 2,
            PE32Plus = 4,
            Unmanaged32Bit = 8,
            Preferred32Bit = 16,
        }
        public enum ProcessorArchitecture
        {
            None = 0,
            MSIL = 1,
            X86 = 2,
            IA64 = 3,
            Amd64 = 4,
            Arm = 5,
        }
        [System.Flags]
        public enum PropertyAttributes
        {
            None = 0,
            SpecialName = 512,
            RTSpecialName = 1024,
            HasDefault = 4096,
            Reserved2 = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 62464,
        }
        public abstract class PropertyInfo : System.Reflection.MemberInfo
        {
            public abstract System.Reflection.PropertyAttributes Attributes { get; }
            public abstract bool CanRead { get; }
            public abstract bool CanWrite { get; }
            protected PropertyInfo() => throw null;
            public override bool Equals(object obj) => throw null;
            public System.Reflection.MethodInfo[] GetAccessors() => throw null;
            public abstract System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
            public virtual object GetConstantValue() => throw null;
            public System.Reflection.MethodInfo GetGetMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            public override int GetHashCode() => throw null;
            public abstract System.Reflection.ParameterInfo[] GetIndexParameters();
            public virtual System.Reflection.MethodInfo GetMethod { get => throw null; }
            public virtual System.Type GetModifiedPropertyType() => throw null;
            public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
            public virtual object GetRawConstantValue() => throw null;
            public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
            public System.Reflection.MethodInfo GetSetMethod() => throw null;
            public abstract System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            public object GetValue(object obj) => throw null;
            public virtual object GetValue(object obj, object[] index) => throw null;
            public abstract object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            public bool IsSpecialName { get => throw null; }
            public override System.Reflection.MemberTypes MemberType { get => throw null; }
            public static bool operator ==(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right) => throw null;
            public static bool operator !=(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right) => throw null;
            public abstract System.Type PropertyType { get; }
            public virtual System.Reflection.MethodInfo SetMethod { get => throw null; }
            public void SetValue(object obj, object value) => throw null;
            public virtual void SetValue(object obj, object value, object[] index) => throw null;
            public abstract void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
        }
        public abstract class ReflectionContext
        {
            protected ReflectionContext() => throw null;
            public virtual System.Reflection.TypeInfo GetTypeForObject(object value) => throw null;
            public abstract System.Reflection.Assembly MapAssembly(System.Reflection.Assembly assembly);
            public abstract System.Reflection.TypeInfo MapType(System.Reflection.TypeInfo type);
        }
        public sealed class ReflectionTypeLoadException : System.SystemException
        {
            public ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions) => throw null;
            public ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions, string message) => throw null;
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.Exception[] LoaderExceptions { get => throw null; }
            public override string Message { get => throw null; }
            public override string ToString() => throw null;
            public System.Type[] Types { get => throw null; }
        }
        [System.Flags]
        public enum ResourceAttributes
        {
            Public = 1,
            Private = 2,
        }
        [System.Flags]
        public enum ResourceLocation
        {
            Embedded = 1,
            ContainedInAnotherAssembly = 2,
            ContainedInManifestFile = 4,
        }
        public static partial class RuntimeReflectionExtensions
        {
            public static System.Reflection.MethodInfo GetMethodInfo(this System.Delegate del) => throw null;
            public static System.Reflection.MethodInfo GetRuntimeBaseDefinition(this System.Reflection.MethodInfo method) => throw null;
            public static System.Reflection.EventInfo GetRuntimeEvent(this System.Type type, string name) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> GetRuntimeEvents(this System.Type type) => throw null;
            public static System.Reflection.FieldInfo GetRuntimeField(this System.Type type, string name) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> GetRuntimeFields(this System.Type type) => throw null;
            public static System.Reflection.InterfaceMapping GetRuntimeInterfaceMap(this System.Reflection.TypeInfo typeInfo, System.Type interfaceType) => throw null;
            public static System.Reflection.MethodInfo GetRuntimeMethod(this System.Type type, string name, System.Type[] parameters) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetRuntimeMethods(this System.Type type) => throw null;
            public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetRuntimeProperties(this System.Type type) => throw null;
            public static System.Reflection.PropertyInfo GetRuntimeProperty(this System.Type type, string name) => throw null;
        }
        public class StrongNameKeyPair : System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            public StrongNameKeyPair(byte[] keyPairArray) => throw null;
            public StrongNameKeyPair(System.IO.FileStream keyPairFile) => throw null;
            protected StrongNameKeyPair(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public StrongNameKeyPair(string keyPairContainer) => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public byte[] PublicKey { get => throw null; }
        }
        public class TargetException : System.ApplicationException
        {
            public TargetException() => throw null;
            protected TargetException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public TargetException(string message) => throw null;
            public TargetException(string message, System.Exception inner) => throw null;
        }
        public sealed class TargetInvocationException : System.ApplicationException
        {
            public TargetInvocationException(System.Exception inner) => throw null;
            public TargetInvocationException(string message, System.Exception inner) => throw null;
        }
        public sealed class TargetParameterCountException : System.ApplicationException
        {
            public TargetParameterCountException() => throw null;
            public TargetParameterCountException(string message) => throw null;
            public TargetParameterCountException(string message, System.Exception inner) => throw null;
        }
        [System.Flags]
        public enum TypeAttributes
        {
            AnsiClass = 0,
            AutoLayout = 0,
            Class = 0,
            NotPublic = 0,
            Public = 1,
            NestedPublic = 2,
            NestedPrivate = 3,
            NestedFamily = 4,
            NestedAssembly = 5,
            NestedFamANDAssem = 6,
            NestedFamORAssem = 7,
            VisibilityMask = 7,
            SequentialLayout = 8,
            ExplicitLayout = 16,
            LayoutMask = 24,
            ClassSemanticsMask = 32,
            Interface = 32,
            Abstract = 128,
            Sealed = 256,
            SpecialName = 1024,
            RTSpecialName = 2048,
            Import = 4096,
            Serializable = 8192,
            WindowsRuntime = 16384,
            UnicodeClass = 65536,
            AutoClass = 131072,
            CustomFormatClass = 196608,
            StringFormatMask = 196608,
            HasSecurity = 262144,
            ReservedMask = 264192,
            BeforeFieldInit = 1048576,
            CustomFormatMask = 12582912,
        }
        public class TypeDelegator : System.Reflection.TypeInfo
        {
            public override System.Reflection.Assembly Assembly { get => throw null; }
            public override string AssemblyQualifiedName { get => throw null; }
            public override System.Type BaseType { get => throw null; }
            protected TypeDelegator() => throw null;
            public TypeDelegator(System.Type delegatingType) => throw null;
            public override string FullName { get => throw null; }
            protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl() => throw null;
            protected override System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public override System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override object[] GetCustomAttributes(bool inherit) => throw null;
            public override object[] GetCustomAttributes(System.Type attributeType, bool inherit) => throw null;
            public override System.Type GetElementType() => throw null;
            public override System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.EventInfo[] GetEvents() => throw null;
            public override System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type[] GetFunctionPointerCallingConventions() => throw null;
            public override System.Type[] GetFunctionPointerParameterTypes() => throw null;
            public override System.Type GetFunctionPointerReturnType() => throw null;
            public override System.Type GetInterface(string name, bool ignoreCase) => throw null;
            public override System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType) => throw null;
            public override System.Type[] GetInterfaces() => throw null;
            public override System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.MemberInfo GetMemberWithSameMetadataDefinitionAs(System.Reflection.MemberInfo member) => throw null;
            protected override System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public override System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr) => throw null;
            public override System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr) => throw null;
            protected override System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
            public override System.Guid GUID { get => throw null; }
            protected override bool HasElementTypeImpl() => throw null;
            public override object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters) => throw null;
            protected override bool IsArrayImpl() => throw null;
            public override bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo) => throw null;
            protected override bool IsByRefImpl() => throw null;
            public override bool IsByRefLike { get => throw null; }
            public override bool IsCollectible { get => throw null; }
            protected override bool IsCOMObjectImpl() => throw null;
            public override bool IsConstructedGenericType { get => throw null; }
            public override bool IsDefined(System.Type attributeType, bool inherit) => throw null;
            public override bool IsFunctionPointer { get => throw null; }
            public override bool IsGenericMethodParameter { get => throw null; }
            public override bool IsGenericTypeParameter { get => throw null; }
            protected override bool IsPointerImpl() => throw null;
            protected override bool IsPrimitiveImpl() => throw null;
            public override bool IsSZArray { get => throw null; }
            public override bool IsTypeDefinition { get => throw null; }
            public override bool IsUnmanagedFunctionPointer { get => throw null; }
            protected override bool IsValueTypeImpl() => throw null;
            public override bool IsVariableBoundArray { get => throw null; }
            public override int MetadataToken { get => throw null; }
            public override System.Reflection.Module Module { get => throw null; }
            public override string Name { get => throw null; }
            public override string Namespace { get => throw null; }
            public override System.RuntimeTypeHandle TypeHandle { get => throw null; }
            protected System.Type typeImpl;
            public override System.Type UnderlyingSystemType { get => throw null; }
        }
        public delegate bool TypeFilter(System.Type m, object filterCriteria);
        public abstract class TypeInfo : System.Type, System.Reflection.IReflectableType
        {
            public virtual System.Type AsType() => throw null;
            protected TypeInfo() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo> DeclaredConstructors { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> DeclaredEvents { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> DeclaredFields { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo> DeclaredMembers { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> DeclaredMethods { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> DeclaredNestedTypes { get => throw null; }
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> DeclaredProperties { get => throw null; }
            public virtual System.Type[] GenericTypeParameters { get => throw null; }
            public virtual System.Reflection.EventInfo GetDeclaredEvent(string name) => throw null;
            public virtual System.Reflection.FieldInfo GetDeclaredField(string name) => throw null;
            public virtual System.Reflection.MethodInfo GetDeclaredMethod(string name) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetDeclaredMethods(string name) => throw null;
            public virtual System.Reflection.TypeInfo GetDeclaredNestedType(string name) => throw null;
            public virtual System.Reflection.PropertyInfo GetDeclaredProperty(string name) => throw null;
            System.Reflection.TypeInfo System.Reflection.IReflectableType.GetTypeInfo() => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Type> ImplementedInterfaces { get => throw null; }
            public virtual bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo) => throw null;
        }
    }
    public class ResolveEventArgs : System.EventArgs
    {
        public ResolveEventArgs(string name) => throw null;
        public ResolveEventArgs(string name, System.Reflection.Assembly requestingAssembly) => throw null;
        public string Name { get => throw null; }
        public System.Reflection.Assembly RequestingAssembly { get => throw null; }
    }
    public delegate System.Reflection.Assembly ResolveEventHandler(object sender, System.ResolveEventArgs args);
    namespace Resources
    {
        public interface IResourceReader : System.IDisposable, System.Collections.IEnumerable
        {
            void Close();
            System.Collections.IDictionaryEnumerator GetEnumerator();
        }
        public class MissingManifestResourceException : System.SystemException
        {
            public MissingManifestResourceException() => throw null;
            protected MissingManifestResourceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public MissingManifestResourceException(string message) => throw null;
            public MissingManifestResourceException(string message, System.Exception inner) => throw null;
        }
        public class MissingSatelliteAssemblyException : System.SystemException
        {
            public MissingSatelliteAssemblyException() => throw null;
            protected MissingSatelliteAssemblyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public MissingSatelliteAssemblyException(string message) => throw null;
            public MissingSatelliteAssemblyException(string message, System.Exception inner) => throw null;
            public MissingSatelliteAssemblyException(string message, string cultureName) => throw null;
            public string CultureName { get => throw null; }
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false)]
        public sealed class NeutralResourcesLanguageAttribute : System.Attribute
        {
            public NeutralResourcesLanguageAttribute(string cultureName) => throw null;
            public NeutralResourcesLanguageAttribute(string cultureName, System.Resources.UltimateResourceFallbackLocation location) => throw null;
            public string CultureName { get => throw null; }
            public System.Resources.UltimateResourceFallbackLocation Location { get => throw null; }
        }
        public class ResourceManager
        {
            public virtual string BaseName { get => throw null; }
            public static System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, System.Type usingResourceSet) => throw null;
            protected ResourceManager() => throw null;
            public ResourceManager(string baseName, System.Reflection.Assembly assembly) => throw null;
            public ResourceManager(string baseName, System.Reflection.Assembly assembly, System.Type usingResourceSet) => throw null;
            public ResourceManager(System.Type resourceSource) => throw null;
            protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get => throw null; set { } }
            protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage(System.Reflection.Assembly a) => throw null;
            public virtual object GetObject(string name) => throw null;
            public virtual object GetObject(string name, System.Globalization.CultureInfo culture) => throw null;
            protected virtual string GetResourceFileName(System.Globalization.CultureInfo culture) => throw null;
            public virtual System.Resources.ResourceSet GetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) => throw null;
            protected static System.Version GetSatelliteContractVersion(System.Reflection.Assembly a) => throw null;
            public System.IO.UnmanagedMemoryStream GetStream(string name) => throw null;
            public System.IO.UnmanagedMemoryStream GetStream(string name, System.Globalization.CultureInfo culture) => throw null;
            public virtual string GetString(string name) => throw null;
            public virtual string GetString(string name, System.Globalization.CultureInfo culture) => throw null;
            public static readonly int HeaderVersionNumber;
            public virtual bool IgnoreCase { get => throw null; set { } }
            protected virtual System.Resources.ResourceSet InternalGetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) => throw null;
            public static readonly int MagicNumber;
            protected System.Reflection.Assembly MainAssembly;
            public virtual void ReleaseAllResources() => throw null;
            public virtual System.Type ResourceSetType { get => throw null; }
        }
        public sealed class ResourceReader : System.IDisposable, System.Collections.IEnumerable, System.Resources.IResourceReader
        {
            public void Close() => throw null;
            public ResourceReader(System.IO.Stream stream) => throw null;
            public ResourceReader(string fileName) => throw null;
            public void Dispose() => throw null;
            public System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public void GetResourceData(string resourceName, out string resourceType, out byte[] resourceData) => throw null;
        }
        public class ResourceSet : System.IDisposable, System.Collections.IEnumerable
        {
            public virtual void Close() => throw null;
            protected ResourceSet() => throw null;
            public ResourceSet(System.IO.Stream stream) => throw null;
            public ResourceSet(System.Resources.IResourceReader reader) => throw null;
            public ResourceSet(string fileName) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public virtual System.Type GetDefaultReader() => throw null;
            public virtual System.Type GetDefaultWriter() => throw null;
            public virtual System.Collections.IDictionaryEnumerator GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public virtual object GetObject(string name) => throw null;
            public virtual object GetObject(string name, bool ignoreCase) => throw null;
            public virtual string GetString(string name) => throw null;
            public virtual string GetString(string name, bool ignoreCase) => throw null;
            protected virtual void ReadResources() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false)]
        public sealed class SatelliteContractVersionAttribute : System.Attribute
        {
            public SatelliteContractVersionAttribute(string version) => throw null;
            public string Version { get => throw null; }
        }
        public enum UltimateResourceFallbackLocation
        {
            MainAssembly = 0,
            Satellite = 1,
        }
    }
    namespace Runtime
    {
        public sealed class AmbiguousImplementationException : System.Exception
        {
            public AmbiguousImplementationException() => throw null;
            public AmbiguousImplementationException(string message) => throw null;
            public AmbiguousImplementationException(string message, System.Exception innerException) => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
        public sealed class AssemblyTargetedPatchBandAttribute : System.Attribute
        {
            public AssemblyTargetedPatchBandAttribute(string targetedPatchBand) => throw null;
            public string TargetedPatchBand { get => throw null; }
        }
        namespace CompilerServices
        {
            [System.AttributeUsage((System.AttributeTargets)256)]
            public sealed class AccessedThroughPropertyAttribute : System.Attribute
            {
                public AccessedThroughPropertyAttribute(string propertyName) => throw null;
                public string PropertyName { get => throw null; }
            }
            public struct AsyncIteratorMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void Complete() => throw null;
                public static System.Runtime.CompilerServices.AsyncIteratorMethodBuilder Create() => throw null;
                public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false, AllowMultiple = false)]
            public sealed class AsyncIteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public AsyncIteratorStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)5212, Inherited = false, AllowMultiple = false)]
            public sealed class AsyncMethodBuilderAttribute : System.Attribute
            {
                public System.Type BuilderType { get => throw null; }
                public AsyncMethodBuilderAttribute(System.Type builderType) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false, AllowMultiple = false)]
            public sealed class AsyncStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public AsyncStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }
            public struct AsyncTaskMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.Task Task { get => throw null; }
            }
            public struct AsyncTaskMethodBuilder<TResult>
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.Task<TResult> Task { get => throw null; }
            }
            public struct AsyncValueTaskMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask Task { get => throw null; }
            }
            public struct AsyncValueTaskMethodBuilder<TResult>
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<TResult> Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask<TResult> Task { get => throw null; }
            }
            public struct AsyncVoidMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
            }
            public class CallConvCdecl
            {
                public CallConvCdecl() => throw null;
            }
            public class CallConvFastcall
            {
                public CallConvFastcall() => throw null;
            }
            public class CallConvMemberFunction
            {
                public CallConvMemberFunction() => throw null;
            }
            public class CallConvStdcall
            {
                public CallConvStdcall() => throw null;
            }
            public class CallConvSuppressGCTransition
            {
                public CallConvSuppressGCTransition() => throw null;
            }
            public class CallConvThiscall
            {
                public CallConvThiscall() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, AllowMultiple = false, Inherited = false)]
            public sealed class CallerArgumentExpressionAttribute : System.Attribute
            {
                public CallerArgumentExpressionAttribute(string parameterName) => throw null;
                public string ParameterName { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class CallerFilePathAttribute : System.Attribute
            {
                public CallerFilePathAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class CallerLineNumberAttribute : System.Attribute
            {
                public CallerLineNumberAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class CallerMemberNameAttribute : System.Attribute
            {
                public CallerMemberNameAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1036, Inherited = false)]
            public sealed class CollectionBuilderAttribute : System.Attribute
            {
                public System.Type BuilderType { get => throw null; }
                public CollectionBuilderAttribute(System.Type builderType, string methodName) => throw null;
                public string MethodName { get => throw null; }
            }
            [System.Flags]
            public enum CompilationRelaxations
            {
                NoStringInterning = 8,
            }
            [System.AttributeUsage((System.AttributeTargets)71)]
            public class CompilationRelaxationsAttribute : System.Attribute
            {
                public int CompilationRelaxations { get => throw null; }
                public CompilationRelaxationsAttribute(int relaxations) => throw null;
                public CompilationRelaxationsAttribute(System.Runtime.CompilerServices.CompilationRelaxations relaxations) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)32767, AllowMultiple = true, Inherited = false)]
            public sealed class CompilerFeatureRequiredAttribute : System.Attribute
            {
                public CompilerFeatureRequiredAttribute(string featureName) => throw null;
                public string FeatureName { get => throw null; }
                public bool IsOptional { get => throw null; set { } }
                public const string RefStructs = default;
                public const string RequiredMembers = default;
            }
            [System.AttributeUsage((System.AttributeTargets)32767, Inherited = true)]
            public sealed class CompilerGeneratedAttribute : System.Attribute
            {
                public CompilerGeneratedAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)4)]
            public class CompilerGlobalScopeAttribute : System.Attribute
            {
                public CompilerGlobalScopeAttribute() => throw null;
            }
            public sealed class ConditionalWeakTable<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable where TKey : class where TValue : class
            {
                public void Add(TKey key, TValue value) => throw null;
                public void AddOrUpdate(TKey key, TValue value) => throw null;
                public void Clear() => throw null;
                public delegate TValue CreateValueCallback(TKey key);
                public ConditionalWeakTable() => throw null;
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>.GetEnumerator() => throw null;
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
                public TValue GetOrCreateValue(TKey key) => throw null;
                public TValue GetValue(TKey key, System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue>.CreateValueCallback createValueCallback) => throw null;
                public bool Remove(TKey key) => throw null;
                public bool TryAdd(TKey key, TValue value) => throw null;
                public bool TryGetValue(TKey key, out TValue value) => throw null;
            }
            public struct ConfiguredAsyncDisposable
            {
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable DisposeAsync() => throw null;
            }
            public struct ConfiguredCancelableAsyncEnumerable<T>
            {
                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public struct Enumerator
                {
                    public T Current { get => throw null; }
                    public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable DisposeAsync() => throw null;
                    public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<bool> MoveNextAsync() => throw null;
                }
                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T>.Enumerator GetAsyncEnumerator() => throw null;
                public System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation(System.Threading.CancellationToken cancellationToken) => throw null;
            }
            public struct ConfiguredTaskAwaitable
            {
                public struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter() => throw null;
            }
            public struct ConfiguredTaskAwaitable<TResult>
            {
                public struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public TResult GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult>.ConfiguredTaskAwaiter GetAwaiter() => throw null;
            }
            public struct ConfiguredValueTaskAwaitable
            {
                public struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter GetAwaiter() => throw null;
            }
            public struct ConfiguredValueTaskAwaitable<TResult>
            {
                public struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public TResult GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult>.ConfiguredValueTaskAwaiter GetAwaiter() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2304, Inherited = false)]
            public abstract class CustomConstantAttribute : System.Attribute
            {
                protected CustomConstantAttribute() => throw null;
                public abstract object Value { get; }
            }
            [System.AttributeUsage((System.AttributeTargets)2304, Inherited = false)]
            public sealed class DateTimeConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                public DateTimeConstantAttribute(long ticks) => throw null;
                public override object Value { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2304, Inherited = false)]
            public sealed class DecimalConstantAttribute : System.Attribute
            {
                public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low) => throw null;
                public DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low) => throw null;
                public decimal Value { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)1)]
            public sealed class DefaultDependencyAttribute : System.Attribute
            {
                public DefaultDependencyAttribute(System.Runtime.CompilerServices.LoadHint loadHintArgument) => throw null;
                public System.Runtime.CompilerServices.LoadHint LoadHint { get => throw null; }
            }
            [System.Runtime.CompilerServices.InterpolatedStringHandler]
            public struct DefaultInterpolatedStringHandler
            {
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount) => throw null;
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, System.IFormatProvider provider) => throw null;
                public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, System.IFormatProvider provider, System.Span<char> initialBuffer) => throw null;
                public override string ToString() => throw null;
                public string ToStringAndClear() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = true)]
            public sealed class DependencyAttribute : System.Attribute
            {
                public DependencyAttribute(string dependentAssemblyArgument, System.Runtime.CompilerServices.LoadHint loadHintArgument) => throw null;
                public string DependentAssembly { get => throw null; }
                public System.Runtime.CompilerServices.LoadHint LoadHint { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
            public sealed class DisablePrivateReflectionAttribute : System.Attribute
            {
                public DisablePrivateReflectionAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, Inherited = false, AllowMultiple = false)]
            public sealed class DisableRuntimeMarshallingAttribute : System.Attribute
            {
                public DisableRuntimeMarshallingAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)32767)]
            public class DiscardableAttribute : System.Attribute
            {
                public DiscardableAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class EnumeratorCancellationAttribute : System.Attribute
            {
                public EnumeratorCancellationAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)69)]
            public sealed class ExtensionAttribute : System.Attribute
            {
                public ExtensionAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)256)]
            public sealed class FixedAddressValueTypeAttribute : System.Attribute
            {
                public FixedAddressValueTypeAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
            public sealed class FixedBufferAttribute : System.Attribute
            {
                public FixedBufferAttribute(System.Type elementType, int length) => throw null;
                public System.Type ElementType { get => throw null; }
                public int Length { get => throw null; }
            }
            public static class FormattableStringFactory
            {
                public static System.FormattableString Create(string format, params object[] arguments) => throw null;
            }
            public interface IAsyncStateMachine
            {
                void MoveNext();
                void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
            public interface ICriticalNotifyCompletion : System.Runtime.CompilerServices.INotifyCompletion
            {
                void UnsafeOnCompleted(System.Action continuation);
            }
            [System.AttributeUsage((System.AttributeTargets)128, Inherited = true)]
            public sealed class IndexerNameAttribute : System.Attribute
            {
                public IndexerNameAttribute(string indexerName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)8, AllowMultiple = false)]
            public sealed class InlineArrayAttribute : System.Attribute
            {
                public InlineArrayAttribute(int length) => throw null;
                public int Length { get => throw null; }
            }
            public interface INotifyCompletion
            {
                void OnCompleted(System.Action continuation);
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = true, Inherited = false)]
            public sealed class InternalsVisibleToAttribute : System.Attribute
            {
                public bool AllInternalsVisible { get => throw null; set { } }
                public string AssemblyName { get => throw null; }
                public InternalsVisibleToAttribute(string assemblyName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, AllowMultiple = false, Inherited = false)]
            public sealed class InterpolatedStringHandlerArgumentAttribute : System.Attribute
            {
                public string[] Arguments { get => throw null; }
                public InterpolatedStringHandlerArgumentAttribute(string argument) => throw null;
                public InterpolatedStringHandlerArgumentAttribute(params string[] arguments) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)12, AllowMultiple = false, Inherited = false)]
            public sealed class InterpolatedStringHandlerAttribute : System.Attribute
            {
                public InterpolatedStringHandlerAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)8)]
            public sealed class IsByRefLikeAttribute : System.Attribute
            {
                public IsByRefLikeAttribute() => throw null;
            }
            public static class IsConst
            {
            }
            public static class IsExternalInit
            {
            }
            [System.AttributeUsage((System.AttributeTargets)32767, Inherited = false)]
            public sealed class IsReadOnlyAttribute : System.Attribute
            {
                public IsReadOnlyAttribute() => throw null;
            }
            public interface IStrongBox
            {
                object Value { get; set; }
            }
            [System.AttributeUsage((System.AttributeTargets)32767)]
            public sealed class IsUnmanagedAttribute : System.Attribute
            {
                public IsUnmanagedAttribute() => throw null;
            }
            public static class IsVolatile
            {
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false, AllowMultiple = false)]
            public sealed class IteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                public IteratorStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) => throw null;
            }
            public interface ITuple
            {
                int Length { get; }
                object this[int index] { get; }
            }
            public enum LoadHint
            {
                Default = 0,
                Always = 1,
                Sometimes = 2,
            }
            public enum MethodCodeType
            {
                IL = 0,
                Native = 1,
                OPTIL = 2,
                Runtime = 3,
            }
            [System.AttributeUsage((System.AttributeTargets)96, Inherited = false)]
            public sealed class MethodImplAttribute : System.Attribute
            {
                public MethodImplAttribute() => throw null;
                public MethodImplAttribute(short value) => throw null;
                public MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions methodImplOptions) => throw null;
                public System.Runtime.CompilerServices.MethodCodeType MethodCodeType;
                public System.Runtime.CompilerServices.MethodImplOptions Value { get => throw null; }
            }
            [System.Flags]
            public enum MethodImplOptions
            {
                Unmanaged = 4,
                NoInlining = 8,
                ForwardRef = 16,
                Synchronized = 32,
                NoOptimization = 64,
                PreserveSig = 128,
                AggressiveInlining = 256,
                AggressiveOptimization = 512,
                InternalCall = 4096,
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class ModuleInitializerAttribute : System.Attribute
            {
                public ModuleInitializerAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)27524, Inherited = false)]
            public sealed class NullableAttribute : System.Attribute
            {
                public NullableAttribute(byte value) => throw null;
                public NullableAttribute(byte[] value) => throw null;
                public readonly byte[] NullableFlags;
            }
            [System.AttributeUsage((System.AttributeTargets)5196, Inherited = false)]
            public sealed class NullableContextAttribute : System.Attribute
            {
                public NullableContextAttribute(byte value) => throw null;
                public readonly byte Flag;
            }
            [System.AttributeUsage((System.AttributeTargets)2, Inherited = false)]
            public sealed class NullablePublicOnlyAttribute : System.Attribute
            {
                public NullablePublicOnlyAttribute(bool value) => throw null;
                public readonly bool IncludesInternals;
            }
            public struct PoolingAsyncValueTaskMethodBuilder
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask Task { get => throw null; }
            }
            public struct PoolingAsyncValueTaskMethodBuilder<TResult>
            {
                public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public static System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder<TResult> Create() => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine) => throw null;
                public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine => throw null;
                public System.Threading.Tasks.ValueTask<TResult> Task { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)64, AllowMultiple = false, Inherited = false)]
            public sealed class PreserveBaseOverridesAttribute : System.Attribute
            {
                public PreserveBaseOverridesAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false)]
            public sealed class ReferenceAssemblyAttribute : System.Attribute
            {
                public ReferenceAssemblyAttribute() => throw null;
                public ReferenceAssemblyAttribute(string description) => throw null;
                public string Description { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2, Inherited = false)]
            public sealed class RefSafetyRulesAttribute : System.Attribute
            {
                public RefSafetyRulesAttribute(int version) => throw null;
                public int Version { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)396, AllowMultiple = false, Inherited = false)]
            public sealed class RequiredMemberAttribute : System.Attribute
            {
                public RequiredMemberAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class RequiresLocationAttribute : System.Attribute
            {
                public RequiresLocationAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, Inherited = false, AllowMultiple = false)]
            public sealed class RuntimeCompatibilityAttribute : System.Attribute
            {
                public RuntimeCompatibilityAttribute() => throw null;
                public bool WrapNonExceptionThrows { get => throw null; set { } }
            }
            public static class RuntimeFeature
            {
                public const string ByRefFields = default;
                public const string CovariantReturnsOfClasses = default;
                public const string DefaultImplementationsOfInterfaces = default;
                public static bool IsDynamicCodeCompiled { get => throw null; }
                public static bool IsDynamicCodeSupported { get => throw null; }
                public static bool IsSupported(string feature) => throw null;
                public const string NumericIntPtr = default;
                public const string PortablePdb = default;
                public const string UnmanagedSignatureCallingConvention = default;
                public const string VirtualStaticsInInterfaces = default;
            }
            public static class RuntimeHelpers
            {
                public static nint AllocateTypeAssociatedMemory(System.Type type, int size) => throw null;
                public delegate void CleanupCode(object userData, bool exceptionThrown);
                public static System.ReadOnlySpan<T> CreateSpan<T>(System.RuntimeFieldHandle fldHandle) => throw null;
                public static void EnsureSufficientExecutionStack() => throw null;
                public static bool Equals(object o1, object o2) => throw null;
                public static void ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData) => throw null;
                public static int GetHashCode(object o) => throw null;
                public static object GetObjectValue(object obj) => throw null;
                public static T[] GetSubArray<T>(T[] array, System.Range range) => throw null;
                public static object GetUninitializedObject(System.Type type) => throw null;
                public static void InitializeArray(System.Array array, System.RuntimeFieldHandle fldHandle) => throw null;
                public static bool IsReferenceOrContainsReferences<T>() => throw null;
                public static int OffsetToStringData { get => throw null; }
                public static void PrepareConstrainedRegions() => throw null;
                public static void PrepareConstrainedRegionsNoOP() => throw null;
                public static void PrepareContractedDelegate(System.Delegate d) => throw null;
                public static void PrepareDelegate(System.Delegate d) => throw null;
                public static void PrepareMethod(System.RuntimeMethodHandle method) => throw null;
                public static void PrepareMethod(System.RuntimeMethodHandle method, System.RuntimeTypeHandle[] instantiation) => throw null;
                public static void ProbeForSufficientStack() => throw null;
                public static void RunClassConstructor(System.RuntimeTypeHandle type) => throw null;
                public static void RunModuleConstructor(System.ModuleHandle module) => throw null;
                public delegate void TryCode(object userData);
                public static bool TryEnsureSufficientExecutionStack() => throw null;
            }
            public sealed class RuntimeWrappedException : System.Exception
            {
                public RuntimeWrappedException(object thrownObject) => throw null;
                public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public object WrappedException { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class ScopedRefAttribute : System.Attribute
            {
                public ScopedRefAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1774, Inherited = false)]
            public sealed class SkipLocalsInitAttribute : System.Attribute
            {
                public SkipLocalsInitAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)972)]
            public sealed class SpecialNameAttribute : System.Attribute
            {
                public SpecialNameAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false, AllowMultiple = false)]
            public class StateMachineAttribute : System.Attribute
            {
                public StateMachineAttribute(System.Type stateMachineType) => throw null;
                public System.Type StateMachineType { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)1, Inherited = false)]
            public sealed class StringFreezingAttribute : System.Attribute
            {
                public StringFreezingAttribute() => throw null;
            }
            public class StrongBox<T> : System.Runtime.CompilerServices.IStrongBox
            {
                public StrongBox() => throw null;
                public StrongBox(T value) => throw null;
                public T Value;
                object System.Runtime.CompilerServices.IStrongBox.Value { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)3)]
            public sealed class SuppressIldasmAttribute : System.Attribute
            {
                public SuppressIldasmAttribute() => throw null;
            }
            public sealed class SwitchExpressionException : System.InvalidOperationException
            {
                public SwitchExpressionException() => throw null;
                public SwitchExpressionException(System.Exception innerException) => throw null;
                public SwitchExpressionException(object unmatchedValue) => throw null;
                public SwitchExpressionException(string message) => throw null;
                public SwitchExpressionException(string message, System.Exception innerException) => throw null;
                public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public override string Message { get => throw null; }
                public object UnmatchedValue { get => throw null; }
            }
            public struct TaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public void GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }
            public struct TaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public TResult GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)11148)]
            public sealed class TupleElementNamesAttribute : System.Attribute
            {
                public TupleElementNamesAttribute(string[] transformNames) => throw null;
                public System.Collections.Generic.IList<string> TransformNames { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)5148, Inherited = false, AllowMultiple = false)]
            public sealed class TypeForwardedFromAttribute : System.Attribute
            {
                public string AssemblyFullName { get => throw null; }
                public TypeForwardedFromAttribute(string assemblyFullName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = true, Inherited = false)]
            public sealed class TypeForwardedToAttribute : System.Attribute
            {
                public TypeForwardedToAttribute(System.Type destination) => throw null;
                public System.Type Destination { get => throw null; }
            }
            public static class Unsafe
            {
                public static unsafe void* Add<T>(void* source, int elementOffset) => throw null;
                public static T Add<T>(ref T source, int elementOffset) => throw null;
                public static T Add<T>(ref T source, nint elementOffset) => throw null;
                public static T Add<T>(ref T source, nuint elementOffset) => throw null;
                public static T AddByteOffset<T>(ref T source, nint byteOffset) => throw null;
                public static T AddByteOffset<T>(ref T source, nuint byteOffset) => throw null;
                public static bool AreSame<T>(ref readonly T left, ref readonly T right) => throw null;
                public static T As<T>(object o) where T : class => throw null;
                public static TTo As<TFrom, TTo>(ref TFrom source) => throw null;
                public static unsafe void* AsPointer<T>(ref T value) => throw null;
                public static unsafe T AsRef<T>(void* source) => throw null;
                public static T AsRef<T>(ref readonly T source) => throw null;
                public static TTo BitCast<TFrom, TTo>(TFrom source) where TFrom : struct where TTo : struct => throw null;
                public static nint ByteOffset<T>(ref readonly T origin, ref readonly T target) => throw null;
                public static unsafe void Copy<T>(void* destination, ref readonly T source) => throw null;
                public static unsafe void Copy<T>(ref T destination, void* source) => throw null;
                public static void CopyBlock(ref byte destination, ref readonly byte source, uint byteCount) => throw null;
                public static unsafe void CopyBlock(void* destination, void* source, uint byteCount) => throw null;
                public static void CopyBlockUnaligned(ref byte destination, ref readonly byte source, uint byteCount) => throw null;
                public static unsafe void CopyBlockUnaligned(void* destination, void* source, uint byteCount) => throw null;
                public static void InitBlock(ref byte startAddress, byte value, uint byteCount) => throw null;
                public static unsafe void InitBlock(void* startAddress, byte value, uint byteCount) => throw null;
                public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount) => throw null;
                public static unsafe void InitBlockUnaligned(void* startAddress, byte value, uint byteCount) => throw null;
                public static bool IsAddressGreaterThan<T>(ref readonly T left, ref readonly T right) => throw null;
                public static bool IsAddressLessThan<T>(ref readonly T left, ref readonly T right) => throw null;
                public static bool IsNullRef<T>(ref readonly T source) => throw null;
                public static T NullRef<T>() => throw null;
                public static unsafe T Read<T>(void* source) => throw null;
                public static T ReadUnaligned<T>(ref readonly byte source) => throw null;
                public static unsafe T ReadUnaligned<T>(void* source) => throw null;
                public static int SizeOf<T>() => throw null;
                public static void SkipInit<T>(out T value) => throw null;
                public static unsafe void* Subtract<T>(void* source, int elementOffset) => throw null;
                public static T Subtract<T>(ref T source, int elementOffset) => throw null;
                public static T Subtract<T>(ref T source, nint elementOffset) => throw null;
                public static T Subtract<T>(ref T source, nuint elementOffset) => throw null;
                public static T SubtractByteOffset<T>(ref T source, nint byteOffset) => throw null;
                public static T SubtractByteOffset<T>(ref T source, nuint byteOffset) => throw null;
                public static T Unbox<T>(object box) where T : struct => throw null;
                public static unsafe void Write<T>(void* destination, T value) => throw null;
                public static void WriteUnaligned<T>(ref byte destination, T value) => throw null;
                public static unsafe void WriteUnaligned<T>(void* destination, T value) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, AllowMultiple = false, Inherited = false)]
            public sealed class UnsafeAccessorAttribute : System.Attribute
            {
                public UnsafeAccessorAttribute(System.Runtime.CompilerServices.UnsafeAccessorKind kind) => throw null;
                public System.Runtime.CompilerServices.UnsafeAccessorKind Kind { get => throw null; }
                public string Name { get => throw null; set { } }
            }
            public enum UnsafeAccessorKind
            {
                Constructor = 0,
                Method = 1,
                StaticMethod = 2,
                Field = 3,
                StaticField = 4,
            }
            [System.AttributeUsage((System.AttributeTargets)8)]
            public sealed class UnsafeValueTypeAttribute : System.Attribute
            {
                public UnsafeValueTypeAttribute() => throw null;
            }
            public struct ValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public void GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }
            public struct ValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                public TResult GetResult() => throw null;
                public bool IsCompleted { get => throw null; }
                public void OnCompleted(System.Action continuation) => throw null;
                public void UnsafeOnCompleted(System.Action continuation) => throw null;
            }
            public struct YieldAwaitable
            {
                public System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter() => throw null;
                public struct YieldAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    public void GetResult() => throw null;
                    public bool IsCompleted { get => throw null; }
                    public void OnCompleted(System.Action continuation) => throw null;
                    public void UnsafeOnCompleted(System.Action continuation) => throw null;
                }
            }
        }
        namespace ConstrainedExecution
        {
            public enum Cer
            {
                None = 0,
                MayFail = 1,
                Success = 2,
            }
            public enum Consistency
            {
                MayCorruptProcess = 0,
                MayCorruptAppDomain = 1,
                MayCorruptInstance = 2,
                WillNotCorruptState = 3,
            }
            public abstract class CriticalFinalizerObject
            {
                protected CriticalFinalizerObject() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)96, Inherited = false)]
            public sealed class PrePrepareMethodAttribute : System.Attribute
            {
                public PrePrepareMethodAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1133, Inherited = false)]
            public sealed class ReliabilityContractAttribute : System.Attribute
            {
                public System.Runtime.ConstrainedExecution.Cer Cer { get => throw null; }
                public System.Runtime.ConstrainedExecution.Consistency ConsistencyGuarantee { get => throw null; }
                public ReliabilityContractAttribute(System.Runtime.ConstrainedExecution.Consistency consistencyGuarantee, System.Runtime.ConstrainedExecution.Cer cer) => throw null;
            }
        }
        public static class ControlledExecution
        {
            public static void Run(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
        }
        public struct DependentHandle : System.IDisposable
        {
            public DependentHandle(object target, object dependent) => throw null;
            public object Dependent { get => throw null; set { } }
            public void Dispose() => throw null;
            public bool IsAllocated { get => throw null; }
            public object Target { get => throw null; set { } }
            public (object Target, object Dependent) TargetAndDependent { get => throw null; }
        }
        namespace ExceptionServices
        {
            public sealed class ExceptionDispatchInfo
            {
                public static System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(System.Exception source) => throw null;
                public static System.Exception SetCurrentStackTrace(System.Exception source) => throw null;
                public static System.Exception SetRemoteStackTrace(System.Exception source, string stackTrace) => throw null;
                public System.Exception SourceException { get => throw null; }
                public void Throw() => throw null;
                public static void Throw(System.Exception source) => throw null;
            }
            public class FirstChanceExceptionEventArgs : System.EventArgs
            {
                public FirstChanceExceptionEventArgs(System.Exception exception) => throw null;
                public System.Exception Exception { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)64, AllowMultiple = false, Inherited = false)]
            public sealed class HandleProcessCorruptedStateExceptionsAttribute : System.Attribute
            {
                public HandleProcessCorruptedStateExceptionsAttribute() => throw null;
            }
        }
        public enum GCLargeObjectHeapCompactionMode
        {
            Default = 1,
            CompactOnce = 2,
        }
        public enum GCLatencyMode
        {
            Batch = 0,
            Interactive = 1,
            LowLatency = 2,
            SustainedLowLatency = 3,
            NoGCRegion = 4,
        }
        public static class GCSettings
        {
            public static bool IsServerGC { get => throw null; }
            public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get => throw null; set { } }
            public static System.Runtime.GCLatencyMode LatencyMode { get => throw null; set { } }
        }
        namespace InteropServices
        {
            public enum Architecture
            {
                X86 = 0,
                X64 = 1,
                Arm = 2,
                Arm64 = 3,
                Wasm = 4,
                S390x = 5,
                LoongArch64 = 6,
                Armv6 = 7,
                Ppc64le = 8,
            }
            public enum CharSet
            {
                None = 1,
                Ansi = 2,
                Unicode = 3,
                Auto = 4,
            }
            [System.AttributeUsage((System.AttributeTargets)5597, Inherited = false)]
            public sealed class ComVisibleAttribute : System.Attribute
            {
                public ComVisibleAttribute(bool visibility) => throw null;
                public bool Value { get => throw null; }
            }
            public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                public void Close() => throw null;
                protected CriticalHandle(nint invalidHandleValue) => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                protected nint handle;
                public bool IsClosed { get => throw null; }
                public abstract bool IsInvalid { get; }
                protected abstract bool ReleaseHandle();
                protected void SetHandle(nint handle) => throw null;
                public void SetHandleAsInvalid() => throw null;
            }
            public class ExternalException : System.SystemException
            {
                public ExternalException() => throw null;
                protected ExternalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public ExternalException(string message) => throw null;
                public ExternalException(string message, System.Exception inner) => throw null;
                public ExternalException(string message, int errorCode) => throw null;
                public virtual int ErrorCode { get => throw null; }
                public override string ToString() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
            public sealed class FieldOffsetAttribute : System.Attribute
            {
                public FieldOffsetAttribute(int offset) => throw null;
                public int Value { get => throw null; }
            }
            public struct GCHandle : System.IEquatable<System.Runtime.InteropServices.GCHandle>
            {
                public nint AddrOfPinnedObject() => throw null;
                public static System.Runtime.InteropServices.GCHandle Alloc(object value) => throw null;
                public static System.Runtime.InteropServices.GCHandle Alloc(object value, System.Runtime.InteropServices.GCHandleType type) => throw null;
                public override bool Equals(object o) => throw null;
                public bool Equals(System.Runtime.InteropServices.GCHandle other) => throw null;
                public void Free() => throw null;
                public static System.Runtime.InteropServices.GCHandle FromIntPtr(nint value) => throw null;
                public override int GetHashCode() => throw null;
                public bool IsAllocated { get => throw null; }
                public static bool operator ==(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b) => throw null;
                public static explicit operator System.Runtime.InteropServices.GCHandle(nint value) => throw null;
                public static explicit operator nint(System.Runtime.InteropServices.GCHandle value) => throw null;
                public static bool operator !=(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b) => throw null;
                public object Target { get => throw null; set { } }
                public static nint ToIntPtr(System.Runtime.InteropServices.GCHandle value) => throw null;
            }
            public enum GCHandleType
            {
                Weak = 0,
                WeakTrackResurrection = 1,
                Normal = 2,
                Pinned = 3,
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class InAttribute : System.Attribute
            {
                public InAttribute() => throw null;
            }
            public enum LayoutKind
            {
                Sequential = 0,
                Explicit = 2,
                Auto = 3,
            }
            namespace Marshalling
            {
                [System.AttributeUsage((System.AttributeTargets)12)]
                public sealed class ContiguousCollectionMarshallerAttribute : System.Attribute
                {
                    public ContiguousCollectionMarshallerAttribute() => throw null;
                }
                [System.AttributeUsage((System.AttributeTargets)12, AllowMultiple = true)]
                public sealed class CustomMarshallerAttribute : System.Attribute
                {
                    public CustomMarshallerAttribute(System.Type managedType, System.Runtime.InteropServices.Marshalling.MarshalMode marshalMode, System.Type marshallerType) => throw null;
                    public struct GenericPlaceholder
                    {
                    }
                    public System.Type ManagedType { get => throw null; }
                    public System.Type MarshallerType { get => throw null; }
                    public System.Runtime.InteropServices.Marshalling.MarshalMode MarshalMode { get => throw null; }
                }
                public enum MarshalMode
                {
                    Default = 0,
                    ManagedToUnmanagedIn = 1,
                    ManagedToUnmanagedRef = 2,
                    ManagedToUnmanagedOut = 3,
                    UnmanagedToManagedIn = 4,
                    UnmanagedToManagedRef = 5,
                    UnmanagedToManagedOut = 6,
                    ElementIn = 7,
                    ElementRef = 8,
                    ElementOut = 9,
                }
                [System.AttributeUsage((System.AttributeTargets)5148)]
                public sealed class NativeMarshallingAttribute : System.Attribute
                {
                    public NativeMarshallingAttribute(System.Type nativeType) => throw null;
                    public System.Type NativeType { get => throw null; }
                }
                public static class ReadOnlySpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : unmanaged
                {
                    public struct ManagedToUnmanagedIn
                    {
                        public static int BufferSize { get => throw null; }
                        public void Free() => throw null;
                        public void FromManaged(System.ReadOnlySpan<T> managed, System.Span<TUnmanagedElement> buffer) => throw null;
                        public System.ReadOnlySpan<T> GetManagedValuesSource() => throw null;
                        public TUnmanagedElement GetPinnableReference() => throw null;
                        public static T GetPinnableReference(System.ReadOnlySpan<T> managed) => throw null;
                        public System.Span<TUnmanagedElement> GetUnmanagedValuesDestination() => throw null;
                        public unsafe TUnmanagedElement* ToUnmanaged() => throw null;
                    }
                    public static class UnmanagedToManagedOut
                    {
                        public static unsafe TUnmanagedElement* AllocateContainerForUnmanagedElements(System.ReadOnlySpan<T> managed, out int numElements) => throw null;
                        public static System.ReadOnlySpan<T> GetManagedValuesSource(System.ReadOnlySpan<T> managed) => throw null;
                        public static unsafe System.Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    }
                }
                public static class SafeHandleMarshaller<T> where T : System.Runtime.InteropServices.SafeHandle
                {
                    public struct ManagedToUnmanagedIn
                    {
                        public void Free() => throw null;
                        public void FromManaged(T handle) => throw null;
                        public nint ToUnmanaged() => throw null;
                    }
                    public struct ManagedToUnmanagedOut
                    {
                        public ManagedToUnmanagedOut() => throw null;
                        public void Free() => throw null;
                        public void FromUnmanaged(nint value) => throw null;
                        public T ToManaged() => throw null;
                    }
                    public struct ManagedToUnmanagedRef
                    {
                        public ManagedToUnmanagedRef() => throw null;
                        public void Free() => throw null;
                        public void FromManaged(T handle) => throw null;
                        public void FromUnmanaged(nint value) => throw null;
                        public void OnInvoked() => throw null;
                        public T ToManagedFinally() => throw null;
                        public nint ToUnmanaged() => throw null;
                    }
                }
                public static class SpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : unmanaged
                {
                    public static unsafe System.Span<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    public static unsafe TUnmanagedElement* AllocateContainerForUnmanagedElements(System.Span<T> managed, out int numElements) => throw null;
                    public static unsafe void Free(TUnmanagedElement* unmanaged) => throw null;
                    public static System.Span<T> GetManagedValuesDestination(System.Span<T> managed) => throw null;
                    public static System.ReadOnlySpan<T> GetManagedValuesSource(System.Span<T> managed) => throw null;
                    public static unsafe System.Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    public static unsafe System.ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements) => throw null;
                    public struct ManagedToUnmanagedIn
                    {
                        public static int BufferSize { get => throw null; }
                        public void Free() => throw null;
                        public void FromManaged(System.Span<T> managed, System.Span<TUnmanagedElement> buffer) => throw null;
                        public System.ReadOnlySpan<T> GetManagedValuesSource() => throw null;
                        public TUnmanagedElement GetPinnableReference() => throw null;
                        public static T GetPinnableReference(System.Span<T> managed) => throw null;
                        public System.Span<TUnmanagedElement> GetUnmanagedValuesDestination() => throw null;
                        public unsafe TUnmanagedElement* ToUnmanaged() => throw null;
                    }
                }
            }
            public struct OSPlatform : System.IEquatable<System.Runtime.InteropServices.OSPlatform>
            {
                public static System.Runtime.InteropServices.OSPlatform Create(string osPlatform) => throw null;
                public override bool Equals(object obj) => throw null;
                public bool Equals(System.Runtime.InteropServices.OSPlatform other) => throw null;
                public static System.Runtime.InteropServices.OSPlatform FreeBSD { get => throw null; }
                public override int GetHashCode() => throw null;
                public static System.Runtime.InteropServices.OSPlatform Linux { get => throw null; }
                public static bool operator ==(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right) => throw null;
                public static bool operator !=(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right) => throw null;
                public static System.Runtime.InteropServices.OSPlatform OSX { get => throw null; }
                public override string ToString() => throw null;
                public static System.Runtime.InteropServices.OSPlatform Windows { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2048, Inherited = false)]
            public sealed class OutAttribute : System.Attribute
            {
                public OutAttribute() => throw null;
            }
            public static class RuntimeInformation
            {
                public static string FrameworkDescription { get => throw null; }
                public static bool IsOSPlatform(System.Runtime.InteropServices.OSPlatform osPlatform) => throw null;
                public static System.Runtime.InteropServices.Architecture OSArchitecture { get => throw null; }
                public static string OSDescription { get => throw null; }
                public static System.Runtime.InteropServices.Architecture ProcessArchitecture { get => throw null; }
                public static string RuntimeIdentifier { get => throw null; }
            }
            public abstract class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                public unsafe void AcquirePointer(ref byte* pointer) => throw null;
                public ulong ByteLength { get => throw null; }
                protected SafeBuffer(bool ownsHandle) : base(default(bool)) => throw null;
                public void Initialize(uint numElements, uint sizeOfEachElement) => throw null;
                public void Initialize(ulong numBytes) => throw null;
                public void Initialize<T>(uint numElements) where T : struct => throw null;
                public T Read<T>(ulong byteOffset) where T : struct => throw null;
                public void ReadArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct => throw null;
                public void ReadSpan<T>(ulong byteOffset, System.Span<T> buffer) where T : struct => throw null;
                public void ReleasePointer() => throw null;
                public void Write<T>(ulong byteOffset, T value) where T : struct => throw null;
                public void WriteArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct => throw null;
                public void WriteSpan<T>(ulong byteOffset, System.ReadOnlySpan<T> data) where T : struct => throw null;
            }
            public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                public void Close() => throw null;
                protected SafeHandle(nint invalidHandleValue, bool ownsHandle) => throw null;
                public void DangerousAddRef(ref bool success) => throw null;
                public nint DangerousGetHandle() => throw null;
                public void DangerousRelease() => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                protected nint handle;
                public bool IsClosed { get => throw null; }
                public abstract bool IsInvalid { get; }
                protected abstract bool ReleaseHandle();
                protected void SetHandle(nint handle) => throw null;
                public void SetHandleAsInvalid() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)12, Inherited = false)]
            public sealed class StructLayoutAttribute : System.Attribute
            {
                public System.Runtime.InteropServices.CharSet CharSet;
                public StructLayoutAttribute(short layoutKind) => throw null;
                public StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind layoutKind) => throw null;
                public int Pack;
                public int Size;
                public System.Runtime.InteropServices.LayoutKind Value { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class SuppressGCTransitionAttribute : System.Attribute
            {
                public SuppressGCTransitionAttribute() => throw null;
            }
            public enum UnmanagedType
            {
                Bool = 2,
                I1 = 3,
                U1 = 4,
                I2 = 5,
                U2 = 6,
                I4 = 7,
                U4 = 8,
                I8 = 9,
                U8 = 10,
                R4 = 11,
                R8 = 12,
                Currency = 15,
                BStr = 19,
                LPStr = 20,
                LPWStr = 21,
                LPTStr = 22,
                ByValTStr = 23,
                IUnknown = 25,
                IDispatch = 26,
                Struct = 27,
                Interface = 28,
                SafeArray = 29,
                ByValArray = 30,
                SysInt = 31,
                SysUInt = 32,
                VBByRefStr = 34,
                AnsiBStr = 35,
                TBStr = 36,
                VariantBool = 37,
                FunctionPtr = 38,
                AsAny = 40,
                LPArray = 42,
                LPStruct = 43,
                CustomMarshaler = 44,
                Error = 45,
                IInspectable = 46,
                HString = 47,
                LPUTF8Str = 48,
            }
        }
        public static class JitInfo
        {
            public static System.TimeSpan GetCompilationTime(bool currentThread = default(bool)) => throw null;
            public static long GetCompiledILBytes(bool currentThread = default(bool)) => throw null;
            public static long GetCompiledMethodCount(bool currentThread = default(bool)) => throw null;
        }
        public sealed class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
        {
            public MemoryFailPoint(int sizeInMegabytes) => throw null;
            public void Dispose() => throw null;
        }
        public static class ProfileOptimization
        {
            public static void SetProfileRoot(string directoryPath) => throw null;
            public static void StartProfile(string profile) => throw null;
        }
        namespace Remoting
        {
            public class ObjectHandle : System.MarshalByRefObject
            {
                public ObjectHandle(object o) => throw null;
                public object Unwrap() => throw null;
            }
        }
        namespace Serialization
        {
            public interface IDeserializationCallback
            {
                void OnDeserialization(object sender);
            }
            public interface IFormatterConverter
            {
                object Convert(object value, System.Type type);
                object Convert(object value, System.TypeCode typeCode);
                bool ToBoolean(object value);
                byte ToByte(object value);
                char ToChar(object value);
                System.DateTime ToDateTime(object value);
                decimal ToDecimal(object value);
                double ToDouble(object value);
                short ToInt16(object value);
                int ToInt32(object value);
                long ToInt64(object value);
                sbyte ToSByte(object value);
                float ToSingle(object value);
                string ToString(object value);
                ushort ToUInt16(object value);
                uint ToUInt32(object value);
                ulong ToUInt64(object value);
            }
            public interface IObjectReference
            {
                object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            }
            public interface ISafeSerializationData
            {
                void CompleteDeserialization(object deserialized);
            }
            public interface ISerializable
            {
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class OnDeserializedAttribute : System.Attribute
            {
                public OnDeserializedAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class OnDeserializingAttribute : System.Attribute
            {
                public OnDeserializingAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class OnSerializedAttribute : System.Attribute
            {
                public OnSerializedAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)64, Inherited = false)]
            public sealed class OnSerializingAttribute : System.Attribute
            {
                public OnSerializingAttribute() => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
            public sealed class OptionalFieldAttribute : System.Attribute
            {
                public OptionalFieldAttribute() => throw null;
                public int VersionAdded { get => throw null; set { } }
            }
            public sealed class SafeSerializationEventArgs : System.EventArgs
            {
                public void AddSerializedState(System.Runtime.Serialization.ISafeSerializationData serializedState) => throw null;
                public System.Runtime.Serialization.StreamingContext StreamingContext { get => throw null; }
            }
            public struct SerializationEntry
            {
                public string Name { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                public object Value { get => throw null; }
            }
            public class SerializationException : System.SystemException
            {
                public SerializationException() => throw null;
                protected SerializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public SerializationException(string message) => throw null;
                public SerializationException(string message, System.Exception innerException) => throw null;
            }
            public sealed class SerializationInfo
            {
                public void AddValue(string name, bool value) => throw null;
                public void AddValue(string name, byte value) => throw null;
                public void AddValue(string name, char value) => throw null;
                public void AddValue(string name, System.DateTime value) => throw null;
                public void AddValue(string name, decimal value) => throw null;
                public void AddValue(string name, double value) => throw null;
                public void AddValue(string name, short value) => throw null;
                public void AddValue(string name, int value) => throw null;
                public void AddValue(string name, long value) => throw null;
                public void AddValue(string name, object value) => throw null;
                public void AddValue(string name, object value, System.Type type) => throw null;
                public void AddValue(string name, sbyte value) => throw null;
                public void AddValue(string name, float value) => throw null;
                public void AddValue(string name, ushort value) => throw null;
                public void AddValue(string name, uint value) => throw null;
                public void AddValue(string name, ulong value) => throw null;
                public string AssemblyName { get => throw null; set { } }
                public SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter) => throw null;
                public SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter, bool requireSameTokenInPartialTrust) => throw null;
                public string FullTypeName { get => throw null; set { } }
                public bool GetBoolean(string name) => throw null;
                public byte GetByte(string name) => throw null;
                public char GetChar(string name) => throw null;
                public System.DateTime GetDateTime(string name) => throw null;
                public decimal GetDecimal(string name) => throw null;
                public double GetDouble(string name) => throw null;
                public System.Runtime.Serialization.SerializationInfoEnumerator GetEnumerator() => throw null;
                public short GetInt16(string name) => throw null;
                public int GetInt32(string name) => throw null;
                public long GetInt64(string name) => throw null;
                public sbyte GetSByte(string name) => throw null;
                public float GetSingle(string name) => throw null;
                public string GetString(string name) => throw null;
                public ushort GetUInt16(string name) => throw null;
                public uint GetUInt32(string name) => throw null;
                public ulong GetUInt64(string name) => throw null;
                public object GetValue(string name, System.Type type) => throw null;
                public bool IsAssemblyNameSetExplicit { get => throw null; }
                public bool IsFullTypeNameSetExplicit { get => throw null; }
                public int MemberCount { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                public void SetType(System.Type type) => throw null;
            }
            public sealed class SerializationInfoEnumerator : System.Collections.IEnumerator
            {
                public System.Runtime.Serialization.SerializationEntry Current { get => throw null; }
                object System.Collections.IEnumerator.Current { get => throw null; }
                public bool MoveNext() => throw null;
                public string Name { get => throw null; }
                public System.Type ObjectType { get => throw null; }
                public void Reset() => throw null;
                public object Value { get => throw null; }
            }
            public struct StreamingContext
            {
                public object Context { get => throw null; }
                public StreamingContext(System.Runtime.Serialization.StreamingContextStates state) => throw null;
                public StreamingContext(System.Runtime.Serialization.StreamingContextStates state, object additional) => throw null;
                public override bool Equals(object obj) => throw null;
                public override int GetHashCode() => throw null;
                public System.Runtime.Serialization.StreamingContextStates State { get => throw null; }
            }
            [System.Flags]
            public enum StreamingContextStates
            {
                CrossProcess = 1,
                CrossMachine = 2,
                File = 4,
                Persistence = 8,
                Remoting = 16,
                Other = 32,
                Clone = 64,
                CrossAppDomain = 128,
                All = 255,
            }
        }
        [System.AttributeUsage((System.AttributeTargets)96, AllowMultiple = false, Inherited = false)]
        public sealed class TargetedPatchingOptOutAttribute : System.Attribute
        {
            public TargetedPatchingOptOutAttribute(string reason) => throw null;
            public string Reason { get => throw null; }
        }
        namespace Versioning
        {
            [System.AttributeUsage((System.AttributeTargets)5887, AllowMultiple = false, Inherited = false)]
            public sealed class ComponentGuaranteesAttribute : System.Attribute
            {
                public ComponentGuaranteesAttribute(System.Runtime.Versioning.ComponentGuaranteesOptions guarantees) => throw null;
                public System.Runtime.Versioning.ComponentGuaranteesOptions Guarantees { get => throw null; }
            }
            [System.Flags]
            public enum ComponentGuaranteesOptions
            {
                None = 0,
                Exchange = 1,
                Stable = 2,
                SideBySide = 4,
            }
            public sealed class FrameworkName : System.IEquatable<System.Runtime.Versioning.FrameworkName>
            {
                public FrameworkName(string frameworkName) => throw null;
                public FrameworkName(string identifier, System.Version version) => throw null;
                public FrameworkName(string identifier, System.Version version, string profile) => throw null;
                public override bool Equals(object obj) => throw null;
                public bool Equals(System.Runtime.Versioning.FrameworkName other) => throw null;
                public string FullName { get => throw null; }
                public override int GetHashCode() => throw null;
                public string Identifier { get => throw null; }
                public static bool operator ==(System.Runtime.Versioning.FrameworkName left, System.Runtime.Versioning.FrameworkName right) => throw null;
                public static bool operator !=(System.Runtime.Versioning.FrameworkName left, System.Runtime.Versioning.FrameworkName right) => throw null;
                public string Profile { get => throw null; }
                public override string ToString() => throw null;
                public System.Version Version { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)2047, AllowMultiple = true, Inherited = false)]
            public sealed class ObsoletedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public ObsoletedOSPlatformAttribute(string platformName) => throw null;
                public ObsoletedOSPlatformAttribute(string platformName, string message) => throw null;
                public string Message { get => throw null; }
                public string Url { get => throw null; set { } }
            }
            public abstract class OSPlatformAttribute : System.Attribute
            {
                public string PlatformName { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)6143, Inherited = false)]
            public sealed class RequiresPreviewFeaturesAttribute : System.Attribute
            {
                public RequiresPreviewFeaturesAttribute() => throw null;
                public RequiresPreviewFeaturesAttribute(string message) => throw null;
                public string Message { get => throw null; }
                public string Url { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)224, Inherited = false)]
            public sealed class ResourceConsumptionAttribute : System.Attribute
            {
                public System.Runtime.Versioning.ResourceScope ConsumptionScope { get => throw null; }
                public ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope) => throw null;
                public ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope, System.Runtime.Versioning.ResourceScope consumptionScope) => throw null;
                public System.Runtime.Versioning.ResourceScope ResourceScope { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)480, Inherited = false)]
            public sealed class ResourceExposureAttribute : System.Attribute
            {
                public ResourceExposureAttribute(System.Runtime.Versioning.ResourceScope exposureLevel) => throw null;
                public System.Runtime.Versioning.ResourceScope ResourceExposureLevel { get => throw null; }
            }
            [System.Flags]
            public enum ResourceScope
            {
                None = 0,
                Machine = 1,
                Process = 2,
                AppDomain = 4,
                Library = 8,
                Private = 16,
                Assembly = 32,
            }
            [System.AttributeUsage((System.AttributeTargets)2047, AllowMultiple = true, Inherited = false)]
            public sealed class SupportedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public SupportedOSPlatformAttribute(string platformName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)448, AllowMultiple = true, Inherited = false)]
            public sealed class SupportedOSPlatformGuardAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public SupportedOSPlatformGuardAttribute(string platformName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
            public sealed class TargetFrameworkAttribute : System.Attribute
            {
                public TargetFrameworkAttribute(string frameworkName) => throw null;
                public string FrameworkDisplayName { get => throw null; set { } }
                public string FrameworkName { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
            public sealed class TargetPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public TargetPlatformAttribute(string platformName) => throw null;
            }
            [System.AttributeUsage((System.AttributeTargets)2047, AllowMultiple = true, Inherited = false)]
            public sealed class UnsupportedOSPlatformAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public UnsupportedOSPlatformAttribute(string platformName) => throw null;
                public UnsupportedOSPlatformAttribute(string platformName, string message) => throw null;
                public string Message { get => throw null; }
            }
            [System.AttributeUsage((System.AttributeTargets)448, AllowMultiple = true, Inherited = false)]
            public sealed class UnsupportedOSPlatformGuardAttribute : System.Runtime.Versioning.OSPlatformAttribute
            {
                public UnsupportedOSPlatformGuardAttribute(string platformName) => throw null;
            }
            public static class VersioningHelper
            {
                public static string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to) => throw null;
                public static string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to, System.Type type) => throw null;
            }
        }
    }
    public struct RuntimeArgumentHandle
    {
    }
    public struct RuntimeFieldHandle : System.IEquatable<System.RuntimeFieldHandle>, System.Runtime.Serialization.ISerializable
    {
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.RuntimeFieldHandle handle) => throw null;
        public static System.RuntimeFieldHandle FromIntPtr(nint value) => throw null;
        public override int GetHashCode() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool operator ==(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) => throw null;
        public static bool operator !=(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) => throw null;
        public static nint ToIntPtr(System.RuntimeFieldHandle value) => throw null;
        public nint Value { get => throw null; }
    }
    public struct RuntimeMethodHandle : System.IEquatable<System.RuntimeMethodHandle>, System.Runtime.Serialization.ISerializable
    {
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.RuntimeMethodHandle handle) => throw null;
        public static System.RuntimeMethodHandle FromIntPtr(nint value) => throw null;
        public nint GetFunctionPointer() => throw null;
        public override int GetHashCode() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool operator ==(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) => throw null;
        public static bool operator !=(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) => throw null;
        public static nint ToIntPtr(System.RuntimeMethodHandle value) => throw null;
        public nint Value { get => throw null; }
    }
    public struct RuntimeTypeHandle : System.IEquatable<System.RuntimeTypeHandle>, System.Runtime.Serialization.ISerializable
    {
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.RuntimeTypeHandle handle) => throw null;
        public static System.RuntimeTypeHandle FromIntPtr(nint value) => throw null;
        public override int GetHashCode() => throw null;
        public System.ModuleHandle GetModuleHandle() => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static bool operator ==(object left, System.RuntimeTypeHandle right) => throw null;
        public static bool operator ==(System.RuntimeTypeHandle left, object right) => throw null;
        public static bool operator !=(object left, System.RuntimeTypeHandle right) => throw null;
        public static bool operator !=(System.RuntimeTypeHandle left, object right) => throw null;
        public static nint ToIntPtr(System.RuntimeTypeHandle value) => throw null;
        public nint Value { get => throw null; }
    }
    public struct SByte : System.Numerics.IAdditionOperators<sbyte, sbyte, sbyte>, System.Numerics.IAdditiveIdentity<sbyte, sbyte>, System.Numerics.IBinaryInteger<sbyte>, System.Numerics.IBinaryNumber<sbyte>, System.Numerics.IBitwiseOperators<sbyte, sbyte, sbyte>, System.IComparable, System.IComparable<sbyte>, System.Numerics.IComparisonOperators<sbyte, sbyte, bool>, System.IConvertible, System.Numerics.IDecrementOperators<sbyte>, System.Numerics.IDivisionOperators<sbyte, sbyte, sbyte>, System.Numerics.IEqualityOperators<sbyte, sbyte, bool>, System.IEquatable<sbyte>, System.IFormattable, System.Numerics.IIncrementOperators<sbyte>, System.Numerics.IMinMaxValue<sbyte>, System.Numerics.IModulusOperators<sbyte, sbyte, sbyte>, System.Numerics.IMultiplicativeIdentity<sbyte, sbyte>, System.Numerics.IMultiplyOperators<sbyte, sbyte, sbyte>, System.Numerics.INumber<sbyte>, System.Numerics.INumberBase<sbyte>, System.IParsable<sbyte>, System.Numerics.IShiftOperators<sbyte, int, sbyte>, System.Numerics.ISignedNumber<sbyte>, System.ISpanFormattable, System.ISpanParsable<sbyte>, System.Numerics.ISubtractionOperators<sbyte, sbyte, sbyte>, System.Numerics.IUnaryNegationOperators<sbyte, sbyte>, System.Numerics.IUnaryPlusOperators<sbyte, sbyte>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<sbyte>
    {
        static sbyte System.Numerics.INumberBase<sbyte>.Abs(sbyte value) => throw null;
        static sbyte System.Numerics.IAdditiveIdentity<sbyte, sbyte>.AdditiveIdentity { get => throw null; }
        static sbyte System.Numerics.IBinaryNumber<sbyte>.AllBitsSet { get => throw null; }
        static sbyte System.Numerics.INumber<sbyte>.Clamp(sbyte value, sbyte min, sbyte max) => throw null;
        public int CompareTo(object obj) => throw null;
        public int CompareTo(sbyte value) => throw null;
        static sbyte System.Numerics.INumber<sbyte>.CopySign(sbyte value, sbyte sign) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.CreateChecked<TOther>(TOther value) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.CreateSaturating<TOther>(TOther value) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.CreateTruncating<TOther>(TOther value) => throw null;
        static (sbyte Quotient, sbyte Remainder) System.Numerics.IBinaryInteger<sbyte>.DivRem(sbyte left, sbyte right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(sbyte obj) => throw null;
        int System.Numerics.IBinaryInteger<sbyte>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<sbyte>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsCanonical(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsComplexNumber(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsEvenInteger(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsFinite(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsImaginaryNumber(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsInfinity(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsInteger(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsNaN(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsNegative(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsNegativeInfinity(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsNormal(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsOddInteger(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsPositive(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsPositiveInfinity(sbyte value) => throw null;
        static bool System.Numerics.IBinaryNumber<sbyte>.IsPow2(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsRealNumber(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsSubnormal(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.IsZero(sbyte value) => throw null;
        static sbyte System.Numerics.IBinaryInteger<sbyte>.LeadingZeroCount(sbyte value) => throw null;
        static sbyte System.Numerics.IBinaryNumber<sbyte>.Log2(sbyte value) => throw null;
        static sbyte System.Numerics.INumber<sbyte>.Max(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.MaxMagnitude(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.MaxMagnitudeNumber(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumber<sbyte>.MaxNumber(sbyte x, sbyte y) => throw null;
        public const sbyte MaxValue = 127;
        static sbyte System.Numerics.IMinMaxValue<sbyte>.MaxValue { get => throw null; }
        static sbyte System.Numerics.INumber<sbyte>.Min(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.MinMagnitude(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.MinMagnitudeNumber(sbyte x, sbyte y) => throw null;
        static sbyte System.Numerics.INumber<sbyte>.MinNumber(sbyte x, sbyte y) => throw null;
        public const sbyte MinValue = -128;
        static sbyte System.Numerics.IMinMaxValue<sbyte>.MinValue { get => throw null; }
        static sbyte System.Numerics.IMultiplicativeIdentity<sbyte, sbyte>.MultiplicativeIdentity { get => throw null; }
        static sbyte System.Numerics.ISignedNumber<sbyte>.NegativeOne { get => throw null; }
        static sbyte System.Numerics.INumberBase<sbyte>.One { get => throw null; }
        static sbyte System.Numerics.IAdditionOperators<sbyte, sbyte, sbyte>.operator +(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IBitwiseOperators<sbyte, sbyte, sbyte>.operator &(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IBitwiseOperators<sbyte, sbyte, sbyte>.operator |(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IAdditionOperators<sbyte, sbyte, sbyte>.operator checked +(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IDecrementOperators<sbyte>.operator checked --(sbyte value) => throw null;
        static sbyte System.Numerics.IIncrementOperators<sbyte>.operator checked ++(sbyte value) => throw null;
        static sbyte System.Numerics.IMultiplyOperators<sbyte, sbyte, sbyte>.operator checked *(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.ISubtractionOperators<sbyte, sbyte, sbyte>.operator checked -(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IUnaryNegationOperators<sbyte, sbyte>.operator checked -(sbyte value) => throw null;
        static sbyte System.Numerics.IDecrementOperators<sbyte>.operator --(sbyte value) => throw null;
        static sbyte System.Numerics.IDivisionOperators<sbyte, sbyte, sbyte>.operator /(sbyte left, sbyte right) => throw null;
        static bool System.Numerics.IEqualityOperators<sbyte, sbyte, bool>.operator ==(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IBitwiseOperators<sbyte, sbyte, sbyte>.operator ^(sbyte left, sbyte right) => throw null;
        static bool System.Numerics.IComparisonOperators<sbyte, sbyte, bool>.operator >(sbyte left, sbyte right) => throw null;
        static bool System.Numerics.IComparisonOperators<sbyte, sbyte, bool>.operator >=(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IIncrementOperators<sbyte>.operator ++(sbyte value) => throw null;
        static bool System.Numerics.IEqualityOperators<sbyte, sbyte, bool>.operator !=(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IShiftOperators<sbyte, int, sbyte>.operator <<(sbyte value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<sbyte, sbyte, bool>.operator <(sbyte left, sbyte right) => throw null;
        static bool System.Numerics.IComparisonOperators<sbyte, sbyte, bool>.operator <=(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IModulusOperators<sbyte, sbyte, sbyte>.operator %(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IMultiplyOperators<sbyte, sbyte, sbyte>.operator *(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IBitwiseOperators<sbyte, sbyte, sbyte>.operator ~(sbyte value) => throw null;
        static sbyte System.Numerics.IShiftOperators<sbyte, int, sbyte>.operator >>(sbyte value, int shiftAmount) => throw null;
        static sbyte System.Numerics.ISubtractionOperators<sbyte, sbyte, sbyte>.operator -(sbyte left, sbyte right) => throw null;
        static sbyte System.Numerics.IUnaryNegationOperators<sbyte, sbyte>.operator -(sbyte value) => throw null;
        static sbyte System.Numerics.IUnaryPlusOperators<sbyte, sbyte>.operator +(sbyte value) => throw null;
        static sbyte System.Numerics.IShiftOperators<sbyte, int, sbyte>.operator >>>(sbyte value, int shiftAmount) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static sbyte System.IUtf8SpanParsable<sbyte>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static sbyte System.ISpanParsable<sbyte>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static sbyte Parse(string s) => throw null;
        public static sbyte Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static sbyte System.IParsable<sbyte>.Parse(string s, System.IFormatProvider provider) => throw null;
        static sbyte System.Numerics.IBinaryInteger<sbyte>.PopCount(sbyte value) => throw null;
        static int System.Numerics.INumberBase<sbyte>.Radix { get => throw null; }
        static sbyte System.Numerics.IBinaryInteger<sbyte>.RotateLeft(sbyte value, int rotateAmount) => throw null;
        static sbyte System.Numerics.IBinaryInteger<sbyte>.RotateRight(sbyte value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<sbyte>.Sign(sbyte value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static sbyte System.Numerics.IBinaryInteger<sbyte>.TrailingZeroCount(sbyte value) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertFromChecked<TOther>(TOther value, out sbyte result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertFromSaturating<TOther>(TOther value, out sbyte result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertFromTruncating<TOther>(TOther value, out sbyte result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertToChecked<TOther>(sbyte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertToSaturating<TOther>(sbyte value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryConvertToTruncating<TOther>(sbyte value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out sbyte result) => throw null;
        static bool System.IUtf8SpanParsable<sbyte>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out sbyte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out sbyte result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out sbyte result) => throw null;
        static bool System.ISpanParsable<sbyte>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out sbyte result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out sbyte result) => throw null;
        static bool System.Numerics.INumberBase<sbyte>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out sbyte result) => throw null;
        static bool System.IParsable<sbyte>.TryParse(string s, System.IFormatProvider provider, out sbyte result) => throw null;
        public static bool TryParse(string s, out sbyte result) => throw null;
        static bool System.Numerics.IBinaryInteger<sbyte>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value) => throw null;
        static bool System.Numerics.IBinaryInteger<sbyte>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value) => throw null;
        bool System.Numerics.IBinaryInteger<sbyte>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<sbyte>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static sbyte System.Numerics.INumberBase<sbyte>.Zero { get => throw null; }
    }
    namespace Security
    {
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
        public sealed class AllowPartiallyTrustedCallersAttribute : System.Attribute
        {
            public AllowPartiallyTrustedCallersAttribute() => throw null;
            public System.Security.PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get => throw null; set { } }
        }
        namespace Cryptography
        {
            public class CryptographicException : System.SystemException
            {
                public CryptographicException() => throw null;
                public CryptographicException(int hr) => throw null;
                protected CryptographicException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public CryptographicException(string message) => throw null;
                public CryptographicException(string message, System.Exception inner) => throw null;
                public CryptographicException(string format, string insert) => throw null;
            }
        }
        public interface IPermission : System.Security.ISecurityEncodable
        {
            System.Security.IPermission Copy();
            void Demand();
            System.Security.IPermission Intersect(System.Security.IPermission target);
            bool IsSubsetOf(System.Security.IPermission target);
            System.Security.IPermission Union(System.Security.IPermission target);
        }
        public interface ISecurityEncodable
        {
            void FromXml(System.Security.SecurityElement e);
            System.Security.SecurityElement ToXml();
        }
        public interface IStackWalk
        {
            void Assert();
            void Demand();
            void Deny();
            void PermitOnly();
        }
        public enum PartialTrustVisibilityLevel
        {
            VisibleToAllHosts = 0,
            NotVisibleByDefault = 1,
        }
        namespace Permissions
        {
            [System.AttributeUsage((System.AttributeTargets)109, AllowMultiple = true, Inherited = false)]
            public abstract class CodeAccessSecurityAttribute : System.Security.Permissions.SecurityAttribute
            {
                protected CodeAccessSecurityAttribute(System.Security.Permissions.SecurityAction action) : base(default(System.Security.Permissions.SecurityAction)) => throw null;
            }
            public enum PermissionState
            {
                None = 0,
                Unrestricted = 1,
            }
            public enum SecurityAction
            {
                Demand = 2,
                Assert = 3,
                Deny = 4,
                PermitOnly = 5,
                LinkDemand = 6,
                InheritanceDemand = 7,
                RequestMinimum = 8,
                RequestOptional = 9,
                RequestRefuse = 10,
            }
            [System.AttributeUsage((System.AttributeTargets)109, AllowMultiple = true, Inherited = false)]
            public abstract class SecurityAttribute : System.Attribute
            {
                public System.Security.Permissions.SecurityAction Action { get => throw null; set { } }
                public abstract System.Security.IPermission CreatePermission();
                protected SecurityAttribute(System.Security.Permissions.SecurityAction action) => throw null;
                public bool Unrestricted { get => throw null; set { } }
            }
            [System.AttributeUsage((System.AttributeTargets)109, AllowMultiple = true, Inherited = false)]
            public sealed class SecurityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                public bool Assertion { get => throw null; set { } }
                public bool BindingRedirects { get => throw null; set { } }
                public bool ControlAppDomain { get => throw null; set { } }
                public bool ControlDomainPolicy { get => throw null; set { } }
                public bool ControlEvidence { get => throw null; set { } }
                public bool ControlPolicy { get => throw null; set { } }
                public bool ControlPrincipal { get => throw null; set { } }
                public bool ControlThread { get => throw null; set { } }
                public override System.Security.IPermission CreatePermission() => throw null;
                public SecurityPermissionAttribute(System.Security.Permissions.SecurityAction action) : base(default(System.Security.Permissions.SecurityAction)) => throw null;
                public bool Execution { get => throw null; set { } }
                public System.Security.Permissions.SecurityPermissionFlag Flags { get => throw null; set { } }
                public bool Infrastructure { get => throw null; set { } }
                public bool RemotingConfiguration { get => throw null; set { } }
                public bool SerializationFormatter { get => throw null; set { } }
                public bool SkipVerification { get => throw null; set { } }
                public bool UnmanagedCode { get => throw null; set { } }
            }
            [System.Flags]
            public enum SecurityPermissionFlag
            {
                NoFlags = 0,
                Assertion = 1,
                UnmanagedCode = 2,
                SkipVerification = 4,
                Execution = 8,
                ControlThread = 16,
                ControlEvidence = 32,
                ControlPolicy = 64,
                SerializationFormatter = 128,
                ControlDomainPolicy = 256,
                ControlPrincipal = 512,
                ControlAppDomain = 1024,
                RemotingConfiguration = 2048,
                Infrastructure = 4096,
                BindingRedirects = 8192,
                AllFlags = 16383,
            }
        }
        public class PermissionSet : System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Collections.IEnumerable, System.Security.ISecurityEncodable, System.Security.IStackWalk
        {
            public System.Security.IPermission AddPermission(System.Security.IPermission perm) => throw null;
            protected virtual System.Security.IPermission AddPermissionImpl(System.Security.IPermission perm) => throw null;
            public void Assert() => throw null;
            public bool ContainsNonCodeAccessPermissions() => throw null;
            public static byte[] ConvertPermissionSet(string inFormat, byte[] inData, string outFormat) => throw null;
            public virtual System.Security.PermissionSet Copy() => throw null;
            public virtual void CopyTo(System.Array array, int index) => throw null;
            public virtual int Count { get => throw null; }
            public PermissionSet(System.Security.Permissions.PermissionState state) => throw null;
            public PermissionSet(System.Security.PermissionSet permSet) => throw null;
            public void Demand() => throw null;
            public void Deny() => throw null;
            public override bool Equals(object o) => throw null;
            public virtual void FromXml(System.Security.SecurityElement et) => throw null;
            public System.Collections.IEnumerator GetEnumerator() => throw null;
            protected virtual System.Collections.IEnumerator GetEnumeratorImpl() => throw null;
            public override int GetHashCode() => throw null;
            public System.Security.IPermission GetPermission(System.Type permClass) => throw null;
            protected virtual System.Security.IPermission GetPermissionImpl(System.Type permClass) => throw null;
            public System.Security.PermissionSet Intersect(System.Security.PermissionSet other) => throw null;
            public bool IsEmpty() => throw null;
            public virtual bool IsReadOnly { get => throw null; }
            public bool IsSubsetOf(System.Security.PermissionSet target) => throw null;
            public virtual bool IsSynchronized { get => throw null; }
            public bool IsUnrestricted() => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public void PermitOnly() => throw null;
            public System.Security.IPermission RemovePermission(System.Type permClass) => throw null;
            protected virtual System.Security.IPermission RemovePermissionImpl(System.Type permClass) => throw null;
            public static void RevertAssert() => throw null;
            public System.Security.IPermission SetPermission(System.Security.IPermission perm) => throw null;
            protected virtual System.Security.IPermission SetPermissionImpl(System.Security.IPermission perm) => throw null;
            public virtual object SyncRoot { get => throw null; }
            public override string ToString() => throw null;
            public virtual System.Security.SecurityElement ToXml() => throw null;
            public System.Security.PermissionSet Union(System.Security.PermissionSet other) => throw null;
        }
        namespace Principal
        {
            public interface IIdentity
            {
                string AuthenticationType { get; }
                bool IsAuthenticated { get; }
                string Name { get; }
            }
            public interface IPrincipal
            {
                System.Security.Principal.IIdentity Identity { get; }
                bool IsInRole(string role);
            }
            public enum PrincipalPolicy
            {
                UnauthenticatedPrincipal = 0,
                NoPrincipal = 1,
                WindowsPrincipal = 2,
            }
            public enum TokenImpersonationLevel
            {
                None = 0,
                Anonymous = 1,
                Identification = 2,
                Impersonation = 3,
                Delegation = 4,
            }
        }
        [System.AttributeUsage((System.AttributeTargets)5501, AllowMultiple = false, Inherited = false)]
        public sealed class SecurityCriticalAttribute : System.Attribute
        {
            public SecurityCriticalAttribute() => throw null;
            public SecurityCriticalAttribute(System.Security.SecurityCriticalScope scope) => throw null;
            public System.Security.SecurityCriticalScope Scope { get => throw null; }
        }
        public enum SecurityCriticalScope
        {
            Explicit = 0,
            Everything = 1,
        }
        public sealed class SecurityElement
        {
            public void AddAttribute(string name, string value) => throw null;
            public void AddChild(System.Security.SecurityElement child) => throw null;
            public string Attribute(string name) => throw null;
            public System.Collections.Hashtable Attributes { get => throw null; set { } }
            public System.Collections.ArrayList Children { get => throw null; set { } }
            public System.Security.SecurityElement Copy() => throw null;
            public SecurityElement(string tag) => throw null;
            public SecurityElement(string tag, string text) => throw null;
            public bool Equal(System.Security.SecurityElement other) => throw null;
            public static string Escape(string str) => throw null;
            public static System.Security.SecurityElement FromString(string xml) => throw null;
            public static bool IsValidAttributeName(string name) => throw null;
            public static bool IsValidAttributeValue(string value) => throw null;
            public static bool IsValidTag(string tag) => throw null;
            public static bool IsValidText(string text) => throw null;
            public System.Security.SecurityElement SearchForChildByTag(string tag) => throw null;
            public string SearchForTextOfTag(string tag) => throw null;
            public string Tag { get => throw null; set { } }
            public string Text { get => throw null; set { } }
            public override string ToString() => throw null;
        }
        public class SecurityException : System.SystemException
        {
            public SecurityException() => throw null;
            protected SecurityException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public SecurityException(string message) => throw null;
            public SecurityException(string message, System.Exception inner) => throw null;
            public SecurityException(string message, System.Type type) => throw null;
            public SecurityException(string message, System.Type type, string state) => throw null;
            public object Demanded { get => throw null; set { } }
            public object DenySetInstance { get => throw null; set { } }
            public System.Reflection.AssemblyName FailedAssemblyInfo { get => throw null; set { } }
            public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public string GrantedSet { get => throw null; set { } }
            public System.Reflection.MethodInfo Method { get => throw null; set { } }
            public string PermissionState { get => throw null; set { } }
            public System.Type PermissionType { get => throw null; set { } }
            public object PermitOnlySetInstance { get => throw null; set { } }
            public string RefusedSet { get => throw null; set { } }
            public override string ToString() => throw null;
            public string Url { get => throw null; set { } }
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false)]
        public sealed class SecurityRulesAttribute : System.Attribute
        {
            public SecurityRulesAttribute(System.Security.SecurityRuleSet ruleSet) => throw null;
            public System.Security.SecurityRuleSet RuleSet { get => throw null; }
            public bool SkipVerificationInFullTrust { get => throw null; set { } }
        }
        public enum SecurityRuleSet : byte
        {
            None = 0,
            Level1 = 1,
            Level2 = 2,
        }
        [System.AttributeUsage((System.AttributeTargets)5500, AllowMultiple = false, Inherited = false)]
        public sealed class SecuritySafeCriticalAttribute : System.Attribute
        {
            public SecuritySafeCriticalAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)1, AllowMultiple = false, Inherited = false)]
        public sealed class SecurityTransparentAttribute : System.Attribute
        {
            public SecurityTransparentAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)5501, AllowMultiple = false, Inherited = false)]
        public sealed class SecurityTreatAsSafeAttribute : System.Attribute
        {
            public SecurityTreatAsSafeAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)5188, AllowMultiple = true, Inherited = false)]
        public sealed class SuppressUnmanagedCodeSecurityAttribute : System.Attribute
        {
            public SuppressUnmanagedCodeSecurityAttribute() => throw null;
        }
        [System.AttributeUsage((System.AttributeTargets)2, AllowMultiple = true, Inherited = false)]
        public sealed class UnverifiableCodeAttribute : System.Attribute
        {
            public UnverifiableCodeAttribute() => throw null;
        }
        public class VerificationException : System.SystemException
        {
            public VerificationException() => throw null;
            protected VerificationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public VerificationException(string message) => throw null;
            public VerificationException(string message, System.Exception innerException) => throw null;
        }
    }
    [System.AttributeUsage((System.AttributeTargets)4124, Inherited = false)]
    public sealed class SerializableAttribute : System.Attribute
    {
        public SerializableAttribute() => throw null;
    }
    public struct Single : System.Numerics.IAdditionOperators<float, float, float>, System.Numerics.IAdditiveIdentity<float, float>, System.Numerics.IBinaryFloatingPointIeee754<float>, System.Numerics.IBinaryNumber<float>, System.Numerics.IBitwiseOperators<float, float, float>, System.IComparable, System.IComparable<float>, System.Numerics.IComparisonOperators<float, float, bool>, System.IConvertible, System.Numerics.IDecrementOperators<float>, System.Numerics.IDivisionOperators<float, float, float>, System.Numerics.IEqualityOperators<float, float, bool>, System.IEquatable<float>, System.Numerics.IExponentialFunctions<float>, System.Numerics.IFloatingPoint<float>, System.Numerics.IFloatingPointConstants<float>, System.Numerics.IFloatingPointIeee754<float>, System.IFormattable, System.Numerics.IHyperbolicFunctions<float>, System.Numerics.IIncrementOperators<float>, System.Numerics.ILogarithmicFunctions<float>, System.Numerics.IMinMaxValue<float>, System.Numerics.IModulusOperators<float, float, float>, System.Numerics.IMultiplicativeIdentity<float, float>, System.Numerics.IMultiplyOperators<float, float, float>, System.Numerics.INumber<float>, System.Numerics.INumberBase<float>, System.IParsable<float>, System.Numerics.IPowerFunctions<float>, System.Numerics.IRootFunctions<float>, System.Numerics.ISignedNumber<float>, System.ISpanFormattable, System.ISpanParsable<float>, System.Numerics.ISubtractionOperators<float, float, float>, System.Numerics.ITrigonometricFunctions<float>, System.Numerics.IUnaryNegationOperators<float, float>, System.Numerics.IUnaryPlusOperators<float, float>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<float>
    {
        static float System.Numerics.INumberBase<float>.Abs(float value) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.Acos(float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Acosh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.AcosPi(float x) => throw null;
        static float System.Numerics.IAdditiveIdentity<float, float>.AdditiveIdentity { get => throw null; }
        static float System.Numerics.IBinaryNumber<float>.AllBitsSet { get => throw null; }
        static float System.Numerics.ITrigonometricFunctions<float>.Asin(float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Asinh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.AsinPi(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.Atan(float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.Atan2(float y, float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.Atan2Pi(float y, float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Atanh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.AtanPi(float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.BitDecrement(float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.BitIncrement(float x) => throw null;
        static float System.Numerics.IRootFunctions<float>.Cbrt(float x) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Ceiling(float x) => throw null;
        static float System.Numerics.INumber<float>.Clamp(float value, float min, float max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(float value) => throw null;
        static float System.Numerics.INumber<float>.CopySign(float value, float sign) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.Cos(float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Cosh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.CosPi(float x) => throw null;
        static float System.Numerics.INumberBase<float>.CreateChecked<TOther>(TOther value) => throw null;
        static float System.Numerics.INumberBase<float>.CreateSaturating<TOther>(TOther value) => throw null;
        static float System.Numerics.INumberBase<float>.CreateTruncating<TOther>(TOther value) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.DegreesToRadians(float degrees) => throw null;
        public const float E = default;
        static float System.Numerics.IFloatingPointConstants<float>.E { get => throw null; }
        public const float Epsilon = default;
        static float System.Numerics.IFloatingPointIeee754<float>.Epsilon { get => throw null; }
        public override bool Equals(object obj) => throw null;
        public bool Equals(float obj) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.Exp(float x) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.Exp10(float x) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.Exp10M1(float x) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.Exp2(float x) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.Exp2M1(float x) => throw null;
        static float System.Numerics.IExponentialFunctions<float>.ExpM1(float x) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Floor(float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.FusedMultiplyAdd(float left, float right, float addend) => throw null;
        int System.Numerics.IFloatingPoint<float>.GetExponentByteCount() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetExponentShortestBitLength() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetSignificandBitLength() => throw null;
        int System.Numerics.IFloatingPoint<float>.GetSignificandByteCount() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static float System.Numerics.IRootFunctions<float>.Hypot(float x, float y) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.Ieee754Remainder(float left, float right) => throw null;
        static int System.Numerics.IFloatingPointIeee754<float>.ILogB(float x) => throw null;
        static bool System.Numerics.INumberBase<float>.IsCanonical(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsComplexNumber(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsEvenInteger(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsFinite(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsImaginaryNumber(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsInfinity(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsInteger(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsNaN(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsNegative(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsNegativeInfinity(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsNormal(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsOddInteger(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsPositive(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsPositiveInfinity(float f) => throw null;
        static bool System.Numerics.IBinaryNumber<float>.IsPow2(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsRealNumber(float value) => throw null;
        static bool System.Numerics.INumberBase<float>.IsSubnormal(float f) => throw null;
        static bool System.Numerics.INumberBase<float>.IsZero(float value) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.Lerp(float value1, float value2, float amount) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log(float x) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log(float x, float newBase) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log10(float x) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log10P1(float x) => throw null;
        static float System.Numerics.IBinaryNumber<float>.Log2(float value) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log2(float value) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.Log2P1(float x) => throw null;
        static float System.Numerics.ILogarithmicFunctions<float>.LogP1(float x) => throw null;
        static float System.Numerics.INumber<float>.Max(float x, float y) => throw null;
        static float System.Numerics.INumberBase<float>.MaxMagnitude(float x, float y) => throw null;
        static float System.Numerics.INumberBase<float>.MaxMagnitudeNumber(float x, float y) => throw null;
        static float System.Numerics.INumber<float>.MaxNumber(float x, float y) => throw null;
        public const float MaxValue = default;
        static float System.Numerics.IMinMaxValue<float>.MaxValue { get => throw null; }
        static float System.Numerics.INumber<float>.Min(float x, float y) => throw null;
        static float System.Numerics.INumberBase<float>.MinMagnitude(float x, float y) => throw null;
        static float System.Numerics.INumberBase<float>.MinMagnitudeNumber(float x, float y) => throw null;
        static float System.Numerics.INumber<float>.MinNumber(float x, float y) => throw null;
        public const float MinValue = default;
        static float System.Numerics.IMinMaxValue<float>.MinValue { get => throw null; }
        static float System.Numerics.IMultiplicativeIdentity<float, float>.MultiplicativeIdentity { get => throw null; }
        public const float NaN = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NaN { get => throw null; }
        public const float NegativeInfinity = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NegativeInfinity { get => throw null; }
        static float System.Numerics.ISignedNumber<float>.NegativeOne { get => throw null; }
        public const float NegativeZero = default;
        static float System.Numerics.IFloatingPointIeee754<float>.NegativeZero { get => throw null; }
        static float System.Numerics.INumberBase<float>.One { get => throw null; }
        static float System.Numerics.IAdditionOperators<float, float, float>.operator +(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator &(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator |(float left, float right) => throw null;
        static float System.Numerics.IDecrementOperators<float>.operator --(float value) => throw null;
        static float System.Numerics.IDivisionOperators<float, float, float>.operator /(float left, float right) => throw null;
        static bool System.Numerics.IEqualityOperators<float, float, bool>.operator ==(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator ^(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator >(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator >=(float left, float right) => throw null;
        static float System.Numerics.IIncrementOperators<float>.operator ++(float value) => throw null;
        static bool System.Numerics.IEqualityOperators<float, float, bool>.operator !=(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator <(float left, float right) => throw null;
        static bool System.Numerics.IComparisonOperators<float, float, bool>.operator <=(float left, float right) => throw null;
        static float System.Numerics.IModulusOperators<float, float, float>.operator %(float left, float right) => throw null;
        static float System.Numerics.IMultiplyOperators<float, float, float>.operator *(float left, float right) => throw null;
        static float System.Numerics.IBitwiseOperators<float, float, float>.operator ~(float value) => throw null;
        static float System.Numerics.ISubtractionOperators<float, float, float>.operator -(float left, float right) => throw null;
        static float System.Numerics.IUnaryNegationOperators<float, float>.operator -(float value) => throw null;
        static float System.Numerics.IUnaryPlusOperators<float, float>.operator +(float value) => throw null;
        static float System.Numerics.INumberBase<float>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static float System.IUtf8SpanParsable<float>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static float System.Numerics.INumberBase<float>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static float System.ISpanParsable<float>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static float Parse(string s) => throw null;
        public static float Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static float System.Numerics.INumberBase<float>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static float System.IParsable<float>.Parse(string s, System.IFormatProvider provider) => throw null;
        public const float Pi = default;
        static float System.Numerics.IFloatingPointConstants<float>.Pi { get => throw null; }
        public const float PositiveInfinity = default;
        static float System.Numerics.IFloatingPointIeee754<float>.PositiveInfinity { get => throw null; }
        static float System.Numerics.IPowerFunctions<float>.Pow(float x, float y) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.RadiansToDegrees(float radians) => throw null;
        static int System.Numerics.INumberBase<float>.Radix { get => throw null; }
        static float System.Numerics.IFloatingPointIeee754<float>.ReciprocalEstimate(float x) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.ReciprocalSqrtEstimate(float x) => throw null;
        static float System.Numerics.IRootFunctions<float>.RootN(float x, int n) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Round(float x) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Round(float x, int digits) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Round(float x, int digits, System.MidpointRounding mode) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Round(float x, System.MidpointRounding mode) => throw null;
        static float System.Numerics.IFloatingPointIeee754<float>.ScaleB(float x, int n) => throw null;
        static int System.Numerics.INumber<float>.Sign(float value) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.Sin(float x) => throw null;
        static (float Sin, float Cos) System.Numerics.ITrigonometricFunctions<float>.SinCos(float x) => throw null;
        static (float SinPi, float CosPi) System.Numerics.ITrigonometricFunctions<float>.SinCosPi(float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Sinh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.SinPi(float x) => throw null;
        static float System.Numerics.IRootFunctions<float>.Sqrt(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.Tan(float x) => throw null;
        static float System.Numerics.IHyperbolicFunctions<float>.Tanh(float x) => throw null;
        static float System.Numerics.ITrigonometricFunctions<float>.TanPi(float x) => throw null;
        public const float Tau = default;
        static float System.Numerics.IFloatingPointConstants<float>.Tau { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static float System.Numerics.IFloatingPoint<float>.Truncate(float x) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromChecked<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromSaturating<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertFromTruncating<TOther>(TOther value, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToChecked<TOther>(float value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToSaturating<TOther>(float value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryConvertToTruncating<TOther>(float value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<float>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) => throw null;
        static bool System.IUtf8SpanParsable<float>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) => throw null;
        static bool System.ISpanParsable<float>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out float result) => throw null;
        static bool System.Numerics.INumberBase<float>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) => throw null;
        static bool System.IParsable<float>.TryParse(string s, System.IFormatProvider provider, out float result) => throw null;
        public static bool TryParse(string s, out float result) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteExponentBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteExponentLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteSignificandBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IFloatingPoint<float>.TryWriteSignificandLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static float System.Numerics.INumberBase<float>.Zero { get => throw null; }
    }
    public struct Span<T>
    {
        public void Clear() => throw null;
        public void CopyTo(System.Span<T> destination) => throw null;
        public unsafe Span(void* pointer, int length) => throw null;
        public Span(T[] array) => throw null;
        public Span(T[] array, int start, int length) => throw null;
        public Span(ref T reference) => throw null;
        public static System.Span<T> Empty { get => throw null; }
        public struct Enumerator
        {
            public T Current { get => throw null; }
            public bool MoveNext() => throw null;
        }
        public override bool Equals(object obj) => throw null;
        public void Fill(T value) => throw null;
        public System.Span<T>.Enumerator GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public T GetPinnableReference() => throw null;
        public bool IsEmpty { get => throw null; }
        public int Length { get => throw null; }
        public static bool operator ==(System.Span<T> left, System.Span<T> right) => throw null;
        public static implicit operator System.Span<T>(System.ArraySegment<T> segment) => throw null;
        public static implicit operator System.ReadOnlySpan<T>(System.Span<T> span) => throw null;
        public static implicit operator System.Span<T>(T[] array) => throw null;
        public static bool operator !=(System.Span<T> left, System.Span<T> right) => throw null;
        public System.Span<T> Slice(int start) => throw null;
        public System.Span<T> Slice(int start, int length) => throw null;
        public T this[int index] { get => throw null; }
        public T[] ToArray() => throw null;
        public override string ToString() => throw null;
        public bool TryCopyTo(System.Span<T> destination) => throw null;
    }
    public sealed class StackOverflowException : System.SystemException
    {
        public StackOverflowException() => throw null;
        public StackOverflowException(string message) => throw null;
        public StackOverflowException(string message, System.Exception innerException) => throw null;
    }
    [System.AttributeUsage((System.AttributeTargets)64)]
    public sealed class STAThreadAttribute : System.Attribute
    {
        public STAThreadAttribute() => throw null;
    }
    public sealed class String : System.ICloneable, System.IComparable, System.IComparable<string>, System.IConvertible, System.Collections.Generic.IEnumerable<char>, System.Collections.IEnumerable, System.IEquatable<string>, System.IParsable<string>, System.ISpanParsable<string>
    {
        public object Clone() => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, System.StringComparison comparisonType) => throw null;
        public static int Compare(string strA, string strB) => throw null;
        public static int Compare(string strA, string strB, bool ignoreCase) => throw null;
        public static int Compare(string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public static int Compare(string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        public static int Compare(string strA, string strB, System.StringComparison comparisonType) => throw null;
        public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length) => throw null;
        public static int CompareOrdinal(string strA, string strB) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(string strB) => throw null;
        public static string Concat(System.Collections.Generic.IEnumerable<string> values) => throw null;
        public static string Concat(object arg0) => throw null;
        public static string Concat(object arg0, object arg1) => throw null;
        public static string Concat(object arg0, object arg1, object arg2) => throw null;
        public static string Concat(params object[] args) => throw null;
        public static string Concat(System.ReadOnlySpan<char> str0, System.ReadOnlySpan<char> str1) => throw null;
        public static string Concat(System.ReadOnlySpan<char> str0, System.ReadOnlySpan<char> str1, System.ReadOnlySpan<char> str2) => throw null;
        public static string Concat(System.ReadOnlySpan<char> str0, System.ReadOnlySpan<char> str1, System.ReadOnlySpan<char> str2, System.ReadOnlySpan<char> str3) => throw null;
        public static string Concat(string str0, string str1) => throw null;
        public static string Concat(string str0, string str1, string str2) => throw null;
        public static string Concat(string str0, string str1, string str2, string str3) => throw null;
        public static string Concat(params string[] values) => throw null;
        public static string Concat<T>(System.Collections.Generic.IEnumerable<T> values) => throw null;
        public bool Contains(char value) => throw null;
        public bool Contains(char value, System.StringComparison comparisonType) => throw null;
        public bool Contains(string value) => throw null;
        public bool Contains(string value, System.StringComparison comparisonType) => throw null;
        public static string Copy(string str) => throw null;
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) => throw null;
        public void CopyTo(System.Span<char> destination) => throw null;
        public static string Create(System.IFormatProvider provider, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("provider")] ref System.Runtime.CompilerServices.DefaultInterpolatedStringHandler handler) => throw null;
        public static string Create(System.IFormatProvider provider, System.Span<char> initialBuffer, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(new[] { "provider", "initialBuffer" })] ref System.Runtime.CompilerServices.DefaultInterpolatedStringHandler handler) => throw null;
        public static string Create<TState>(int length, TState state, System.Buffers.SpanAction<char, TState> action) => throw null;
        public unsafe String(char* value) => throw null;
        public unsafe String(char* value, int startIndex, int length) => throw null;
        public String(char c, int count) => throw null;
        public String(char[] value) => throw null;
        public String(char[] value, int startIndex, int length) => throw null;
        public String(System.ReadOnlySpan<char> value) => throw null;
        public unsafe String(sbyte* value) => throw null;
        public unsafe String(sbyte* value, int startIndex, int length) => throw null;
        public unsafe String(sbyte* value, int startIndex, int length, System.Text.Encoding enc) => throw null;
        public static readonly string Empty;
        public bool EndsWith(char value) => throw null;
        public bool EndsWith(string value) => throw null;
        public bool EndsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public bool EndsWith(string value, System.StringComparison comparisonType) => throw null;
        public System.Text.StringRuneEnumerator EnumerateRunes() => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(string value) => throw null;
        public static bool Equals(string a, string b) => throw null;
        public static bool Equals(string a, string b, System.StringComparison comparisonType) => throw null;
        public bool Equals(string value, System.StringComparison comparisonType) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1) => throw null;
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) => throw null;
        public static string Format(System.IFormatProvider provider, string format, params object[] args) => throw null;
        public static string Format(string format, object arg0) => throw null;
        public static string Format(string format, object arg0, object arg1) => throw null;
        public static string Format(string format, object arg0, object arg1, object arg2) => throw null;
        public static string Format(string format, params object[] args) => throw null;
        public static string Format<TArg0>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0) => throw null;
        public static string Format<TArg0, TArg1>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0, TArg1 arg1) => throw null;
        public static string Format<TArg0, TArg1, TArg2>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2) => throw null;
        public static string Format(System.IFormatProvider provider, System.Text.CompositeFormat format, params object[] args) => throw null;
        public static string Format(System.IFormatProvider provider, System.Text.CompositeFormat format, System.ReadOnlySpan<object> args) => throw null;
        public System.CharEnumerator GetEnumerator() => throw null;
        System.Collections.Generic.IEnumerator<char> System.Collections.Generic.IEnumerable<char>.GetEnumerator() => throw null;
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
        public override int GetHashCode() => throw null;
        public static int GetHashCode(System.ReadOnlySpan<char> value) => throw null;
        public static int GetHashCode(System.ReadOnlySpan<char> value, System.StringComparison comparisonType) => throw null;
        public int GetHashCode(System.StringComparison comparisonType) => throw null;
        public char GetPinnableReference() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        public int IndexOf(char value) => throw null;
        public int IndexOf(char value, int startIndex) => throw null;
        public int IndexOf(char value, int startIndex, int count) => throw null;
        public int IndexOf(char value, System.StringComparison comparisonType) => throw null;
        public int IndexOf(string value) => throw null;
        public int IndexOf(string value, int startIndex) => throw null;
        public int IndexOf(string value, int startIndex, int count) => throw null;
        public int IndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) => throw null;
        public int IndexOf(string value, int startIndex, System.StringComparison comparisonType) => throw null;
        public int IndexOf(string value, System.StringComparison comparisonType) => throw null;
        public int IndexOfAny(char[] anyOf) => throw null;
        public int IndexOfAny(char[] anyOf, int startIndex) => throw null;
        public int IndexOfAny(char[] anyOf, int startIndex, int count) => throw null;
        public string Insert(int startIndex, string value) => throw null;
        public static string Intern(string str) => throw null;
        public static string IsInterned(string str) => throw null;
        public bool IsNormalized() => throw null;
        public bool IsNormalized(System.Text.NormalizationForm normalizationForm) => throw null;
        public static bool IsNullOrEmpty(string value) => throw null;
        public static bool IsNullOrWhiteSpace(string value) => throw null;
        public static string Join(char separator, params object[] values) => throw null;
        public static string Join(char separator, params string[] value) => throw null;
        public static string Join(char separator, string[] value, int startIndex, int count) => throw null;
        public static string Join(string separator, System.Collections.Generic.IEnumerable<string> values) => throw null;
        public static string Join(string separator, params object[] values) => throw null;
        public static string Join(string separator, params string[] value) => throw null;
        public static string Join(string separator, string[] value, int startIndex, int count) => throw null;
        public static string Join<T>(char separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
        public static string Join<T>(string separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
        public int LastIndexOf(char value) => throw null;
        public int LastIndexOf(char value, int startIndex) => throw null;
        public int LastIndexOf(char value, int startIndex, int count) => throw null;
        public int LastIndexOf(string value) => throw null;
        public int LastIndexOf(string value, int startIndex) => throw null;
        public int LastIndexOf(string value, int startIndex, int count) => throw null;
        public int LastIndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) => throw null;
        public int LastIndexOf(string value, int startIndex, System.StringComparison comparisonType) => throw null;
        public int LastIndexOf(string value, System.StringComparison comparisonType) => throw null;
        public int LastIndexOfAny(char[] anyOf) => throw null;
        public int LastIndexOfAny(char[] anyOf, int startIndex) => throw null;
        public int LastIndexOfAny(char[] anyOf, int startIndex, int count) => throw null;
        public int Length { get => throw null; }
        public string Normalize() => throw null;
        public string Normalize(System.Text.NormalizationForm normalizationForm) => throw null;
        public static bool operator ==(string a, string b) => throw null;
        public static implicit operator System.ReadOnlySpan<char>(string value) => throw null;
        public static bool operator !=(string a, string b) => throw null;
        public string PadLeft(int totalWidth) => throw null;
        public string PadLeft(int totalWidth, char paddingChar) => throw null;
        public string PadRight(int totalWidth) => throw null;
        public string PadRight(int totalWidth, char paddingChar) => throw null;
        static string System.IParsable<string>.Parse(string s, System.IFormatProvider provider) => throw null;
        static string System.ISpanParsable<string>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public string Remove(int startIndex) => throw null;
        public string Remove(int startIndex, int count) => throw null;
        public string Replace(char oldChar, char newChar) => throw null;
        public string Replace(string oldValue, string newValue) => throw null;
        public string Replace(string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public string Replace(string oldValue, string newValue, System.StringComparison comparisonType) => throw null;
        public string ReplaceLineEndings() => throw null;
        public string ReplaceLineEndings(string replacementText) => throw null;
        public string[] Split(char separator, int count, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(char separator, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(params char[] separator) => throw null;
        public string[] Split(char[] separator, int count) => throw null;
        public string[] Split(char[] separator, int count, System.StringSplitOptions options) => throw null;
        public string[] Split(char[] separator, System.StringSplitOptions options) => throw null;
        public string[] Split(string separator, int count, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(string separator, System.StringSplitOptions options = default(System.StringSplitOptions)) => throw null;
        public string[] Split(string[] separator, int count, System.StringSplitOptions options) => throw null;
        public string[] Split(string[] separator, System.StringSplitOptions options) => throw null;
        public bool StartsWith(char value) => throw null;
        public bool StartsWith(string value) => throw null;
        public bool StartsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture) => throw null;
        public bool StartsWith(string value, System.StringComparison comparisonType) => throw null;
        public string Substring(int startIndex) => throw null;
        public string Substring(int startIndex, int length) => throw null;
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public char this[int index] { get => throw null; }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        public char[] ToCharArray() => throw null;
        public char[] ToCharArray(int startIndex, int length) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        public string ToLower() => throw null;
        public string ToLower(System.Globalization.CultureInfo culture) => throw null;
        public string ToLowerInvariant() => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        public string ToUpper() => throw null;
        public string ToUpper(System.Globalization.CultureInfo culture) => throw null;
        public string ToUpperInvariant() => throw null;
        public string Trim() => throw null;
        public string Trim(char trimChar) => throw null;
        public string Trim(params char[] trimChars) => throw null;
        public string TrimEnd() => throw null;
        public string TrimEnd(char trimChar) => throw null;
        public string TrimEnd(params char[] trimChars) => throw null;
        public string TrimStart() => throw null;
        public string TrimStart(char trimChar) => throw null;
        public string TrimStart(params char[] trimChars) => throw null;
        public bool TryCopyTo(System.Span<char> destination) => throw null;
        static bool System.IParsable<string>.TryParse(string s, System.IFormatProvider provider, out string result) => throw null;
        static bool System.ISpanParsable<string>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out string result) => throw null;
    }
    public abstract class StringComparer : System.Collections.Generic.IComparer<string>, System.Collections.IComparer, System.Collections.Generic.IEqualityComparer<string>, System.Collections.IEqualityComparer
    {
        public int Compare(object x, object y) => throw null;
        public abstract int Compare(string x, string y);
        public static System.StringComparer Create(System.Globalization.CultureInfo culture, bool ignoreCase) => throw null;
        public static System.StringComparer Create(System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options) => throw null;
        protected StringComparer() => throw null;
        public static System.StringComparer CurrentCulture { get => throw null; }
        public static System.StringComparer CurrentCultureIgnoreCase { get => throw null; }
        public bool Equals(object x, object y) => throw null;
        public abstract bool Equals(string x, string y);
        public static System.StringComparer FromComparison(System.StringComparison comparisonType) => throw null;
        public int GetHashCode(object obj) => throw null;
        public abstract int GetHashCode(string obj);
        public static System.StringComparer InvariantCulture { get => throw null; }
        public static System.StringComparer InvariantCultureIgnoreCase { get => throw null; }
        public static bool IsWellKnownCultureAwareComparer(System.Collections.Generic.IEqualityComparer<string> comparer, out System.Globalization.CompareInfo compareInfo, out System.Globalization.CompareOptions compareOptions) => throw null;
        public static bool IsWellKnownOrdinalComparer(System.Collections.Generic.IEqualityComparer<string> comparer, out bool ignoreCase) => throw null;
        public static System.StringComparer Ordinal { get => throw null; }
        public static System.StringComparer OrdinalIgnoreCase { get => throw null; }
    }
    public enum StringComparison
    {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }
    public static partial class StringNormalizationExtensions
    {
        public static bool IsNormalized(this string strInput) => throw null;
        public static bool IsNormalized(this string strInput, System.Text.NormalizationForm normalizationForm) => throw null;
        public static string Normalize(this string strInput) => throw null;
        public static string Normalize(this string strInput, System.Text.NormalizationForm normalizationForm) => throw null;
    }
    [System.Flags]
    public enum StringSplitOptions
    {
        None = 0,
        RemoveEmptyEntries = 1,
        TrimEntries = 2,
    }
    public class SystemException : System.Exception
    {
        public SystemException() => throw null;
        protected SystemException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public SystemException(string message) => throw null;
        public SystemException(string message, System.Exception innerException) => throw null;
    }
    namespace Text
    {
        public static class Ascii
        {
            public static bool Equals(System.ReadOnlySpan<byte> left, System.ReadOnlySpan<byte> right) => throw null;
            public static bool Equals(System.ReadOnlySpan<byte> left, System.ReadOnlySpan<char> right) => throw null;
            public static bool Equals(System.ReadOnlySpan<char> left, System.ReadOnlySpan<byte> right) => throw null;
            public static bool Equals(System.ReadOnlySpan<char> left, System.ReadOnlySpan<char> right) => throw null;
            public static bool EqualsIgnoreCase(System.ReadOnlySpan<byte> left, System.ReadOnlySpan<byte> right) => throw null;
            public static bool EqualsIgnoreCase(System.ReadOnlySpan<byte> left, System.ReadOnlySpan<char> right) => throw null;
            public static bool EqualsIgnoreCase(System.ReadOnlySpan<char> left, System.ReadOnlySpan<byte> right) => throw null;
            public static bool EqualsIgnoreCase(System.ReadOnlySpan<char> left, System.ReadOnlySpan<char> right) => throw null;
            public static System.Buffers.OperationStatus FromUtf16(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int bytesWritten) => throw null;
            public static bool IsValid(System.ReadOnlySpan<byte> value) => throw null;
            public static bool IsValid(System.ReadOnlySpan<char> value) => throw null;
            public static bool IsValid(byte value) => throw null;
            public static bool IsValid(char value) => throw null;
            public static System.Buffers.OperationStatus ToLower(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToLower(System.ReadOnlySpan<char> source, System.Span<char> destination, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToLower(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToLower(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToLowerInPlace(System.Span<byte> value, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToLowerInPlace(System.Span<char> value, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpper(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpper(System.ReadOnlySpan<char> source, System.Span<char> destination, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpper(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpper(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpperInPlace(System.Span<byte> value, out int bytesWritten) => throw null;
            public static System.Buffers.OperationStatus ToUpperInPlace(System.Span<char> value, out int charsWritten) => throw null;
            public static System.Buffers.OperationStatus ToUtf16(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int charsWritten) => throw null;
            public static System.Range Trim(System.ReadOnlySpan<byte> value) => throw null;
            public static System.Range Trim(System.ReadOnlySpan<char> value) => throw null;
            public static System.Range TrimEnd(System.ReadOnlySpan<byte> value) => throw null;
            public static System.Range TrimEnd(System.ReadOnlySpan<char> value) => throw null;
            public static System.Range TrimStart(System.ReadOnlySpan<byte> value) => throw null;
            public static System.Range TrimStart(System.ReadOnlySpan<char> value) => throw null;
        }
        public sealed class CompositeFormat
        {
            public string Format { get => throw null; }
            public int MinimumArgumentCount { get => throw null; }
            public static System.Text.CompositeFormat Parse(string format) => throw null;
        }
        public abstract class Decoder
        {
            public virtual unsafe void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            public virtual void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            public virtual void Convert(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed) => throw null;
            protected Decoder() => throw null;
            public System.Text.DecoderFallback Fallback { get => throw null; set { } }
            public System.Text.DecoderFallbackBuffer FallbackBuffer { get => throw null; }
            public virtual unsafe int GetCharCount(byte* bytes, int count, bool flush) => throw null;
            public abstract int GetCharCount(byte[] bytes, int index, int count);
            public virtual int GetCharCount(byte[] bytes, int index, int count, bool flush) => throw null;
            public virtual int GetCharCount(System.ReadOnlySpan<byte> bytes, bool flush) => throw null;
            public virtual unsafe int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush) => throw null;
            public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush) => throw null;
            public virtual int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, bool flush) => throw null;
            public virtual void Reset() => throw null;
        }
        public sealed class DecoderExceptionFallback : System.Text.DecoderFallback
        {
            public override System.Text.DecoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public DecoderExceptionFallback() => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }
        public sealed class DecoderExceptionFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            public DecoderExceptionFallbackBuffer() => throw null;
            public override bool Fallback(byte[] bytesUnknown, int index) => throw null;
            public override char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
        }
        public abstract class DecoderFallback
        {
            public abstract System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            protected DecoderFallback() => throw null;
            public static System.Text.DecoderFallback ExceptionFallback { get => throw null; }
            public abstract int MaxCharCount { get; }
            public static System.Text.DecoderFallback ReplacementFallback { get => throw null; }
        }
        public abstract class DecoderFallbackBuffer
        {
            protected DecoderFallbackBuffer() => throw null;
            public abstract bool Fallback(byte[] bytesUnknown, int index);
            public abstract char GetNextChar();
            public abstract bool MovePrevious();
            public abstract int Remaining { get; }
            public virtual void Reset() => throw null;
        }
        public sealed class DecoderFallbackException : System.ArgumentException
        {
            public byte[] BytesUnknown { get => throw null; }
            public DecoderFallbackException() => throw null;
            public DecoderFallbackException(string message) => throw null;
            public DecoderFallbackException(string message, byte[] bytesUnknown, int index) => throw null;
            public DecoderFallbackException(string message, System.Exception innerException) => throw null;
            public int Index { get => throw null; }
        }
        public sealed class DecoderReplacementFallback : System.Text.DecoderFallback
        {
            public override System.Text.DecoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public DecoderReplacementFallback() => throw null;
            public DecoderReplacementFallback(string replacement) => throw null;
            public string DefaultString { get => throw null; }
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }
        public sealed class DecoderReplacementFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            public DecoderReplacementFallbackBuffer(System.Text.DecoderReplacementFallback fallback) => throw null;
            public override bool Fallback(byte[] bytesUnknown, int index) => throw null;
            public override char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
            public override void Reset() => throw null;
        }
        public abstract class Encoder
        {
            public virtual unsafe void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            public virtual void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            public virtual void Convert(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed) => throw null;
            protected Encoder() => throw null;
            public System.Text.EncoderFallback Fallback { get => throw null; set { } }
            public System.Text.EncoderFallbackBuffer FallbackBuffer { get => throw null; }
            public virtual unsafe int GetByteCount(char* chars, int count, bool flush) => throw null;
            public abstract int GetByteCount(char[] chars, int index, int count, bool flush);
            public virtual int GetByteCount(System.ReadOnlySpan<char> chars, bool flush) => throw null;
            public virtual unsafe int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush) => throw null;
            public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
            public virtual int GetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, bool flush) => throw null;
            public virtual void Reset() => throw null;
        }
        public sealed class EncoderExceptionFallback : System.Text.EncoderFallback
        {
            public override System.Text.EncoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public EncoderExceptionFallback() => throw null;
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }
        public sealed class EncoderExceptionFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            public EncoderExceptionFallbackBuffer() => throw null;
            public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index) => throw null;
            public override bool Fallback(char charUnknown, int index) => throw null;
            public override char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
        }
        public abstract class EncoderFallback
        {
            public abstract System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            protected EncoderFallback() => throw null;
            public static System.Text.EncoderFallback ExceptionFallback { get => throw null; }
            public abstract int MaxCharCount { get; }
            public static System.Text.EncoderFallback ReplacementFallback { get => throw null; }
        }
        public abstract class EncoderFallbackBuffer
        {
            protected EncoderFallbackBuffer() => throw null;
            public abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            public abstract bool Fallback(char charUnknown, int index);
            public abstract char GetNextChar();
            public abstract bool MovePrevious();
            public abstract int Remaining { get; }
            public virtual void Reset() => throw null;
        }
        public sealed class EncoderFallbackException : System.ArgumentException
        {
            public char CharUnknown { get => throw null; }
            public char CharUnknownHigh { get => throw null; }
            public char CharUnknownLow { get => throw null; }
            public EncoderFallbackException() => throw null;
            public EncoderFallbackException(string message) => throw null;
            public EncoderFallbackException(string message, System.Exception innerException) => throw null;
            public int Index { get => throw null; }
            public bool IsUnknownSurrogate() => throw null;
        }
        public sealed class EncoderReplacementFallback : System.Text.EncoderFallback
        {
            public override System.Text.EncoderFallbackBuffer CreateFallbackBuffer() => throw null;
            public EncoderReplacementFallback() => throw null;
            public EncoderReplacementFallback(string replacement) => throw null;
            public string DefaultString { get => throw null; }
            public override bool Equals(object value) => throw null;
            public override int GetHashCode() => throw null;
            public override int MaxCharCount { get => throw null; }
        }
        public sealed class EncoderReplacementFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            public EncoderReplacementFallbackBuffer(System.Text.EncoderReplacementFallback fallback) => throw null;
            public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index) => throw null;
            public override bool Fallback(char charUnknown, int index) => throw null;
            public override char GetNextChar() => throw null;
            public override bool MovePrevious() => throw null;
            public override int Remaining { get => throw null; }
            public override void Reset() => throw null;
        }
        public abstract class Encoding : System.ICloneable
        {
            public static System.Text.Encoding ASCII { get => throw null; }
            public static System.Text.Encoding BigEndianUnicode { get => throw null; }
            public virtual string BodyName { get => throw null; }
            public virtual object Clone() => throw null;
            public virtual int CodePage { get => throw null; }
            public static byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes) => throw null;
            public static byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count) => throw null;
            public static System.IO.Stream CreateTranscodingStream(System.IO.Stream innerStream, System.Text.Encoding innerStreamEncoding, System.Text.Encoding outerStreamEncoding, bool leaveOpen = default(bool)) => throw null;
            protected Encoding() => throw null;
            protected Encoding(int codePage) => throw null;
            protected Encoding(int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public System.Text.DecoderFallback DecoderFallback { get => throw null; set { } }
            public static System.Text.Encoding Default { get => throw null; }
            public System.Text.EncoderFallback EncoderFallback { get => throw null; set { } }
            public virtual string EncodingName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public virtual unsafe int GetByteCount(char* chars, int count) => throw null;
            public virtual int GetByteCount(char[] chars) => throw null;
            public abstract int GetByteCount(char[] chars, int index, int count);
            public virtual int GetByteCount(System.ReadOnlySpan<char> chars) => throw null;
            public virtual int GetByteCount(string s) => throw null;
            public int GetByteCount(string s, int index, int count) => throw null;
            public virtual unsafe int GetBytes(char* chars, int charCount, byte* bytes, int byteCount) => throw null;
            public virtual byte[] GetBytes(char[] chars) => throw null;
            public virtual byte[] GetBytes(char[] chars, int index, int count) => throw null;
            public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            public virtual int GetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes) => throw null;
            public virtual byte[] GetBytes(string s) => throw null;
            public byte[] GetBytes(string s, int index, int count) => throw null;
            public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex) => throw null;
            public virtual unsafe int GetCharCount(byte* bytes, int count) => throw null;
            public virtual int GetCharCount(byte[] bytes) => throw null;
            public abstract int GetCharCount(byte[] bytes, int index, int count);
            public virtual int GetCharCount(System.ReadOnlySpan<byte> bytes) => throw null;
            public virtual unsafe int GetChars(byte* bytes, int byteCount, char* chars, int charCount) => throw null;
            public virtual char[] GetChars(byte[] bytes) => throw null;
            public virtual char[] GetChars(byte[] bytes, int index, int count) => throw null;
            public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            public virtual int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars) => throw null;
            public virtual System.Text.Decoder GetDecoder() => throw null;
            public virtual System.Text.Encoder GetEncoder() => throw null;
            public static System.Text.Encoding GetEncoding(int codepage) => throw null;
            public static System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public static System.Text.Encoding GetEncoding(string name) => throw null;
            public static System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public static System.Text.EncodingInfo[] GetEncodings() => throw null;
            public override int GetHashCode() => throw null;
            public abstract int GetMaxByteCount(int charCount);
            public abstract int GetMaxCharCount(int byteCount);
            public virtual byte[] GetPreamble() => throw null;
            public unsafe string GetString(byte* bytes, int byteCount) => throw null;
            public virtual string GetString(byte[] bytes) => throw null;
            public virtual string GetString(byte[] bytes, int index, int count) => throw null;
            public string GetString(System.ReadOnlySpan<byte> bytes) => throw null;
            public virtual string HeaderName { get => throw null; }
            public bool IsAlwaysNormalized() => throw null;
            public virtual bool IsAlwaysNormalized(System.Text.NormalizationForm form) => throw null;
            public virtual bool IsBrowserDisplay { get => throw null; }
            public virtual bool IsBrowserSave { get => throw null; }
            public virtual bool IsMailNewsDisplay { get => throw null; }
            public virtual bool IsMailNewsSave { get => throw null; }
            public bool IsReadOnly { get => throw null; }
            public virtual bool IsSingleByte { get => throw null; }
            public static System.Text.Encoding Latin1 { get => throw null; }
            public virtual System.ReadOnlySpan<byte> Preamble { get => throw null; }
            public static void RegisterProvider(System.Text.EncodingProvider provider) => throw null;
            public virtual bool TryGetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, out int bytesWritten) => throw null;
            public virtual bool TryGetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, out int charsWritten) => throw null;
            public static System.Text.Encoding Unicode { get => throw null; }
            public static System.Text.Encoding UTF32 { get => throw null; }
            public static System.Text.Encoding UTF7 { get => throw null; }
            public static System.Text.Encoding UTF8 { get => throw null; }
            public virtual string WebName { get => throw null; }
            public virtual int WindowsCodePage { get => throw null; }
        }
        public sealed class EncodingInfo
        {
            public int CodePage { get => throw null; }
            public EncodingInfo(System.Text.EncodingProvider provider, int codePage, string name, string displayName) => throw null;
            public string DisplayName { get => throw null; }
            public override bool Equals(object value) => throw null;
            public System.Text.Encoding GetEncoding() => throw null;
            public override int GetHashCode() => throw null;
            public string Name { get => throw null; }
        }
        public abstract class EncodingProvider
        {
            public EncodingProvider() => throw null;
            public abstract System.Text.Encoding GetEncoding(int codepage);
            public virtual System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public abstract System.Text.Encoding GetEncoding(string name);
            public virtual System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback) => throw null;
            public virtual System.Collections.Generic.IEnumerable<System.Text.EncodingInfo> GetEncodings() => throw null;
        }
        public enum NormalizationForm
        {
            FormC = 1,
            FormD = 2,
            FormKC = 5,
            FormKD = 6,
        }
        public struct Rune : System.IComparable, System.IComparable<System.Text.Rune>, System.IEquatable<System.Text.Rune>, System.IFormattable, System.ISpanFormattable, System.IUtf8SpanFormattable
        {
            public int CompareTo(System.Text.Rune other) => throw null;
            int System.IComparable.CompareTo(object obj) => throw null;
            public Rune(char ch) => throw null;
            public Rune(char highSurrogate, char lowSurrogate) => throw null;
            public Rune(int value) => throw null;
            public Rune(uint value) => throw null;
            public static System.Buffers.OperationStatus DecodeFromUtf16(System.ReadOnlySpan<char> source, out System.Text.Rune result, out int charsConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<byte> source, out System.Text.Rune result, out int bytesConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeLastFromUtf16(System.ReadOnlySpan<char> source, out System.Text.Rune result, out int charsConsumed) => throw null;
            public static System.Buffers.OperationStatus DecodeLastFromUtf8(System.ReadOnlySpan<byte> source, out System.Text.Rune value, out int bytesConsumed) => throw null;
            public int EncodeToUtf16(System.Span<char> destination) => throw null;
            public int EncodeToUtf8(System.Span<byte> destination) => throw null;
            public override bool Equals(object obj) => throw null;
            public bool Equals(System.Text.Rune other) => throw null;
            public override int GetHashCode() => throw null;
            public static double GetNumericValue(System.Text.Rune value) => throw null;
            public static System.Text.Rune GetRuneAt(string input, int index) => throw null;
            public static System.Globalization.UnicodeCategory GetUnicodeCategory(System.Text.Rune value) => throw null;
            public bool IsAscii { get => throw null; }
            public bool IsBmp { get => throw null; }
            public static bool IsControl(System.Text.Rune value) => throw null;
            public static bool IsDigit(System.Text.Rune value) => throw null;
            public static bool IsLetter(System.Text.Rune value) => throw null;
            public static bool IsLetterOrDigit(System.Text.Rune value) => throw null;
            public static bool IsLower(System.Text.Rune value) => throw null;
            public static bool IsNumber(System.Text.Rune value) => throw null;
            public static bool IsPunctuation(System.Text.Rune value) => throw null;
            public static bool IsSeparator(System.Text.Rune value) => throw null;
            public static bool IsSymbol(System.Text.Rune value) => throw null;
            public static bool IsUpper(System.Text.Rune value) => throw null;
            public static bool IsValid(int value) => throw null;
            public static bool IsValid(uint value) => throw null;
            public static bool IsWhiteSpace(System.Text.Rune value) => throw null;
            public static bool operator ==(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static explicit operator System.Text.Rune(char ch) => throw null;
            public static explicit operator System.Text.Rune(int value) => throw null;
            public static explicit operator System.Text.Rune(uint value) => throw null;
            public static bool operator >(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator >=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator !=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator <(System.Text.Rune left, System.Text.Rune right) => throw null;
            public static bool operator <=(System.Text.Rune left, System.Text.Rune right) => throw null;
            public int Plane { get => throw null; }
            public static System.Text.Rune ReplacementChar { get => throw null; }
            public static System.Text.Rune ToLower(System.Text.Rune value, System.Globalization.CultureInfo culture) => throw null;
            public static System.Text.Rune ToLowerInvariant(System.Text.Rune value) => throw null;
            string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
            public override string ToString() => throw null;
            public static System.Text.Rune ToUpper(System.Text.Rune value, System.Globalization.CultureInfo culture) => throw null;
            public static System.Text.Rune ToUpperInvariant(System.Text.Rune value) => throw null;
            public static bool TryCreate(char highSurrogate, char lowSurrogate, out System.Text.Rune result) => throw null;
            public static bool TryCreate(char ch, out System.Text.Rune result) => throw null;
            public static bool TryCreate(int value, out System.Text.Rune result) => throw null;
            public static bool TryCreate(uint value, out System.Text.Rune result) => throw null;
            public bool TryEncodeToUtf16(System.Span<char> destination, out int charsWritten) => throw null;
            public bool TryEncodeToUtf8(System.Span<byte> destination, out int bytesWritten) => throw null;
            bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
            bool System.IUtf8SpanFormattable.TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
            public static bool TryGetRuneAt(string input, int index, out System.Text.Rune value) => throw null;
            public int Utf16SequenceLength { get => throw null; }
            public int Utf8SequenceLength { get => throw null; }
            public int Value { get => throw null; }
        }
        public sealed class StringBuilder : System.Runtime.Serialization.ISerializable
        {
            public System.Text.StringBuilder Append(bool value) => throw null;
            public System.Text.StringBuilder Append(byte value) => throw null;
            public System.Text.StringBuilder Append(char value) => throw null;
            public unsafe System.Text.StringBuilder Append(char* value, int valueCount) => throw null;
            public System.Text.StringBuilder Append(char value, int repeatCount) => throw null;
            public System.Text.StringBuilder Append(char[] value) => throw null;
            public System.Text.StringBuilder Append(char[] value, int startIndex, int charCount) => throw null;
            public System.Text.StringBuilder Append(decimal value) => throw null;
            public System.Text.StringBuilder Append(double value) => throw null;
            public System.Text.StringBuilder Append(System.IFormatProvider provider, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(new[] { "", "provider" })] ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder Append(short value) => throw null;
            public System.Text.StringBuilder Append(int value) => throw null;
            public System.Text.StringBuilder Append(long value) => throw null;
            public System.Text.StringBuilder Append(object value) => throw null;
            public System.Text.StringBuilder Append(System.ReadOnlyMemory<char> value) => throw null;
            public System.Text.StringBuilder Append(System.ReadOnlySpan<char> value) => throw null;
            public System.Text.StringBuilder Append(sbyte value) => throw null;
            public System.Text.StringBuilder Append(float value) => throw null;
            public System.Text.StringBuilder Append(string value) => throw null;
            public System.Text.StringBuilder Append(string value, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Append(System.Text.StringBuilder value) => throw null;
            public System.Text.StringBuilder Append(System.Text.StringBuilder value, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Append([System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("")] ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder Append(ushort value) => throw null;
            public System.Text.StringBuilder Append(uint value) => throw null;
            public System.Text.StringBuilder Append(ulong value) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, params object[] args) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) => throw null;
            public System.Text.StringBuilder AppendFormat(string format, params object[] args) => throw null;
            public System.Text.StringBuilder AppendFormat<TArg0>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0) => throw null;
            public System.Text.StringBuilder AppendFormat<TArg0, TArg1>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0, TArg1 arg1) => throw null;
            public System.Text.StringBuilder AppendFormat<TArg0, TArg1, TArg2>(System.IFormatProvider provider, System.Text.CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, System.Text.CompositeFormat format, params object[] args) => throw null;
            public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, System.Text.CompositeFormat format, System.ReadOnlySpan<object> args) => throw null;
            [System.Runtime.CompilerServices.InterpolatedStringHandler]
            public struct AppendInterpolatedStringHandler
            {
                public void AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value) => throw null;
                public void AppendFormatted(System.ReadOnlySpan<char> value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted(string value) => throw null;
                public void AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                public void AppendFormatted<T>(T value) => throw null;
                public void AppendFormatted<T>(T value, int alignment) => throw null;
                public void AppendFormatted<T>(T value, int alignment, string format) => throw null;
                public void AppendFormatted<T>(T value, string format) => throw null;
                public void AppendLiteral(string value) => throw null;
                public AppendInterpolatedStringHandler(int literalLength, int formattedCount, System.Text.StringBuilder stringBuilder) => throw null;
                public AppendInterpolatedStringHandler(int literalLength, int formattedCount, System.Text.StringBuilder stringBuilder, System.IFormatProvider provider) => throw null;
            }
            public System.Text.StringBuilder AppendJoin(char separator, params object[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(char separator, params string[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(string separator, params object[] values) => throw null;
            public System.Text.StringBuilder AppendJoin(string separator, params string[] values) => throw null;
            public System.Text.StringBuilder AppendJoin<T>(char separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
            public System.Text.StringBuilder AppendJoin<T>(string separator, System.Collections.Generic.IEnumerable<T> values) => throw null;
            public System.Text.StringBuilder AppendLine() => throw null;
            public System.Text.StringBuilder AppendLine(System.IFormatProvider provider, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(new[] { "", "provider" })] ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public System.Text.StringBuilder AppendLine(string value) => throw null;
            public System.Text.StringBuilder AppendLine([System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("")] ref System.Text.StringBuilder.AppendInterpolatedStringHandler handler) => throw null;
            public int Capacity { get => throw null; set { } }
            public struct ChunkEnumerator
            {
                public System.ReadOnlyMemory<char> Current { get => throw null; }
                public System.Text.StringBuilder.ChunkEnumerator GetEnumerator() => throw null;
                public bool MoveNext() => throw null;
            }
            public System.Text.StringBuilder Clear() => throw null;
            public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) => throw null;
            public void CopyTo(int sourceIndex, System.Span<char> destination, int count) => throw null;
            public StringBuilder() => throw null;
            public StringBuilder(int capacity) => throw null;
            public StringBuilder(int capacity, int maxCapacity) => throw null;
            public StringBuilder(string value) => throw null;
            public StringBuilder(string value, int capacity) => throw null;
            public StringBuilder(string value, int startIndex, int length, int capacity) => throw null;
            public int EnsureCapacity(int capacity) => throw null;
            public bool Equals(System.ReadOnlySpan<char> span) => throw null;
            public bool Equals(System.Text.StringBuilder sb) => throw null;
            public System.Text.StringBuilder.ChunkEnumerator GetChunks() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public System.Text.StringBuilder Insert(int index, bool value) => throw null;
            public System.Text.StringBuilder Insert(int index, byte value) => throw null;
            public System.Text.StringBuilder Insert(int index, char value) => throw null;
            public System.Text.StringBuilder Insert(int index, char[] value) => throw null;
            public System.Text.StringBuilder Insert(int index, char[] value, int startIndex, int charCount) => throw null;
            public System.Text.StringBuilder Insert(int index, decimal value) => throw null;
            public System.Text.StringBuilder Insert(int index, double value) => throw null;
            public System.Text.StringBuilder Insert(int index, short value) => throw null;
            public System.Text.StringBuilder Insert(int index, int value) => throw null;
            public System.Text.StringBuilder Insert(int index, long value) => throw null;
            public System.Text.StringBuilder Insert(int index, object value) => throw null;
            public System.Text.StringBuilder Insert(int index, System.ReadOnlySpan<char> value) => throw null;
            public System.Text.StringBuilder Insert(int index, sbyte value) => throw null;
            public System.Text.StringBuilder Insert(int index, float value) => throw null;
            public System.Text.StringBuilder Insert(int index, string value) => throw null;
            public System.Text.StringBuilder Insert(int index, string value, int count) => throw null;
            public System.Text.StringBuilder Insert(int index, ushort value) => throw null;
            public System.Text.StringBuilder Insert(int index, uint value) => throw null;
            public System.Text.StringBuilder Insert(int index, ulong value) => throw null;
            public int Length { get => throw null; set { } }
            public int MaxCapacity { get => throw null; }
            public System.Text.StringBuilder Remove(int startIndex, int length) => throw null;
            public System.Text.StringBuilder Replace(char oldChar, char newChar) => throw null;
            public System.Text.StringBuilder Replace(char oldChar, char newChar, int startIndex, int count) => throw null;
            public System.Text.StringBuilder Replace(string oldValue, string newValue) => throw null;
            public System.Text.StringBuilder Replace(string oldValue, string newValue, int startIndex, int count) => throw null;
            [System.Runtime.CompilerServices.IndexerName("Chars")]
            public char this[int index] { get => throw null; set { } }
            public override string ToString() => throw null;
            public string ToString(int startIndex, int length) => throw null;
        }
        public struct StringRuneEnumerator : System.IDisposable, System.Collections.Generic.IEnumerable<System.Text.Rune>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Text.Rune>, System.Collections.IEnumerator
        {
            public System.Text.Rune Current { get => throw null; }
            object System.Collections.IEnumerator.Current { get => throw null; }
            void System.IDisposable.Dispose() => throw null;
            public System.Text.StringRuneEnumerator GetEnumerator() => throw null;
            System.Collections.Generic.IEnumerator<System.Text.Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator() => throw null;
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => throw null;
            public bool MoveNext() => throw null;
            void System.Collections.IEnumerator.Reset() => throw null;
        }
        namespace Unicode
        {
            public static class Utf8
            {
                public static System.Buffers.OperationStatus FromUtf16(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int charsRead, out int bytesWritten, bool replaceInvalidSequences = default(bool), bool isFinalBlock = default(bool)) => throw null;
                public static bool IsValid(System.ReadOnlySpan<byte> value) => throw null;
                public static System.Buffers.OperationStatus ToUtf16(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int bytesRead, out int charsWritten, bool replaceInvalidSequences = default(bool), bool isFinalBlock = default(bool)) => throw null;
                public static bool TryWrite(System.Span<byte> destination, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("destination")] ref System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler handler, out int bytesWritten) => throw null;
                public static bool TryWrite(System.Span<byte> destination, System.IFormatProvider provider, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument(new[] { "destination", "provider" })] ref System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler handler, out int bytesWritten) => throw null;
                [System.Runtime.CompilerServices.InterpolatedStringHandler]
                public struct TryWriteInterpolatedStringHandler
                {
                    public bool AppendFormatted(System.ReadOnlySpan<char> value) => throw null;
                    public bool AppendFormatted(System.ReadOnlySpan<char> value, int alignment = default(int), string format = default(string)) => throw null;
                    public bool AppendFormatted(System.ReadOnlySpan<byte> utf8Value) => throw null;
                    public bool AppendFormatted(System.ReadOnlySpan<byte> utf8Value, int alignment = default(int), string format = default(string)) => throw null;
                    public bool AppendFormatted<T>(T value) => throw null;
                    public bool AppendFormatted<T>(T value, string format) => throw null;
                    public bool AppendFormatted<T>(T value, int alignment) => throw null;
                    public bool AppendFormatted<T>(T value, int alignment, string format) => throw null;
                    public bool AppendFormatted(object value, int alignment = default(int), string format = default(string)) => throw null;
                    public bool AppendFormatted(string value) => throw null;
                    public bool AppendFormatted(string value, int alignment = default(int), string format = default(string)) => throw null;
                    public bool AppendLiteral(string value) => throw null;
                    public TryWriteInterpolatedStringHandler(int literalLength, int formattedCount, System.Span<byte> destination, out bool shouldAppend) => throw null;
                    public TryWriteInterpolatedStringHandler(int literalLength, int formattedCount, System.Span<byte> destination, System.IFormatProvider provider, out bool shouldAppend) => throw null;
                }
            }
        }
    }
    namespace Threading
    {
        public struct CancellationToken : System.IEquatable<System.Threading.CancellationToken>
        {
            public bool CanBeCanceled { get => throw null; }
            public CancellationToken(bool canceled) => throw null;
            public override bool Equals(object other) => throw null;
            public bool Equals(System.Threading.CancellationToken other) => throw null;
            public override int GetHashCode() => throw null;
            public bool IsCancellationRequested { get => throw null; }
            public static System.Threading.CancellationToken None { get => throw null; }
            public static bool operator ==(System.Threading.CancellationToken left, System.Threading.CancellationToken right) => throw null;
            public static bool operator !=(System.Threading.CancellationToken left, System.Threading.CancellationToken right) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action callback) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action callback, bool useSynchronizationContext) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object, System.Threading.CancellationToken> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state, bool useSynchronizationContext) => throw null;
            public void ThrowIfCancellationRequested() => throw null;
            public System.Threading.CancellationTokenRegistration UnsafeRegister(System.Action<object, System.Threading.CancellationToken> callback, object state) => throw null;
            public System.Threading.CancellationTokenRegistration UnsafeRegister(System.Action<object> callback, object state) => throw null;
            public System.Threading.WaitHandle WaitHandle { get => throw null; }
        }
        public struct CancellationTokenRegistration : System.IAsyncDisposable, System.IDisposable, System.IEquatable<System.Threading.CancellationTokenRegistration>
        {
            public void Dispose() => throw null;
            public System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
            public override bool Equals(object obj) => throw null;
            public bool Equals(System.Threading.CancellationTokenRegistration other) => throw null;
            public override int GetHashCode() => throw null;
            public static bool operator ==(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right) => throw null;
            public static bool operator !=(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right) => throw null;
            public System.Threading.CancellationToken Token { get => throw null; }
            public bool Unregister() => throw null;
        }
        public class CancellationTokenSource : System.IDisposable
        {
            public void Cancel() => throw null;
            public void Cancel(bool throwOnFirstException) => throw null;
            public void CancelAfter(int millisecondsDelay) => throw null;
            public void CancelAfter(System.TimeSpan delay) => throw null;
            public System.Threading.Tasks.Task CancelAsync() => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token) => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2) => throw null;
            public static System.Threading.CancellationTokenSource CreateLinkedTokenSource(params System.Threading.CancellationToken[] tokens) => throw null;
            public CancellationTokenSource() => throw null;
            public CancellationTokenSource(System.TimeSpan delay, System.TimeProvider timeProvider) => throw null;
            public CancellationTokenSource(int millisecondsDelay) => throw null;
            public CancellationTokenSource(System.TimeSpan delay) => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool disposing) => throw null;
            public bool IsCancellationRequested { get => throw null; }
            public System.Threading.CancellationToken Token { get => throw null; }
            public bool TryReset() => throw null;
        }
        public interface ITimer : System.IAsyncDisposable, System.IDisposable
        {
            bool Change(System.TimeSpan dueTime, System.TimeSpan period);
        }
        public enum LazyThreadSafetyMode
        {
            None = 0,
            PublicationOnly = 1,
            ExecutionAndPublication = 2,
        }
        public sealed class PeriodicTimer : System.IDisposable
        {
            public PeriodicTimer(System.TimeSpan period) => throw null;
            public PeriodicTimer(System.TimeSpan period, System.TimeProvider timeProvider) => throw null;
            public void Dispose() => throw null;
            public System.TimeSpan Period { get => throw null; set { } }
            public System.Threading.Tasks.ValueTask<bool> WaitForNextTickAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
        }
        namespace Tasks
        {
            public class ConcurrentExclusiveSchedulerPair
            {
                public void Complete() => throw null;
                public System.Threading.Tasks.Task Completion { get => throw null; }
                public System.Threading.Tasks.TaskScheduler ConcurrentScheduler { get => throw null; }
                public ConcurrentExclusiveSchedulerPair() => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler) => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel) => throw null;
                public ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask) => throw null;
                public System.Threading.Tasks.TaskScheduler ExclusiveScheduler { get => throw null; }
            }
            [System.Flags]
            public enum ConfigureAwaitOptions
            {
                None = 0,
                ContinueOnCapturedContext = 1,
                SuppressThrowing = 2,
                ForceYielding = 4,
            }
            namespace Sources
            {
                public interface IValueTaskSource
                {
                    void GetResult(short token);
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                }
                public interface IValueTaskSource<TResult>
                {
                    TResult GetResult(short token);
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                }
                public struct ManualResetValueTaskSourceCore<TResult>
                {
                    public TResult GetResult(short token) => throw null;
                    public System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token) => throw null;
                    public void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags) => throw null;
                    public void Reset() => throw null;
                    public bool RunContinuationsAsynchronously { get => throw null; set { } }
                    public void SetException(System.Exception error) => throw null;
                    public void SetResult(TResult result) => throw null;
                    public short Version { get => throw null; }
                }
                [System.Flags]
                public enum ValueTaskSourceOnCompletedFlags
                {
                    None = 0,
                    UseSchedulingContext = 1,
                    FlowExecutionContext = 2,
                }
                public enum ValueTaskSourceStatus
                {
                    Pending = 0,
                    Succeeded = 1,
                    Faulted = 2,
                    Canceled = 3,
                }
            }
            public class Task : System.IAsyncResult, System.IDisposable
            {
                public object AsyncState { get => throw null; }
                System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get => throw null; }
                bool System.IAsyncResult.CompletedSynchronously { get => throw null; }
                public static System.Threading.Tasks.Task CompletedTask { get => throw null; }
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(System.Threading.Tasks.ConfigureAwaitOptions options) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public Task(System.Action action) => throw null;
                public Task(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public Task(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action<object> action, object state) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public Task(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public static int? CurrentId { get => throw null; }
                public static System.Threading.Tasks.Task Delay(int millisecondsDelay) => throw null;
                public static System.Threading.Tasks.Task Delay(int millisecondsDelay, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay) => throw null;
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay, System.TimeProvider timeProvider) => throw null;
                public static System.Threading.Tasks.Task Delay(System.TimeSpan delay, System.TimeProvider timeProvider, System.Threading.CancellationToken cancellationToken) => throw null;
                public void Dispose() => throw null;
                protected virtual void Dispose(bool disposing) => throw null;
                public System.AggregateException Exception { get => throw null; }
                public static System.Threading.Tasks.TaskFactory Factory { get => throw null; }
                public static System.Threading.Tasks.Task FromCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task FromException(System.Exception exception) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromException<TResult>(System.Exception exception) => throw null;
                public static System.Threading.Tasks.Task<TResult> FromResult<TResult>(TResult result) => throw null;
                public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() => throw null;
                public int Id { get => throw null; }
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public static System.Threading.Tasks.Task Run(System.Action action) => throw null;
                public static System.Threading.Tasks.Task Run(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function) => throw null;
                public static System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function) => throw null;
                public static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public void RunSynchronously() => throw null;
                public void RunSynchronously(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public void Start() => throw null;
                public void Start(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.TaskStatus Status { get => throw null; }
                public void Wait() => throw null;
                public bool Wait(int millisecondsTimeout) => throw null;
                public bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public void Wait(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool Wait(System.TimeSpan timeout) => throw null;
                public bool Wait(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static void WaitAll(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static void WaitAll(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken) => throw null;
                public static bool WaitAll(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout) => throw null;
                public static int WaitAny(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken) => throw null;
                public static int WaitAny(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout, System.TimeProvider timeProvider) => throw null;
                public System.Threading.Tasks.Task WaitAsync(System.TimeSpan timeout, System.TimeProvider timeProvider, System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.Task WhenAll(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks) => throw null;
                public static System.Threading.Tasks.Task WhenAll(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks) => throw null;
                public static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(params System.Threading.Tasks.Task<TResult>[] tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Threading.Tasks.Task task1, System.Threading.Tasks.Task task2) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(params System.Threading.Tasks.Task[] tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Threading.Tasks.Task<TResult> task1, System.Threading.Tasks.Task<TResult> task2) => throw null;
                public static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(params System.Threading.Tasks.Task<TResult>[] tasks) => throw null;
                public static System.Runtime.CompilerServices.YieldAwaitable Yield() => throw null;
            }
            public class Task<TResult> : System.Threading.Tasks.Task
            {
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult> ConfigureAwait(System.Threading.Tasks.ConfigureAwaitOptions options) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public Task(System.Func<object, TResult> function, object state) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public Task(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) : base(default(System.Action)) => throw null;
                public static System.Threading.Tasks.TaskFactory<TResult> Factory { get => throw null; }
                public System.Runtime.CompilerServices.TaskAwaiter<TResult> GetAwaiter() => throw null;
                public TResult Result { get => throw null; }
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout, System.TimeProvider timeProvider) => throw null;
                public System.Threading.Tasks.Task<TResult> WaitAsync(System.TimeSpan timeout, System.TimeProvider timeProvider, System.Threading.CancellationToken cancellationToken) => throw null;
            }
            public static partial class TaskAsyncEnumerableExtensions
            {
                public static System.Runtime.CompilerServices.ConfiguredAsyncDisposable ConfigureAwait(this System.IAsyncDisposable source, bool continueOnCapturedContext) => throw null;
                public static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, bool continueOnCapturedContext) => throw null;
                public static System.Collections.Generic.IEnumerable<T> ToBlockingEnumerable<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) => throw null;
                public static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation<T>(this System.Collections.Generic.IAsyncEnumerable<T> source, System.Threading.CancellationToken cancellationToken) => throw null;
            }
            public class TaskCanceledException : System.OperationCanceledException
            {
                public TaskCanceledException() => throw null;
                protected TaskCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public TaskCanceledException(string message) => throw null;
                public TaskCanceledException(string message, System.Exception innerException) => throw null;
                public TaskCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token) => throw null;
                public TaskCanceledException(System.Threading.Tasks.Task task) => throw null;
                public System.Threading.Tasks.Task Task { get => throw null; }
            }
            public class TaskCompletionSource
            {
                public TaskCompletionSource() => throw null;
                public TaskCompletionSource(object state) => throw null;
                public TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public void SetCanceled() => throw null;
                public void SetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public void SetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult() => throw null;
                public System.Threading.Tasks.Task Task { get => throw null; }
                public bool TrySetCanceled() => throw null;
                public bool TrySetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool TrySetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public bool TrySetException(System.Exception exception) => throw null;
                public bool TrySetResult() => throw null;
            }
            public class TaskCompletionSource<TResult>
            {
                public TaskCompletionSource() => throw null;
                public TaskCompletionSource(object state) => throw null;
                public TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public void SetCanceled() => throw null;
                public void SetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public void SetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public void SetException(System.Exception exception) => throw null;
                public void SetResult(TResult result) => throw null;
                public System.Threading.Tasks.Task<TResult> Task { get => throw null; }
                public bool TrySetCanceled() => throw null;
                public bool TrySetCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public bool TrySetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) => throw null;
                public bool TrySetException(System.Exception exception) => throw null;
                public bool TrySetResult(TResult result) => throw null;
            }
            [System.Flags]
            public enum TaskContinuationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                LazyCancellation = 32,
                RunContinuationsAsynchronously = 64,
                NotOnRanToCompletion = 65536,
                NotOnFaulted = 131072,
                OnlyOnCanceled = 196608,
                NotOnCanceled = 262144,
                OnlyOnFaulted = 327680,
                OnlyOnRanToCompletion = 393216,
                ExecuteSynchronously = 524288,
            }
            [System.Flags]
            public enum TaskCreationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                RunContinuationsAsynchronously = 64,
            }
            public static partial class TaskExtensions
            {
                public static System.Threading.Tasks.Task Unwrap(this System.Threading.Tasks.Task<System.Threading.Tasks.Task> task) => throw null;
                public static System.Threading.Tasks.Task<TResult> Unwrap<TResult>(this System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> task) => throw null;
            }
            public class TaskFactory
            {
                public System.Threading.CancellationToken CancellationToken { get => throw null; }
                public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get => throw null; }
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public TaskFactory() => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken) => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.TaskScheduler Scheduler { get => throw null; }
                public System.Threading.Tasks.Task StartNew(System.Action action) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
            }
            public class TaskFactory<TResult>
            {
                public System.Threading.CancellationToken CancellationToken { get => throw null; }
                public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get => throw null; }
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult>[] tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public System.Threading.Tasks.TaskCreationOptions CreationOptions { get => throw null; }
                public TaskFactory() => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken) => throw null;
                public TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions) => throw null;
                public TaskFactory(System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.TaskScheduler Scheduler { get => throw null; }
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler) => throw null;
                public System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions) => throw null;
            }
            public abstract class TaskScheduler
            {
                protected TaskScheduler() => throw null;
                public static System.Threading.Tasks.TaskScheduler Current { get => throw null; }
                public static System.Threading.Tasks.TaskScheduler Default { get => throw null; }
                public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() => throw null;
                protected abstract System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();
                public int Id { get => throw null; }
                public virtual int MaximumConcurrencyLevel { get => throw null; }
                protected abstract void QueueTask(System.Threading.Tasks.Task task);
                protected virtual bool TryDequeue(System.Threading.Tasks.Task task) => throw null;
                protected bool TryExecuteTask(System.Threading.Tasks.Task task) => throw null;
                protected abstract bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                public static event System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> UnobservedTaskException;
            }
            public class TaskSchedulerException : System.Exception
            {
                public TaskSchedulerException() => throw null;
                public TaskSchedulerException(System.Exception innerException) => throw null;
                protected TaskSchedulerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
                public TaskSchedulerException(string message) => throw null;
                public TaskSchedulerException(string message, System.Exception innerException) => throw null;
            }
            public enum TaskStatus
            {
                Created = 0,
                WaitingForActivation = 1,
                WaitingToRun = 2,
                Running = 3,
                WaitingForChildrenToComplete = 4,
                RanToCompletion = 5,
                Canceled = 6,
                Faulted = 7,
            }
            public static class TaskToAsyncResult
            {
                public static System.IAsyncResult Begin(System.Threading.Tasks.Task task, System.AsyncCallback callback, object state) => throw null;
                public static void End(System.IAsyncResult asyncResult) => throw null;
                public static TResult End<TResult>(System.IAsyncResult asyncResult) => throw null;
                public static System.Threading.Tasks.Task Unwrap(System.IAsyncResult asyncResult) => throw null;
                public static System.Threading.Tasks.Task<TResult> Unwrap<TResult>(System.IAsyncResult asyncResult) => throw null;
            }
            public class UnobservedTaskExceptionEventArgs : System.EventArgs
            {
                public UnobservedTaskExceptionEventArgs(System.AggregateException exception) => throw null;
                public System.AggregateException Exception { get => throw null; }
                public bool Observed { get => throw null; }
                public void SetObserved() => throw null;
            }
            public struct ValueTask : System.IEquatable<System.Threading.Tasks.ValueTask>
            {
                public System.Threading.Tasks.Task AsTask() => throw null;
                public static System.Threading.Tasks.ValueTask CompletedTask { get => throw null; }
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public ValueTask(System.Threading.Tasks.Sources.IValueTaskSource source, short token) => throw null;
                public ValueTask(System.Threading.Tasks.Task task) => throw null;
                public override bool Equals(object obj) => throw null;
                public bool Equals(System.Threading.Tasks.ValueTask other) => throw null;
                public static System.Threading.Tasks.ValueTask FromCanceled(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken) => throw null;
                public static System.Threading.Tasks.ValueTask FromException(System.Exception exception) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromException<TResult>(System.Exception exception) => throw null;
                public static System.Threading.Tasks.ValueTask<TResult> FromResult<TResult>(TResult result) => throw null;
                public System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter() => throw null;
                public override int GetHashCode() => throw null;
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public static bool operator ==(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right) => throw null;
                public static bool operator !=(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right) => throw null;
                public System.Threading.Tasks.ValueTask Preserve() => throw null;
            }
            public struct ValueTask<TResult> : System.IEquatable<System.Threading.Tasks.ValueTask<TResult>>
            {
                public System.Threading.Tasks.Task<TResult> AsTask() => throw null;
                public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) => throw null;
                public ValueTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, short token) => throw null;
                public ValueTask(System.Threading.Tasks.Task<TResult> task) => throw null;
                public ValueTask(TResult result) => throw null;
                public override bool Equals(object obj) => throw null;
                public bool Equals(System.Threading.Tasks.ValueTask<TResult> other) => throw null;
                public System.Runtime.CompilerServices.ValueTaskAwaiter<TResult> GetAwaiter() => throw null;
                public override int GetHashCode() => throw null;
                public bool IsCanceled { get => throw null; }
                public bool IsCompleted { get => throw null; }
                public bool IsCompletedSuccessfully { get => throw null; }
                public bool IsFaulted { get => throw null; }
                public static bool operator ==(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right) => throw null;
                public static bool operator !=(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right) => throw null;
                public System.Threading.Tasks.ValueTask<TResult> Preserve() => throw null;
                public TResult Result { get => throw null; }
                public override string ToString() => throw null;
            }
        }
        public static class Timeout
        {
            public const int Infinite = -1;
            public static readonly System.TimeSpan InfiniteTimeSpan;
        }
        public sealed class Timer : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable, System.Threading.ITimer
        {
            public static long ActiveCount { get => throw null; }
            public bool Change(int dueTime, int period) => throw null;
            public bool Change(long dueTime, long period) => throw null;
            public bool Change(System.TimeSpan dueTime, System.TimeSpan period) => throw null;
            public bool Change(uint dueTime, uint period) => throw null;
            public Timer(System.Threading.TimerCallback callback) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, int dueTime, int period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, long dueTime, long period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, System.TimeSpan dueTime, System.TimeSpan period) => throw null;
            public Timer(System.Threading.TimerCallback callback, object state, uint dueTime, uint period) => throw null;
            public void Dispose() => throw null;
            public bool Dispose(System.Threading.WaitHandle notifyObject) => throw null;
            public System.Threading.Tasks.ValueTask DisposeAsync() => throw null;
        }
        public delegate void TimerCallback(object state);
        public abstract class WaitHandle : System.MarshalByRefObject, System.IDisposable
        {
            public virtual void Close() => throw null;
            protected WaitHandle() => throw null;
            public void Dispose() => throw null;
            protected virtual void Dispose(bool explicitDisposing) => throw null;
            public virtual nint Handle { get => throw null; set { } }
            protected static readonly nint InvalidHandle;
            public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get => throw null; set { } }
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn) => throw null;
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext) => throw null;
            public static bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, System.TimeSpan timeout, bool exitContext) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) => throw null;
            public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) => throw null;
            public static int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext) => throw null;
            public virtual bool WaitOne() => throw null;
            public virtual bool WaitOne(int millisecondsTimeout) => throw null;
            public virtual bool WaitOne(int millisecondsTimeout, bool exitContext) => throw null;
            public virtual bool WaitOne(System.TimeSpan timeout) => throw null;
            public virtual bool WaitOne(System.TimeSpan timeout, bool exitContext) => throw null;
            public const int WaitTimeout = 258;
        }
        public static partial class WaitHandleExtensions
        {
            public static Microsoft.Win32.SafeHandles.SafeWaitHandle GetSafeWaitHandle(this System.Threading.WaitHandle waitHandle) => throw null;
            public static void SetSafeWaitHandle(this System.Threading.WaitHandle waitHandle, Microsoft.Win32.SafeHandles.SafeWaitHandle value) => throw null;
        }
    }
    [System.AttributeUsage((System.AttributeTargets)256, Inherited = false)]
    public class ThreadStaticAttribute : System.Attribute
    {
        public ThreadStaticAttribute() => throw null;
    }
    public struct TimeOnly : System.IComparable, System.IComparable<System.TimeOnly>, System.IEquatable<System.TimeOnly>, System.IFormattable, System.IParsable<System.TimeOnly>, System.ISpanFormattable, System.ISpanParsable<System.TimeOnly>, System.IUtf8SpanFormattable
    {
        public System.TimeOnly Add(System.TimeSpan value) => throw null;
        public System.TimeOnly Add(System.TimeSpan value, out int wrappedDays) => throw null;
        public System.TimeOnly AddHours(double value) => throw null;
        public System.TimeOnly AddHours(double value, out int wrappedDays) => throw null;
        public System.TimeOnly AddMinutes(double value) => throw null;
        public System.TimeOnly AddMinutes(double value, out int wrappedDays) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.TimeOnly value) => throw null;
        public TimeOnly(int hour, int minute) => throw null;
        public TimeOnly(int hour, int minute, int second) => throw null;
        public TimeOnly(int hour, int minute, int second, int millisecond) => throw null;
        public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond) => throw null;
        public TimeOnly(long ticks) => throw null;
        public void Deconstruct(out int hour, out int minute) => throw null;
        public void Deconstruct(out int hour, out int minute, out int second) => throw null;
        public void Deconstruct(out int hour, out int minute, out int second, out int millisecond) => throw null;
        public void Deconstruct(out int hour, out int minute, out int second, out int millisecond, out int microsecond) => throw null;
        public override bool Equals(object value) => throw null;
        public bool Equals(System.TimeOnly value) => throw null;
        public static System.TimeOnly FromDateTime(System.DateTime dateTime) => throw null;
        public static System.TimeOnly FromTimeSpan(System.TimeSpan timeSpan) => throw null;
        public override int GetHashCode() => throw null;
        public int Hour { get => throw null; }
        public bool IsBetween(System.TimeOnly start, System.TimeOnly end) => throw null;
        public static System.TimeOnly MaxValue { get => throw null; }
        public int Microsecond { get => throw null; }
        public int Millisecond { get => throw null; }
        public int Minute { get => throw null; }
        public static System.TimeOnly MinValue { get => throw null; }
        public int Nanosecond { get => throw null; }
        public static bool operator ==(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator >(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator >=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator !=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator <(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static bool operator <=(System.TimeOnly left, System.TimeOnly right) => throw null;
        public static System.TimeSpan operator -(System.TimeOnly t1, System.TimeOnly t2) => throw null;
        static System.TimeOnly System.ISpanParsable<System.TimeOnly>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.TimeOnly Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly Parse(string s) => throw null;
        static System.TimeOnly System.IParsable<System.TimeOnly>.Parse(string s, System.IFormatProvider provider) => throw null;
        public static System.TimeOnly Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider = default(System.IFormatProvider), System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<char> s, string[] formats) => throw null;
        public static System.TimeOnly ParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(string s, string format) => throw null;
        public static System.TimeOnly ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public static System.TimeOnly ParseExact(string s, string[] formats) => throw null;
        public static System.TimeOnly ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style = default(System.Globalization.DateTimeStyles)) => throw null;
        public int Second { get => throw null; }
        public long Ticks { get => throw null; }
        public string ToLongTimeString() => throw null;
        public string ToShortTimeString() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public System.TimeSpan ToTimeSpan() => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        static bool System.ISpanParsable<System.TimeOnly>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.TimeOnly result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.TimeOnly result) => throw null;
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        static bool System.IParsable<System.TimeOnly>.TryParse(string s, System.IFormatProvider provider, out System.TimeOnly result) => throw null;
        public static bool TryParse(string s, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string format, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.TimeOnly result) => throw null;
        public static bool TryParseExact(string s, string[] formats, out System.TimeOnly result) => throw null;
    }
    public class TimeoutException : System.SystemException
    {
        public TimeoutException() => throw null;
        protected TimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TimeoutException(string message) => throw null;
        public TimeoutException(string message, System.Exception innerException) => throw null;
    }
    public abstract class TimeProvider
    {
        public virtual System.Threading.ITimer CreateTimer(System.Threading.TimerCallback callback, object state, System.TimeSpan dueTime, System.TimeSpan period) => throw null;
        protected TimeProvider() => throw null;
        public System.TimeSpan GetElapsedTime(long startingTimestamp) => throw null;
        public System.TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp) => throw null;
        public System.DateTimeOffset GetLocalNow() => throw null;
        public virtual long GetTimestamp() => throw null;
        public virtual System.DateTimeOffset GetUtcNow() => throw null;
        public virtual System.TimeZoneInfo LocalTimeZone { get => throw null; }
        public static System.TimeProvider System { get => throw null; }
        public virtual long TimestampFrequency { get => throw null; }
    }
    public struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.IParsable<System.TimeSpan>, System.ISpanFormattable, System.ISpanParsable<System.TimeSpan>, System.IUtf8SpanFormattable
    {
        public System.TimeSpan Add(System.TimeSpan ts) => throw null;
        public static int Compare(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.TimeSpan value) => throw null;
        public TimeSpan(int hours, int minutes, int seconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds) => throw null;
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds) => throw null;
        public TimeSpan(long ticks) => throw null;
        public int Days { get => throw null; }
        public System.TimeSpan Divide(double divisor) => throw null;
        public double Divide(System.TimeSpan ts) => throw null;
        public System.TimeSpan Duration() => throw null;
        public override bool Equals(object value) => throw null;
        public bool Equals(System.TimeSpan obj) => throw null;
        public static bool Equals(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan FromDays(double value) => throw null;
        public static System.TimeSpan FromHours(double value) => throw null;
        public static System.TimeSpan FromMicroseconds(double value) => throw null;
        public static System.TimeSpan FromMilliseconds(double value) => throw null;
        public static System.TimeSpan FromMinutes(double value) => throw null;
        public static System.TimeSpan FromSeconds(double value) => throw null;
        public static System.TimeSpan FromTicks(long value) => throw null;
        public override int GetHashCode() => throw null;
        public int Hours { get => throw null; }
        public static readonly System.TimeSpan MaxValue;
        public int Microseconds { get => throw null; }
        public int Milliseconds { get => throw null; }
        public int Minutes { get => throw null; }
        public static readonly System.TimeSpan MinValue;
        public System.TimeSpan Multiply(double factor) => throw null;
        public int Nanoseconds { get => throw null; }
        public const long NanosecondsPerTick = 100;
        public System.TimeSpan Negate() => throw null;
        public static System.TimeSpan operator +(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator /(System.TimeSpan timeSpan, double divisor) => throw null;
        public static double operator /(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator ==(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator >(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator >=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator !=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator <(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static bool operator <=(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator *(double factor, System.TimeSpan timeSpan) => throw null;
        public static System.TimeSpan operator *(System.TimeSpan timeSpan, double factor) => throw null;
        public static System.TimeSpan operator -(System.TimeSpan t1, System.TimeSpan t2) => throw null;
        public static System.TimeSpan operator -(System.TimeSpan t) => throw null;
        public static System.TimeSpan operator +(System.TimeSpan t) => throw null;
        static System.TimeSpan System.ISpanParsable<System.TimeSpan>.Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public static System.TimeSpan Parse(string s) => throw null;
        static System.TimeSpan System.IParsable<System.TimeSpan>.Parse(string input, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles = default(System.Globalization.TimeSpanStyles)) => throw null;
        public static System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles = default(System.Globalization.TimeSpanStyles)) => throw null;
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) => throw null;
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider) => throw null;
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) => throw null;
        public int Seconds { get => throw null; }
        public System.TimeSpan Subtract(System.TimeSpan ts) => throw null;
        public long Ticks { get => throw null; }
        public const long TicksPerDay = 864000000000;
        public const long TicksPerHour = 36000000000;
        public const long TicksPerMicrosecond = 10;
        public const long TicksPerMillisecond = 10000;
        public const long TicksPerMinute = 600000000;
        public const long TicksPerSecond = 10000000;
        public override string ToString() => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public double TotalDays { get => throw null; }
        public double TotalHours { get => throw null; }
        public double TotalMicroseconds { get => throw null; }
        public double TotalMilliseconds { get => throw null; }
        public double TotalMinutes { get => throw null; }
        public double TotalNanoseconds { get => throw null; }
        public double TotalSeconds { get => throw null; }
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider formatProvider = default(System.IFormatProvider)) => throw null;
        static bool System.ISpanParsable<System.TimeSpan>.TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.TimeSpan result) => throw null;
        static bool System.IParsable<System.TimeSpan>.TryParse(string input, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParse(string s, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) => throw null;
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, out System.TimeSpan result) => throw null;
        public static readonly System.TimeSpan Zero;
    }
    public abstract class TimeZone
    {
        protected TimeZone() => throw null;
        public static System.TimeZone CurrentTimeZone { get => throw null; }
        public abstract string DaylightName { get; }
        public abstract System.Globalization.DaylightTime GetDaylightChanges(int year);
        public abstract System.TimeSpan GetUtcOffset(System.DateTime time);
        public virtual bool IsDaylightSavingTime(System.DateTime time) => throw null;
        public static bool IsDaylightSavingTime(System.DateTime time, System.Globalization.DaylightTime daylightTimes) => throw null;
        public abstract string StandardName { get; }
        public virtual System.DateTime ToLocalTime(System.DateTime time) => throw null;
        public virtual System.DateTime ToUniversalTime(System.DateTime time) => throw null;
    }
    public sealed class TimeZoneInfo : System.Runtime.Serialization.IDeserializationCallback, System.IEquatable<System.TimeZoneInfo>, System.Runtime.Serialization.ISerializable
    {
        public sealed class AdjustmentRule : System.Runtime.Serialization.IDeserializationCallback, System.IEquatable<System.TimeZoneInfo.AdjustmentRule>, System.Runtime.Serialization.ISerializable
        {
            public System.TimeSpan BaseUtcOffsetDelta { get => throw null; }
            public static System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd) => throw null;
            public static System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta) => throw null;
            public System.DateTime DateEnd { get => throw null; }
            public System.DateTime DateStart { get => throw null; }
            public System.TimeSpan DaylightDelta { get => throw null; }
            public System.TimeZoneInfo.TransitionTime DaylightTransitionEnd { get => throw null; }
            public System.TimeZoneInfo.TransitionTime DaylightTransitionStart { get => throw null; }
            public bool Equals(System.TimeZoneInfo.AdjustmentRule other) => throw null;
            public override bool Equals(object obj) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        }
        public System.TimeSpan BaseUtcOffset { get => throw null; }
        public static void ClearCachedData() => throw null;
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTimeOffset ConvertTime(System.DateTimeOffset dateTimeOffset, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string destinationTimeZoneId) => throw null;
        public static System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId) => throw null;
        public static System.DateTimeOffset ConvertTimeBySystemTimeZoneId(System.DateTimeOffset dateTimeOffset, string destinationTimeZoneId) => throw null;
        public static System.DateTime ConvertTimeFromUtc(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone) => throw null;
        public static System.DateTime ConvertTimeToUtc(System.DateTime dateTime) => throw null;
        public static System.DateTime ConvertTimeToUtc(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules) => throw null;
        public static System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime) => throw null;
        public string DaylightName { get => throw null; }
        public string DisplayName { get => throw null; }
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.TimeZoneInfo other) => throw null;
        public static System.TimeZoneInfo FindSystemTimeZoneById(string id) => throw null;
        public static System.TimeZoneInfo FromSerializedString(string source) => throw null;
        public System.TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules() => throw null;
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTime dateTime) => throw null;
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTimeOffset dateTimeOffset) => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public static System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones() => throw null;
        public static System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones(bool skipSorting) => throw null;
        public System.TimeSpan GetUtcOffset(System.DateTime dateTime) => throw null;
        public System.TimeSpan GetUtcOffset(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool HasIanaId { get => throw null; }
        public bool HasSameRules(System.TimeZoneInfo other) => throw null;
        public string Id { get => throw null; }
        public bool IsAmbiguousTime(System.DateTime dateTime) => throw null;
        public bool IsAmbiguousTime(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool IsDaylightSavingTime(System.DateTime dateTime) => throw null;
        public bool IsDaylightSavingTime(System.DateTimeOffset dateTimeOffset) => throw null;
        public bool IsInvalidTime(System.DateTime dateTime) => throw null;
        public static System.TimeZoneInfo Local { get => throw null; }
        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
        public string StandardName { get => throw null; }
        public bool SupportsDaylightSavingTime { get => throw null; }
        public string ToSerializedString() => throw null;
        public override string ToString() => throw null;
        public struct TransitionTime : System.Runtime.Serialization.IDeserializationCallback, System.IEquatable<System.TimeZoneInfo.TransitionTime>, System.Runtime.Serialization.ISerializable
        {
            public static System.TimeZoneInfo.TransitionTime CreateFixedDateRule(System.DateTime timeOfDay, int month, int day) => throw null;
            public static System.TimeZoneInfo.TransitionTime CreateFloatingDateRule(System.DateTime timeOfDay, int month, int week, System.DayOfWeek dayOfWeek) => throw null;
            public int Day { get => throw null; }
            public System.DayOfWeek DayOfWeek { get => throw null; }
            public override bool Equals(object obj) => throw null;
            public bool Equals(System.TimeZoneInfo.TransitionTime other) => throw null;
            public override int GetHashCode() => throw null;
            void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
            public bool IsFixedDateRule { get => throw null; }
            public int Month { get => throw null; }
            void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) => throw null;
            public static bool operator ==(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2) => throw null;
            public static bool operator !=(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2) => throw null;
            public System.DateTime TimeOfDay { get => throw null; }
            public int Week { get => throw null; }
        }
        public static bool TryConvertIanaIdToWindowsId(string ianaId, out string windowsId) => throw null;
        public static bool TryConvertWindowsIdToIanaId(string windowsId, string region, out string ianaId) => throw null;
        public static bool TryConvertWindowsIdToIanaId(string windowsId, out string ianaId) => throw null;
        public static bool TryFindSystemTimeZoneById(string id, out System.TimeZoneInfo timeZoneInfo) => throw null;
        public static System.TimeZoneInfo Utc { get => throw null; }
    }
    public class TimeZoneNotFoundException : System.Exception
    {
        public TimeZoneNotFoundException() => throw null;
        protected TimeZoneNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TimeZoneNotFoundException(string message) => throw null;
        public TimeZoneNotFoundException(string message, System.Exception innerException) => throw null;
    }
    public static class Tuple
    {
        public static System.Tuple<T1> Create<T1>(T1 item1) => throw null;
        public static System.Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2) => throw null;
        public static System.Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) => throw null;
        public static System.Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8) => throw null;
    }
    public class Tuple<T1> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3, T4> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3, T4, T5> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3, T4, T5, T6> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3, T4, T5, T6, T7> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        public T7 Item7 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object obj) => throw null;
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) => throw null;
        public override bool Equals(object obj) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1 { get => throw null; }
        public T2 Item2 { get => throw null; }
        public T3 Item3 { get => throw null; }
        public T4 Item4 { get => throw null; }
        public T5 Item5 { get => throw null; }
        public T6 Item6 { get => throw null; }
        public T7 Item7 { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public TRest Rest { get => throw null; }
        public override string ToString() => throw null;
    }
    public static partial class TupleExtensions
    {
        public static void Deconstruct<T1>(this System.Tuple<T1> value, out T1 item1) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19) => throw null;
        public static void Deconstruct<T1, T2>(this System.Tuple<T1, T2> value, out T1 item1, out T2 item2) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20, out T21 item21) => throw null;
        public static void Deconstruct<T1, T2, T3>(this System.Tuple<T1, T2, T3> value, out T1 item1, out T2 item2, out T3 item3) => throw null;
        public static void Deconstruct<T1, T2, T3, T4>(this System.Tuple<T1, T2, T3, T4> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5>(this System.Tuple<T1, T2, T3, T4, T5> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6>(this System.Tuple<T1, T2, T3, T4, T5, T6> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8) => throw null;
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9) => throw null;
        public static System.Tuple<T1> ToTuple<T1>(this System.ValueTuple<T1> value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) value) => throw null;
        public static System.Tuple<T1, T2> ToTuple<T1, T2>(this (T1, T2) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) value) => throw null;
        public static System.Tuple<T1, T2, T3> ToTuple<T1, T2, T3>(this (T1, T2, T3) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4> ToTuple<T1, T2, T3, T4>(this (T1, T2, T3, T4) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5> ToTuple<T1, T2, T3, T4, T5>(this (T1, T2, T3, T4, T5) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6> ToTuple<T1, T2, T3, T4, T5, T6>(this (T1, T2, T3, T4, T5, T6) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7> ToTuple<T1, T2, T3, T4, T5, T6, T7>(this (T1, T2, T3, T4, T5, T6, T7) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this (T1, T2, T3, T4, T5, T6, T7, T8) value) => throw null;
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T1, T2, T3, T4, T5, T6, T7, T8, T9) value) => throw null;
        public static System.ValueTuple<T1> ToValueTuple<T1>(this System.Tuple<T1> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value) => throw null;
        public static (T1, T2) ToValueTuple<T1, T2>(this System.Tuple<T1, T2> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value) => throw null;
        public static (T1, T2, T3) ToValueTuple<T1, T2, T3>(this System.Tuple<T1, T2, T3> value) => throw null;
        public static (T1, T2, T3, T4) ToValueTuple<T1, T2, T3, T4>(this System.Tuple<T1, T2, T3, T4> value) => throw null;
        public static (T1, T2, T3, T4, T5) ToValueTuple<T1, T2, T3, T4, T5>(this System.Tuple<T1, T2, T3, T4, T5> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6) ToValueTuple<T1, T2, T3, T4, T5, T6>(this System.Tuple<T1, T2, T3, T4, T5, T6> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7) ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8, T9) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value) => throw null;
    }
    public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect
    {
        public abstract System.Reflection.Assembly Assembly { get; }
        public abstract string AssemblyQualifiedName { get; }
        public System.Reflection.TypeAttributes Attributes { get => throw null; }
        public abstract System.Type BaseType { get; }
        public virtual bool ContainsGenericParameters { get => throw null; }
        protected Type() => throw null;
        public virtual System.Reflection.MethodBase DeclaringMethod { get => throw null; }
        public override System.Type DeclaringType { get => throw null; }
        public static System.Reflection.Binder DefaultBinder { get => throw null; }
        public static readonly char Delimiter;
        public static readonly System.Type[] EmptyTypes;
        public override bool Equals(object o) => throw null;
        public virtual bool Equals(System.Type o) => throw null;
        public static readonly System.Reflection.MemberFilter FilterAttribute;
        public static readonly System.Reflection.MemberFilter FilterName;
        public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;
        public virtual System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria) => throw null;
        public virtual System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria) => throw null;
        public abstract string FullName { get; }
        public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get => throw null; }
        public virtual int GenericParameterPosition { get => throw null; }
        public virtual System.Type[] GenericTypeArguments { get => throw null; }
        public virtual int GetArrayRank() => throw null;
        protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Type[] types) => throw null;
        public System.Reflection.ConstructorInfo GetConstructor(System.Type[] types) => throw null;
        protected abstract System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        public System.Reflection.ConstructorInfo[] GetConstructors() => throw null;
        public abstract System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Reflection.MemberInfo[] GetDefaultMembers() => throw null;
        public abstract System.Type GetElementType();
        public virtual string GetEnumName(object value) => throw null;
        public virtual string[] GetEnumNames() => throw null;
        public virtual System.Type GetEnumUnderlyingType() => throw null;
        public virtual System.Array GetEnumValues() => throw null;
        public virtual System.Array GetEnumValuesAsUnderlyingType() => throw null;
        public System.Reflection.EventInfo GetEvent(string name) => throw null;
        public abstract System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        public virtual System.Reflection.EventInfo[] GetEvents() => throw null;
        public abstract System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.FieldInfo GetField(string name) => throw null;
        public abstract System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.FieldInfo[] GetFields() => throw null;
        public abstract System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Type[] GetFunctionPointerCallingConventions() => throw null;
        public virtual System.Type[] GetFunctionPointerParameterTypes() => throw null;
        public virtual System.Type GetFunctionPointerReturnType() => throw null;
        public virtual System.Type[] GetGenericArguments() => throw null;
        public virtual System.Type[] GetGenericParameterConstraints() => throw null;
        public virtual System.Type GetGenericTypeDefinition() => throw null;
        public override int GetHashCode() => throw null;
        public System.Type GetInterface(string name) => throw null;
        public abstract System.Type GetInterface(string name, bool ignoreCase);
        public virtual System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType) => throw null;
        public abstract System.Type[] GetInterfaces();
        public System.Reflection.MemberInfo[] GetMember(string name) => throw null;
        public virtual System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public virtual System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr) => throw null;
        public System.Reflection.MemberInfo[] GetMembers() => throw null;
        public abstract System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Reflection.MemberInfo GetMemberWithSameMetadataDefinitionAs(System.Reflection.MemberInfo member) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types) => throw null;
        public System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        protected virtual System.Reflection.MethodInfo GetMethodImpl(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        protected abstract System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        public System.Reflection.MethodInfo[] GetMethods() => throw null;
        public abstract System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        public System.Type GetNestedType(string name) => throw null;
        public abstract System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
        public System.Type[] GetNestedTypes() => throw null;
        public abstract System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
        public virtual System.Type[] GetOptionalCustomModifiers() => throw null;
        public System.Reflection.PropertyInfo[] GetProperties() => throw null;
        public abstract System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        public System.Reflection.PropertyInfo GetProperty(string name) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers) => throw null;
        public System.Reflection.PropertyInfo GetProperty(string name, System.Type[] types) => throw null;
        protected abstract System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        public virtual System.Type[] GetRequiredCustomModifiers() => throw null;
        public System.Type GetType() => throw null;
        public static System.Type GetType(string typeName) => throw null;
        public static System.Type GetType(string typeName, bool throwOnError) => throw null;
        public static System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError) => throw null;
        public static System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase) => throw null;
        public static System.Type[] GetTypeArray(object[] args) => throw null;
        public static System.TypeCode GetTypeCode(System.Type type) => throw null;
        protected virtual System.TypeCode GetTypeCodeImpl() => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, bool throwOnError) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, string server) => throw null;
        public static System.Type GetTypeFromCLSID(System.Guid clsid, string server, bool throwOnError) => throw null;
        public static System.Type GetTypeFromHandle(System.RuntimeTypeHandle handle) => throw null;
        public static System.Type GetTypeFromProgID(string progID) => throw null;
        public static System.Type GetTypeFromProgID(string progID, bool throwOnError) => throw null;
        public static System.Type GetTypeFromProgID(string progID, string server) => throw null;
        public static System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) => throw null;
        public static System.RuntimeTypeHandle GetTypeHandle(object o) => throw null;
        public abstract System.Guid GUID { get; }
        public bool HasElementType { get => throw null; }
        protected abstract bool HasElementTypeImpl();
        public object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args) => throw null;
        public object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture) => throw null;
        public abstract object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
        public bool IsAbstract { get => throw null; }
        public bool IsAnsiClass { get => throw null; }
        public bool IsArray { get => throw null; }
        protected abstract bool IsArrayImpl();
        public virtual bool IsAssignableFrom(System.Type c) => throw null;
        public bool IsAssignableTo(System.Type targetType) => throw null;
        public bool IsAutoClass { get => throw null; }
        public bool IsAutoLayout { get => throw null; }
        public bool IsByRef { get => throw null; }
        protected abstract bool IsByRefImpl();
        public virtual bool IsByRefLike { get => throw null; }
        public bool IsClass { get => throw null; }
        public bool IsCOMObject { get => throw null; }
        protected abstract bool IsCOMObjectImpl();
        public virtual bool IsConstructedGenericType { get => throw null; }
        public bool IsContextful { get => throw null; }
        protected virtual bool IsContextfulImpl() => throw null;
        public virtual bool IsEnum { get => throw null; }
        public virtual bool IsEnumDefined(object value) => throw null;
        public virtual bool IsEquivalentTo(System.Type other) => throw null;
        public bool IsExplicitLayout { get => throw null; }
        public virtual bool IsFunctionPointer { get => throw null; }
        public virtual bool IsGenericMethodParameter { get => throw null; }
        public virtual bool IsGenericParameter { get => throw null; }
        public virtual bool IsGenericType { get => throw null; }
        public virtual bool IsGenericTypeDefinition { get => throw null; }
        public virtual bool IsGenericTypeParameter { get => throw null; }
        public bool IsImport { get => throw null; }
        public virtual bool IsInstanceOfType(object o) => throw null;
        public bool IsInterface { get => throw null; }
        public bool IsLayoutSequential { get => throw null; }
        public bool IsMarshalByRef { get => throw null; }
        protected virtual bool IsMarshalByRefImpl() => throw null;
        public bool IsNested { get => throw null; }
        public bool IsNestedAssembly { get => throw null; }
        public bool IsNestedFamANDAssem { get => throw null; }
        public bool IsNestedFamily { get => throw null; }
        public bool IsNestedFamORAssem { get => throw null; }
        public bool IsNestedPrivate { get => throw null; }
        public bool IsNestedPublic { get => throw null; }
        public bool IsNotPublic { get => throw null; }
        public bool IsPointer { get => throw null; }
        protected abstract bool IsPointerImpl();
        public bool IsPrimitive { get => throw null; }
        protected abstract bool IsPrimitiveImpl();
        public bool IsPublic { get => throw null; }
        public bool IsSealed { get => throw null; }
        public virtual bool IsSecurityCritical { get => throw null; }
        public virtual bool IsSecuritySafeCritical { get => throw null; }
        public virtual bool IsSecurityTransparent { get => throw null; }
        public virtual bool IsSerializable { get => throw null; }
        public virtual bool IsSignatureType { get => throw null; }
        public bool IsSpecialName { get => throw null; }
        public virtual bool IsSubclassOf(System.Type c) => throw null;
        public virtual bool IsSZArray { get => throw null; }
        public virtual bool IsTypeDefinition { get => throw null; }
        public bool IsUnicodeClass { get => throw null; }
        public virtual bool IsUnmanagedFunctionPointer { get => throw null; }
        public bool IsValueType { get => throw null; }
        protected virtual bool IsValueTypeImpl() => throw null;
        public virtual bool IsVariableBoundArray { get => throw null; }
        public bool IsVisible { get => throw null; }
        public virtual System.Type MakeArrayType() => throw null;
        public virtual System.Type MakeArrayType(int rank) => throw null;
        public virtual System.Type MakeByRefType() => throw null;
        public static System.Type MakeGenericMethodParameter(int position) => throw null;
        public static System.Type MakeGenericSignatureType(System.Type genericTypeDefinition, params System.Type[] typeArguments) => throw null;
        public virtual System.Type MakeGenericType(params System.Type[] typeArguments) => throw null;
        public virtual System.Type MakePointerType() => throw null;
        public override System.Reflection.MemberTypes MemberType { get => throw null; }
        public static readonly object Missing;
        public abstract System.Reflection.Module Module { get; }
        public abstract string Namespace { get; }
        public static bool operator ==(System.Type left, System.Type right) => throw null;
        public static bool operator !=(System.Type left, System.Type right) => throw null;
        public override System.Type ReflectedType { get => throw null; }
        public static System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) => throw null;
        public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get => throw null; }
        public override string ToString() => throw null;
        public virtual System.RuntimeTypeHandle TypeHandle { get => throw null; }
        public System.Reflection.ConstructorInfo TypeInitializer { get => throw null; }
        public abstract System.Type UnderlyingSystemType { get; }
    }
    public class TypeAccessException : System.TypeLoadException
    {
        public TypeAccessException() => throw null;
        protected TypeAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeAccessException(string message) => throw null;
        public TypeAccessException(string message, System.Exception inner) => throw null;
    }
    public enum TypeCode
    {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18,
    }
    public struct TypedReference
    {
        public override bool Equals(object o) => throw null;
        public override int GetHashCode() => throw null;
        public static System.Type GetTargetType(System.TypedReference value) => throw null;
        public static System.TypedReference MakeTypedReference(object target, System.Reflection.FieldInfo[] flds) => throw null;
        public static void SetTypedReference(System.TypedReference target, object value) => throw null;
        public static System.RuntimeTypeHandle TargetTypeToken(System.TypedReference value) => throw null;
        public static object ToObject(System.TypedReference value) => throw null;
    }
    public sealed class TypeInitializationException : System.SystemException
    {
        public TypeInitializationException(string fullTypeName, System.Exception innerException) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public string TypeName { get => throw null; }
    }
    public class TypeLoadException : System.SystemException
    {
        public TypeLoadException() => throw null;
        protected TypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeLoadException(string message) => throw null;
        public TypeLoadException(string message, System.Exception inner) => throw null;
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public override string Message { get => throw null; }
        public string TypeName { get => throw null; }
    }
    public class TypeUnloadedException : System.SystemException
    {
        public TypeUnloadedException() => throw null;
        protected TypeUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public TypeUnloadedException(string message) => throw null;
        public TypeUnloadedException(string message, System.Exception innerException) => throw null;
    }
    public struct UInt128 : System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IAdditiveIdentity<System.UInt128, System.UInt128>, System.Numerics.IBinaryInteger<System.UInt128>, System.Numerics.IBinaryNumber<System.UInt128>, System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>, System.IComparable, System.IComparable<System.UInt128>, System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>, System.Numerics.IDecrementOperators<System.UInt128>, System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>, System.IEquatable<System.UInt128>, System.IFormattable, System.Numerics.IIncrementOperators<System.UInt128>, System.Numerics.IMinMaxValue<System.UInt128>, System.Numerics.IModulusOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IMultiplicativeIdentity<System.UInt128, System.UInt128>, System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.INumber<System.UInt128>, System.Numerics.INumberBase<System.UInt128>, System.IParsable<System.UInt128>, System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>, System.ISpanFormattable, System.ISpanParsable<System.UInt128>, System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>, System.Numerics.IUnaryPlusOperators<System.UInt128, System.UInt128>, System.Numerics.IUnsignedNumber<System.UInt128>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.UInt128>
    {
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Abs(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IAdditiveIdentity<System.UInt128, System.UInt128>.AdditiveIdentity { get => throw null; }
        static System.UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get => throw null; }
        static System.UInt128 System.Numerics.INumber<System.UInt128>.Clamp(System.UInt128 value, System.UInt128 min, System.UInt128 max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.INumber<System.UInt128>.CopySign(System.UInt128 value, System.UInt128 sign) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateChecked<TOther>(TOther value) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateSaturating<TOther>(TOther value) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.CreateTruncating<TOther>(TOther value) => throw null;
        public UInt128(ulong upper, ulong lower) => throw null;
        static (System.UInt128 Quotient, System.UInt128 Remainder) System.Numerics.IBinaryInteger<System.UInt128>.DivRem(System.UInt128 left, System.UInt128 right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.UInt128 other) => throw null;
        int System.Numerics.IBinaryInteger<System.UInt128>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<System.UInt128>.GetShortestBitLength() => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsCanonical(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsComplexNumber(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsEvenInteger(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsFinite(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsImaginaryNumber(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsInfinity(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsInteger(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsNaN(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsNegative(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsNegativeInfinity(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsNormal(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsOddInteger(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsPositive(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsPositiveInfinity(System.UInt128 value) => throw null;
        static bool System.Numerics.IBinaryNumber<System.UInt128>.IsPow2(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsRealNumber(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsSubnormal(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.IsZero(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IBinaryInteger<System.UInt128>.LeadingZeroCount(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IBinaryNumber<System.UInt128>.Log2(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.INumber<System.UInt128>.Max(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitude(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitudeNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumber<System.UInt128>.MaxNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.IMinMaxValue<System.UInt128>.MaxValue { get => throw null; }
        static System.UInt128 System.Numerics.INumber<System.UInt128>.Min(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitude(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitudeNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.INumber<System.UInt128>.MinNumber(System.UInt128 x, System.UInt128 y) => throw null;
        static System.UInt128 System.Numerics.IMinMaxValue<System.UInt128>.MinValue { get => throw null; }
        static System.UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128, System.UInt128>.MultiplicativeIdentity { get => throw null; }
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.One { get => throw null; }
        static System.UInt128 System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>.operator +(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator &(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator |(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked +(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IDecrementOperators<System.UInt128>.operator checked --(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked /(System.UInt128 left, System.UInt128 right) => throw null;
        public static explicit operator checked System.UInt128(double value) => throw null;
        public static explicit operator checked System.UInt128(short value) => throw null;
        public static explicit operator checked System.UInt128(int value) => throw null;
        public static explicit operator checked System.UInt128(long value) => throw null;
        public static explicit operator checked System.UInt128(nint value) => throw null;
        public static explicit operator checked System.UInt128(sbyte value) => throw null;
        public static explicit operator checked System.UInt128(float value) => throw null;
        public static explicit operator checked byte(System.UInt128 value) => throw null;
        public static explicit operator checked char(System.UInt128 value) => throw null;
        public static explicit operator checked short(System.UInt128 value) => throw null;
        public static explicit operator checked int(System.UInt128 value) => throw null;
        public static explicit operator checked long(System.UInt128 value) => throw null;
        public static explicit operator checked System.Int128(System.UInt128 value) => throw null;
        public static explicit operator checked nint(System.UInt128 value) => throw null;
        public static explicit operator checked sbyte(System.UInt128 value) => throw null;
        public static explicit operator checked ushort(System.UInt128 value) => throw null;
        public static explicit operator checked uint(System.UInt128 value) => throw null;
        public static explicit operator checked ulong(System.UInt128 value) => throw null;
        public static explicit operator checked nuint(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IIncrementOperators<System.UInt128>.operator checked ++(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked *(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>.operator checked -(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>.operator checked -(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IDecrementOperators<System.UInt128>.operator --(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>.operator /(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>.operator ==(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator ^(System.UInt128 left, System.UInt128 right) => throw null;
        public static explicit operator System.UInt128(decimal value) => throw null;
        public static explicit operator System.UInt128(double value) => throw null;
        public static explicit operator System.UInt128(short value) => throw null;
        public static explicit operator System.UInt128(int value) => throw null;
        public static explicit operator System.UInt128(long value) => throw null;
        public static explicit operator System.UInt128(nint value) => throw null;
        public static explicit operator System.UInt128(sbyte value) => throw null;
        public static explicit operator System.UInt128(float value) => throw null;
        public static explicit operator byte(System.UInt128 value) => throw null;
        public static explicit operator char(System.UInt128 value) => throw null;
        public static explicit operator decimal(System.UInt128 value) => throw null;
        public static explicit operator double(System.UInt128 value) => throw null;
        public static explicit operator System.Half(System.UInt128 value) => throw null;
        public static explicit operator System.Int128(System.UInt128 value) => throw null;
        public static explicit operator short(System.UInt128 value) => throw null;
        public static explicit operator int(System.UInt128 value) => throw null;
        public static explicit operator long(System.UInt128 value) => throw null;
        public static explicit operator nint(System.UInt128 value) => throw null;
        public static explicit operator sbyte(System.UInt128 value) => throw null;
        public static explicit operator float(System.UInt128 value) => throw null;
        public static explicit operator ushort(System.UInt128 value) => throw null;
        public static explicit operator uint(System.UInt128 value) => throw null;
        public static explicit operator ulong(System.UInt128 value) => throw null;
        public static explicit operator nuint(System.UInt128 value) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator >(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator >=(System.UInt128 left, System.UInt128 right) => throw null;
        public static implicit operator System.UInt128(byte value) => throw null;
        public static implicit operator System.UInt128(char value) => throw null;
        public static implicit operator System.UInt128(ushort value) => throw null;
        public static implicit operator System.UInt128(uint value) => throw null;
        public static implicit operator System.UInt128(ulong value) => throw null;
        public static implicit operator System.UInt128(nuint value) => throw null;
        static System.UInt128 System.Numerics.IIncrementOperators<System.UInt128>.operator ++(System.UInt128 value) => throw null;
        static bool System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>.operator !=(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator <<(System.UInt128 value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator <(System.UInt128 left, System.UInt128 right) => throw null;
        static bool System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>.operator <=(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IModulusOperators<System.UInt128, System.UInt128, System.UInt128>.operator %(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>.operator *(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>.operator ~(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator >>(System.UInt128 value, int shiftAmount) => throw null;
        static System.UInt128 System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>.operator -(System.UInt128 left, System.UInt128 right) => throw null;
        static System.UInt128 System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>.operator -(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IUnaryPlusOperators<System.UInt128, System.UInt128>.operator +(System.UInt128 value) => throw null;
        static System.UInt128 System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>.operator >>>(System.UInt128 value, int shiftAmount) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.UInt128 System.IUtf8SpanParsable<System.UInt128>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static System.UInt128 System.ISpanParsable<System.UInt128>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static System.UInt128 Parse(string s) => throw null;
        public static System.UInt128 Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static System.UInt128 System.IParsable<System.UInt128>.Parse(string s, System.IFormatProvider provider) => throw null;
        static System.UInt128 System.Numerics.IBinaryInteger<System.UInt128>.PopCount(System.UInt128 value) => throw null;
        static int System.Numerics.INumberBase<System.UInt128>.Radix { get => throw null; }
        static System.UInt128 System.Numerics.IBinaryInteger<System.UInt128>.RotateLeft(System.UInt128 value, int rotateAmount) => throw null;
        static System.UInt128 System.Numerics.IBinaryInteger<System.UInt128>.RotateRight(System.UInt128 value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<System.UInt128>.Sign(System.UInt128 value) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        static System.UInt128 System.Numerics.IBinaryInteger<System.UInt128>.TrailingZeroCount(System.UInt128 value) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromChecked<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromSaturating<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromTruncating<TOther>(TOther value, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToChecked<TOther>(System.UInt128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToSaturating<TOther>(System.UInt128 value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryConvertToTruncating<TOther>(System.UInt128 value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        static bool System.IUtf8SpanParsable<System.UInt128>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        static bool System.ISpanParsable<System.UInt128>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out System.UInt128 result) => throw null;
        static bool System.Numerics.INumberBase<System.UInt128>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        static bool System.IParsable<System.UInt128>.TryParse(string s, System.IFormatProvider provider, out System.UInt128 result) => throw null;
        public static bool TryParse(string s, out System.UInt128 result) => throw null;
        static bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out System.UInt128 value) => throw null;
        static bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out System.UInt128 value) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static System.UInt128 System.Numerics.INumberBase<System.UInt128>.Zero { get => throw null; }
    }
    public struct UInt16 : System.Numerics.IAdditionOperators<ushort, ushort, ushort>, System.Numerics.IAdditiveIdentity<ushort, ushort>, System.Numerics.IBinaryInteger<ushort>, System.Numerics.IBinaryNumber<ushort>, System.Numerics.IBitwiseOperators<ushort, ushort, ushort>, System.IComparable, System.IComparable<ushort>, System.Numerics.IComparisonOperators<ushort, ushort, bool>, System.IConvertible, System.Numerics.IDecrementOperators<ushort>, System.Numerics.IDivisionOperators<ushort, ushort, ushort>, System.Numerics.IEqualityOperators<ushort, ushort, bool>, System.IEquatable<ushort>, System.IFormattable, System.Numerics.IIncrementOperators<ushort>, System.Numerics.IMinMaxValue<ushort>, System.Numerics.IModulusOperators<ushort, ushort, ushort>, System.Numerics.IMultiplicativeIdentity<ushort, ushort>, System.Numerics.IMultiplyOperators<ushort, ushort, ushort>, System.Numerics.INumber<ushort>, System.Numerics.INumberBase<ushort>, System.IParsable<ushort>, System.Numerics.IShiftOperators<ushort, int, ushort>, System.ISpanFormattable, System.ISpanParsable<ushort>, System.Numerics.ISubtractionOperators<ushort, ushort, ushort>, System.Numerics.IUnaryNegationOperators<ushort, ushort>, System.Numerics.IUnaryPlusOperators<ushort, ushort>, System.Numerics.IUnsignedNumber<ushort>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<ushort>
    {
        static ushort System.Numerics.INumberBase<ushort>.Abs(ushort value) => throw null;
        static ushort System.Numerics.IAdditiveIdentity<ushort, ushort>.AdditiveIdentity { get => throw null; }
        static ushort System.Numerics.IBinaryNumber<ushort>.AllBitsSet { get => throw null; }
        static ushort System.Numerics.INumber<ushort>.Clamp(ushort value, ushort min, ushort max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(ushort value) => throw null;
        static ushort System.Numerics.INumber<ushort>.CopySign(ushort value, ushort sign) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.CreateChecked<TOther>(TOther value) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.CreateSaturating<TOther>(TOther value) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.CreateTruncating<TOther>(TOther value) => throw null;
        static (ushort Quotient, ushort Remainder) System.Numerics.IBinaryInteger<ushort>.DivRem(ushort left, ushort right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(ushort obj) => throw null;
        int System.Numerics.IBinaryInteger<ushort>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<ushort>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsCanonical(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsComplexNumber(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsEvenInteger(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsFinite(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsImaginaryNumber(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsInfinity(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsInteger(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsNaN(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsNegative(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsNegativeInfinity(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsNormal(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsOddInteger(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsPositive(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsPositiveInfinity(ushort value) => throw null;
        static bool System.Numerics.IBinaryNumber<ushort>.IsPow2(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsRealNumber(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsSubnormal(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.IsZero(ushort value) => throw null;
        static ushort System.Numerics.IBinaryInteger<ushort>.LeadingZeroCount(ushort value) => throw null;
        static ushort System.Numerics.IBinaryNumber<ushort>.Log2(ushort value) => throw null;
        static ushort System.Numerics.INumber<ushort>.Max(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.MaxMagnitude(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.MaxMagnitudeNumber(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumber<ushort>.MaxNumber(ushort x, ushort y) => throw null;
        public const ushort MaxValue = 65535;
        static ushort System.Numerics.IMinMaxValue<ushort>.MaxValue { get => throw null; }
        static ushort System.Numerics.INumber<ushort>.Min(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.MinMagnitude(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.MinMagnitudeNumber(ushort x, ushort y) => throw null;
        static ushort System.Numerics.INumber<ushort>.MinNumber(ushort x, ushort y) => throw null;
        public const ushort MinValue = 0;
        static ushort System.Numerics.IMinMaxValue<ushort>.MinValue { get => throw null; }
        static ushort System.Numerics.IMultiplicativeIdentity<ushort, ushort>.MultiplicativeIdentity { get => throw null; }
        static ushort System.Numerics.INumberBase<ushort>.One { get => throw null; }
        static ushort System.Numerics.IAdditionOperators<ushort, ushort, ushort>.operator +(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IBitwiseOperators<ushort, ushort, ushort>.operator &(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IBitwiseOperators<ushort, ushort, ushort>.operator |(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IAdditionOperators<ushort, ushort, ushort>.operator checked +(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IDecrementOperators<ushort>.operator checked --(ushort value) => throw null;
        static ushort System.Numerics.IIncrementOperators<ushort>.operator checked ++(ushort value) => throw null;
        static ushort System.Numerics.IMultiplyOperators<ushort, ushort, ushort>.operator checked *(ushort left, ushort right) => throw null;
        static ushort System.Numerics.ISubtractionOperators<ushort, ushort, ushort>.operator checked -(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IUnaryNegationOperators<ushort, ushort>.operator checked -(ushort value) => throw null;
        static ushort System.Numerics.IDecrementOperators<ushort>.operator --(ushort value) => throw null;
        static ushort System.Numerics.IDivisionOperators<ushort, ushort, ushort>.operator /(ushort left, ushort right) => throw null;
        static bool System.Numerics.IEqualityOperators<ushort, ushort, bool>.operator ==(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IBitwiseOperators<ushort, ushort, ushort>.operator ^(ushort left, ushort right) => throw null;
        static bool System.Numerics.IComparisonOperators<ushort, ushort, bool>.operator >(ushort left, ushort right) => throw null;
        static bool System.Numerics.IComparisonOperators<ushort, ushort, bool>.operator >=(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IIncrementOperators<ushort>.operator ++(ushort value) => throw null;
        static bool System.Numerics.IEqualityOperators<ushort, ushort, bool>.operator !=(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IShiftOperators<ushort, int, ushort>.operator <<(ushort value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<ushort, ushort, bool>.operator <(ushort left, ushort right) => throw null;
        static bool System.Numerics.IComparisonOperators<ushort, ushort, bool>.operator <=(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IModulusOperators<ushort, ushort, ushort>.operator %(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IMultiplyOperators<ushort, ushort, ushort>.operator *(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IBitwiseOperators<ushort, ushort, ushort>.operator ~(ushort value) => throw null;
        static ushort System.Numerics.IShiftOperators<ushort, int, ushort>.operator >>(ushort value, int shiftAmount) => throw null;
        static ushort System.Numerics.ISubtractionOperators<ushort, ushort, ushort>.operator -(ushort left, ushort right) => throw null;
        static ushort System.Numerics.IUnaryNegationOperators<ushort, ushort>.operator -(ushort value) => throw null;
        static ushort System.Numerics.IUnaryPlusOperators<ushort, ushort>.operator +(ushort value) => throw null;
        static ushort System.Numerics.IShiftOperators<ushort, int, ushort>.operator >>>(ushort value, int shiftAmount) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static ushort System.IUtf8SpanParsable<ushort>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static ushort System.ISpanParsable<ushort>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static ushort Parse(string s) => throw null;
        public static ushort Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static ushort System.IParsable<ushort>.Parse(string s, System.IFormatProvider provider) => throw null;
        static ushort System.Numerics.IBinaryInteger<ushort>.PopCount(ushort value) => throw null;
        static int System.Numerics.INumberBase<ushort>.Radix { get => throw null; }
        static ushort System.Numerics.IBinaryInteger<ushort>.RotateLeft(ushort value, int rotateAmount) => throw null;
        static ushort System.Numerics.IBinaryInteger<ushort>.RotateRight(ushort value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<ushort>.Sign(ushort value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static ushort System.Numerics.IBinaryInteger<ushort>.TrailingZeroCount(ushort value) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertFromChecked<TOther>(TOther value, out ushort result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertFromSaturating<TOther>(TOther value, out ushort result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertFromTruncating<TOther>(TOther value, out ushort result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertToChecked<TOther>(ushort value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertToSaturating<TOther>(ushort value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryConvertToTruncating<TOther>(ushort value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ushort result) => throw null;
        static bool System.IUtf8SpanParsable<ushort>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out ushort result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out ushort result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ushort result) => throw null;
        static bool System.ISpanParsable<ushort>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out ushort result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out ushort result) => throw null;
        static bool System.Numerics.INumberBase<ushort>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ushort result) => throw null;
        static bool System.IParsable<ushort>.TryParse(string s, System.IFormatProvider provider, out ushort result) => throw null;
        public static bool TryParse(string s, out ushort result) => throw null;
        static bool System.Numerics.IBinaryInteger<ushort>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out ushort value) => throw null;
        static bool System.Numerics.IBinaryInteger<ushort>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out ushort value) => throw null;
        bool System.Numerics.IBinaryInteger<ushort>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<ushort>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static ushort System.Numerics.INumberBase<ushort>.Zero { get => throw null; }
    }
    public struct UInt32 : System.Numerics.IAdditionOperators<uint, uint, uint>, System.Numerics.IAdditiveIdentity<uint, uint>, System.Numerics.IBinaryInteger<uint>, System.Numerics.IBinaryNumber<uint>, System.Numerics.IBitwiseOperators<uint, uint, uint>, System.IComparable, System.IComparable<uint>, System.Numerics.IComparisonOperators<uint, uint, bool>, System.IConvertible, System.Numerics.IDecrementOperators<uint>, System.Numerics.IDivisionOperators<uint, uint, uint>, System.Numerics.IEqualityOperators<uint, uint, bool>, System.IEquatable<uint>, System.IFormattable, System.Numerics.IIncrementOperators<uint>, System.Numerics.IMinMaxValue<uint>, System.Numerics.IModulusOperators<uint, uint, uint>, System.Numerics.IMultiplicativeIdentity<uint, uint>, System.Numerics.IMultiplyOperators<uint, uint, uint>, System.Numerics.INumber<uint>, System.Numerics.INumberBase<uint>, System.IParsable<uint>, System.Numerics.IShiftOperators<uint, int, uint>, System.ISpanFormattable, System.ISpanParsable<uint>, System.Numerics.ISubtractionOperators<uint, uint, uint>, System.Numerics.IUnaryNegationOperators<uint, uint>, System.Numerics.IUnaryPlusOperators<uint, uint>, System.Numerics.IUnsignedNumber<uint>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<uint>
    {
        static uint System.Numerics.INumberBase<uint>.Abs(uint value) => throw null;
        static uint System.Numerics.IAdditiveIdentity<uint, uint>.AdditiveIdentity { get => throw null; }
        static uint System.Numerics.IBinaryNumber<uint>.AllBitsSet { get => throw null; }
        static uint System.Numerics.INumber<uint>.Clamp(uint value, uint min, uint max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(uint value) => throw null;
        static uint System.Numerics.INumber<uint>.CopySign(uint value, uint sign) => throw null;
        static uint System.Numerics.INumberBase<uint>.CreateChecked<TOther>(TOther value) => throw null;
        static uint System.Numerics.INumberBase<uint>.CreateSaturating<TOther>(TOther value) => throw null;
        static uint System.Numerics.INumberBase<uint>.CreateTruncating<TOther>(TOther value) => throw null;
        static (uint Quotient, uint Remainder) System.Numerics.IBinaryInteger<uint>.DivRem(uint left, uint right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(uint obj) => throw null;
        int System.Numerics.IBinaryInteger<uint>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<uint>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<uint>.IsCanonical(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsComplexNumber(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsEvenInteger(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsFinite(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsImaginaryNumber(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsInfinity(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsInteger(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsNaN(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsNegative(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsNegativeInfinity(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsNormal(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsOddInteger(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsPositive(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsPositiveInfinity(uint value) => throw null;
        static bool System.Numerics.IBinaryNumber<uint>.IsPow2(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsRealNumber(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsSubnormal(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.IsZero(uint value) => throw null;
        static uint System.Numerics.IBinaryInteger<uint>.LeadingZeroCount(uint value) => throw null;
        static uint System.Numerics.IBinaryNumber<uint>.Log2(uint value) => throw null;
        static uint System.Numerics.INumber<uint>.Max(uint x, uint y) => throw null;
        static uint System.Numerics.INumberBase<uint>.MaxMagnitude(uint x, uint y) => throw null;
        static uint System.Numerics.INumberBase<uint>.MaxMagnitudeNumber(uint x, uint y) => throw null;
        static uint System.Numerics.INumber<uint>.MaxNumber(uint x, uint y) => throw null;
        public const uint MaxValue = 4294967295;
        static uint System.Numerics.IMinMaxValue<uint>.MaxValue { get => throw null; }
        static uint System.Numerics.INumber<uint>.Min(uint x, uint y) => throw null;
        static uint System.Numerics.INumberBase<uint>.MinMagnitude(uint x, uint y) => throw null;
        static uint System.Numerics.INumberBase<uint>.MinMagnitudeNumber(uint x, uint y) => throw null;
        static uint System.Numerics.INumber<uint>.MinNumber(uint x, uint y) => throw null;
        public const uint MinValue = 0;
        static uint System.Numerics.IMinMaxValue<uint>.MinValue { get => throw null; }
        static uint System.Numerics.IMultiplicativeIdentity<uint, uint>.MultiplicativeIdentity { get => throw null; }
        static uint System.Numerics.INumberBase<uint>.One { get => throw null; }
        static uint System.Numerics.IAdditionOperators<uint, uint, uint>.operator +(uint left, uint right) => throw null;
        static uint System.Numerics.IBitwiseOperators<uint, uint, uint>.operator &(uint left, uint right) => throw null;
        static uint System.Numerics.IBitwiseOperators<uint, uint, uint>.operator |(uint left, uint right) => throw null;
        static uint System.Numerics.IAdditionOperators<uint, uint, uint>.operator checked +(uint left, uint right) => throw null;
        static uint System.Numerics.IDecrementOperators<uint>.operator checked --(uint value) => throw null;
        static uint System.Numerics.IIncrementOperators<uint>.operator checked ++(uint value) => throw null;
        static uint System.Numerics.IMultiplyOperators<uint, uint, uint>.operator checked *(uint left, uint right) => throw null;
        static uint System.Numerics.ISubtractionOperators<uint, uint, uint>.operator checked -(uint left, uint right) => throw null;
        static uint System.Numerics.IUnaryNegationOperators<uint, uint>.operator checked -(uint value) => throw null;
        static uint System.Numerics.IDecrementOperators<uint>.operator --(uint value) => throw null;
        static uint System.Numerics.IDivisionOperators<uint, uint, uint>.operator /(uint left, uint right) => throw null;
        static bool System.Numerics.IEqualityOperators<uint, uint, bool>.operator ==(uint left, uint right) => throw null;
        static uint System.Numerics.IBitwiseOperators<uint, uint, uint>.operator ^(uint left, uint right) => throw null;
        static bool System.Numerics.IComparisonOperators<uint, uint, bool>.operator >(uint left, uint right) => throw null;
        static bool System.Numerics.IComparisonOperators<uint, uint, bool>.operator >=(uint left, uint right) => throw null;
        static uint System.Numerics.IIncrementOperators<uint>.operator ++(uint value) => throw null;
        static bool System.Numerics.IEqualityOperators<uint, uint, bool>.operator !=(uint left, uint right) => throw null;
        static uint System.Numerics.IShiftOperators<uint, int, uint>.operator <<(uint value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<uint, uint, bool>.operator <(uint left, uint right) => throw null;
        static bool System.Numerics.IComparisonOperators<uint, uint, bool>.operator <=(uint left, uint right) => throw null;
        static uint System.Numerics.IModulusOperators<uint, uint, uint>.operator %(uint left, uint right) => throw null;
        static uint System.Numerics.IMultiplyOperators<uint, uint, uint>.operator *(uint left, uint right) => throw null;
        static uint System.Numerics.IBitwiseOperators<uint, uint, uint>.operator ~(uint value) => throw null;
        static uint System.Numerics.IShiftOperators<uint, int, uint>.operator >>(uint value, int shiftAmount) => throw null;
        static uint System.Numerics.ISubtractionOperators<uint, uint, uint>.operator -(uint left, uint right) => throw null;
        static uint System.Numerics.IUnaryNegationOperators<uint, uint>.operator -(uint value) => throw null;
        static uint System.Numerics.IUnaryPlusOperators<uint, uint>.operator +(uint value) => throw null;
        static uint System.Numerics.IShiftOperators<uint, int, uint>.operator >>>(uint value, int shiftAmount) => throw null;
        static uint System.Numerics.INumberBase<uint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static uint System.IUtf8SpanParsable<uint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static uint System.Numerics.INumberBase<uint>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static uint System.ISpanParsable<uint>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static uint Parse(string s) => throw null;
        public static uint Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static uint System.Numerics.INumberBase<uint>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static uint System.IParsable<uint>.Parse(string s, System.IFormatProvider provider) => throw null;
        static uint System.Numerics.IBinaryInteger<uint>.PopCount(uint value) => throw null;
        static int System.Numerics.INumberBase<uint>.Radix { get => throw null; }
        static uint System.Numerics.IBinaryInteger<uint>.RotateLeft(uint value, int rotateAmount) => throw null;
        static uint System.Numerics.IBinaryInteger<uint>.RotateRight(uint value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<uint>.Sign(uint value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static uint System.Numerics.IBinaryInteger<uint>.TrailingZeroCount(uint value) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertFromChecked<TOther>(TOther value, out uint result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertFromSaturating<TOther>(TOther value, out uint result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertFromTruncating<TOther>(TOther value, out uint result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertToChecked<TOther>(uint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertToSaturating<TOther>(uint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryConvertToTruncating<TOther>(uint value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out uint result) => throw null;
        static bool System.IUtf8SpanParsable<uint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out uint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out uint result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out uint result) => throw null;
        static bool System.ISpanParsable<uint>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out uint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out uint result) => throw null;
        static bool System.Numerics.INumberBase<uint>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out uint result) => throw null;
        static bool System.IParsable<uint>.TryParse(string s, System.IFormatProvider provider, out uint result) => throw null;
        public static bool TryParse(string s, out uint result) => throw null;
        static bool System.Numerics.IBinaryInteger<uint>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out uint value) => throw null;
        static bool System.Numerics.IBinaryInteger<uint>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out uint value) => throw null;
        bool System.Numerics.IBinaryInteger<uint>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<uint>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static uint System.Numerics.INumberBase<uint>.Zero { get => throw null; }
    }
    public struct UInt64 : System.Numerics.IAdditionOperators<ulong, ulong, ulong>, System.Numerics.IAdditiveIdentity<ulong, ulong>, System.Numerics.IBinaryInteger<ulong>, System.Numerics.IBinaryNumber<ulong>, System.Numerics.IBitwiseOperators<ulong, ulong, ulong>, System.IComparable, System.IComparable<ulong>, System.Numerics.IComparisonOperators<ulong, ulong, bool>, System.IConvertible, System.Numerics.IDecrementOperators<ulong>, System.Numerics.IDivisionOperators<ulong, ulong, ulong>, System.Numerics.IEqualityOperators<ulong, ulong, bool>, System.IEquatable<ulong>, System.IFormattable, System.Numerics.IIncrementOperators<ulong>, System.Numerics.IMinMaxValue<ulong>, System.Numerics.IModulusOperators<ulong, ulong, ulong>, System.Numerics.IMultiplicativeIdentity<ulong, ulong>, System.Numerics.IMultiplyOperators<ulong, ulong, ulong>, System.Numerics.INumber<ulong>, System.Numerics.INumberBase<ulong>, System.IParsable<ulong>, System.Numerics.IShiftOperators<ulong, int, ulong>, System.ISpanFormattable, System.ISpanParsable<ulong>, System.Numerics.ISubtractionOperators<ulong, ulong, ulong>, System.Numerics.IUnaryNegationOperators<ulong, ulong>, System.Numerics.IUnaryPlusOperators<ulong, ulong>, System.Numerics.IUnsignedNumber<ulong>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<ulong>
    {
        static ulong System.Numerics.INumberBase<ulong>.Abs(ulong value) => throw null;
        static ulong System.Numerics.IAdditiveIdentity<ulong, ulong>.AdditiveIdentity { get => throw null; }
        static ulong System.Numerics.IBinaryNumber<ulong>.AllBitsSet { get => throw null; }
        static ulong System.Numerics.INumber<ulong>.Clamp(ulong value, ulong min, ulong max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(ulong value) => throw null;
        static ulong System.Numerics.INumber<ulong>.CopySign(ulong value, ulong sign) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.CreateChecked<TOther>(TOther value) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.CreateSaturating<TOther>(TOther value) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.CreateTruncating<TOther>(TOther value) => throw null;
        static (ulong Quotient, ulong Remainder) System.Numerics.IBinaryInteger<ulong>.DivRem(ulong left, ulong right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(ulong obj) => throw null;
        int System.Numerics.IBinaryInteger<ulong>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        int System.Numerics.IBinaryInteger<ulong>.GetShortestBitLength() => throw null;
        public System.TypeCode GetTypeCode() => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsCanonical(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsComplexNumber(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsEvenInteger(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsFinite(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsImaginaryNumber(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsInfinity(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsInteger(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsNaN(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsNegative(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsNegativeInfinity(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsNormal(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsOddInteger(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsPositive(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsPositiveInfinity(ulong value) => throw null;
        static bool System.Numerics.IBinaryNumber<ulong>.IsPow2(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsRealNumber(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsSubnormal(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.IsZero(ulong value) => throw null;
        static ulong System.Numerics.IBinaryInteger<ulong>.LeadingZeroCount(ulong value) => throw null;
        static ulong System.Numerics.IBinaryNumber<ulong>.Log2(ulong value) => throw null;
        static ulong System.Numerics.INumber<ulong>.Max(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.MaxMagnitude(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.MaxMagnitudeNumber(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumber<ulong>.MaxNumber(ulong x, ulong y) => throw null;
        public const ulong MaxValue = 18446744073709551615;
        static ulong System.Numerics.IMinMaxValue<ulong>.MaxValue { get => throw null; }
        static ulong System.Numerics.INumber<ulong>.Min(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.MinMagnitude(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.MinMagnitudeNumber(ulong x, ulong y) => throw null;
        static ulong System.Numerics.INumber<ulong>.MinNumber(ulong x, ulong y) => throw null;
        public const ulong MinValue = 0;
        static ulong System.Numerics.IMinMaxValue<ulong>.MinValue { get => throw null; }
        static ulong System.Numerics.IMultiplicativeIdentity<ulong, ulong>.MultiplicativeIdentity { get => throw null; }
        static ulong System.Numerics.INumberBase<ulong>.One { get => throw null; }
        static ulong System.Numerics.IAdditionOperators<ulong, ulong, ulong>.operator +(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IBitwiseOperators<ulong, ulong, ulong>.operator &(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IBitwiseOperators<ulong, ulong, ulong>.operator |(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IAdditionOperators<ulong, ulong, ulong>.operator checked +(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IDecrementOperators<ulong>.operator checked --(ulong value) => throw null;
        static ulong System.Numerics.IIncrementOperators<ulong>.operator checked ++(ulong value) => throw null;
        static ulong System.Numerics.IMultiplyOperators<ulong, ulong, ulong>.operator checked *(ulong left, ulong right) => throw null;
        static ulong System.Numerics.ISubtractionOperators<ulong, ulong, ulong>.operator checked -(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IUnaryNegationOperators<ulong, ulong>.operator checked -(ulong value) => throw null;
        static ulong System.Numerics.IDecrementOperators<ulong>.operator --(ulong value) => throw null;
        static ulong System.Numerics.IDivisionOperators<ulong, ulong, ulong>.operator /(ulong left, ulong right) => throw null;
        static bool System.Numerics.IEqualityOperators<ulong, ulong, bool>.operator ==(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IBitwiseOperators<ulong, ulong, ulong>.operator ^(ulong left, ulong right) => throw null;
        static bool System.Numerics.IComparisonOperators<ulong, ulong, bool>.operator >(ulong left, ulong right) => throw null;
        static bool System.Numerics.IComparisonOperators<ulong, ulong, bool>.operator >=(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IIncrementOperators<ulong>.operator ++(ulong value) => throw null;
        static bool System.Numerics.IEqualityOperators<ulong, ulong, bool>.operator !=(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IShiftOperators<ulong, int, ulong>.operator <<(ulong value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<ulong, ulong, bool>.operator <(ulong left, ulong right) => throw null;
        static bool System.Numerics.IComparisonOperators<ulong, ulong, bool>.operator <=(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IModulusOperators<ulong, ulong, ulong>.operator %(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IMultiplyOperators<ulong, ulong, ulong>.operator *(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IBitwiseOperators<ulong, ulong, ulong>.operator ~(ulong value) => throw null;
        static ulong System.Numerics.IShiftOperators<ulong, int, ulong>.operator >>(ulong value, int shiftAmount) => throw null;
        static ulong System.Numerics.ISubtractionOperators<ulong, ulong, ulong>.operator -(ulong left, ulong right) => throw null;
        static ulong System.Numerics.IUnaryNegationOperators<ulong, ulong>.operator -(ulong value) => throw null;
        static ulong System.Numerics.IUnaryPlusOperators<ulong, ulong>.operator +(ulong value) => throw null;
        static ulong System.Numerics.IShiftOperators<ulong, int, ulong>.operator >>>(ulong value, int shiftAmount) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static ulong System.IUtf8SpanParsable<ulong>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static ulong System.ISpanParsable<ulong>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static ulong Parse(string s) => throw null;
        public static ulong Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static ulong System.IParsable<ulong>.Parse(string s, System.IFormatProvider provider) => throw null;
        static ulong System.Numerics.IBinaryInteger<ulong>.PopCount(ulong value) => throw null;
        static int System.Numerics.INumberBase<ulong>.Radix { get => throw null; }
        static ulong System.Numerics.IBinaryInteger<ulong>.RotateLeft(ulong value, int rotateAmount) => throw null;
        static ulong System.Numerics.IBinaryInteger<ulong>.RotateRight(ulong value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<ulong>.Sign(ulong value) => throw null;
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) => throw null;
        byte System.IConvertible.ToByte(System.IFormatProvider provider) => throw null;
        char System.IConvertible.ToChar(System.IFormatProvider provider) => throw null;
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) => throw null;
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) => throw null;
        double System.IConvertible.ToDouble(System.IFormatProvider provider) => throw null;
        short System.IConvertible.ToInt16(System.IFormatProvider provider) => throw null;
        int System.IConvertible.ToInt32(System.IFormatProvider provider) => throw null;
        long System.IConvertible.ToInt64(System.IFormatProvider provider) => throw null;
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) => throw null;
        float System.IConvertible.ToSingle(System.IFormatProvider provider) => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) => throw null;
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) => throw null;
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) => throw null;
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) => throw null;
        static ulong System.Numerics.IBinaryInteger<ulong>.TrailingZeroCount(ulong value) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertFromChecked<TOther>(TOther value, out ulong result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertFromSaturating<TOther>(TOther value, out ulong result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertFromTruncating<TOther>(TOther value, out ulong result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertToChecked<TOther>(ulong value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertToSaturating<TOther>(ulong value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryConvertToTruncating<TOther>(ulong value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ulong result) => throw null;
        static bool System.IUtf8SpanParsable<ulong>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out ulong result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out ulong result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ulong result) => throw null;
        static bool System.ISpanParsable<ulong>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out ulong result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out ulong result) => throw null;
        static bool System.Numerics.INumberBase<ulong>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ulong result) => throw null;
        static bool System.IParsable<ulong>.TryParse(string s, System.IFormatProvider provider, out ulong result) => throw null;
        public static bool TryParse(string s, out ulong result) => throw null;
        static bool System.Numerics.IBinaryInteger<ulong>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out ulong value) => throw null;
        static bool System.Numerics.IBinaryInteger<ulong>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out ulong value) => throw null;
        bool System.Numerics.IBinaryInteger<ulong>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<ulong>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        static ulong System.Numerics.INumberBase<ulong>.Zero { get => throw null; }
    }
    public struct UIntPtr : System.Numerics.IAdditionOperators<nuint, nuint, nuint>, System.Numerics.IAdditiveIdentity<nuint, nuint>, System.Numerics.IBinaryInteger<nuint>, System.Numerics.IBinaryNumber<nuint>, System.Numerics.IBitwiseOperators<nuint, nuint, nuint>, System.IComparable, System.IComparable<nuint>, System.Numerics.IComparisonOperators<nuint, nuint, bool>, System.Numerics.IDecrementOperators<nuint>, System.Numerics.IDivisionOperators<nuint, nuint, nuint>, System.Numerics.IEqualityOperators<nuint, nuint, bool>, System.IEquatable<nuint>, System.IFormattable, System.Numerics.IIncrementOperators<nuint>, System.Numerics.IMinMaxValue<nuint>, System.Numerics.IModulusOperators<nuint, nuint, nuint>, System.Numerics.IMultiplicativeIdentity<nuint, nuint>, System.Numerics.IMultiplyOperators<nuint, nuint, nuint>, System.Numerics.INumber<nuint>, System.Numerics.INumberBase<nuint>, System.IParsable<nuint>, System.Runtime.Serialization.ISerializable, System.Numerics.IShiftOperators<nuint, int, nuint>, System.ISpanFormattable, System.ISpanParsable<nuint>, System.Numerics.ISubtractionOperators<nuint, nuint, nuint>, System.Numerics.IUnaryNegationOperators<nuint, nuint>, System.Numerics.IUnaryPlusOperators<nuint, nuint>, System.Numerics.IUnsignedNumber<nuint>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<nuint>
    {
        static nuint System.Numerics.INumberBase<nuint>.Abs(nuint value) => throw null;
        public static nuint Add(nuint pointer, int offset) => throw null;
        static nuint System.Numerics.IAdditiveIdentity<nuint, nuint>.AdditiveIdentity { get => throw null; }
        static nuint System.Numerics.IBinaryNumber<nuint>.AllBitsSet { get => throw null; }
        static nuint System.Numerics.INumber<nuint>.Clamp(nuint value, nuint min, nuint max) => throw null;
        public int CompareTo(object value) => throw null;
        public int CompareTo(nuint value) => throw null;
        static nuint System.Numerics.INumber<nuint>.CopySign(nuint value, nuint sign) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.CreateChecked<TOther>(TOther value) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.CreateSaturating<TOther>(TOther value) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.CreateTruncating<TOther>(TOther value) => throw null;
        public UIntPtr(uint value) => throw null;
        public UIntPtr(ulong value) => throw null;
        public unsafe UIntPtr(void* value) => throw null;
        static (nuint Quotient, nuint Remainder) System.Numerics.IBinaryInteger<nuint>.DivRem(nuint left, nuint right) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(nuint other) => throw null;
        int System.Numerics.IBinaryInteger<nuint>.GetByteCount() => throw null;
        public override int GetHashCode() => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        int System.Numerics.IBinaryInteger<nuint>.GetShortestBitLength() => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsCanonical(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsComplexNumber(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsEvenInteger(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsFinite(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsImaginaryNumber(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsInfinity(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsInteger(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsNaN(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsNegative(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsNegativeInfinity(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsNormal(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsOddInteger(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsPositive(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsPositiveInfinity(nuint value) => throw null;
        static bool System.Numerics.IBinaryNumber<nuint>.IsPow2(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsRealNumber(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsSubnormal(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.IsZero(nuint value) => throw null;
        static nuint System.Numerics.IBinaryInteger<nuint>.LeadingZeroCount(nuint value) => throw null;
        static nuint System.Numerics.IBinaryNumber<nuint>.Log2(nuint value) => throw null;
        static nuint System.Numerics.INumber<nuint>.Max(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.MaxMagnitude(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.MaxMagnitudeNumber(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumber<nuint>.MaxNumber(nuint x, nuint y) => throw null;
        public static nuint MaxValue { get => throw null; }
        static nuint System.Numerics.IMinMaxValue<nuint>.MaxValue { get => throw null; }
        static nuint System.Numerics.INumber<nuint>.Min(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.MinMagnitude(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.MinMagnitudeNumber(nuint x, nuint y) => throw null;
        static nuint System.Numerics.INumber<nuint>.MinNumber(nuint x, nuint y) => throw null;
        public static nuint MinValue { get => throw null; }
        static nuint System.Numerics.IMinMaxValue<nuint>.MinValue { get => throw null; }
        static nuint System.Numerics.IMultiplicativeIdentity<nuint, nuint>.MultiplicativeIdentity { get => throw null; }
        static nuint System.Numerics.INumberBase<nuint>.One { get => throw null; }
        public static nuint operator +(nuint pointer, int offset) => throw null;
        static nuint System.Numerics.IAdditionOperators<nuint, nuint, nuint>.operator +(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IBitwiseOperators<nuint, nuint, nuint>.operator &(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IBitwiseOperators<nuint, nuint, nuint>.operator |(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IAdditionOperators<nuint, nuint, nuint>.operator checked +(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IDecrementOperators<nuint>.operator checked --(nuint value) => throw null;
        static nuint System.Numerics.IIncrementOperators<nuint>.operator checked ++(nuint value) => throw null;
        static nuint System.Numerics.IMultiplyOperators<nuint, nuint, nuint>.operator checked *(nuint left, nuint right) => throw null;
        static nuint System.Numerics.ISubtractionOperators<nuint, nuint, nuint>.operator checked -(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IUnaryNegationOperators<nuint, nuint>.operator checked -(nuint value) => throw null;
        static nuint System.Numerics.IDecrementOperators<nuint>.operator --(nuint value) => throw null;
        static nuint System.Numerics.IDivisionOperators<nuint, nuint, nuint>.operator /(nuint left, nuint right) => throw null;
        static bool System.Numerics.IEqualityOperators<nuint, nuint, bool>.operator ==(nuint value1, nuint value2) => throw null;
        static nuint System.Numerics.IBitwiseOperators<nuint, nuint, nuint>.operator ^(nuint left, nuint right) => throw null;
        public static explicit operator nuint(uint value) => throw null;
        public static explicit operator nuint(ulong value) => throw null;
        public static explicit operator uint(nuint value) => throw null;
        public static explicit operator ulong(nuint value) => throw null;
        public static unsafe explicit operator void*(nuint value) => throw null;
        public static unsafe explicit operator nuint(void* value) => throw null;
        static bool System.Numerics.IComparisonOperators<nuint, nuint, bool>.operator >(nuint left, nuint right) => throw null;
        static bool System.Numerics.IComparisonOperators<nuint, nuint, bool>.operator >=(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IIncrementOperators<nuint>.operator ++(nuint value) => throw null;
        static bool System.Numerics.IEqualityOperators<nuint, nuint, bool>.operator !=(nuint value1, nuint value2) => throw null;
        static nuint System.Numerics.IShiftOperators<nuint, int, nuint>.operator <<(nuint value, int shiftAmount) => throw null;
        static bool System.Numerics.IComparisonOperators<nuint, nuint, bool>.operator <(nuint left, nuint right) => throw null;
        static bool System.Numerics.IComparisonOperators<nuint, nuint, bool>.operator <=(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IModulusOperators<nuint, nuint, nuint>.operator %(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IMultiplyOperators<nuint, nuint, nuint>.operator *(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IBitwiseOperators<nuint, nuint, nuint>.operator ~(nuint value) => throw null;
        static nuint System.Numerics.IShiftOperators<nuint, int, nuint>.operator >>(nuint value, int shiftAmount) => throw null;
        public static nuint operator -(nuint pointer, int offset) => throw null;
        static nuint System.Numerics.ISubtractionOperators<nuint, nuint, nuint>.operator -(nuint left, nuint right) => throw null;
        static nuint System.Numerics.IUnaryNegationOperators<nuint, nuint>.operator -(nuint value) => throw null;
        static nuint System.Numerics.IUnaryPlusOperators<nuint, nuint>.operator +(nuint value) => throw null;
        static nuint System.Numerics.IShiftOperators<nuint, int, nuint>.operator >>>(nuint value, int shiftAmount) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static nuint System.IUtf8SpanParsable<nuint>.Parse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = default(System.Globalization.NumberStyles), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static nuint System.ISpanParsable<nuint>.Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider) => throw null;
        public static nuint Parse(string s) => throw null;
        public static nuint Parse(string s, System.Globalization.NumberStyles style) => throw null;
        static nuint System.Numerics.INumberBase<nuint>.Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) => throw null;
        static nuint System.IParsable<nuint>.Parse(string s, System.IFormatProvider provider) => throw null;
        static nuint System.Numerics.IBinaryInteger<nuint>.PopCount(nuint value) => throw null;
        static int System.Numerics.INumberBase<nuint>.Radix { get => throw null; }
        static nuint System.Numerics.IBinaryInteger<nuint>.RotateLeft(nuint value, int rotateAmount) => throw null;
        static nuint System.Numerics.IBinaryInteger<nuint>.RotateRight(nuint value, int rotateAmount) => throw null;
        static int System.Numerics.INumber<nuint>.Sign(nuint value) => throw null;
        public static int Size { get => throw null; }
        public static nuint Subtract(nuint pointer, int offset) => throw null;
        public unsafe void* ToPointer() => throw null;
        public override string ToString() => throw null;
        public string ToString(System.IFormatProvider provider) => throw null;
        public string ToString(string format) => throw null;
        public string ToString(string format, System.IFormatProvider provider) => throw null;
        public uint ToUInt32() => throw null;
        public ulong ToUInt64() => throw null;
        static nuint System.Numerics.IBinaryInteger<nuint>.TrailingZeroCount(nuint value) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertFromChecked<TOther>(TOther value, out nuint result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertFromSaturating<TOther>(TOther value, out nuint result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertFromTruncating<TOther>(TOther value, out nuint result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertToChecked<TOther>(nuint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertToSaturating<TOther>(nuint value, out TOther result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryConvertToTruncating<TOther>(nuint value, out TOther result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider provider = default(System.IFormatProvider)) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nuint result) => throw null;
        static bool System.IUtf8SpanParsable<nuint>.TryParse(System.ReadOnlySpan<byte> utf8Text, System.IFormatProvider provider, out nuint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out nuint result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nuint result) => throw null;
        static bool System.ISpanParsable<nuint>.TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, out nuint result) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> s, out nuint result) => throw null;
        static bool System.Numerics.INumberBase<nuint>.TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out nuint result) => throw null;
        static bool System.IParsable<nuint>.TryParse(string s, System.IFormatProvider provider, out nuint result) => throw null;
        public static bool TryParse(string s, out nuint result) => throw null;
        static bool System.Numerics.IBinaryInteger<nuint>.TryReadBigEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out nuint value) => throw null;
        static bool System.Numerics.IBinaryInteger<nuint>.TryReadLittleEndian(System.ReadOnlySpan<byte> source, bool isUnsigned, out nuint value) => throw null;
        bool System.Numerics.IBinaryInteger<nuint>.TryWriteBigEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        bool System.Numerics.IBinaryInteger<nuint>.TryWriteLittleEndian(System.Span<byte> destination, out int bytesWritten) => throw null;
        public static readonly nuint Zero;
        static nuint System.Numerics.INumberBase<nuint>.Zero { get => throw null; }
    }
    public class UnauthorizedAccessException : System.SystemException
    {
        public UnauthorizedAccessException() => throw null;
        protected UnauthorizedAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public UnauthorizedAccessException(string message) => throw null;
        public UnauthorizedAccessException(string message, System.Exception inner) => throw null;
    }
    public class UnhandledExceptionEventArgs : System.EventArgs
    {
        public UnhandledExceptionEventArgs(object exception, bool isTerminating) => throw null;
        public object ExceptionObject { get => throw null; }
        public bool IsTerminating { get => throw null; }
    }
    public delegate void UnhandledExceptionEventHandler(object sender, System.UnhandledExceptionEventArgs e);
    public class Uri : System.IFormattable, System.Runtime.Serialization.ISerializable, System.ISpanFormattable
    {
        public string AbsolutePath { get => throw null; }
        public string AbsoluteUri { get => throw null; }
        public string Authority { get => throw null; }
        protected virtual void Canonicalize() => throw null;
        public static System.UriHostNameType CheckHostName(string name) => throw null;
        public static bool CheckSchemeName(string schemeName) => throw null;
        protected virtual void CheckSecurity() => throw null;
        public static int Compare(System.Uri uri1, System.Uri uri2, System.UriComponents partsToCompare, System.UriFormat compareFormat, System.StringComparison comparisonType) => throw null;
        protected Uri(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public Uri(string uriString) => throw null;
        public Uri(string uriString, bool dontEscape) => throw null;
        public Uri(string uriString, in System.UriCreationOptions creationOptions) => throw null;
        public Uri(string uriString, System.UriKind uriKind) => throw null;
        public Uri(System.Uri baseUri, string relativeUri) => throw null;
        public Uri(System.Uri baseUri, string relativeUri, bool dontEscape) => throw null;
        public Uri(System.Uri baseUri, System.Uri relativeUri) => throw null;
        public string DnsSafeHost { get => throw null; }
        public override bool Equals(object comparand) => throw null;
        protected virtual void Escape() => throw null;
        public static string EscapeDataString(string stringToEscape) => throw null;
        protected static string EscapeString(string str) => throw null;
        public static string EscapeUriString(string stringToEscape) => throw null;
        public string Fragment { get => throw null; }
        public static int FromHex(char digit) => throw null;
        public string GetComponents(System.UriComponents components, System.UriFormat format) => throw null;
        public override int GetHashCode() => throw null;
        public string GetLeftPart(System.UriPartial part) => throw null;
        protected void GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public static string HexEscape(char character) => throw null;
        public static char HexUnescape(string pattern, ref int index) => throw null;
        public string Host { get => throw null; }
        public System.UriHostNameType HostNameType { get => throw null; }
        public string IdnHost { get => throw null; }
        public bool IsAbsoluteUri { get => throw null; }
        protected virtual bool IsBadFileSystemCharacter(char character) => throw null;
        public bool IsBaseOf(System.Uri uri) => throw null;
        public bool IsDefaultPort { get => throw null; }
        protected static bool IsExcludedCharacter(char character) => throw null;
        public bool IsFile { get => throw null; }
        public static bool IsHexDigit(char character) => throw null;
        public static bool IsHexEncoding(string pattern, int index) => throw null;
        public bool IsLoopback { get => throw null; }
        protected virtual bool IsReservedCharacter(char character) => throw null;
        public bool IsUnc { get => throw null; }
        public bool IsWellFormedOriginalString() => throw null;
        public static bool IsWellFormedUriString(string uriString, System.UriKind uriKind) => throw null;
        public string LocalPath { get => throw null; }
        public string MakeRelative(System.Uri toUri) => throw null;
        public System.Uri MakeRelativeUri(System.Uri uri) => throw null;
        public static bool operator ==(System.Uri uri1, System.Uri uri2) => throw null;
        public static bool operator !=(System.Uri uri1, System.Uri uri2) => throw null;
        public string OriginalString { get => throw null; }
        protected virtual void Parse() => throw null;
        public string PathAndQuery { get => throw null; }
        public int Port { get => throw null; }
        public string Query { get => throw null; }
        public string Scheme { get => throw null; }
        public static readonly string SchemeDelimiter;
        public string[] Segments { get => throw null; }
        public override string ToString() => throw null;
        string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public static bool TryCreate(string uriString, in System.UriCreationOptions creationOptions, out System.Uri result) => throw null;
        public static bool TryCreate(string uriString, System.UriKind uriKind, out System.Uri result) => throw null;
        public static bool TryCreate(System.Uri baseUri, string relativeUri, out System.Uri result) => throw null;
        public static bool TryCreate(System.Uri baseUri, System.Uri relativeUri, out System.Uri result) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        protected virtual string Unescape(string path) => throw null;
        public static string UnescapeDataString(string stringToUnescape) => throw null;
        public static readonly string UriSchemeFile;
        public static readonly string UriSchemeFtp;
        public static readonly string UriSchemeFtps;
        public static readonly string UriSchemeGopher;
        public static readonly string UriSchemeHttp;
        public static readonly string UriSchemeHttps;
        public static readonly string UriSchemeMailto;
        public static readonly string UriSchemeNetPipe;
        public static readonly string UriSchemeNetTcp;
        public static readonly string UriSchemeNews;
        public static readonly string UriSchemeNntp;
        public static readonly string UriSchemeSftp;
        public static readonly string UriSchemeSsh;
        public static readonly string UriSchemeTelnet;
        public static readonly string UriSchemeWs;
        public static readonly string UriSchemeWss;
        public bool UserEscaped { get => throw null; }
        public string UserInfo { get => throw null; }
    }
    public class UriBuilder
    {
        public UriBuilder() => throw null;
        public UriBuilder(string uri) => throw null;
        public UriBuilder(string schemeName, string hostName) => throw null;
        public UriBuilder(string scheme, string host, int portNumber) => throw null;
        public UriBuilder(string scheme, string host, int port, string pathValue) => throw null;
        public UriBuilder(string scheme, string host, int port, string path, string extraValue) => throw null;
        public UriBuilder(System.Uri uri) => throw null;
        public override bool Equals(object rparam) => throw null;
        public string Fragment { get => throw null; set { } }
        public override int GetHashCode() => throw null;
        public string Host { get => throw null; set { } }
        public string Password { get => throw null; set { } }
        public string Path { get => throw null; set { } }
        public int Port { get => throw null; set { } }
        public string Query { get => throw null; set { } }
        public string Scheme { get => throw null; set { } }
        public override string ToString() => throw null;
        public System.Uri Uri { get => throw null; }
        public string UserName { get => throw null; set { } }
    }
    [System.Flags]
    public enum UriComponents
    {
        SerializationInfoString = -2147483648,
        Scheme = 1,
        UserInfo = 2,
        Host = 4,
        Port = 8,
        SchemeAndServer = 13,
        Path = 16,
        Query = 32,
        PathAndQuery = 48,
        HttpRequestUrl = 61,
        Fragment = 64,
        AbsoluteUri = 127,
        StrongPort = 128,
        HostAndPort = 132,
        StrongAuthority = 134,
        NormalizedHost = 256,
        KeepDelimiter = 1073741824,
    }
    public struct UriCreationOptions
    {
        public bool DangerousDisablePathAndQueryCanonicalization { get => throw null; set { } }
    }
    public enum UriFormat
    {
        UriEscaped = 1,
        Unescaped = 2,
        SafeUnescaped = 3,
    }
    public class UriFormatException : System.FormatException, System.Runtime.Serialization.ISerializable
    {
        public UriFormatException() => throw null;
        protected UriFormatException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
        public UriFormatException(string textString) => throw null;
        public UriFormatException(string textString, System.Exception e) => throw null;
        void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) => throw null;
    }
    public enum UriHostNameType
    {
        Unknown = 0,
        Basic = 1,
        Dns = 2,
        IPv4 = 3,
        IPv6 = 4,
    }
    public enum UriKind
    {
        RelativeOrAbsolute = 0,
        Absolute = 1,
        Relative = 2,
    }
    public abstract class UriParser
    {
        protected UriParser() => throw null;
        protected virtual string GetComponents(System.Uri uri, System.UriComponents components, System.UriFormat format) => throw null;
        protected virtual void InitializeAndValidate(System.Uri uri, out System.UriFormatException parsingError) => throw null;
        protected virtual bool IsBaseOf(System.Uri baseUri, System.Uri relativeUri) => throw null;
        public static bool IsKnownScheme(string schemeName) => throw null;
        protected virtual bool IsWellFormedOriginalString(System.Uri uri) => throw null;
        protected virtual System.UriParser OnNewUri() => throw null;
        protected virtual void OnRegister(string schemeName, int defaultPort) => throw null;
        public static void Register(System.UriParser uriParser, string schemeName, int defaultPort) => throw null;
        protected virtual string Resolve(System.Uri baseUri, System.Uri relativeUri, out System.UriFormatException parsingError) => throw null;
    }
    public enum UriPartial
    {
        Scheme = 0,
        Authority = 1,
        Path = 2,
        Query = 3,
    }
    public struct ValueTuple : System.IComparable, System.IComparable<System.ValueTuple>, System.IEquatable<System.ValueTuple>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo(System.ValueTuple other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public static System.ValueTuple Create() => throw null;
        public static System.ValueTuple<T1> Create<T1>(T1 item1) => throw null;
        public static (T1, T2) Create<T1, T2>(T1 item1, T2 item2) => throw null;
        public static (T1, T2, T3) Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) => throw null;
        public static (T1, T2, T3, T4) Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public static (T1, T2, T3, T4, T5) Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public static (T1, T2, T3, T4, T5, T6) Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7) Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public static (T1, T2, T3, T4, T5, T6, T7, T8) Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.ValueTuple other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1> : System.IComparable, System.IComparable<System.ValueTuple<T1>>, System.IEquatable<System.ValueTuple<T1>>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo(System.ValueTuple<T1> other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.ValueTuple<T1> other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2> : System.IComparable, System.IComparable<(T1, T2)>, System.IEquatable<(T1, T2)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3> : System.IComparable, System.IComparable<(T1, T2, T3)>, System.IEquatable<(T1, T2, T3)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2, T3) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3, T4> : System.IComparable, System.IComparable<(T1, T2, T3, T4)>, System.IEquatable<(T1, T2, T3, T4)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2, T3, T4) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3, T4, T5> : System.IComparable, System.IComparable<(T1, T2, T3, T4, T5)>, System.IEquatable<(T1, T2, T3, T4, T5)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2, T3, T4, T5) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3, T4, T5, T6> : System.IComparable, System.IComparable<(T1, T2, T3, T4, T5, T6)>, System.IEquatable<(T1, T2, T3, T4, T5, T6)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5, T6) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2, T3, T4, T5, T6) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : System.IComparable, System.IComparable<(T1, T2, T3, T4, T5, T6, T7)>, System.IEquatable<(T1, T2, T3, T4, T5, T6, T7)>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple
    {
        public int CompareTo((T1, T2, T3, T4, T5, T6, T7) other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals((T1, T2, T3, T4, T5, T6, T7) other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public override string ToString() => throw null;
    }
    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple where TRest : struct
    {
        public int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other) => throw null;
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) => throw null;
        int System.IComparable.CompareTo(object other) => throw null;
        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other) => throw null;
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) => throw null;
        public override int GetHashCode() => throw null;
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) => throw null;
        object System.Runtime.CompilerServices.ITuple.this[int index] { get => throw null; }
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;
        int System.Runtime.CompilerServices.ITuple.Length { get => throw null; }
        public TRest Rest;
        public override string ToString() => throw null;
    }
    public abstract class ValueType
    {
        protected ValueType() => throw null;
        public override bool Equals(object obj) => throw null;
        public override int GetHashCode() => throw null;
        public override string ToString() => throw null;
    }
    public sealed class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version>, System.IEquatable<System.Version>, System.IFormattable, System.ISpanFormattable, System.IUtf8SpanFormattable
    {
        public int Build { get => throw null; }
        public object Clone() => throw null;
        public int CompareTo(object version) => throw null;
        public int CompareTo(System.Version value) => throw null;
        public Version() => throw null;
        public Version(int major, int minor) => throw null;
        public Version(int major, int minor, int build) => throw null;
        public Version(int major, int minor, int build, int revision) => throw null;
        public Version(string version) => throw null;
        public override bool Equals(object obj) => throw null;
        public bool Equals(System.Version obj) => throw null;
        public override int GetHashCode() => throw null;
        public int Major { get => throw null; }
        public short MajorRevision { get => throw null; }
        public int Minor { get => throw null; }
        public short MinorRevision { get => throw null; }
        public static bool operator ==(System.Version v1, System.Version v2) => throw null;
        public static bool operator >(System.Version v1, System.Version v2) => throw null;
        public static bool operator >=(System.Version v1, System.Version v2) => throw null;
        public static bool operator !=(System.Version v1, System.Version v2) => throw null;
        public static bool operator <(System.Version v1, System.Version v2) => throw null;
        public static bool operator <=(System.Version v1, System.Version v2) => throw null;
        public static System.Version Parse(System.ReadOnlySpan<char> input) => throw null;
        public static System.Version Parse(string input) => throw null;
        public int Revision { get => throw null; }
        string System.IFormattable.ToString(string format, System.IFormatProvider formatProvider) => throw null;
        public override string ToString() => throw null;
        public string ToString(int fieldCount) => throw null;
        bool System.ISpanFormattable.TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        bool System.IUtf8SpanFormattable.TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider) => throw null;
        public bool TryFormat(System.Span<char> destination, int fieldCount, out int charsWritten) => throw null;
        public bool TryFormat(System.Span<char> destination, out int charsWritten) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, int fieldCount, out int bytesWritten) => throw null;
        public bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten) => throw null;
        public static bool TryParse(System.ReadOnlySpan<char> input, out System.Version result) => throw null;
        public static bool TryParse(string input, out System.Version result) => throw null;
    }
    public struct Void
    {
    }
    public class WeakReference : System.Runtime.Serialization.ISerializable
    {
        public WeakReference(object target) => throw null;
        public WeakReference(object target, bool trackResurrection) => throw null;
        protected WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public virtual bool IsAlive { get => throw null; }
        public virtual object Target { get => throw null; set { } }
        public virtual bool TrackResurrection { get => throw null; }
    }
    public sealed class WeakReference<T> : System.Runtime.Serialization.ISerializable where T : class
    {
        public WeakReference(T target) => throw null;
        public WeakReference(T target, bool trackResurrection) => throw null;
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) => throw null;
        public void SetTarget(T target) => throw null;
        public bool TryGetTarget(out T target) => throw null;
    }
}
