/**
 * @name Temporary Directory Hijacking Vulnerability disclosure
 * @description Detect temporary directory hijack vulnerability
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import DataFlow::PathGraph

/**
 * All `java.io.File::createTempFile` methods.
 */
private class MethodFileCreateTempFile extends Method {
  MethodFileCreateTempFile() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("createTempFile")
  }
}

private class MethodFileMkdir extends Method {
  MethodFileMkdir() {
    getDeclaringType() instanceof TypeFile and
    hasName("mkdir")
    or
    hasName("mkdirs")
  }
}

/**
 * An expression that will create a directory without throwing an exception if a file/directory already exists.
 */
private predicate isNonThrowingDirectoryCreationExpression(Expr expr, MethodAccess creationCall) {
  creationCall.getMethod() instanceof MethodFileMkdir and creationCall.getQualifier() = expr
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    getDeclaringType() instanceof TypeFile and
    hasName("delete")
  }
}

predicate isDeleteFileExpr(Expr expr) {
  expr = any(MethodFileDelete m).getAReference().getQualifier()
}

private class TempDirHijackingToDeleteConfig extends TaintTracking::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) {
    source.asExpr() =
      any(MethodAccess ma |
        ma.getMethod() instanceof MethodFileCreateTempFile and ma.getNumArgument() = 2
      ) or
      // TODO: Replace with getSystemProperty("java.io.tmpdir")
    source.asExpr() = any(MethodAccessSystemGetProperty maSgp | maSgp.hasCompileTimeConstantGetPropertyName("java.io.tmpdir"))
  }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    node2.asExpr() =
      any(MethodAccess ma |
        ma.getMethod() instanceof MethodFileCreateTempFile and ma.getArgument(2) = node1.asExpr()
      )
  }

  override predicate isSink(DataFlow::Node sink) { isDeleteFileExpr(sink.asExpr()) }
}

private class TempDirHijackingFromDeleteConfig extends DataFlow2::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeleteFileExpr(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }
}

/**
 * Holds when there is an epression `unsafeUse` which is an unsafe use of the file that
 * is not guarded by a check of the return value of `File::mkdir(s)`.
 */
predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node sink, Expr unsafeUse) {
  exists(Guard g, MethodAccess ma |
    any(TempDirHijackingFromDeleteConfig c).isSink(sink) and // Sink is a call to `mkdir` or `mkdirs`
    sink.asExpr() = ma.getQualifier() and // The method access is on the same object as the sink
    g = ma and // The guard is the method access
    DataFlow::localExprFlow(sink.asExpr(), unsafeUse) and // There is some flow from the sink to an unsafe use of the File
    unsafeUse != sink.asExpr() and // The unsafe use is not the sink itself
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not g.controls(unsafeUse.getBasicBlock(), true) and
    not booleanVarAccessGuardsGuard(g) // The guard is not guarded by a boolean variable access guard
  )
}

/**
 * Holds for any guard `g` that that is itself guarded by a a boolean variable access guard.
 *
 * For example, the following code: `if (isDirectory && !file.mkdir()) { ... }`.
 */
private predicate booleanVarAccessGuardsGuard(Guard g) {
  exists(Guard g2 | g2 = any(VarAccess va | va.getType() instanceof BooleanType) |
    g2.controls(g.getBasicBlock(), true)
  )
}

private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
  or
  // File is being concatenated to a string, probably for a log or exception message
  exists(AddExpr addExp |
    addExp.getType() instanceof TypeString and
    (
      addExp.getRightOperand() = e
      or
      // A method call, like `File.getAbsolutePath()` is being called and concatenated into a string
      exists(MethodAccess fileMethodAccess |
        fileMethodAccess.getQualifier() = e and
        addExp.getRightOperand() = fileMethodAccess and
        fileMethodAccess.getMethod().getReturnType() instanceof TypeString
      )
    )
  )
  or
  // A call to `File::deleteOnExit`
  exists(MethodAccess ma |
    ma.getMethod().hasName("deleteOnExit") and
    ma.getMethod().getDeclaringType() instanceof TypeFile and
    ma.getQualifier() = e
  )
}

from
  DataFlow::PathNode source, DataFlow::PathNode deleteCheckpoint, DataFlow2::Node deleteCheckpoint2,
  DataFlow2::Node sink, MethodAccess creationCall, Expr unsafe
where
  any(TempDirHijackingToDeleteConfig c).hasFlowPath(source, deleteCheckpoint) and
  any(TempDirHijackingFromDeleteConfig c).hasFlow(deleteCheckpoint2, sink) and
  deleteCheckpoint.getNode().asExpr() = deleteCheckpoint2.asExpr() and
  isUnsafeUseUnconstrainedByIfCheck(sink, unsafe) and
  isNonThrowingDirectoryCreationExpression(sink.asExpr(), creationCall)
select deleteCheckpoint.getNode(), source, deleteCheckpoint,
  "Local temporary directory hijacking race condition $@, file $@ may have been hijacked",
  creationCall, "here", unsafe, "here"
