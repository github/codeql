/**
 * @name Temporary Directory Hijacking Vulnerability disclosure
 * @description Detect temporary directory hijack vulnerability
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.security.TempFileLib
import semmle.code.java.dataflow.DataFlow3
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.TaintTracking2
import DataFlow::PathGraph

/**
 * An expression that will create a directory without throwing an exception if a file/directory already exists.
 */
private predicate isNonThrowingDirectoryCreationExpression(Expr expr, MethodAccess creationCall) {
  creationCall.getMethod() instanceof MethodFileCreatesDirs and creationCall.getQualifier() = expr
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    getDeclaringType() instanceof TypeFile and
    hasName("delete")
  }
}

predicate isDeleteFileExpr(Expr expr) {
  expr = any(MethodFileDelete m).getAReference().getQualifier()
}

private class DirHijackingTaintSource extends DataFlow::Node {
  DirHijackingTaintSource() {
    this.asExpr() =
      any(MethodAccess ma |
        ma.getMethod() instanceof MethodFileCreateTempFile and ma.getNumArgument() = 2
      )
    or
    // TODO: Replace with getSystemProperty("java.io.tmpdir")
    this.asExpr() =
      any(MethodAccessSystemGetProperty maSgp |
        maSgp.hasCompileTimeConstantGetPropertyName("java.io.tmpdir")
      )
  }
}

private predicate isAdditionalTaintStepCommon(DataFlow::Node node1, DataFlow::Node node2) {
  node2.asExpr() =
    any(MethodAccess ma |
      ma.getMethod() instanceof MethodFileCreateTempFile and ma.getArgument(2) = node1.asExpr()
    )
}

private class TempDirHijackingToDeleteConfig extends TaintTracking2::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { source instanceof DirHijackingTaintSource }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    isAdditionalTaintStepCommon(node1, node2)
  }

  override predicate isSink(DataFlow::Node sink) { isDeleteFileExpr(sink.asExpr()) }
}

private class TempDirHijackingFromDeleteConfig extends DataFlow3::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeleteFileExpr(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }
}

/**
 * Holds when there is an expression `unsafeUse` which is an unsafe use of the file that
 * is not guarded by a check of the return value of `File::mkdir(s)`.
 */
predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node sink, Expr unsafeUse) {
  exists(Guard g, MethodAccess ma |
    any(TempDirHijackingFromDeleteConfig c).isSink(sink) and // Sink is a call to `mkdir` or `mkdirs`
    sink.asExpr() = ma.getQualifier() and // The method access is on the same object as the sink
    g = ma and // The guard is the method access
    DataFlow::localExprFlow(sink.asExpr(), unsafeUse) and // There is some flow from the sink to an unsafe use of the File
    unsafeUse != sink.asExpr() and // The unsafe use is not the sink itself
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not g.controls(unsafeUse.getBasicBlock(), true) and
    not booleanVarAccessGuardsGuard(g) // The guard is not guarded by a boolean variable access guard
  )
}

/**
 * Holds for any guard `g` that is itself guarded by a boolean variable access guard.
 *
 * For example, the following code: `if (isDirectory && !file.mkdir()) { ... }`.
 */
private predicate booleanVarAccessGuardsGuard(Guard g) {
  exists(Guard g2 | g2 = any(VarAccess va | va.getType() instanceof BooleanType) |
    g2.controls(g.getBasicBlock(), true)
  )
}

private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
  or
  // File is being concatenated to a string, probably for a log or exception message
  exists(AddExpr addExp |
    addExp.getType() instanceof TypeString and
    (
      addExp.getRightOperand() = e
      or
      // A method call, like `File.getAbsolutePath()` is being called and concatenated into a string
      exists(MethodAccess fileMethodAccess |
        fileMethodAccess.getQualifier() = e and
        addExp.getRightOperand() = fileMethodAccess and
        fileMethodAccess.getMethod().getReturnType() instanceof TypeString
      )
    )
  )
  or
  // A call to `File::deleteOnExit`
  exists(MethodAccess ma |
    ma.getMethod().hasName("deleteOnExit") and
    ma.getMethod().getDeclaringType() instanceof TypeFile and
    ma.getQualifier() = e
  )
}

private class TempDirHijackingFullPath extends TaintTracking::Configuration {
  TempDirHijackingFullPath() { this = "TempDirHijackingFullPath" }

  override predicate isSource(DataFlow::Node source) { source instanceof DirHijackingTaintSource }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    isAdditionalTaintStepCommon(node1, node2)
    or
    node1.asExpr() = node2.asExpr() and isDeleteFileExpr(node1.asExpr())
  }
}

from
  DataFlow::PathNode pathSource, DataFlow::PathNode pathSink, DataFlow::Node deleteCheckpoint,
  MethodAccess creationCall, Expr unsafe
where
  any(TempDirHijackingFullPath c).hasFlowPath(pathSource, pathSink) and
  any(TempDirHijackingToDeleteConfig c).hasFlow(pathSource.getNode(), deleteCheckpoint) and
  any(TempDirHijackingFromDeleteConfig c).hasFlow(deleteCheckpoint, pathSink.getNode()) and
  isUnsafeUseUnconstrainedByIfCheck(pathSink.getNode(), unsafe) and
  isNonThrowingDirectoryCreationExpression(pathSink.getNode().asExpr(), creationCall)
select pathSink, pathSource, pathSink,
  "Local temporary directory hijacking race condition between $@ and this directory creation call. As such, the directory usage $@ may have been hijacked by another local user.",
  deleteCheckpoint.asExpr(), "delete here", unsafe, "here"
