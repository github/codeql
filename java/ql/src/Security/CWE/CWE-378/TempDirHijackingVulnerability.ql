/**
 * @name Temporary Directory Hijacking Vulnerability
 * @description Detect temporary directory hijacking vulnerability due too file creation race condition.
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 * @security-severity 7.8
 * @tags security
 *       external/cwe/cwe-378
 *       external/cwe/cwe-379
 *       external/cwe/cwe-552
 *       external/cwe/cwe-732
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.DataFlow3
import semmle.code.java.dataflow.DataFlow4
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.TaintTracking2
import semmle.code.java.environment.SystemProperty
import semmle.code.java.security.TempFileLib
import DataFlow::PathGraph

/**
 * The flow state after the call to `System.getProperty`.
 */
private class FromSystemPropertyFlowState extends DataFlow::FlowState {
  FromSystemPropertyFlowState() { this = "FromSystemPropertyFlowState" }
}

/**
 * The flow state after the `File.createTempFile` method has been called on the tracked taint.
 *
 * This state may be achieved two ways:
 *  1. If the source of the taint is a `File.createTempFile(_, _)` call.
 *  2. From state `FromSystemPropertyFlowState` if `File.createTempFile(_, _, taint)` is called.
 */
private class FromFileCreateTempFileFlowState extends DataFlow::FlowState {
  FromFileCreateTempFileFlowState() { this = "FromFileCreateTempFileFlowState" }
}

/**
 * The flow state after the `File::delete` method has been called on tracked taint.
 * This is the final state of the flow before hijackable call `File::mkdir(s)` (ie. the sink) is reached.
 */
private class FromDeleteFileFlowState extends DataFlow::FlowState {
  FromDeleteFileFlowState() { this = "FromDeleteFileFlowState" }
}

/**
 * The flow state after the `File::mkdir(s)` method has been called on tracked taint.
 * This is the final state, and is only used when computing the 'unsafe' call site.
 */
private class FromMkdirsFileFlowState extends DataFlow::FlowState {
  FromMkdirsFileFlowState() { this = "FromMkdirsFileFlowState" }
}

/**
 * Holds if `s` is executed if a `File.exists` or `File.isDirectory` check fails.
 */
private predicate throwsIfDirectoryDoesNotExist(ThrowStmt s) {
  exists(Guard g |
    g =
      any(MethodAccess existenceCheck |
        (
          existenceCheck.getMethod() instanceof MethodFileExists
          or
          existenceCheck.getMethod() instanceof MethodFileIsDirectory
        )
      ) and
    g.directlyControls(s.getEnclosingStmt(), false)
  )
}

/**
 * Holds if `test` checks if a `File.mkdir` or `mkdirs` operation failed, in which case throw statement `s` is executed.
 */
private predicate throwsIfMkdirFailed(Guard test, ThrowStmt s) {
  test =
    any(MethodAccess creationCheck | creationCheck.getMethod() instanceof MethodFileCreatesDirs) and
  test.directlyControls(s.getEnclosingStmt(), false)
}

/**
 * Holds if `test` checks if a `File.mkdir` or `mkdirs` operation failed, in which case an exception is thrown,
 * and that same throw isn't also reachable from a failing `exists` or `isDirectory` check.
 *
 * For example, gets the test expression in  `if(!f.mkdir()) { throw ... }` but not `if(!f.mkdir() && !f.exists()) { throw ... }`,
 * since the latter accepts the case where `f` already exists.
 */
private predicate throwsIfMkdirFailedExcludingExistenceChecks(Guard test) {
  exists(ThrowStmt s |
    throwsIfMkdirFailed(test, s) and
    // The same throw statement must not result from a failing `f.exists()` or similar call.
    not throwsIfDirectoryDoesNotExist(s)
  )
}

/**
 * Holds if `creationCall` is of the form `fileInstanceExpr.mkdir()`,
 * and it is not clear that failure to create a fresh directory will result in throwing an exception.
 *
 * Note `fileInstanceExpr` may be passed to the actual `mkdir` via a wrapper function: in this case
 * `fileInstanceExpr` is the argument to the outer wrapper function, but `creationCall` is still the
 * inner `mkdir` call.
 *
 * TODO: that may warrant changing.
 */
private predicate isNonThrowingDirectoryCreationExpression(
  Expr fileInstanceExpr, MethodAccess creationCall
) {
  creationCall.getMethod() instanceof MethodFileCreatesDirs and
  creationCall.getQualifier() = fileInstanceExpr and
  (
    // The result of `mkdir` is not directly tested at all...
    not creationCall.(Guard).directlyControls(_, _)
    or
    // ... or it is tested, but that test doesn't clearly have the form `if(!f.mkdir()) throw ...`.
    not throwsIfMkdirFailedExcludingExistenceChecks(creationCall)
  )
  or
  // Recursively look for methods that encapsulate the above.
  // Thus, the use of 'helper directory creation methods' are still considered
  // when assessing if an `unsafeUse` is present or not.
  exists(Method m, int argumentIndex, Expr fileInstanceParam |
    DataFlow::localExprFlow(m.getParameter(pragma[only_bind_into](argumentIndex)).getAnAccess(),
      fileInstanceParam) and
    isNonThrowingDirectoryCreationExpression(fileInstanceParam, creationCall)
  |
    m.getAReference().getArgument(pragma[only_bind_into](argumentIndex)) = fileInstanceExpr
  )
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("delete")
  }
}

private class MethodFileIsDirectory extends Method {
  MethodFileIsDirectory() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("isDirectory")
  }
}

private class MethodFileExists extends Method {
  MethodFileExists() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("exists")
  }
}

/**
 * Holds if `file` is deleted, by a call to `file.delete()` or a method that wraps the same.
 */
predicate isDeletedFile(Expr file) {
  exists(Expr deleteMethodQualifier |
    deleteMethodQualifier = any(MethodFileDelete m).getAReference().getQualifier()
  |
    // The expression is the qualifier of the `delete` method call.
    file = deleteMethodQualifier
    or
    // Any wrapper method that calls the `delete` method on a file instance argument.
    file =
      any(Method m, int argIndex |
        // We intentionally don't call this method recursively as it will increase the false positive rate.
        // A delete call at a depth of one call is enough to cover most cases.
        DataFlow::localExprFlow(m.getParameter(argIndex).getAnAccess(), deleteMethodQualifier)
      |
        m.getAReference().getArgument(argIndex)
      )
  )
}

abstract private class SystemTempDirNode extends DataFlow::Node {
  abstract DataFlow::FlowState getFlowState();
}

private class TempFileInSystemTempDirNode extends SystemTempDirNode {
  TempFileInSystemTempDirNode() {
    this.asExpr() =
      any(MethodAccess ma |
        // The two argument variant of this method uses the system property `java.io.tmpdir` as the base directory.
        ma.getMethod() instanceof MethodFileCreateTempFile and
        (
          // The two argument variant of this method uses the system property `java.io.tmpdir` as the base directory.
          ma.getNumArgument() = 2
          or
          // The three argument variant of this method uses the system property `java.io.tmpdir` as the base directory when `null`.
          DataFlow::localExprOrInitializerFlow(any(NullLiteral n), ma.getArgument(2))
        )
      )
  }

  override DataFlow::FlowState getFlowState() { result instanceof FromFileCreateTempFileFlowState }
}

private class SystemTempDirPropertyNode extends SystemTempDirNode {
  SystemTempDirPropertyNode() { this.asExpr() = getSystemProperty("java.io.tmpdir") }

  override DataFlow::FlowState getFlowState() { result instanceof FromSystemPropertyFlowState }
}

/**
 * Holds when `createdTempFile` = `File.createTempFile(_, _, createInDir)`.
 */
private predicate isTaintStepFileCreateTempFile(
  DataFlow::Node createInDir, DataFlow::Node createdTempFile
) {
  createdTempFile.asExpr() =
    any(MethodAccess ma |
      ma.getMethod() instanceof MethodFileCreateTempFile and
      ma.getArgument(2) = createInDir.asExpr()
    )
}

/**
 * Tracks taint from references to the system global temporary directory (`java.io.tmpdir`),
 * either directly through `System.getProperty()` or indirectly using `File.createTempFile`, to
 * a `file.delete()` call.
 */
private class TempDirHijackingToDeleteConfig extends TaintTracking2::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { source instanceof SystemTempDirNode }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    // Propagates taint from the directory a temporary file is created in, to the created file.
    isTaintStepFileCreateTempFile(node1, node2)
  }

  override predicate isSink(DataFlow::Node sink) { isDeletedFile(sink.asExpr()) }
}

/**
 * Tracks taint from deleted files to an attempt to create the same file, where that creation attempt
 * does not appear to throw an exception on failure.
 *
 * For example, we would flag the path from one use of `f` to the next in `f.delete(); f.mkdir();`,
 * but not in `f.delete(); if(!f.mkdir()) throw ...` because the latter case checks that the `mkdir`
 * worked as expected and throws otherwise.
 */
private class TempDirHijackingFromDeleteConfig extends DataFlow3::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeletedFile(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }
}

/**
 * Tracks taint from a file that is created without throwing on failure to an unsafe use of that file.
 */
private class TempDirHijackingFromDirectoryCreateToUnsafeUseConfig extends DataFlow4::Configuration {
  TempDirHijackingFromDirectoryCreateToUnsafeUseConfig() {
    this = "TempDirHijackingFromDirectoryCreateToUnsafeUseConfig"
  }

  override predicate isSource(DataFlow::Node source) {
    isNonThrowingDirectoryCreationExpression(source.asExpr(), _)
  }

  override predicate isSink(DataFlow::Node sink) { not safeUse(sink.asExpr()) }
}

/**
 * Holds when there is an expression `unsafeUse` which is an unsafe use of the file `createdFileNode` that
 * is not guarded by a check of the return value of `File::mkdir(s)`.
 *
 * TODO: this is confusing, due to the fact that `isNonThrowingDirectoryCreationExpression` may identify a `mkdir`
 * method call inside a wrapper, in whcih case `fileInstanceExpr` is the argument to the wrapper but `createdFileNode`
 * is the direct qualifier to `mkdir`. Hence the global flow from the direct `mkdir` qualifier and the local flow from
 * a wrapper function's argument are not redundant as they may seem, but this was probably an accident.
 */
predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node createdFileNode, Expr unsafeUse) {
  exists(Expr fileInstanceExpr, MethodAccess creationCall |
    // Note `fileInstanceExpr` may be an argument to method wrapping `mkdir`, and therefore not the same as `createdFileNode.asExpr()`
    isNonThrowingDirectoryCreationExpression(fileInstanceExpr, creationCall) and
    createdFileNode.asExpr() = creationCall.getQualifier() and // `createdFileNode` is the direct qualifier to `creationCall`
    (
      // TODO: Consider replacing this entire bit of logic with `TempDirHijackingFullPathIncludingUnsafeUse`.
      any(TempDirHijackingFromDirectoryCreateToUnsafeUseConfig c)
          .hasFlow(createdFileNode, DataFlow::exprNode(unsafeUse)) // There is some flow from the created file to an unsafe use of the File
      or
      DataFlow::localExprFlow(fileInstanceExpr, unsafeUse) // There is some local flow from the passed file instance to an unsafe use
    ) and
    unsafeUse != createdFileNode.asExpr() and // The unsafe use is not the sink itself
    not fileInstanceExpr = unsafeUse and // The unsafe use is not the file instance
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not creationCall.(Guard).controls(unsafeUse.getBasicBlock(), true) and
    not booleanVarAccessGuardsGuard(creationCall) // The guard is not guarded by a boolean variable access guard
  )
}

/**
 * Holds for any guard `g` that is itself guarded by a boolean variable access guard.
 *
 * For example, the following code: `if (isDirectory && !file.mkdir()) { ... }`.
 *
 * TODO: This is an unreasoned heuristic -- there's no reason to prefer the other check passing vs. failing,
 * and generally speaking indiscriminately eliminating anything guarded by any other boolean regardless of context
 * would be confusing to a user wondering why `if (itsMonday && !file.mkdir()) { ... }` is being treated differently
 * to `if (!file.mkdir()) { ... }`
 */
private predicate booleanVarAccessGuardsGuard(Guard g) {
  exists(Guard g2 | g2 = any(VarAccess va | va.getType() instanceof BooleanType) |
    g2.controls(g.getBasicBlock(), true)
  )
}

/**
 * Gets the result of a call `file.method()`, where `file` is a `java.io.File` and `method` returns `String`.
 *
 * These are all path elements of `file`.
 */
private MethodAccess getAStringAccessOnFile(Expr file) {
  result =
    any(MethodAccess fileMethodAccess |
      fileMethodAccess.getMethod().getDeclaringType() instanceof TypeFile and
      fileMethodAccess.getQualifier() = file and
      fileMethodAccess.getMethod().getReturnType() instanceof TypeString
    )
}

/**
 * Gets an argument to a constructor of a throwable type (e.g. the `e` in `new Exception(e)`).
 */
private Argument getThrowableConstructorArgument() {
  exists(ConstructorCall c |
    c.getConstructor().getDeclaringType().getAnAncestor() instanceof TypeThrowable and
    c.getAnArgument() = result
  )
}

/**
 * Holds if `e` is considered a safe way to use a potentially hijacked `File` instance:
 *
 * This can be any of the contexts _:
 *
 * _ && _
 * x &= _
 * str + _
 * str + _.getPath() and similar
 * _.getPath() + " message" // FIXME -- the file itself could be used here, not necessarily `getPath` or similar
 * new Exception(_) and similar
 * _.deleteOnExit()
 * var = _ where all uses of var are safe
 * ^^ TODO is this redundant with the local-flow case?
 * Any expression where it has at least one local flow sink, and all of those sinks match one of the above cases (redundant with the var case)
 * ^^ TODO why is the local-flow case limited to `getPath()` and similar? Why not the file itself?
 */
private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
  or
  // File is being concatenated to a string, probably for a log or exception message
  exists(AddExpr addExp |
    addExp.getType() instanceof TypeString and
    (
      // TODO this is an unreasoned heuristic -- there is no reason why `file + " couldn't be created"` should be treated differently to `"Can't create " + file`.
      addExp.getRightOperand() = e
      or
      // A method call, like `File.getAbsolutePath()` is being called and concatenated to the end of a a string
      addExp.getRightOperand() = getAStringAccessOnFile(e)
      or
      // A method call, like `File.getAbsolutePath()` is being called and prepended to another string with a leading space character.
      addExp.getLeftOperand() = getAStringAccessOnFile(e) and
      addExp.getRightOperand().(CompileTimeConstantExpr).getStringValue().matches(" %")
    )
  )
  or
  // File is being used to construct an exception message
  e = getThrowableConstructorArgument()
  or
  // A call to `File::deleteOnExit`
  exists(MethodAccess ma |
    ma.getMethod().hasName("deleteOnExit") and
    ma.getMethod().getDeclaringType() instanceof TypeFile and
    ma.getQualifier() = e
  )
  or
  // An assignment to a variable that is exclusively used when safe
  e = any(VariableAssign assign | safeUse(assign.getDestVar().getAnAccess())).getSource() and
  not e = any(VariableAssign assign | not safeUse(assign.getDestVar().getAnAccess())).getSource()
  or
  // Data flow exists exclusively to locations that are known to be safe
  DataFlow::localExprFlow(getAStringAccessOnFile(e), any(Expr sink | safeUse(sink))) and
  not DataFlow::localExprFlow(getAStringAccessOnFile(e), any(Expr sink | not safeUse(sink)))
}

private predicate isSystemTempDirSource(DataFlow::Node source, DataFlow::FlowState state) {
  exists(SystemTempDirNode taintSource |
    source = taintSource and state = taintSource.getFlowState()
  )
}

private predicate isAdditionalTaintStepCommon(
  DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2, DataFlow::FlowState state2
) {
  // From a temporary directory system property access to `File.createTempFile(_, _, flow)` call
  isTaintStepFileCreateTempFile(node1, node2) and
  state1 instanceof FromSystemPropertyFlowState and
  state2 instanceof FromFileCreateTempFileFlowState
  or
  // From `File.createTempFile(_, _, flow)` to a call to `File::delete`
  node1 = node2 and
  isDeletedFile(node1.asExpr()) and
  state1 instanceof FromFileCreateTempFileFlowState and
  state2 instanceof FromDeleteFileFlowState
}

private class TempDirHijackingFullPath extends TaintTracking::Configuration {
  TempDirHijackingFullPath() { this = "TempDirHijackingFullPath" }

  override predicate isSource(DataFlow::Node source, DataFlow::FlowState state) {
    isSystemTempDirSource(source, state)
  }

  override predicate isAdditionalTaintStep(
    DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2,
    DataFlow::FlowState state2
  ) {
    isAdditionalTaintStepCommon(node1, state1, node2, state2)
  }

  override predicate isSink(DataFlow::Node sink, DataFlow::FlowState state) {
    // From a `File::delete` call, to a call to `File::mkdir(s)`
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _) and
    state instanceof FromDeleteFileFlowState
  }
}

/**
 * A configuration that tracks the full path of the temporary directory taint all the way to an
 * `unsafeUse` of the potentially hijacked temporary directory.
 *
 * This is intentionally not used in the the generation of the displayed path;
 * this is because there may not exist an explicit path from the call to `File::mkdir(s)` call to the the `unsafeUse`.
 */
class TempDirHijackingFullPathIncludingUnsafeUse extends TaintTracking2::Configuration {
  TempDirHijackingFullPathIncludingUnsafeUse() {
    this = "TempDirHijackingFullPathIncludingUnsafeUse"
  }

  override predicate isSource(DataFlow::Node source, DataFlow::FlowState state) {
    isSystemTempDirSource(source, state)
  }

  override predicate isAdditionalTaintStep(
    DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2,
    DataFlow::FlowState state2
  ) {
    isAdditionalTaintStepCommon(node1, state1, node2, state2)
    or
    // `File::mkdir(s)` is not an end-state when looking for an unsafe use
    isNonThrowingDirectoryCreationExpression(node1.asExpr(), _) and
    node1 = node2 and
    state1 instanceof FromDeleteFileFlowState and
    state2 instanceof FromMkdirsFileFlowState
  }

  override predicate isSink(DataFlow::Node sink, DataFlow::FlowState state) {
    // From a `File::delete` call, to a call to `File::mkdir(s)`
    isUnsafeUseUnconstrainedByIfCheck(_, sink.asExpr()) and
    state instanceof FromMkdirsFileFlowState
  }
}

from
  DataFlow::PathNode pathSource, DataFlow::PathNode pathSink, DataFlow::Node deleteCheckpoint,
  MethodAccess creationCall, Expr unsafe
where
  // Generate the full path to display to the user
  any(TempDirHijackingFullPath c).hasFlowPath(pathSource, pathSink) and
  // Find the delete checkpoint to display to the user
  any(TempDirHijackingToDeleteConfig c).hasFlow(pathSource.getNode(), deleteCheckpoint) and
  // Find the delete checkpoint to display to the user
  any(TempDirHijackingFromDeleteConfig c).hasFlow(deleteCheckpoint, pathSink.getNode()) and
  // Find a full path where an `unsafe` use is present
  any(TempDirHijackingFullPathIncludingUnsafeUse c)
      .hasFlow(pathSource.getNode(), DataFlow::exprNode(unsafe)) and
  // Verify the unsafe use is not constrained by an if check
  isUnsafeUseUnconstrainedByIfCheck(pathSink.getNode(), unsafe) and
  // Verfy the creation call expression is the expected sink
  isNonThrowingDirectoryCreationExpression(pathSink.getNode().asExpr(), creationCall)
select pathSink, pathSource, pathSink,
  "Local temporary directory hijacking race condition between $@ and this directory creation call. As such, the directory usage $@ may have been hijacked by another local user.",
  deleteCheckpoint.asExpr(), "delete here", unsafe, "here"
