/**
 * @name Temporary Directory Hijacking Vulnerability disclosure
 * @description Detect temporary directory hijack vulnerability
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import DataFlow::PathGraph

/**
 * All `java.io.File::createTempFile` methods.
 */
private class MethodFileCreateTempFile extends Method {
  MethodFileCreateTempFile() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("createTempFile")
  }
}

private class MethodFileMkdir extends Method {
  MethodFileMkdir() {
    getDeclaringType() instanceof TypeFile and
    hasName("mkdir")
    or
    hasName("mkdirs")
  }
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    getDeclaringType() instanceof TypeFile and
    hasName("delete")
  }
}

predicate isDeleteFileExpr(Expr expr) {
  exists(MethodAccess ma |
    expr = ma.getQualifier() and
    ma.getMethod() instanceof MethodFileDelete
  )
}

private class TempDirHijackingToDeleteConfig extends DataFlow::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) {
    exists(MethodAccess ma |
      ma.getMethod() instanceof MethodFileCreateTempFile and
      source.asExpr() = ma
    )
  }

  override predicate isSink(DataFlow::Node sink) { isDeleteFileExpr(sink.asExpr()) }
}

private class TempDirHijackingFromDeleteConfig extends DataFlow2::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeleteFileExpr(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess ma |
      ma.getMethod() instanceof MethodFileMkdir and
      ma.getQualifier() = sink.asExpr()
    )
  }
}

predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node sink, Expr unsafeUse) {
  exists(Guard g, MethodAccess ma |
    any(TempDirHijackingFromDeleteConfig c).isSink(sink) and // Sink is a call to delete
    sink.asExpr() = ma.getQualifier() and // The method access is on the same object as the sink
    g = ma and // The guard is the method access
    DataFlow::localExprFlow(sink.asExpr(), unsafeUse) and // There is some flow from the sink to an unsafe use of the File
    unsafeUse != sink.asExpr() and // The unsafe use is not the sink itself
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not g.controls(unsafeUse.getBasicBlock(), true)
  )
}

private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
}

from
  DataFlow::PathNode source, DataFlow::PathNode deleteCheckpoint, DataFlow2::Node deleteCheckpoint2,
  DataFlow2::Node sink, TempDirHijackingToDeleteConfig toDeleteConfig, Expr unsafeUse,
  TempDirHijackingFromDeleteConfig fromDeleteConfig
where
  toDeleteConfig.hasFlowPath(source, deleteCheckpoint) and
  fromDeleteConfig.hasFlow(deleteCheckpoint2, sink) and
  deleteCheckpoint.getNode().asExpr() = deleteCheckpoint2.asExpr() and
  isUnsafeUseUnconstrainedByIfCheck(sink, unsafeUse)
select deleteCheckpoint.getNode(), source, deleteCheckpoint,
  "Local temporary directory hijacking race condition $@", sink, "here"
