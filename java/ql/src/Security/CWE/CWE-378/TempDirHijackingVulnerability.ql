/**
 * @name Temporary Directory Hijacking Vulnerability disclosure
 * @description Detect temporary directory hijack vulnerability
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.DataFlow3
import semmle.code.java.dataflow.DataFlow4
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.TaintTracking2
import semmle.code.java.environment.SystemProperty
import semmle.code.java.security.TempFileLib
import DataFlow::PathGraph

/**
 * An expression that will create a directory without throwing an exception if a file/directory already exists.
 */
private predicate isNonThrowingDirectoryCreationExpression(Expr expr, MethodAccess creationCall) {
  creationCall.getMethod() instanceof MethodFileCreatesDirs and creationCall.getQualifier() = expr
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    getDeclaringType() instanceof TypeFile and
    hasName("delete")
  }
}

predicate isDeleteFileExpr(Expr expr) {
  expr = any(MethodFileDelete m).getAReference().getQualifier()
}

abstract private class DirHijackingTaintSource extends DataFlow::Node {
  abstract DataFlow::FlowState getFlowState();
}

private class FromSystemPropertyFlowState extends DataFlow::FlowState {
  FromSystemPropertyFlowState() { this = "FromSystemPropertyFlowState" }
}

private class FileCreateTempFileDirHijackingTaintSource extends DirHijackingTaintSource {
  FileCreateTempFileDirHijackingTaintSource() {
    this.asExpr() =
      any(MethodAccess ma |
        ma.getMethod() instanceof MethodFileCreateTempFile and ma.getNumArgument() = 2
      )
  }

  override DataFlow::FlowState getFlowState() { result instanceof DataFlow::FlowStateEmpty }
}

private class SystemPropertyDirHijackingTaintSource extends DirHijackingTaintSource {
  SystemPropertyDirHijackingTaintSource() { this.asExpr() = getSystemProperty("java.io.tmpdir") }

  override DataFlow::FlowState getFlowState() { result instanceof FromSystemPropertyFlowState }
}

private predicate isAdditionalTaintStepCommon(DataFlow::Node node1, DataFlow::Node node2) {
  node2.asExpr() =
    any(MethodAccess ma |
      ma.getMethod() instanceof MethodFileCreateTempFile and ma.getArgument(2) = node1.asExpr()
    )
}

private class TempDirHijackingToDeleteConfig extends TaintTracking2::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { source instanceof DirHijackingTaintSource }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    isAdditionalTaintStepCommon(node1, node2)
  }

  override predicate isSink(DataFlow::Node sink) { isDeleteFileExpr(sink.asExpr()) }
}

private class TempDirHijackingFromDeleteConfig extends DataFlow3::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeleteFileExpr(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }
}

private class TempDirHijackingFromDirectoryCreateToUnsafeUseConfig extends DataFlow4::Configuration {
  TempDirHijackingFromDirectoryCreateToUnsafeUseConfig() {
    this = "TempDirHijackingFromDirectoryCreateToUnsafeUseConfig"
  }

  override predicate isSource(DataFlow::Node source) {
    isNonThrowingDirectoryCreationExpression(source.asExpr(), _)
  }

  override predicate isSink(DataFlow::Node sink) { not safeUse(sink.asExpr()) }

  override predicate isBarrierGuard(DataFlow::BarrierGuard guard) {
    guard instanceof DirectoryCreationBarrierGuard
  }
}

private class DirectoryCreationBarrierGuard extends DataFlow::BarrierGuard {
  DirectoryCreationBarrierGuard() { isNonThrowingDirectoryCreationExpression(_, this) }

  override predicate checks(Expr e, boolean branch) { this.controls(e, branch) }
}

/**
 * Holds when there is an expression `unsafeUse` which is an unsafe use of the file that
 * is not guarded by a check of the return value of `File::mkdir(s)`.
 */
predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node sink, Expr unsafeUse) {
  exists(Guard g, MethodAccess ma |
    any(TempDirHijackingFromDeleteConfig c).isSink(sink) and // Sink is a call to `mkdir` or `mkdirs`
    sink.asExpr() = ma.getQualifier() and // The method access is on the same object as the sink
    g = ma and // The guard is the method access
    any(TempDirHijackingFromDirectoryCreateToUnsafeUseConfig c)
        .hasFlow(sink, DataFlow::exprNode(unsafeUse)) and // There is some flow from the sink to an unsafe use of the File
    unsafeUse != sink.asExpr() and // The unsafe use is not the sink itself
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not g.controls(unsafeUse.getBasicBlock(), true) and
    not booleanVarAccessGuardsGuard(g) // The guard is not guarded by a boolean variable access guard
  )
}

/**
 * Holds for any guard `g` that is itself guarded by a boolean variable access guard.
 *
 * For example, the following code: `if (isDirectory && !file.mkdir()) { ... }`.
 */
private predicate booleanVarAccessGuardsGuard(Guard g) {
  exists(Guard g2 | g2 = any(VarAccess va | va.getType() instanceof BooleanType) |
    g2.controls(g.getBasicBlock(), true)
  )
}

/**
 * Gets any `MethodAccess` that access string returning methods on the expression `e` of type `File`.
 */
private MethodAccess getStringAccessOnFile(Expr e) {
  result =
    any(MethodAccess fileMethodAccess |
      fileMethodAccess.getMethod().getDeclaringType() instanceof TypeFile and
      fileMethodAccess.getQualifier() = e and
      fileMethodAccess.getMethod().getReturnType() instanceof TypeString
    )
}

private Argument getThrowableConstructorParam() {
  result =
    any(Argument a |
      exists(ConstructorCall c |
        c.getConstructor().getDeclaringType().getAnAncestor() instanceof TypeThrowable and
        c.getAnArgument() = a
      )
    )
}

private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
  or
  // File is being concatenated to a string, probably for a log or exception message
  exists(AddExpr addExp |
    addExp.getType() instanceof TypeString and
    (
      addExp.getRightOperand() = e
      or
      // A method call, like `File.getAbsolutePath()` is being called and concatenated to the end of a a string
      addExp.getRightOperand() = getStringAccessOnFile(e)
      or
      // A method call, like `File.getAbsolutePath()` is being called and prepended to another string with a leading space character.
      addExp.getLeftOperand() = getStringAccessOnFile(e) and
      addExp.getRightOperand().(CompileTimeConstantExpr).getStringValue().matches(" %")
    )
  )
  or
  // File is being used to construct an exception message
  e = getThrowableConstructorParam()
  or
  // A call to `File::deleteOnExit`
  exists(MethodAccess ma |
    ma.getMethod().hasName("deleteOnExit") and
    ma.getMethod().getDeclaringType() instanceof TypeFile and
    ma.getQualifier() = e
  )
  or
  // An assignment to a variable that is exclusively used when safe
  e = any(VariableAssign assign | safeUse(assign.getDestVar().getAnAccess())).getSource() and
  not e = any(VariableAssign assign | not safeUse(assign.getDestVar().getAnAccess())).getSource()
  or
  // Data flow exists exclusively to locations that are known to be safe
  DataFlow::localExprFlow(getStringAccessOnFile(e), any(Expr sink | safeUse(sink))) and
  not DataFlow::localExprFlow(getStringAccessOnFile(e), any(Expr sink | not safeUse(sink)))
}

private class TempDirHijackingFullPath extends TaintTracking::Configuration {
  TempDirHijackingFullPath() { this = "TempDirHijackingFullPath" }

  override predicate isSource(DataFlow::Node source, DataFlow::FlowState state) {
    exists(DirHijackingTaintSource taintSource |
      source = taintSource and state = taintSource.getFlowState()
    )
  }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }

  override predicate isAdditionalTaintStep(
    DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2,
    DataFlow::FlowState state2
  ) {
    isAdditionalTaintStepCommon(node1, node2) and
    state1 instanceof FromSystemPropertyFlowState and
    state2 instanceof DataFlow::FlowStateEmpty
  }
}

from
  DataFlow::PathNode pathSource, DataFlow::PathNode pathSink, DataFlow::Node deleteCheckpoint,
  MethodAccess creationCall, Expr unsafe
where
  any(TempDirHijackingFullPath c).hasFlowPath(pathSource, pathSink) and
  any(TempDirHijackingToDeleteConfig c).hasFlow(pathSource.getNode(), deleteCheckpoint) and
  any(TempDirHijackingFromDeleteConfig c).hasFlow(deleteCheckpoint, pathSink.getNode()) and
  isUnsafeUseUnconstrainedByIfCheck(pathSink.getNode(), unsafe) and
  isNonThrowingDirectoryCreationExpression(pathSink.getNode().asExpr(), creationCall)
select pathSink, pathSource, pathSink,
  "Local temporary directory hijacking race condition between $@ and this directory creation call. As such, the directory usage $@ may have been hijacked by another local user.",
  deleteCheckpoint.asExpr(), "delete here", unsafe, "here"
