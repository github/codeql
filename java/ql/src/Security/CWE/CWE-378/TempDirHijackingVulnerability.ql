/**
 * @name Temporary Directory Hijacking Vulnerability disclosure
 * @description Detect temporary directory hijack vulnerability
 * @kind path-problem
 * @problem.severity error
 * @precision very-high
 * @id java/temp-directory-hijacking
 */

import java
import semmle.code.java.controlflow.Guards
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.DataFlow3
import semmle.code.java.dataflow.DataFlow4
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.TaintTracking2
import semmle.code.java.environment.SystemProperty
import semmle.code.java.security.TempFileLib
import DataFlow::PathGraph

/**
 * The flow state after the call to `System.getProperty`.
 */
private class FromSystemPropertyFlowState extends DataFlow::FlowState {
  FromSystemPropertyFlowState() { this = "FromSystemPropertyFlowState" }
}

/**
 * The flow state after the `File.createTempFile` method has been called on the tracked taint.
 *
 * This state may be achieved two ways:
 *  1. If the source of the taint is a `File.createTempFile(_, _)` call.
 *  2. From state `FromSystemPropertyFlowState` if `File.createTempFile(_, _, taint)` is called.
 */
private class FromFileCreateTempFileFlowState extends DataFlow::FlowState {
  FromFileCreateTempFileFlowState() { this = "FromFileCreateTempFileFlowState" }
}

/**
 * The flow state after the `File::delete` method has been called on tracked taint.
 * This is the final state of the flow before hijackable call `File::mkdir(s)` (ie. the sink) is reached.
 */
private class FromDeleteFileFlowState extends DataFlow::FlowState {
  FromDeleteFileFlowState() { this = "FromDeleteFileFlowState" }
}

/**
 * The flow state after the `File::mkdir(s)` method has been called on tracked taint.
 * This is the final state, and is only used when computing the 'unsafe' call site.
 */
private class FromMkdirsFileFlowState extends DataFlow::FlowState {
  FromMkdirsFileFlowState() { this = "FromMkdirsFileFlowState" }
}

/**
 * A guard that is checking if a directory exists, throwing if it does not exist.
 */
private Guard directoryExistsGuard(ThrowStmt s) {
  result =
    any(MethodAccess existanceCheck |
      (
        existanceCheck.getMethod() instanceof MethodFileExists
        or
        existanceCheck.getMethod() instanceof MethodFileIsDirectory
      )
    ) and
  result.directlyControls(s.getEnclosingStmt(), false)
}

/**
 * A guard that is verifying that the directory is sucsessfully created, throwing when it is not created.
 */
private Guard directoryCreationGuard(ThrowStmt s) {
  result =
    any(MethodAccess creationCheck | creationCheck.getMethod() instanceof MethodFileCreatesDirs) and
  result.directlyControls(s.getEnclosingStmt(), false)
}

/**
 * A guard that is safely verfying that a directory is created.
 *
 * 'Safe' means that the directory is guarnteed to have been created, and the directory did not already exist.
 */
private Guard safeDirectoryCreationGuard(ThrowStmt s) {
  result = directoryCreationGuard(s) and
  // This guard is not 'safe' if a `directoryExistsGuard` is also guarding this throw statement
  not exists(directoryExistsGuard(s))
}

/**
 * An expression that will create a directory without throwing an exception if a file/directory already exists.
 */
private predicate isNonThrowingDirectoryCreationExpression(
  Expr fileInstanceExpr, MethodAccess creationCall
) {
  creationCall.getMethod() instanceof MethodFileCreatesDirs and
  creationCall.getQualifier() = fileInstanceExpr and
  // Check for 'throwing creations' and ensure that this call is not used in a throwing case.
  if creationCall.(Guard).directlyControls(_, _)
  then
    // The creation call is used in a guard
    not creationCall = safeDirectoryCreationGuard(_) // Ensure that the guard is insufficient.
  else any() // The creation call is not used in a guard. Thus is not a 'throwing creation'.
  or
  // Recursively look for methods that encapsulate the above.
  // Thus, the use of 'helper directory creation methods' are still considered
  // when assessing if an `unsafeUse` is present or not.
  exists(Method m, int argumentIndex, Expr arg |
    arg.(VarAccess).getVariable() = m.getParameter(argumentIndex) and
    isNonThrowingDirectoryCreationExpression(any(Expr e2 | DataFlow::localExprFlow(arg, e2)),
      creationCall)
  |
    m.getAReference().getArgument(argumentIndex) = fileInstanceExpr
  )
}

private class MethodFileDelete extends Method {
  MethodFileDelete() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("delete")
  }
}

private class MethodFileIsDirectory extends Method {
  MethodFileIsDirectory() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("isDirectory")
  }
}

private class MethodFileExists extends Method {
  MethodFileExists() {
    this.getDeclaringType() instanceof TypeFile and
    this.hasName("exists")
  }
}

predicate isDeleteFileExpr(Expr expr) {
  expr = any(MethodFileDelete m).getAReference().getQualifier()
}

abstract private class DirHijackingTaintSource extends DataFlow::Node {
  abstract DataFlow::FlowState getFlowState();
}

private class FileCreateTempFileDirHijackingTaintSource extends DirHijackingTaintSource {
  FileCreateTempFileDirHijackingTaintSource() {
    this.asExpr() =
      any(MethodAccess ma |
        // The two argument variant of this method uses the system property `java.io.tmpdir` as the base directory.
        ma.getMethod() instanceof MethodFileCreateTempFile and
        (
          // The two argument variant of this method uses the system property `java.io.tmpdir` as the base directory.
          ma.getNumArgument() = 2
          or
          // The three argument variant of this method uses the system property `java.io.tmpdir` as the base directory when `null`.
          DataFlow::localExprFlowPlusInitializers(any(NullLiteral n), ma.getArgument(2))
        )
      )
  }

  override DataFlow::FlowState getFlowState() { result instanceof FromFileCreateTempFileFlowState }
}

private class SystemPropertyDirHijackingTaintSource extends DirHijackingTaintSource {
  SystemPropertyDirHijackingTaintSource() { this.asExpr() = getSystemProperty("java.io.tmpdir") }

  override DataFlow::FlowState getFlowState() { result instanceof FromSystemPropertyFlowState }
}

/**
 * Holds when for a call to `File.createTempFile(_, _, node2)` where `node1` is the `MethodAccess`.
 */
private predicate isTaintStepFileCreateTempFile(DataFlow::Node node1, DataFlow::Node node2) {
  node2.asExpr() =
    any(MethodAccess ma |
      // Argument two is the target directory.
      // This vulnerability exists when the system property `java.io.tmpdir` is used as the target directory.
      ma.getMethod() instanceof MethodFileCreateTempFile and ma.getArgument(2) = node1.asExpr()
    )
}

private class TempDirHijackingToDeleteConfig extends TaintTracking2::Configuration {
  TempDirHijackingToDeleteConfig() { this = "TempDirHijackingToDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { source instanceof DirHijackingTaintSource }

  override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {
    isTaintStepFileCreateTempFile(node1, node2)
  }

  override predicate isSink(DataFlow::Node sink) { isDeleteFileExpr(sink.asExpr()) }
}

private class TempDirHijackingFromDeleteConfig extends DataFlow3::Configuration {
  TempDirHijackingFromDeleteConfig() { this = "TempDirHijackingFromDeleteConfig" }

  override predicate isSource(DataFlow::Node source) { isDeleteFileExpr(source.asExpr()) }

  override predicate isSink(DataFlow::Node sink) {
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _)
  }
}

private class TempDirHijackingFromDirectoryCreateToUnsafeUseConfig extends DataFlow4::Configuration {
  TempDirHijackingFromDirectoryCreateToUnsafeUseConfig() {
    this = "TempDirHijackingFromDirectoryCreateToUnsafeUseConfig"
  }

  override predicate isSource(DataFlow::Node source) {
    isNonThrowingDirectoryCreationExpression(source.asExpr(), _)
  }

  override predicate isSink(DataFlow::Node sink) { not safeUse(sink.asExpr()) }

  override predicate isBarrierGuard(DataFlow::BarrierGuard guard) {
    guard instanceof DirectoryCreationBarrierGuard
  }
}

private class DirectoryCreationBarrierGuard extends DataFlow::BarrierGuard {
  Expr fileInstanceExpr;

  DirectoryCreationBarrierGuard() {
    isNonThrowingDirectoryCreationExpression(fileInstanceExpr, this)
  }

  Expr getFileInstanceExpr() { result = fileInstanceExpr }

  override predicate checks(Expr e, boolean branch) { this.controls(e, branch) }
}

/**
 * Holds when there is an expression `unsafeUse` which is an unsafe use of the file that
 * is not guarded by a check of the return value of `File::mkdir(s)`.
 */
predicate isUnsafeUseUnconstrainedByIfCheck(DataFlow::Node sink, Expr unsafeUse) {
  exists(DirectoryCreationBarrierGuard g, MethodAccess ma |
    any(TempDirHijackingFromDeleteConfig c).isSink(sink) and // Sink is a call to `mkdir` or `mkdirs`
    sink.asExpr() = ma.getQualifier() and // The method access is on the same object as the sink
    g = ma and // The guard is the method access
    (
      // TODO: Consider replacing this entire bit of logic with `TempDirHijackingFullPathInlcudingUnsafeUse`.
      any(TempDirHijackingFromDirectoryCreateToUnsafeUseConfig c)
          .hasFlow(sink, DataFlow::exprNode(unsafeUse)) // There is some flow from the sink to an unsafe use of the File
      or
      DataFlow::localExprFlow(g.getFileInstanceExpr(), unsafeUse) // There is some local flow from the passed file instance to an unsafe use
    ) and
    unsafeUse != sink.asExpr() and // The unsafe use is not the sink itself
    not g.getFileInstanceExpr() = unsafeUse and // The unsafe use is not the file instance
    not safeUse(unsafeUse) and // The unsafe use is not a safe use
    not g.controls(unsafeUse.getBasicBlock(), true) and
    not booleanVarAccessGuardsGuard(g) // The guard is not guarded by a boolean variable access guard
  )
}

/**
 * Holds for any guard `g` that is itself guarded by a boolean variable access guard.
 *
 * For example, the following code: `if (isDirectory && !file.mkdir()) { ... }`.
 */
private predicate booleanVarAccessGuardsGuard(Guard g) {
  exists(Guard g2 | g2 = any(VarAccess va | va.getType() instanceof BooleanType) |
    g2.controls(g.getBasicBlock(), true)
  )
}

/**
 * Gets any `MethodAccess` that access string returning methods on the expression `e` of type `File`.
 */
private MethodAccess getStringAccessOnFile(Expr e) {
  result =
    any(MethodAccess fileMethodAccess |
      fileMethodAccess.getMethod().getDeclaringType() instanceof TypeFile and
      fileMethodAccess.getQualifier() = e and
      fileMethodAccess.getMethod().getReturnType() instanceof TypeString
    )
}

private Argument getThrowableConstructorParam() {
  result =
    any(Argument a |
      exists(ConstructorCall c |
        c.getConstructor().getDeclaringType().getAnAncestor() instanceof TypeThrowable and
        c.getAnArgument() = a
      )
    )
}

private predicate safeUse(Expr e) {
  exists(AndLogicalExpr andExp |
    andExp.getType() instanceof BooleanType and andExp.getAnOperand() = e
  )
  or
  exists(AssignAndExpr assignAndExp |
    assignAndExp.getType() instanceof BooleanType and assignAndExp.getSource() = e
  )
  or
  // File is being concatenated to a string, probably for a log or exception message
  exists(AddExpr addExp |
    addExp.getType() instanceof TypeString and
    (
      addExp.getRightOperand() = e
      or
      // A method call, like `File.getAbsolutePath()` is being called and concatenated to the end of a a string
      addExp.getRightOperand() = getStringAccessOnFile(e)
      or
      // A method call, like `File.getAbsolutePath()` is being called and prepended to another string with a leading space character.
      addExp.getLeftOperand() = getStringAccessOnFile(e) and
      addExp.getRightOperand().(CompileTimeConstantExpr).getStringValue().matches(" %")
    )
  )
  or
  // File is being used to construct an exception message
  e = getThrowableConstructorParam()
  or
  // A call to `File::deleteOnExit`
  exists(MethodAccess ma |
    ma.getMethod().hasName("deleteOnExit") and
    ma.getMethod().getDeclaringType() instanceof TypeFile and
    ma.getQualifier() = e
  )
  or
  // An assignment to a variable that is exclusively used when safe
  e = any(VariableAssign assign | safeUse(assign.getDestVar().getAnAccess())).getSource() and
  not e = any(VariableAssign assign | not safeUse(assign.getDestVar().getAnAccess())).getSource()
  or
  // Data flow exists exclusively to locations that are known to be safe
  DataFlow::localExprFlow(getStringAccessOnFile(e), any(Expr sink | safeUse(sink))) and
  not DataFlow::localExprFlow(getStringAccessOnFile(e), any(Expr sink | not safeUse(sink)))
}

private predicate isSourceUnified(DataFlow::Node source, DataFlow::FlowState state) {
  exists(DirHijackingTaintSource taintSource |
    source = taintSource and state = taintSource.getFlowState()
  )
}

private predicate isAdditionalTaintStepUnified(
  DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2, DataFlow::FlowState state2
) {
  // From a temporary directory system property access to `File.createTempFile(_, _, flow)` call
  isTaintStepFileCreateTempFile(node1, node2) and
  state1 instanceof FromSystemPropertyFlowState and
  state2 instanceof FromFileCreateTempFileFlowState
  or
  // From `File.createTempFile(_, _, flow)` to a call to `File::delete`
  node1 = node2 and
  isDeleteFileExpr(node1.asExpr()) and
  state1 instanceof FromFileCreateTempFileFlowState and
  state2 instanceof FromDeleteFileFlowState
}

private class TempDirHijackingFullPath extends TaintTracking::Configuration {
  TempDirHijackingFullPath() { this = "TempDirHijackingFullPath" }

  override predicate isSource(DataFlow::Node source, DataFlow::FlowState state) {
    isSourceUnified(source, state)
  }

  override predicate isAdditionalTaintStep(
    DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2,
    DataFlow::FlowState state2
  ) {
    isAdditionalTaintStepUnified(node1, state1, node2, state2)
  }

  override predicate isSink(DataFlow::Node sink, DataFlow::FlowState state) {
    // From a `File::delete` call, to a call to `File::mkdir(s)`
    isNonThrowingDirectoryCreationExpression(sink.asExpr(), _) and
    state instanceof FromDeleteFileFlowState
  }
}

/**
 * A configuration that tracks the full path of the temporary directory taint all the way to an
 * `unsafeUse` of the potentially hijacked temporary directory.
 *
 * This is intentionally not used in the the generation of the displayed path;
 * this is because there may not exist an explicit path from the call to `File::mkdir(s)` call to the the `unsafeUse`.
 */
class TempDirHijackingFullPathInlcudingUnsafeUse extends TaintTracking2::Configuration {
  TempDirHijackingFullPathInlcudingUnsafeUse() {
    this = "TempDirHijackingFullPathInlcudingUnsafeUse"
  }

  override predicate isSource(DataFlow::Node source, DataFlow::FlowState state) {
    isSourceUnified(source, state)
  }

  override predicate isAdditionalTaintStep(
    DataFlow::Node node1, DataFlow::FlowState state1, DataFlow::Node node2,
    DataFlow::FlowState state2
  ) {
    isAdditionalTaintStepUnified(node1, state1, node2, state2)
    or
    // `File::mkdir(s)` is not an end-state when looking for an unsafe use
    isNonThrowingDirectoryCreationExpression(node1.asExpr(), _) and
    node1.asExpr() = node2.asExpr() and
    state1 instanceof FromDeleteFileFlowState and
    state2 instanceof FromMkdirsFileFlowState
  }

  override predicate isSink(DataFlow::Node sink, DataFlow::FlowState state) {
    // From a `File::delete` call, to a call to `File::mkdir(s)`
    isUnsafeUseUnconstrainedByIfCheck(_, sink.asExpr()) and
    state instanceof FromMkdirsFileFlowState
  }
}

from
  DataFlow::PathNode pathSource, DataFlow::PathNode pathSink, DataFlow::Node deleteCheckpoint,
  MethodAccess creationCall, Expr unsafe
where
  // Generate the full path to display to the user
  any(TempDirHijackingFullPath c).hasFlowPath(pathSource, pathSink) and
  // Find the delete checkpoint to display to the user
  any(TempDirHijackingToDeleteConfig c).hasFlow(pathSource.getNode(), deleteCheckpoint) and
  // Find the delete checkpoint to display to the user
  any(TempDirHijackingFromDeleteConfig c).hasFlow(deleteCheckpoint, pathSink.getNode()) and
  // Find a full path where an `unsafe` use is present
  any(TempDirHijackingFullPathInlcudingUnsafeUse c)
      .hasFlow(pathSource.getNode(), DataFlow::exprNode(unsafe)) and
  // Verify the unsafe use is not constrained by an if check
  isUnsafeUseUnconstrainedByIfCheck(pathSink.getNode(), unsafe) and
  // Verfy the creation call expression is the expected sink
  isNonThrowingDirectoryCreationExpression(pathSink.getNode().asExpr(), creationCall)
select pathSink, pathSource, pathSink,
  "Local temporary directory hijacking race condition between $@ and this directory creation call. As such, the directory usage $@ may have been hijacked by another local user.",
  deleteCheckpoint.asExpr(), "delete here", unsafe, "here"
