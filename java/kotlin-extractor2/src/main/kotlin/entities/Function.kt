package com.github.codeql

import com.github.codeql.useType
import com.github.codeql.utils.getJvmName
import org.jetbrains.kotlin.analysis.api.KaSession
import org.jetbrains.kotlin.analysis.api.symbols.*
import org.jetbrains.kotlin.analysis.api.types.KaType
import org.jetbrains.kotlin.load.java.JvmAbi
import org.jetbrains.kotlin.psi.KtDeclarationWithBody

/*
         * There are some pairs of classes (e.g. `kotlin.Throwable` and
         * `java.lang.Throwable`) which are really just 2 different names
         * for the same class. However, we extract them as separate
         * classes. When extracting `kotlin.Throwable`'s methods, if we
         * looked up the parent ID ourselves, we would get as ID for
         * `java.lang.Throwable`, which isn't what we want. So we have to
         * allow it to be passed in.
         *
         * `maybeParameterList` can be supplied to override the function's
         * value parameters; this is used for generating labels of overloads
         * that omit one or more parameters that has a default value specified.

@OptIn(ObsoleteDescriptorBasedAPI::class)
*/
context(KaSession)
fun KotlinUsesExtractor.getFunctionLabel(
    f: KaFunctionSymbol,
    parentId: Label<out DbElement>,
    /*
    OLD: KE1
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?,
            maybeParameterList: List<IrValueParameter>? = null
    */
): String =
    getFunctionLabel(
        /*
        OLD: KE1
                    f.parent,
        */
        parentId,
        getFunctionShortName(f).nameInDB,
        /*
        OLD: KE1
                    (maybeParameterList ?: f.valueParameters).map { it.type },
                    getAdjustedReturnType(f),
                    f.extensionReceiverParameter?.type,
                    getFunctionTypeParameters(f),
                    classTypeArgsIncludingOuterClasses,
                    overridesCollectionsMethodWithAlteredParameterTypes(f),
                    getJavaCallable(f),
                    !getInnermostWildcardSupppressionAnnotation(f)
        */
    )

/*
OLD: KE1
    /*
     * This function actually generates the label for a function.
     * Sometimes, a function is only generated by kotlinc when writing a
     * class file, so there is no corresponding `IrFunction` for it.
     * This function therefore takes all the constituent parts of a
     * function instead.
     */
*/
context(KaSession)
fun KotlinUsesExtractor.getFunctionLabel(
    /*
    OLD: KE1
            // The parent of the function; normally f.parent.
            parent: IrDeclarationParent,
    */
    // OLD: KE1: The ID of the function's parent, or null if we should work it out ourselves.
    parentId: Label<out DbElement>,
    // OLD: KE1: The name of the function; normally f.name.asString().
    name: String,
    /*
    OLD: KE1
            // The types of the value parameters that the functions takes; normally
            // f.valueParameters.map { it.type }.
            parameterTypes: List<IrType>,
            // The return type of the function; normally f.returnType.
            returnType: IrType,
            // The extension receiver of the function, if any; normally
            // f.extensionReceiverParameter?.type.
            extensionParamType: IrType?,
            // The type parameters of the function. This does not include type parameters of enclosing
            // classes.
            functionTypeParameters: List<IrTypeParameter>,
            // The type arguments of enclosing classes of the function.
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?,
            // If true, this method implements a Java Collections interface (Collection, Map or List)
            // and may need
            // parameter erasure to match the way this class will appear to an external consumer of the
            // .class file.
            overridesCollectionsMethod: Boolean,
            // The Java signature of this callable, if known.
            javaSignature: JavaMember?,
            // If true, Java wildcards implied by Kotlin type parameter variance should be added by
            // default to this function's value parameters' types.
            // (Return-type wildcard addition is always off by default)
            addParameterWildcardsByDefault: Boolean,
            // The prefix used in the label. "callable", unless a property label is created, then it's
            // "property".
            prefix: String = "callable"
    */
): String {
    /*
    OLD: KE1
            val allParamTypes =
                if (extensionParamType == null) parameterTypes
                else listOf(extensionParamType) + parameterTypes

            val substitutionMap =
                classTypeArgsIncludingOuterClasses?.let { notNullArgs ->
                    if (notNullArgs.isEmpty()) {
                        null
                    } else {
                        val enclosingClass = getEnclosingClass(parent)
                        enclosingClass?.let { notNullClass ->
                            makeTypeGenericSubstitutionMap(notNullClass, notNullArgs)
                        }
                    }
                }
            val getIdForFunctionLabel = { it: IndexedValue<IrType> ->
                // Kotlin rewrites certain Java collections types adding additional generic
                // constraints-- for example,
                // Collection.remove(Object) because Collection.remove(Collection::E) in the Kotlin
                // universe.
                // If this has happened, erase the type again to get the correct Java signature.
                val maybeAmendedForCollections =
                    if (overridesCollectionsMethod)
                        eraseCollectionsMethodParameterType(it.value, name, it.index)
                    else it.value
                // Add any wildcard types that the Kotlin compiler would add in the Java lowering of
                // this function:
                val withAddedWildcards =
                    addJavaLoweringWildcards(
                        maybeAmendedForCollections,
                        addParameterWildcardsByDefault,
                        javaSignature?.let { sig -> getJavaValueParameterType(sig, it.index) }
                    )
                // Now substitute any class type parameters in:
                val maybeSubbed =
                    withAddedWildcards.substituteTypeAndArguments(
                        substitutionMap,
                        TypeContext.OTHER,
                        pluginContext
                    )
                // Finally, mimic the Java extractor's behaviour by naming functions with type
                // parameters for their erased types;
                // those without type parameters are named for the generic type.
                val maybeErased =
                    if (functionTypeParameters.isEmpty()) maybeSubbed else erase(maybeSubbed)
                "{${useType(maybeErased).javaResult.id}}"
            }
            val paramTypeIds =
                allParamTypes
                    .withIndex()
                    .joinToString(separator = ",", transform = getIdForFunctionLabel)
            val labelReturnType =
                if (name == "<init>") pluginContext.irBuiltIns.unitType
                else
                    erase(
                        returnType.substituteTypeAndArguments(
                            substitutionMap,
                            TypeContext.RETURN,
                            pluginContext
                        )
                    )
            // Note that `addJavaLoweringWildcards` is not required here because the return type used to
            // form the function
            // label is always erased.
            val returnTypeId = useType(labelReturnType, TypeContext.RETURN).javaResult.id
            // This suffix is added to generic methods (and constructors) to match the Java extractor's
            // behaviour.
            // Comments in that extractor indicates it didn't want the label of the callable to clash
            // with the raw
            // method (and presumably that disambiguation is never needed when the method belongs to a
            // parameterized
            // instance of a generic class), but as of now I don't know when the raw method would be
            // referred to.
            val typeArgSuffix =
                if (
                    functionTypeParameters.isNotEmpty() &&
                        classTypeArgsIncludingOuterClasses.isNullOrEmpty()
                )
                    "<${functionTypeParameters.size}>"
                else ""
    */
    val prefix = "callable" // TODO
    val paramTypeIds = "x" // TODO
    val returnTypeId = "x" // TODO
    val typeArgSuffix = "" // TODO
    return "@\"$prefix;{$parentId}.$name($paramTypeIds){$returnTypeId}$typeArgSuffix\""
}

data class FunctionNames(val nameInDB: String, val kotlinName: String)

/*
OLD: KE1
private val IrDeclaration.isAnonymousFunction
            get() = this is IrSimpleFunction && name == SpecialNames.NO_NAME_PROVIDED


        @OptIn(ObsoleteDescriptorBasedAPI::class)
        private fun getJvmModuleName(f: IrFunction) =
            NameUtils.sanitizeAsJavaIdentifier(
                getJvmModuleNameForDeserializedDescriptor(f.descriptor)
                    ?: JvmCodegenUtil.getModuleName(pluginContext.moduleDescriptor)
            )

 */
context(KaSession)
fun KotlinUsesExtractor.getFunctionShortName(f: KaFunctionSymbol): FunctionNames {
    if (f.isLocal)
        return FunctionNames(
            "invoke",
            "invoke"
        )
    fun getSuffixIfInternal() = ""
        /* OLD: KE1
        if (
            f.visibility == DescriptorVisibilities.INTERNAL &&
                f !is IrConstructor &&
                !(f.parent is IrFile || isExternalFileClassMember(f))
        ) {
            "\$" + getJvmModuleName(f)
        } else {
            ""
        }
         */

    (f as? KaPropertyAccessorSymbol)?.let {
        val propSymbol = it.containingSymbol!! as KaPropertySymbol // TODO: Drop or justify !!
        val propName = propSymbol.name.asString()
        val getter = propSymbol.getter
        val setter = propSymbol.setter

        /* OLD: KE1
        if (it.owner.parentClassOrNull?.kind == ClassKind.ANNOTATION_CLASS) {
            if (getter == null) {
                logger.error(
                    "Expected to find a getter for a property inside an annotation class"
                )
                return FunctionNames(propName, propName)
            } else {
                val jvmName = getJvmName(getter)
                return FunctionNames(jvmName ?: propName, propName)
            }
        }
         */

        val maybeFunctionName =
            when (f) {
                getter -> JvmAbi.getterName(propName)
                setter -> JvmAbi.setterName(propName)
                else -> {
                    logger.error(
                        "Function has a corresponding property, but is neither the getter nor the setter"
                    )
                    null
                }
            }
        maybeFunctionName?.let { defaultFunctionName ->
            val suffix = ""
            /* OLD: KE1
                if (
                    f.visibility == DescriptorVisibilities.PRIVATE &&
                        f.origin == IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR
                ) {
                    "\$private"
                } else {
                    getSuffixIfInternal()
                }
             */
            return FunctionNames(
                getJvmName(f) ?: "$defaultFunctionName$suffix",
                defaultFunctionName
            )
        }
    }

    // TODO: Justify or drop !!
    val name = if (f is KaConstructorSymbol) f.containingSymbol!!.name!! else f.name!!
    return FunctionNames(
        getJvmName(f) ?: "${name.asString()}${getSuffixIfInternal()}",
        name.identifier
    )
}

/*
OLD: KE1
        // This excludes class type parameters that show up in (at least) constructors' typeParameters
        // list.
        fun getFunctionTypeParameters(f: IrFunction): List<IrTypeParameter> {
            return if (f is IrConstructor) f.typeParameters
            else f.typeParameters.filter { it.parent == f }
        }

        /*
         * This is the normal getFunctionLabel function to use. If you want
         * to refer to the function in its source class then
         * classTypeArgsIncludingOuterClasses should be null. Otherwise, it
         * is the list of type arguments that need to be applied to its
         * enclosing classes to get the instantiation that this function is
         * in.
         */
        fun getFunctionLabel(
            f: IrFunction,
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?
        ): String? {
            val parentId = useDeclarationParentOf(f, false, classTypeArgsIncludingOuterClasses, true)
            if (parentId == null) {
                logger.error("Couldn't get parent ID for function label")
                return null
            }
            return getFunctionLabel(f, parentId, classTypeArgsIncludingOuterClasses)
        }
 */

context(KaSession)
fun KotlinFileExtractor.extractFunction(
    f: KaFunctionSymbol,
    parentId: Label<out DbReftype>,
    /*
    OLD: KE1
            extractBody: Boolean,
            extractMethodAndParameterTypeAccesses: Boolean,
            extractAnnotations: Boolean,
            typeSubstitution: TypeSubstitution?,
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?
    */
): Label<out DbCallable> {
    /*
    OLD: KE1
                val overriddenVisibility = null
    */
    return forceExtractFunction(
        f,
        parentId,
        /*
        OLD: KE1
                            extractBody,
                            extractMethodAndParameterTypeAccesses,
                            extractAnnotations,
                            typeSubstitution,
                            classTypeArgsIncludingOuterClasses,
                            overriddenAttributes = overriddenVisibility
        */
    )
    /*
    OLD: KE1
                    .also {
                        // The defaults-forwarder function is a static utility, not a member, so we only
                        // need to extract this for the unspecialised instance of this class.
                        if (classTypeArgsIncludingOuterClasses.isNullOrEmpty())
                            extractDefaultsFunction(
                                f,
                                parentId,
                                extractBody,
                                extractMethodAndParameterTypeAccesses
                            )
                        extractGeneratedOverloads(
                            f,
                            parentId,
                            null,
                            extractBody,
                            extractMethodAndParameterTypeAccesses,
                            typeSubstitution,
                            classTypeArgsIncludingOuterClasses
                        )
                    }
    */
}

// TODO: Can this be inlined?
context(KaSession)
private fun KotlinFileExtractor.forceExtractFunction(
    f: KaFunctionSymbol,
    parentId: Label<out DbReftype>,
    /*
    OLD: KE1
            extractBody: Boolean,
            extractMethodAndParameterTypeAccesses: Boolean,
            extractAnnotations: Boolean,
            typeSubstitution: TypeSubstitution?,
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?,
            extractOrigin: Boolean = true,
            overriddenAttributes: OverriddenFunctionAttributes? = null
    */
): Label<out DbCallable> {
    with("function", f) {
/*
OLD: KE1
            DeclarationStackAdjuster(f, overriddenAttributes).use {
                val javaCallable = getJavaCallable(f)
                getFunctionTypeParameters(f).mapIndexed { idx, tp ->
                    extractTypeParameter(
                        tp,
                        idx,
                        (javaCallable as? JavaTypeParameterListOwner)
                            ?.typeParameters
                            ?.getOrNull(idx)
                    )
                }
*/

        val id =
            /*
            OLD: KE1
                                overriddenAttributes?.id
                                    ?: // If this is a class that would ordinarily be replaced by a Java
                                       // equivalent (e.g. kotlin.Map -> java.util.Map),
                                    // don't replace here, really extract the Kotlin version:
            */
            useFunction<DbCallable>(
                f,
                parentId,
                /*
                OLD: KE1
                                            classTypeArgsIncludingOuterClasses,
                                            noReplace = true
                */
            )

        /*
        OLD: KE1
                        val sourceDeclaration =
                            overriddenAttributes?.sourceDeclarationId
                                ?: if (typeSubstitution != null && overriddenAttributes?.id == null) {
                                    val sourceFunId = useFunction<DbCallable>(f)
                                    if (sourceFunId == null) {
                                        logger.errorElement("Cannot get source ID for function", f)
                                        id // TODO: This is wrong; we ought to just fail in this case
                                    } else {
                                        sourceFunId
                                    }
                                } else {
                                    id
                                }

                        val extReceiver = f.extensionReceiverParameter
                        // The following parameter order is correct, because member $default methods (where
                        // the order would be [dispatchParam], [extensionParam], normalParams) are not
                        // extracted here
                        val fParameters =
                            listOfNotNull(extReceiver) +
                                (overriddenAttributes?.valueParameters ?: f.valueParameters)
                        val paramTypes =
                            fParameters.mapIndexed { i, vp ->
                                extractValueParameter(
                                    vp,
                                    id,
                                    i,
                                    typeSubstitution,
                                    sourceDeclaration,
                                    classTypeArgsIncludingOuterClasses,
                                    extractTypeAccess = extractMethodAndParameterTypeAccesses,
                                    overriddenAttributes?.sourceLoc
                                )
                            }
                        if (extReceiver != null) {
                            val extendedType = paramTypes[0]
                            tw.writeKtExtensionFunctions(
                                id.cast<DbMethod>(),
                                extendedType.javaResult.id,
                                extendedType.kotlinResult.id
                            )
                        }
        */

        val paramsSignature = "()" // TODO:
        /*
        OLD: KE1
                            paramTypes.joinToString(separator = ",", prefix = "(", postfix = ")") {
                                signatureOrWarn(it.javaResult, f)
                            }

                        val adjustedReturnType =
                            addJavaLoweringWildcards(
                                getAdjustedReturnType(f),
                                false,
                                (javaCallable as? JavaMethod)?.returnType
                            )
                        val substReturnType =
                            typeSubstitution?.let {
                                it(adjustedReturnType, TypeContext.RETURN, pluginContext)
                            } ?: adjustedReturnType
        */
        val functionSyntax = f.psi as? KtDeclarationWithBody
        val locId = functionSyntax?.let {
            tw.getLocation(functionSyntax ?: TODO())
        } ?: tw.getWholeFileLocation()
        /*
        OLD: KE1
                            overriddenAttributes?.sourceLoc
                                ?: getLocation(f, classTypeArgsIncludingOuterClasses)

                        if (f.symbol is IrConstructorSymbol) {
                            val shortName =
                                when {
                                    adjustedReturnType.isAnonymous -> ""
                                    typeSubstitution != null ->
                                        useType(substReturnType).javaResult.shortName
                                    else ->
                                        adjustedReturnType.classFqName?.shortName()?.asString()
                                            ?: f.name.asString()
                                }
                            extractConstructor(
                                id.cast(),
                                shortName,
                                paramsSignature,
                                parentId,
                                sourceDeclaration.cast()
                            )
                        } else {
                            val shortNames = getFunctionShortName(f)
        */
        val shortNames = getFunctionShortName(f)
        val methodId = id.cast<DbMethod>()
        extractMethod(
            methodId,
            /*
            OLD: KE1
                                    locId,
            */
            shortNames.nameInDB,
            f.returnType, // OLD: KE1: substReturnType,
            paramsSignature,
            parentId,
            /*
            OLD: KE1
                                    sourceDeclaration.cast(),
                                    if (extractOrigin) f.origin else null,
                                    extractMethodAndParameterTypeAccesses
            */
        )

        /*
        OLD: KE1
                            if (shortNames.nameInDB != shortNames.kotlinName) {
                                tw.writeKtFunctionOriginalNames(methodId, shortNames.kotlinName)
                            }

                            if (f.hasInterfaceParent() && f.body != null) {
                                addModifiers(
                                    methodId,
                                    "default"
                                ) // The actual output class file may or may not have this modifier,
                                  // depending on the -Xjvm-default setting.
                            }
                        }
        */

        tw.writeHasLocation(id, locId)
        val body = functionSyntax?.bodyExpression ?: functionSyntax?.bodyBlockExpression
        if (body != null /* TODO && extractBody */) {
            /*
            OLD: KE1
                                if (typeSubstitution != null)
                                    logger.errorElement(
                                        "Type substitution should only be used to extract a function prototype, not the body",
                                        f
                                    )
            */
            extractBody(body, id)
        }

        /*
        OLD: KE1
                        extractVisibility(f, id, overriddenAttributes?.visibility ?: f.visibility)

                        if (f.isInline) {
                            addModifiers(id, "inline")
                        }
                        if (f.shouldExtractAsStatic) {
                            addModifiers(id, "static")
                        }
                        if (f is IrSimpleFunction && f.overriddenSymbols.isNotEmpty()) {
                            addModifiers(id, "override")
                        }
                        if (f.isSuspend) {
                            addModifiers(id, "suspend")
                        }
                        if (f.symbol !is IrConstructorSymbol) {
                            when (overriddenAttributes?.modality ?: (f as? IrSimpleFunction)?.modality) {
                                Modality.ABSTRACT -> addModifiers(id, "abstract")
                                Modality.FINAL -> addModifiers(id, "final")
                                else -> Unit
                            }
                        }

                        linesOfCode?.linesOfCodeInDeclaration(f, id)

                        if (extractAnnotations) {
                            val extraAnnotations =
                                if (f.symbol is IrConstructorSymbol) listOf()
                                else
                                    listOfNotNull(
                                        getNullabilityAnnotation(
                                            f.returnType,
                                            f.origin,
                                            f.annotations,
                                            getJavaCallable(f)?.annotations
                                        )
                                    )
                            extractAnnotations(
                                f,
                                f.annotations + extraAnnotations,
                                id,
                                extractMethodAndParameterTypeAccesses
                            )
                        }
        */

        return id
        /*
        OLD: KE1
                    }
        */
    }
}

context(KaSession)
fun KotlinFileExtractor.extractValueParameter(
    id: Label<out DbParam>,
    t: KaType,
    name: String?,
    locId: Label<DbLocation>,
    parent: Label<out DbCallable>,
    idx: Int,
    paramSourceDeclaration: Label<out DbParam>,
    isVararg: Boolean,
    isNoinline: Boolean,
    isCrossinline: Boolean
): TypeResults {
    val type = useType(t)
    tw.writeParams(id, type.javaResult.id, idx, parent, paramSourceDeclaration)
    tw.writeParamsKotlinType(id, type.kotlinResult.id)
    tw.writeHasLocation(id, locId)
    if (name != null) {
        tw.writeParamName(id, name)
    }
    if (isVararg) {
        tw.writeIsVarargsParam(id)
    }
    if (isNoinline) {
        addModifiers(id, "noinline")
    }
    if (isCrossinline) {
        addModifiers(id, "crossinline")
    }
    return type
}

// TODO: Can this be inlined?
context(KaSession)
private fun KotlinFileExtractor.extractMethod(
    id: Label<out DbMethod>,
    /*
    OLD: KE1
            locId: Label<out DbLocation>,
    */
    shortName: String,
    returnType: KaType,
    paramsSignature: String,
    parentId: Label<out DbReftype>,
    /*
    OLD: KE1
            sourceDeclaration: Label<out DbMethod>,
            origin: IrDeclarationOrigin?,
            extractTypeAccess: Boolean
    */
) {
    val returnTypeResults = useType(returnType, TypeContext.RETURN)
    tw.writeMethods(
        id,
        shortName,
        "$shortName$paramsSignature",
        returnTypeResults.javaResult.id,
        parentId,
        id, // OLD: KE1: sourceDeclaration
    )
    /*
    OLD: KE1
            tw.writeMethodsKotlinType(id, returnTypeResults.kotlinResult.id)
            when (origin) {
                IrDeclarationOrigin.GENERATED_DATA_CLASS_MEMBER ->
                    tw.writeCompiler_generated(
                        id,
                        CompilerGeneratedKinds.GENERATED_DATA_CLASS_MEMBER.kind
                    )
                IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR ->
                    tw.writeCompiler_generated(
                        id,
                        CompilerGeneratedKinds.DEFAULT_PROPERTY_ACCESSOR.kind
                    )
                IrDeclarationOrigin.ENUM_CLASS_SPECIAL_MEMBER ->
                    tw.writeCompiler_generated(
                        id,
                        CompilerGeneratedKinds.ENUM_CLASS_SPECIAL_MEMBER.kind
                    )
            }
            if (extractTypeAccess) {
                extractTypeAccessRecursive(returnType, locId, id, -1)
            }
    */
}

context(KaSession)
fun <T : DbCallable> KotlinUsesExtractor.useFunction(
    f: KaFunctionSymbol,
    /*
    OLD: KE1
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?,
            noReplace: Boolean = false
    */
): Label<out T> = useFunction(f, useDeclarationParentOf(f, true)!! /* TODO */)

context(KaSession)
fun <T : DbCallable> KotlinUsesExtractor.useFunction(
    f: KaFunctionSymbol,
    parentId: Label<out DbElement>,
    /*
    OLD: KE1
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?,
            noReplace: Boolean = false
    */
): Label<out T> {
    if (f.isLocal) {
        val ids = tw.lm.getLocallyVisibleFunctionLabelMapping(f)
        return ids.function.cast<T>()
    }
    val javaFun = f // TODO: kotlinFunctionToJavaEquivalent(f, noReplace)
    return useFunction(f, javaFun, parentId /* TODO , classTypeArgsIncludingOuterClasses */)
}

context(KaSession)
private fun <T : DbCallable> KotlinUsesExtractor.useFunction(
    f: KaFunctionSymbol,
    javaFun: KaFunctionSymbol,
    parentId: Label<out DbElement>,
    /*
    OLD: KE1
            classTypeArgsIncludingOuterClasses: List<IrTypeArgument>?
    */
): Label<out T> {
    val label = getFunctionLabel(javaFun, parentId /* TODO , classTypeArgsIncludingOuterClasses */)
    val id: Label<T> =
        tw.getLabelFor(label) {
/*
OLD: KE1
                extractPrivateSpecialisedDeclaration(f, classTypeArgsIncludingOuterClasses)
*/
        }
    /*
    OLD: KE1
            if (isExternalDeclaration(javaFun)) {
                extractFunctionLaterIfExternalFileMember(javaFun)
                extractExternalEnclosingClassLater(javaFun)
            }
    */
    return id
}
