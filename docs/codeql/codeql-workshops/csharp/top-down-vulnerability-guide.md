# A Top-Down Guide to Vulnerability Searches

The following uses some extracts from yesterday's [ZipSlip](https://git.io/JfeOs) problem. While yesterday's presentation worked through details, this is a high-level overview and guide.

The first goal when starting from a known vulnerability is to identify *a* data flow path through the source. Then, write a query that describes it and finds at least that one in the source. The query may find more.

After the vulnerability is patched, for example with an extra check, the query will likely still find these flow paths. They may have gotten longer because of the patch.

The second goal is to enhance the query so that these patched vulnerabilities do not show up as flow paths any longer.

It is important to distinguish *C# code* from *CodeQL code*. It's usually easier to look at the C# code than the CodeQL code.

The [ZipSlip](https://git.io/JfeOs) problem is easily described in terms of *C# code*. We have this vulnerable *C# code*:

```csharp
foreach (ZipArchiveEntry entry in zipArchive.Entries)
{
    string extractPath = Path.Combine(destination, entry.FullName);
    entry.ExtractToFile(extractPath);
}
```

The problematic data flow path is simply

-   `entry.FullName` into argument of
-   `Path.Combine` into argument of
-   `entry.ExtractToFile`

It is important to keep the above description in mind; everything in yesterday's [ZipSlip](https://git.io/JfeOs) problem presentation focused on implementing the *CodeQL code* that identifies the path.

Let's take yesterday's resulting query as a given and consider the remaining steps. We have a known vulnerability, the flow path for it, and the query to describe it.

The structure of the query (our *CodeQL code*) at this point is

```java
/** @kind path-problem */
import csharp
import DataFlow::PathGraph

class ZipSlipConfig extends TaintTracking::Configuration {
  ZipSlipConfig() { this = "ZipSlipConfig" }

  override predicate isSource(DataFlow::Node source) {... }

  override predicate isSink(DataFlow::Node sink) {...}
}

from DataFlow::PathNode source, DataFlow::PathNode sink, ZipSlipConfig cfg
where cfg.hasFlowPath(source, sink)
select sink, source, sink, "Zip Slip from $@.", source, "this source"
```

and it is tailored to the *C# code*

```csharp
foreach (ZipArchiveEntry entry in zipArchive.Entries)
{
    string extractPath = Path.Combine(destination, entry.FullName);
    entry.ExtractToFile(extractPath);
}
```

Now we patch the source to

```csharp
foreach (ZipArchiveEntry entry in zipArchive.Entries)
{
    string extractPath = Path.Combine(destination,entry.FullName);
    if (Path.GetFullPath(extractPath).StartsWith(destination))
        entry.ExtractToFile(extractPath);
    else
        throw new Exception(...);
}
```

but the [path query](https://gist.github.com/adityasharad/96bd27efc324502a32bcbb0c7a1ba607#creating-path-queries-and-viewing-path-alerts) still identifies the whole path.

Looking at the data, the statement

```csharp
if (Path.GetFullPath(extractPath).StartsWith(destination))
    entry.ExtractToFile(extractPath);
```

*guards* the use of `extractPath`, and is safe. This should therefore *not be reached* by a taint flow path.

The unguarded expression

```csharp
entry.ExtractToFile(extractPath);
```

is unsafe and *should still be reached* by a taint flow path.

To accomodate both requirements, CodeQL provides sanitizers. They are included in the configuration via

```csharp
override predicate isSanitizer(DataFlow::Node nd) {...}
```

so the query's structure is extended to

```csharp
class ZipSlipConfig extends TaintTracking::Configuration {
  ZipSlipConfig() { this = "ZipSlipConfig" }

  override predicate isSource(DataFlow::Node source) {... }

  override predicate isSink(DataFlow::Node sink) {...}

  override predicate isSanitizer(DataFlow::Node nd) {...}
}
```

The `isSanitizer` predicate has to identify the C# code

```csharp
if (Path.GetFullPath(extractPath).StartsWith(destination))
    entry.ExtractToFile(extractPath);
```

and can do this via the `Guards` library. If the sanitizer matches earlier in the path than the sink, then the sink will remain a sink, but there will be no tainted flow into the sink. This is precisely what we need here.

# From C# to codeql

From C# to codeql

1.  Find the C# program syntax component on the [language specification](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction) page. For example: Under [statements](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/introduction#statements), the spec states that "**Declaration statements** are used to declare local variables and constants."

2.  Either in the [QL documentation for C#](https://help.semmle.com/QL/learn-ql/csharp/introduce-libraries-csharp.html#introducing-the-codeql-libraries-for-c) or using VS Code autocompletion, find the same name. For example: The documentation section [Declarations](https://help.semmle.com/QL/learn-ql/csharp/introduce-libraries-csharp.html#declarations) describes the main type `Declaration` along with all specialized subtypes and useful predicates on that type. It also has a link to the [library reference](https://help.semmle.com/qldoc/csharp/semmle/code/cil/Declaration.qll/type.Declaration$Declaration.html) (which is what you see in VS Code) and a short sample query.

3.  Examine the available predicates for a type to make connections between them. Example: The documentation section [Declarations](https://help.semmle.com/QL/learn-ql/csharp/introduce-libraries-csharp.html#declarations) lists hand-picked useful predicates on that type, while the [library reference](https://help.semmle.com/qldoc/csharp/semmle/code/cil/Declaration.qll/type.Declaration$Declaration.html) and vs code will show *all* available predicates.
